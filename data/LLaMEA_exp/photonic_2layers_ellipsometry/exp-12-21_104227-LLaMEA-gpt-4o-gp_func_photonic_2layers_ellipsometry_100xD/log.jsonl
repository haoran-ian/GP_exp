{"id": "88496150-4509-42a1-b96d-593675406fe0", "fitness": 0.05301490781694619, "name": "HybridPSODE", "description": "A hybrid swarm-based metaheuristic combining Particle Swarm Optimization (PSO) with Differential Evolution (DE) for robust exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05301 with standard deviation 0.03109.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.009266544255624454, 0.009276180458143823, 0.009260884528348279, 0.07865560151379636, 0.07874981837354289, 0.07859495727401711, 0.07110087428870637, 0.0711746607916518, 0.07105464886868462]}}
{"id": "7e96a9f2-8ed2-42f0-bb9f-9ce1722413c8", "fitness": 0.05301490781694619, "name": "HybridPSODE", "description": "Introduced dynamic adjustment of c1 (cognitive component) based on budget utilization for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.c1 = 1.5 * (1 - evaluations / self.budget)  # Dynamic adjustment of c1\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05301 with standard deviation 0.03109.", "error": "", "parent_ids": ["88496150-4509-42a1-b96d-593675406fe0"], "operator": null, "metadata": {"aucs": [0.009266544255624454, 0.009276180458143823, 0.009260884528348279, 0.07865560151379636, 0.07874981837354289, 0.07859495727401711, 0.07110087428870637, 0.0711746607916518, 0.07105464886868462]}}
{"id": "5cb4e8f9-0214-4a81-82ba-91cfe661fb9a", "fitness": 0.05302984232718536, "name": "HybridPSODE", "description": "A hybrid swarm-based metaheuristic with improved inertia adaptation for Particle Swarm Optimization (PSO) coupled with Differential Evolution (DE) for enhanced convergence in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Adjust inertia weight over time\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["88496150-4509-42a1-b96d-593675406fe0"], "operator": null, "metadata": {"aucs": [0.009266649442147501, 0.009276466129915284, 0.009267553795391015, 0.07865667526184483, 0.07875273521030413, 0.07866270034951628, 0.07110170922373404, 0.071176923329206, 0.0711071682026092]}}
{"id": "ca915da7-467a-4aec-a7c5-2c0832865211", "fitness": 0.05302984232718536, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive mutation factor for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Adjust inertia weight over time\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # DE mutation\n            self.F = 0.8 + 0.2 * (evaluations / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["5cb4e8f9-0214-4a81-82ba-91cfe661fb9a"], "operator": null, "metadata": {"aucs": [0.009266649442147501, 0.009276466129915284, 0.009267553795391015, 0.07865667526184483, 0.07875273521030413, 0.07866270034951628, 0.07110170922373404, 0.071176923329206, 0.0711071682026092]}}
{"id": "74de41dc-11d3-43a5-a7fb-dc6bbb2c5248", "fitness": -Infinity, "name": "EnhancedHybridPSODE", "description": "Enhanced HybridPSODE with adaptive mutation strategies and dynamic population size for improved exploration and convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.final_population_size = 5\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F_min = 0.5  # minimum DE mutation factor\n        self.F_max = 0.9  # maximum DE mutation factor\n        self.CR = 0.9  # crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            # Update population size dynamically\n            population_size = max(self.final_population_size, int(self.initial_population_size - \n                                                                 evaluations / self.budget * \n                                                                 (self.initial_population_size - self.final_population_size)))\n            # Adjust inertia weight over time\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            \n            # PSO update\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += population_size\n\n            # Dynamic mutation factor\n            F_adaptive = self.F_min + (self.F_max - self.F_min) * (1 - evaluations / self.budget)\n            \n            # DE mutation\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + F_adaptive * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n                \n        return global_best_position, global_best_score", "configspace": "", "generation": 4, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (18,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (18,2) (20,2) ')", "parent_ids": ["5cb4e8f9-0214-4a81-82ba-91cfe661fb9a"], "operator": null, "metadata": {}}
{"id": "3ca1c3a2-0a2a-4948-aa85-1752fa91e3ae", "fitness": 0.05302982389919418, "name": "AdaptiveHybridPSODE", "description": "An adaptive hybrid metaheuristic that combines Particle Swarm Optimization (PSO) with Differential Evolution (DE) by dynamically adjusting control parameters based on convergence trends to enhance robustness and convergence speed in black box optimization.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_init = 2.0  # initial cognitive component\n        self.c2_init = 2.0  # initial social component\n        self.w_init = 0.9   # initial inertia weight\n        self.w_min = 0.4    # minimum inertia weight\n        self.F_init = 0.8   # initial mutation factor for DE\n        self.CR_init = 0.9  # initial crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        c1, c2 = self.c1_init, self.c2_init\n        w = self.w_init\n        F = self.F_init\n        CR = self.CR_init\n\n        while evaluations < self.budget:\n            # Dynamic adjustments\n            if evaluations > self.budget / 2:\n                c1 = max(1.0, c1 - 0.001)\n                c2 = min(3.0, c2 + 0.001)\n                w = max(self.w_min, w - 0.001)\n                F = max(0.1, F - 0.001)\n                CR = max(0.7, CR - 0.001)\n\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities +\n                          c1 * r1 * (personal_best_positions - population) +\n                          c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # DE mutation and crossover\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["5cb4e8f9-0214-4a81-82ba-91cfe661fb9a"], "operator": null, "metadata": {"aucs": [0.009266713847112973, 0.009276449892511085, 0.00926749820595374, 0.07865733283113574, 0.07875256963843635, 0.07866214025654827, 0.07110221816256157, 0.0711767947725841, 0.07110669748590381]}}
{"id": "4fb9c398-f1c5-4939-bcc9-680c9f5e92cb", "fitness": 0.05302984232718536, "name": "HybridPSODE", "description": "A hybrid swarm-based metaheuristic with adaptive mutation in DE for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Adjust inertia weight over time\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # DE mutation with adaptive factor\n            adaptive_F = self.F * (1 - evaluations / self.budget)\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + adaptive_F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["5cb4e8f9-0214-4a81-82ba-91cfe661fb9a"], "operator": null, "metadata": {"aucs": [0.009266649442147501, 0.009276466129915284, 0.009267553795391015, 0.07865667526184483, 0.07875273521030413, 0.07866270034951628, 0.07110170922373404, 0.071176923329206, 0.0711071682026092]}}
{"id": "cf47aeb8-4c3e-4a44-a819-56b49375e32b", "fitness": 0.05302984232718536, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic adaptation of the mutation factor (F) in Differential Evolution for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Adjust inertia weight over time\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic adaptation of F\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["5cb4e8f9-0214-4a81-82ba-91cfe661fb9a"], "operator": null, "metadata": {"aucs": [0.009266649442147501, 0.009276466129915284, 0.009267553795391015, 0.07865667526184483, 0.07875273521030413, 0.07866270034951628, 0.07110170922373404, 0.071176923329206, 0.0711071682026092]}}
{"id": "371110ad-a442-48cb-992b-0a4674e4cb28", "fitness": 0.05302984232718536, "name": "HybridPSODE", "description": "Improved HybridPSODE with dynamic mutation factor adjustment for better exploration-exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Adjust inertia weight over time\n            self.F = 0.5 + 0.3 * np.sin((np.pi / 2) * (evaluations / self.budget))  # Dynamic mutation factor adjustment\n            \n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["5cb4e8f9-0214-4a81-82ba-91cfe661fb9a"], "operator": null, "metadata": {"aucs": [0.009266649442147501, 0.009276466129915284, 0.009267553795391015, 0.07865667526184483, 0.07875273521030413, 0.07866270034951628, 0.07110170922373404, 0.071176923329206, 0.0711071682026092]}}
{"id": "ac680f32-8dd1-4c35-9e29-f058260ea823", "fitness": 0.05302984232718536, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic crossover rate adjustment based on evaluation progress for better convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Adjust inertia weight over time\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Evaluate new positions\n            scores = np.array([func(ind) for ind in population])\n            evaluations += self.population_size\n            \n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                self.CR = 0.6 + 0.3 * (evaluations / self.budget)  # Dynamic crossover rate adjustment\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["5cb4e8f9-0214-4a81-82ba-91cfe661fb9a"], "operator": null, "metadata": {"aucs": [0.009266649442147501, 0.009276466129915284, 0.009267553795391015, 0.07865667526184483, 0.07875273521030413, 0.07866270034951628, 0.07110170922373404, 0.071176923329206, 0.0711071682026092]}}
{"id": "48878c31-11f2-48ce-8cd3-c6fd91370c9f", "fitness": 0.0530787464525457, "name": "EnhancedHybridPSODE", "description": "Enhanced HybridPSODE with adaptive parameters and parallel evaluations for efficient exploration and exploitation in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * shrink_factor\n            population = np.clip(population, lb, ub)\n            \n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = list(executor.map(evaluate, population))\n            scores = np.array(scores)\n            evaluations += self.population_size\n            \n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05308 with standard deviation 0.03114.", "error": "", "parent_ids": ["5cb4e8f9-0214-4a81-82ba-91cfe661fb9a"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276542955726552, 0.009269274883343392, 0.07865670748703424, 0.07875351913112427, 0.07910137218645619, 0.07110173371522521, 0.07117753091856105, 0.07110538421421997]}}
{"id": "9de41dcc-98d1-4f6a-971f-33f4f6db9e6d", "fitness": 0.05303271921393412, "name": "AdaptiveMemoryHybridPSODE", "description": "Adaptive Memory-Based Hybrid PSODE incorporating historical learning to enhance convergence speed and solution quality in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveMemoryHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.memory_size = 5  # Number of previous best positions to keep\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n        historical_best_positions = [global_best_position] * self.memory_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Update memory and adaptive weights\n            historical_best_positions.pop(0)\n            historical_best_positions.append(global_best_position)\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n\n            # PSO update with adaptive memory influence\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            historical_influence = np.mean(historical_best_positions, axis=0)\n            velocities += self.c2 * r2 * (historical_influence - population)\n            population += velocities * shrink_factor\n            population = np.clip(population, lb, ub)\n            \n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = list(executor.map(evaluate, population))\n            scores = np.array(scores)\n            evaluations += self.population_size\n            \n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 11, "feedback": "The algorithm AdaptiveMemoryHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["48878c31-11f2-48ce-8cd3-c6fd91370c9f"], "operator": null, "metadata": {"aucs": [0.009266713847112973, 0.009276424800066407, 0.009269274883343392, 0.07865733283113574, 0.07875329531823538, 0.07868012908315425, 0.07110221816256157, 0.07117735712646012, 0.07111172687333722]}}
{"id": "f51d4926-07c1-4c24-b14e-ebce66294ea6", "fitness": 0.05302961396963865, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive HybridPSODE with dynamic learning components and differential local search for improved convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # initial cognitive component\n        self.c2_initial = 2.0  # initial social component\n        self.w_initial = 0.9   # initial inertia weight\n        self.w_final = 0.4     # final inertia weight\n        self.F_initial = 0.8   # initial mutation factor for DE\n        self.CR = 0.9          # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Dynamic parameter adaptation\n            t = evaluations / self.budget\n            self.w = self.w_initial - (self.w_initial - self.w_final) * t\n            self.F = self.F_initial * (1 - t)\n            self.c1 = self.c1_initial * t\n            self.c2 = self.c2_initial * (1 - t)\n\n            # PSO update with adaptive learning components\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = list(executor.map(evaluate, population))\n            scores = np.array(scores)\n            evaluations += self.population_size\n\n            # DE mutation and local search enhancement\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Local search\n                local_trial = trial + np.random.normal(0, 0.1, self.dim)\n                local_trial = np.clip(local_trial, lb, ub)\n                local_trial_score = func(local_trial)\n                evaluations += 1\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if local_trial_score < trial_score:\n                    trial = local_trial\n                    trial_score = local_trial_score\n\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["48878c31-11f2-48ce-8cd3-c6fd91370c9f"], "operator": null, "metadata": {"aucs": [0.00926669428474658, 0.00927645542789124, 0.009267410350046856, 0.07865713300951438, 0.0787526260731446, 0.07866125896388143, 0.07110206308010614, 0.07117683859252777, 0.0711060459448889]}}
{"id": "760287f2-a6a6-4cc3-ba42-2fca77c5f6f5", "fitness": 0.0530199900405022, "name": "SynergisticEvolutionaryOptimization", "description": "Synergistic Evolutionary Optimization combines adaptive PSO with dynamic DE strategies and learning reinforcement for robust exploration-exploitation balance in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass SynergisticEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size for diversity\n        self.c1_initial, self.c1_final = 2.5, 0.5  # Adaptive cognitive component\n        self.c2_initial, self.c2_final = 0.5, 2.5  # Adaptive social component\n        self.w_initial, self.w_final = 0.9, 0.4    # Linearly decreasing inertia weight\n        self.F_initial, self.F_final = 0.2, 0.9    # Adaptive mutation factor for DE\n        self.CR = 0.9                              # Crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            t = evaluations / self.budget\n            self.w = self.w_final + (self.w_initial - self.w_final) * (1 - t)**2\n            self.c1 = self.c1_final + (self.c1_initial - self.c1_final) * (1 - t)\n            self.c2 = self.c2_final + (self.c2_initial - self.c2_final) * t\n            self.F = self.F_final * t + self.F_initial * (1 - t)\n\n            # PSO update with adaptive parameters\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = list(executor.map(evaluate, population))\n            scores = np.array(scores)\n            evaluations += self.population_size\n            \n            # DE mutation with dynamic selection pressure\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 13, "feedback": "The algorithm SynergisticEvolutionaryOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05302 with standard deviation 0.03109.", "error": "", "parent_ids": ["48878c31-11f2-48ce-8cd3-c6fd91370c9f"], "operator": null, "metadata": {"aucs": [0.009265452638015592, 0.009275799506022753, 0.009264833364701963, 0.07864449708316978, 0.07874593493584936, 0.07863247225433545, 0.07109226664528767, 0.07117279158128853, 0.07108586235584868]}}
{"id": "68d6e052-e166-49d3-ab9a-e4330fa2e483", "fitness": -Infinity, "name": "EnhancedHybridPSODE", "description": "Enhanced HybridPSODE with dynamic population size adjustment for improved adaptability in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * shrink_factor\n            population = np.clip(population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = list(executor.map(evaluate, population))\n            scores = np.array(scores)\n            evaluations += self.population_size\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n            # Dynamically adjust population size\n            self.population_size = int(20 + 10 * (evaluations / self.budget))  # New line added\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 14, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (23,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (23,2) (20,2) ')", "parent_ids": ["48878c31-11f2-48ce-8cd3-c6fd91370c9f"], "operator": null, "metadata": {}}
{"id": "1970be5f-b0a5-484b-9a8b-db47ed08dc7d", "fitness": 0.08170710106303752, "name": "AdaptiveQuantumInspiredPSODE", "description": "\"Adaptive Quantum-Inspired PSODE leverages quantum-inspired initialization and adaptive parameters for enhanced exploration and convergence in black box optimization.\"", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * shrink_factor\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 15, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08171 with standard deviation 0.09212.", "error": "", "parent_ids": ["48878c31-11f2-48ce-8cd3-c6fd91370c9f"], "operator": null, "metadata": {"aucs": [0.00926652451394172, 0.009276520999149884, 0.010626554178601588, 0.0786566886715393, 0.07875329531823538, 0.07868012908315425, 0.07110171910621077, 0.07117735712646012, 0.32782512057004465]}}
{"id": "7bc13558-6cf7-4e1d-a344-91cfdca8f163", "fitness": 0.05433871124591064, "name": "HybridQuantumEnhancedPSODE", "description": "\"Hybrid Quantum-Enhanced PSODE synergizes adaptive strategies and a hybrid selection mechanism to boost convergence and exploration in black box optimization.\"", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass HybridQuantumEnhancedPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1, self.c2 = 1.5, 1.5  # cognitive and social components\n        self.w = 0.5  # inertia weight\n        self.F = 0.8  # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * shrink_factor\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            \n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 16, "feedback": "The algorithm HybridQuantumEnhancedPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05434 with standard deviation 0.03199.", "error": "", "parent_ids": ["1970be5f-b0a5-484b-9a8b-db47ed08dc7d"], "operator": null, "metadata": {"aucs": [0.009813192242803082, 0.009276280501440914, 0.009267717319800362, 0.08508534799845702, 0.07875084185743997, 0.07866436602745508, 0.07590672662108633, 0.07117545481597187, 0.07110847382874108]}}
{"id": "e8bba2d3-5e68-4cff-bdf0-3742c3ab222e", "fitness": 0.05305377604646295, "name": "EnhancedQuantumInspiredPSODE", "description": "\"Enhanced Quantum-Inspired PSODE incorporates adaptive inertia, dynamic DE parameters, and a quantum interference mechanism to bolster exploration and exploitation in black box optimization.\"", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * shrink_factor\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update with interference\n            interference = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n            q_population = 0.5 * (population + global_best_position) + interference * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03107.", "error": "", "parent_ids": ["1970be5f-b0a5-484b-9a8b-db47ed08dc7d"], "operator": null, "metadata": {"aucs": [0.009266650736055926, 0.009458213051760644, 0.009269274883343392, 0.0786566886715393, 0.07875329531823538, 0.07868012908315425, 0.07110171910621077, 0.07117735712646012, 0.07112065644140675]}}
{"id": "a808acc3-3869-4707-8a5c-bcfdae43aa79", "fitness": 0.09538635966442219, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE leverages dynamic shrink_factor modulation for better balance between exploration and exploitation in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 18, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09539 with standard deviation 0.12577.", "error": "", "parent_ids": ["1970be5f-b0a5-484b-9a8b-db47ed08dc7d"], "operator": null, "metadata": {"aucs": [0.010105250137009247, 0.009276520999149884, 0.009828889644483918, 0.08948883096840032, 0.07875329531823538, 0.4397621439452576, 0.07896133445169495, 0.07118031507416167, 0.07112065644140675]}}
{"id": "e25da454-687e-4337-93b3-9ac1aa2de26a", "fitness": 0.05311780286247457, "name": "EnhancedQuantumInspiredPSODE", "description": "Enhanced Quantum-Inspired PSODE utilizes dynamic parameter tuning and selective elitism to strengthen convergence precision and efficiency in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Enhanced adaptive inertia weight\n            self.w = 0.9 - 0.4 * (evaluations / self.budget)\n            # Enhanced adaptive mutation factor with oscillation\n            self.F = 0.1 + 0.7 * np.sin(np.pi * evaluations / self.budget)\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.8 + 0.2 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation with elitism\n            elite_indices = np.argsort(scores)[:5]\n            for i in range(self.population_size):\n                if i in elite_indices:\n                    continue  # Keep elites unchanged\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05312 with standard deviation 0.03116.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.00926663671317618, 0.009276472899608201, 0.009268340345217618, 0.07922111984995406, 0.07875035116528095, 0.07866357427975335, 0.07110008294674841, 0.07117545481597187, 0.0713381927465605]}}
{"id": "e2881b51-f61a-4ce6-9410-d21ca8068fc2", "fitness": -Infinity, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with Dynamic Population and Inertia adjusts population size and inertia for enhanced adaptability in diverse optimization landscapes.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 20\n        self.population_size = self.base_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            self.population_size = self.base_population_size + int(10 * (1 - evaluations / self.budget))\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 20, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (29,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (29,2) (20,2) ')", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {}}
{"id": "67a656de-b465-4f67-adf1-43e76e14ab7a", "fitness": 0.05303354517942005, "name": "AdaptiveQuantumInspiredPSODE", "description": "Introducing randomized dynamic selection mutation in DE to enhance exploration in the black box optimization.  ", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c) + np.random.rand()*self.F*np.random.normal(0,1,self.dim)  # Modified Line\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 21, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266560682381408, 0.009276520999149884, 0.009270196449936208, 0.07865545679883124, 0.07875329531823538, 0.07868012908315425, 0.07110173371522521, 0.07117735712646012, 0.07112065644140675]}}
{"id": "736d2676-fee9-4293-bb9e-aeebf5b07108", "fitness": 0.05519951358495864, "name": "EnhancedQuantumPSODE", "description": "Enhanced Quantum-PSODE uses dynamic selection pressure adjustment and crowding distance for improved diversity and convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.selection_pressure = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            self.selection_pressure = 0.4 + 0.6 * (evaluations / self.budget)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n            # Dynamic crowding distance to maintain diversity\n            crowding_distances = np.zeros(self.population_size)\n            sorted_indices = np.argsort(scores)\n            for j in range(self.dim):\n                sorted_population = population[sorted_indices, j]\n                range_p = np.max(sorted_population) - np.min(sorted_population)\n                if range_p == 0:\n                    continue\n                crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = float('inf')\n                for k in range(1, self.population_size - 1):\n                    crowding_distances[sorted_indices[k]] += (sorted_population[k+1] - sorted_population[k-1]) / range_p\n\n            selection_prob = np.exp(-crowding_distances * self.selection_pressure)\n            selection_prob /= np.sum(selection_prob)\n            selected_indices = np.random.choice(np.arange(self.population_size), self.population_size, p=selection_prob)\n            population = population[selected_indices]\n            scores = scores[selected_indices]\n            personal_best_positions = personal_best_positions[selected_indices]\n            personal_best_scores = personal_best_scores[selected_indices]\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.03267.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.010105096972277794, 0.009276280501440914, 0.009267717319800362, 0.08948726760814663, 0.07875084185743997, 0.07866436602745508, 0.07896012333335412, 0.07117545481597187, 0.07110847382874108]}}
{"id": "b1bf2f5a-44d8-4fce-8a3c-3e5baa034ee6", "fitness": 0.05308907173807284, "name": "EnhancedQuantumPSODE", "description": "Enhanced Quantum-PSODE integrates chaotic sequences and diversity preservation strategies to accelerate convergence and improve exploration in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        chaotic_sequence = np.random.rand(self.population_size)\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight with chaotic sequence\n            chaotic_sequence = 4 * chaotic_sequence * (1 - chaotic_sequence)\n            self.w = 0.9 - 0.5 * (evaluations / self.budget) * chaotic_sequence\n\n            # PSO update with enhanced exploration\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w[:, np.newaxis] * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update with diversity preservation\n            diversity_control = np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = 0.5 * (population + global_best_position) + diversity_control\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation and crossover with diversity\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best with diversity check\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05309 with standard deviation 0.03115.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.00926618955951175, 0.009276328600982708, 0.009268172901501948, 0.07865199091901443, 0.0792760193195976, 0.078668757079986, 0.07109807600468254, 0.07117545481597187, 0.07112065644140675]}}
{"id": "3c9a586a-c891-4dd7-a85b-e8e37f46243e", "fitness": 0.053207897916219285, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE incorporates adaptive diversity control and dynamically adjusted crossover probability for improved convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # initial crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # Dynamic crossover probability\n            self.CR = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update with diversity control\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position) * (1 - evaluations / self.budget)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation and dynamic crossover\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05321 with standard deviation 0.03121.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276520999149884, 0.009352993621801198, 0.07865670748703424, 0.0787513325495991, 0.07952204868506074, 0.0711000381495479, 0.07117583527806959, 0.07176910505922196]}}
{"id": "6c52e8f2-6692-4ea9-87c0-250ee31ecaea", "fitness": 0.05494169756820239, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with fine-tuned crossover probability for improved exploration-exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.85  # crossover probability for DE (tuned)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 25, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05494 with standard deviation 0.03268.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266560682381408, 0.009276424800066407, 0.009269274883343392, 0.08948883096840032, 0.07875329531823538, 0.07868012908315425, 0.07110173371522521, 0.07117735712646012, 0.07746167153655503]}}
{"id": "c66e3f2d-4a2c-45d4-9e27-3b8d1fe8f884", "fitness": 0.0539962954525433, "name": "AdaptiveQuantumInspiredPSODE", "description": "The algorithm now includes an adaptive crossover probability for Differential Evolution (DE) to enhance exploration-exploitation balance in optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover with adaptive probability\n                self.CR = 0.7 + 0.2 * np.sin(np.pi * evaluations / self.budget)  # Changed line\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 26, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05400 with standard deviation 0.03157.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.010105127605224196, 0.009276280501440914, 0.009267717319800362, 0.07865545679883124, 0.07875084185743997, 0.07866436602745508, 0.07896012333335412, 0.07117583527806959, 0.07111091035127426]}}
{"id": "1771df2e-5acc-44d1-809e-c8414623ba41", "fitness": 0.05303574367297043, "name": "HybridQuantumEnhancedPSODE", "description": "Hybrid Quantum-Enhanced PSODE incorporates adaptive learning rates and chaotic randomization for enhanced exploration-exploitation balance in complex search spaces.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\nimport random\n\nclass HybridQuantumEnhancedPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def chaotic_sequence(x):\n            return 4 * x * (1 - x)\n\n        chaotic_map = np.random.rand()\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            chaotic_map = chaotic_sequence(chaotic_map)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            velocities *= (0.7 + chaotic_map * 0.3)\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 27, "feedback": "The algorithm HybridQuantumEnhancedPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03110.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266713847112973, 0.009276543386279701, 0.009269274883343392, 0.07865733283113574, 0.07875326103549762, 0.07868012908315425, 0.07110221816256157, 0.07119556338624189, 0.07112065644140675]}}
{"id": "1175658b-a4e6-4985-8acd-74a402fafa51", "fitness": 0.05303338835749231, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE augments diversity through adaptive crossover and mutation scaling for heightened exploration and convergence.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # initial mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.6 * (1 - evaluations / self.budget)\n            self.CR = 0.5 + 0.4 * (evaluations / self.budget)  # Adaptive crossover probability\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + \\\n                           np.random.uniform(-1, 1, (self.population_size, self.dim)) * \\\n                           np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276280501440914, 0.009268651857926247, 0.07865670748703424, 0.07875329531823538, 0.07868012908315425, 0.0711007648205525, 0.07117735712646012, 0.07112065644140675]}}
{"id": "48220981-b13d-4031-87ae-8b4c0f797a41", "fitness": 0.053033631421013486, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE introduces non-linear dynamic components and diversity preservation for improved exploration and convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F_max = 0.9\n        self.F_min = 0.2\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        diversity_preserving_factor = 0.1\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2\n            # Adaptive mutation factor\n            self.F = self.F_min + (self.F_max - self.F_min) * (1 - (evaluations / self.budget) ** 2)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (1.0 - diversity_preserving_factor * (evaluations / self.budget) ** 2)\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266671156507145, 0.009276520999149884, 0.009269274883343392, 0.0786568969619913, 0.07875329531823538, 0.07868012908315425, 0.07110188081887314, 0.07117735712646012, 0.07112065644140675]}}
{"id": "8f15883d-14e4-40e4-a97e-c14cb6810781", "fitness": 0.05335592479241184, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE introduces stochastic rank-based selection and adaptive DE parameters to improve convergence speed and robustness in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection with stochastic rank-based selection\n                trial_score = func(trial)\n                evaluations += 1\n                if np.random.rand() < 0.5 or trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05336 with standard deviation 0.03137.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276328600982708, 0.009310690040387315, 0.07865545679883124, 0.07874986047312194, 0.08155760003776402, 0.07110052259688426, 0.07117545481597187, 0.07111091035127426]}}
{"id": "d9e7b545-b857-46b9-9b53-de764a73e1ba", "fitness": -Infinity, "name": "EnhancedQuantumInspiredPSODE", "description": "Enhanced Quantum-Inspired PSODE with Adaptive Population Size and Dynamic DE Parameters for Improved Convergence Speed.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.min_population_size = 10\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n            # Adaptive population size\n            if evaluations / self.budget > 0.5:\n                population_size = max(self.min_population_size, population_size - 1)\n                population = population[:population_size]\n                personal_best_positions = personal_best_positions[:population_size]\n                personal_best_scores = personal_best_scores[:population_size]\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 31, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (20,2) (19,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (20,2) (19,2) ')", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {}}
{"id": "eacb3f0a-6392-425d-b1b4-b3fcd9775d9c", "fitness": 0.053029477832333666, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE integrates dynamic population resizing and local search refinement for improved convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.min_population_size = 5\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F_max = 0.9\n        self.F_min = 0.1\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = self.F_max - (self.F_max - self.F_min) * (evaluations / self.budget)\n            \n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation with local refinement\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n            # Dynamic population resizing\n            if evaluations / self.budget > 0.5 and population_size > self.min_population_size:\n                population_size -= 1\n                population = population[:population_size]\n                velocities = velocities[:population_size]\n                personal_best_positions = personal_best_positions[:population_size]\n                personal_best_scores = personal_best_scores[:population_size]\n                q_population = q_population[:population_size]\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276280501440914, 0.009267717319800362, 0.07865514412678054, 0.07875084185743997, 0.07866436602745508, 0.07110052259688426, 0.07117545481597187, 0.07110847382874108]}}
{"id": "bffc81b7-c7db-4e31-a322-6a99b3abae6e", "fitness": 0.05633237550474357, "name": "AdaptiveQuantumInspiredPSODESLS", "description": "Adaptive Quantum-Inspired PSODE with Selective Leader Swarm enhances convergence by periodically incorporating the best performing sub-swarms to guide overall optimization process.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODESLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.swarm_division = 4  # Number of sub-swarms\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n            \n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n            \n            # Divide population into sub-swarms and find best sub-swarm leader\n            sub_swarm_size = self.population_size // self.swarm_division\n            for i in range(self.swarm_division):\n                start = i * sub_swarm_size\n                end = start + sub_swarm_size\n                best_local_idx = np.argmin(scores[start:end]) + start\n                if scores[best_local_idx] < global_best_score:\n                    global_best_position = population[best_local_idx]\n                    global_best_score = scores[best_local_idx]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 33, "feedback": "The algorithm AdaptiveQuantumInspiredPSODESLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05633 with standard deviation 0.03348.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.010105127605224196, 0.009276520999149884, 0.009829824182609692, 0.08948883096840032, 0.07875329531823538, 0.08827843244951084, 0.07896133445169495, 0.07117735712646012, 0.07112065644140675]}}
{"id": "423342a9-9eda-483a-af03-dc4ee2ec3055", "fitness": 0.05303190388122894, "name": "QuantumInspiredAdaptiveHybridPSODE_ABC", "description": "Quantum-Inspired Adaptive Hybrid PSODE-ABC leverages adaptive parameter tuning with quantum-enhanced PSO and DE enhanced by Artificial Bee Colony for effective exploration and exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass QuantumInspiredAdaptiveHybridPSODE_ABC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.onlooker_size = int(0.5 * self.population_size)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.7 * np.random.rand() + 0.1 * (1 - evaluations / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            prob = scores / np.sum(scores)\n            onlookers = population[np.random.choice(self.population_size, self.onlooker_size, p=prob)]\n            onlooker_scores = np.array([func(ind) for ind in onlookers])\n            evaluations += self.onlooker_size\n\n            if np.min(onlooker_scores) < global_best_score:\n                global_best_position = onlookers[np.argmin(onlooker_scores)]\n                global_best_score = np.min(onlooker_scores)\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 34, "feedback": "The algorithm QuantumInspiredAdaptiveHybridPSODE_ABC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266713847112973, 0.0092764928879574, 0.009268340345217618, 0.07865733283113574, 0.07875349905585882, 0.07866436602745508, 0.07110221816256157, 0.0711775153323545, 0.07112065644140675]}}
{"id": "d961107d-30de-4997-98c7-35f631c58541", "fitness": 0.05411883870257904, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with improved mutation factor calculation enhances convergence through slight adjustment in position updates.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.6 * (1 - evaluations / self.budget)  # Slight modification here\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 35, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05412 with standard deviation 0.03212.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.00926662194827399, 0.009276520999149884, 0.009269274883343392, 0.07865670748703424, 0.07875329531823538, 0.08827843244951084, 0.07110028037321614, 0.07135994103570642, 0.07110847382874108]}}
{"id": "e9586bac-cf93-4016-a71d-55c9c1bde04c", "fitness": 0.05326253891823263, "name": "EnhancedQuantumInspiredPSODE", "description": "The algorithm blends adaptive PSO with quantum-inspired dynamics and DE to enhance convergence speed and robustness in black box optimization by dynamically tuning exploration-exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 2.0  # enhanced cognitive component\n        self.c2 = 2.0  # enhanced social component\n        self.w = 0.9   # initial inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight and shrink factor\n            self.w = 0.9 - 0.7 * (evaluations / self.budget)\n            shrink_factor = 0.9 - 0.4 * (evaluations / self.budget)\n            self.F = 0.1 + 0.6 * (1 - evaluations / self.budget)\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * shrink_factor\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05326 with standard deviation 0.03123.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.009266697607183016, 0.009537964104548324, 0.009269274883343392, 0.07865716699625513, 0.0805526554728323, 0.07868012908315425, 0.07110208993520328, 0.07117621574016719, 0.07112065644140675]}}
{"id": "e074e0f1-53d2-40bc-a5e8-dce5e5c95f92", "fitness": 0.05400005843638758, "name": "EnhancedQuantumInspiredPSODE", "description": "Enhanced Quantum-Inspired Adaptive PSODE introduces a dynamic learning strategy using crowding distance and a diversity-preserving mechanism to improve exploration and exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def crowding_distance_update(pop, scores):\n            distance = np.zeros(self.population_size)\n            sorted_indices = np.argsort(scores)\n            for i in range(1, self.population_size - 1):\n                next_index = sorted_indices[i + 1]\n                prev_index = sorted_indices[i - 1]\n                distance[sorted_indices[i]] = np.linalg.norm(pop[next_index] - pop[prev_index])\n            return distance\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(func, population)))\n                q_scores = np.array(list(executor.map(func, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation with diversity preservation\n            crowding_distances = crowding_distance_update(population, scores)\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection with crowding distance\n                trial_score = func(trial)\n                if trial_score < scores[i] or crowding_distances[i] < np.median(crowding_distances):\n                    population[i] = trial\n                    scores[i] = trial_score\n                evaluations += 1\n\n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05400 with standard deviation 0.03157.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.010105250137009247, 0.009276520999149884, 0.009269274883343392, 0.07865670748703424, 0.07875329531823538, 0.07868012908315425, 0.07896133445169495, 0.07117735712646012, 0.07112065644140675]}}
{"id": "bfe2cc81-6bad-4558-8403-697667d79c95", "fitness": 0.053033229961880674, "name": "QuantumEnhancedAdaptiveCooperativePSODE", "description": "Quantum-Enhanced Adaptive Cooperative Coevolutionary PSODE introduces cooperative coevolution among subpopulations to refine global search efficiency and precision in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass QuantumEnhancedAdaptiveCooperativePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.num_subpopulations = 4\n        self.subpopulation_size = self.population_size // self.num_subpopulations\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            \n            # Divide into subpopulations\n            for sp in range(self.num_subpopulations):\n                sp_start = sp * self.subpopulation_size\n                sp_end = sp_start + self.subpopulation_size\n                r1, r2 = np.random.rand(self.subpopulation_size, self.dim), np.random.rand(self.subpopulation_size, self.dim)\n                velocities[sp_start:sp_end] = (\n                    self.w * velocities[sp_start:sp_end] +\n                    self.c1 * r1 * (personal_best_positions[sp_start:sp_end] - population[sp_start:sp_end]) +\n                    self.c2 * r2 * (global_best_position - population[sp_start:sp_end])\n                )\n                population[sp_start:sp_end] += velocities[sp_start:sp_end] * (0.9 + 0.1 * (evaluations / self.budget))\n                population[sp_start:sp_end] = np.clip(population[sp_start:sp_end], lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation and crossover within subpopulations\n            for sp in range(self.num_subpopulations):\n                sp_start = sp * self.subpopulation_size\n                sp_end = sp_start + self.subpopulation_size\n                for i in range(sp_start, sp_end):\n                    indices = np.arange(sp_start, sp_end)\n                    indices = indices[indices != i]\n                    a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                    mutant = a + self.F * (b - c)\n                    mutant = np.clip(mutant, lb, ub)\n\n                    # DE crossover\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n                    trial = np.where(cross_points, mutant, population[i])\n\n                    # Selection\n                    trial_score = func(trial)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        population[i] = trial\n                        scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 38, "feedback": "The algorithm QuantumEnhancedAdaptiveCooperativePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.00926646160529343, 0.00927655654950088, 0.009269274883343392, 0.0786547656815425, 0.07875365784919286, 0.07868012908315425, 0.07110022785910686, 0.07117733970438511, 0.07112065644140675]}}
{"id": "072ee2d3-5ab6-441f-9b5e-b5731b6289ac", "fitness": 0.05635289491095292, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE by introducing adaptive crossover probability for dynamic exploration-exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            self.CR = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 39, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05635 with standard deviation 0.03350.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.010105219504062957, 0.009276520999149884, 0.009829824182609692, 0.08948883096840032, 0.07875329531823538, 0.0884630152065562, 0.07896133445169495, 0.07117735712646012, 0.07112065644140675]}}
{"id": "074d446b-f253-45fa-985d-d2e25f37804b", "fitness": 0.09609057083160984, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with optimized DE mutation factor for enhanced convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 40, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09609 with standard deviation 0.12565.", "error": "", "parent_ids": ["a808acc3-3869-4707-8a5c-bcfdae43aa79"], "operator": null, "metadata": {"aucs": [0.010105096972277794, 0.009276520999149884, 0.009829824182609692, 0.08948789295224813, 0.07875329531823538, 0.4397621439452576, 0.07896133445169495, 0.07117735712646012, 0.07746167153655503]}}
{"id": "95331a7a-f441-4504-bd91-0726c5b6cd8e", "fitness": 0.05439420687375196, "name": "AdaptiveQuantumInspiredPSODE", "description": "Improved convergence by adjusting inertia weight adaptation for enhanced exploration-exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.6 * (evaluations / self.budget)  # Adjusted for better balance\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 41, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05439 with standard deviation 0.03203.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009833521382705324, 0.009276280501440914, 0.009267717319800362, 0.08536468048673063, 0.07875084185743997, 0.07866436602745508, 0.07610652564348241, 0.07117545481597187, 0.07110847382874108]}}
{"id": "38648f25-83ff-4920-ac8f-9c5375ca60b3", "fitness": 0.05633079642452252, "name": "AdaptiveQuantumInspiredPSODE", "description": "Improved convergence by dynamically adjusting the inertia weight and mutation factor for better exploration-exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight and mutation factor dynamically combined in one line\n            self.w, self.F = 0.9 - 0.5 * (evaluations / self.budget), 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 42, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05633 with standard deviation 0.03348.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105250137009247, 0.009276520999149884, 0.009829824182609692, 0.08948820562429882, 0.07875182324175811, 0.08827843244951084, 0.07896036555702224, 0.07117583527806959, 0.07111091035127426]}}
{"id": "15706dcb-9310-447f-81d1-aceb8484579f", "fitness": 0.05303900456686693, "name": "AdaptiveQuantumInspiredPSODE", "description": "Introduced an adaptive crossover probability in DE for enhanced exploration and exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # Adaptive crossover probability\n            self.CR = 0.6 + 0.3 * (evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 43, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03108.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.00926662194827399, 0.009361898580455219, 0.009267717319800362, 0.07865514412678054, 0.07875084185743997, 0.07866436602745508, 0.07110052259688426, 0.07117545481597187, 0.07110847382874108]}}
{"id": "ddd539b6-dae5-45f7-bd37-6d4d12e1b179", "fitness": 0.05303136765261088, "name": "AdaptiveQuantumInspiredPSODE", "description": "Refined Adaptive Quantum-Inspired PSODE with enhanced population update through dynamic crossover rate adjustment based on current evaluations.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            self.CR = 0.5 + 0.4 * (evaluations / self.budget)  # Adjust crossover probability dynamically\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 44, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266560682381408, 0.009276520999149884, 0.009269274883343392, 0.07865670748703424, 0.07875329531823538, 0.07868012908315425, 0.0711007648205525, 0.07117545481597187, 0.07110360078367495]}}
{"id": "0351af78-5afa-4974-81e0-24ab9c065a13", "fitness": 0.05302648383896934, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with dynamic learning strategy and adaptive population size for robust black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.decay_rate = 0.99  # decay rate for adaptive population size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation with enhanced exploration\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n            # Decay population size for enhanced exploitation\n            population_size = max(5, int(self.initial_population_size * self.decay_rate ** (evaluations / self.budget)))\n            population = population[:population_size]\n            velocities = velocities[:population_size]\n            personal_best_positions = personal_best_positions[:population_size]\n            personal_best_scores = personal_best_scores[:population_size]\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03109.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266624716037786, 0.009276463484242048, 0.009265997025241668, 0.07865642303999276, 0.07875270814376223, 0.07864684237097552, 0.07110151340614412, 0.07117690379406527, 0.07109487857026264]}}
{"id": "aa9509df-9903-4015-af70-8c975ed22c1b", "fitness": 0.09544296605952836, "name": "HybridAdaptiveQuantumInspiredPSODE", "description": "Hybrid Adaptive Quantum-Inspired PSO-DE with Dynamic Population Resizing for Enhanced Exploration-Exploitation Balance in Black Box Optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass HybridAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.min_population_size = 5\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.initial_population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.initial_population_size\n        population_size = self.initial_population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(func, population)))\n                q_scores = np.array(list(executor.map(func, q_population)))\n            evaluations += 2 * population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n            # Dynamic population resizing\n            if evaluations >= self.budget * 0.5 and population_size > self.min_population_size:\n                population_size = max(self.min_population_size, population_size // 2)\n                population = population[:population_size]\n                personal_best_positions = personal_best_positions[:population_size]\n                personal_best_scores = personal_best_scores[:population_size]\n                velocities = velocities[:population_size]\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 46, "feedback": "The algorithm HybridAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09544 with standard deviation 0.12578.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105250137009247, 0.009276520999149884, 0.009384236059875928, 0.08948883096840032, 0.07875329531823538, 0.4397621439452576, 0.07896133445169495, 0.07117735712646012, 0.07207772552967184]}}
{"id": "7c5c4851-51f2-493f-962d-94b7228082bf", "fitness": 0.055894706284748734, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with enhanced DE mutation factor for improved population diversity in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.85  # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 47, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05589 with standard deviation 0.03307.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105250137009247, 0.009276376700524502, 0.009269274883343392, 0.08948883096840032, 0.07875329531823538, 0.07868012908315425, 0.07896133445169495, 0.07117583527806959, 0.07734202974230697]}}
{"id": "23321f99-e791-475a-a7c2-4d16550d175c", "fitness": 0.053029477832333666, "name": "AdaptiveQuantumInspiredPSODE", "description": "Introduce adaptive crossover probability to improve the exploration-exploitation balance in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover with adaptive CR\n                self.CR = 0.7 + 0.2 * (evaluations / self.budget)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 48, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276280501440914, 0.009267717319800362, 0.07865514412678054, 0.07875084185743997, 0.07866436602745508, 0.07110052259688426, 0.07117545481597187, 0.07110847382874108]}}
{"id": "86e7cebf-67c0-4dc1-a73a-9fcd644da7b7", "fitness": 0.05604759926624844, "name": "AdaptiveQuantumInspiredPSODE", "description": "Refined Adaptive Quantum-Inspired PSODE with enhanced global exploration through modified crossover probability.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.85  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 49, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05605 with standard deviation 0.03337.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266530049435229, 0.009276520999149884, 0.009269274883343392, 0.08948883096840032, 0.07875329531823538, 0.08089512216769801, 0.07896133445169495, 0.07117545481597187, 0.07734202974230697]}}
{"id": "3e5fa5fe-830b-4332-b851-f7d4f892a233", "fitness": -Infinity, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with Learning-based Dynamic Component to Harness Population Diversity and Accelerate Convergence.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        learning_rate = 0.01\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            \n            diversity_metric = np.std(population, axis=0)\n            self.c1 = max(0.5, self.c1 * (1 + learning_rate * diversity_metric))\n            self.c2 = max(0.5, self.c2 * (1 + learning_rate * diversity_metric))\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 50, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "08f84bc5-060c-43fa-ac20-58e258bbdeff", "fitness": 0.053256373157628184, "name": "HybridQuantumEnhancedPSODE", "description": "Hybrid Quantum-Enhanced PSO-DE with adaptive parameter scaling for dynamic exploration and exploitation balance in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass HybridQuantumEnhancedPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.49445  # cognitive component\n        self.c2 = 1.49445  # social component\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F_max = 0.9\n        self.F_min = 0.5\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight and mutation factor\n            self.w = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget))\n            self.F = self.F_min + ((self.F_max - self.F_min) * (1 - evaluations / self.budget))\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-0.5, 0.5, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 51, "feedback": "The algorithm HybridQuantumEnhancedPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05326 with standard deviation 0.03123.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266641444973911, 0.009276541787088366, 0.009330468100681721, 0.07865688943090576, 0.07875350721111185, 0.07931361749483357, 0.0711018739979069, 0.071177521664056, 0.0724302972870956]}}
{"id": "e2e88ee9-a310-40e8-b09d-c97bed64a024", "fitness": 0.053765413484368904, "name": "EnhancedQuantumInspiredPSODE", "description": "Enhanced Quantum-Inspired PSODE with adaptive cognitive components and dynamic global best influence for improved convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            self.c1 = 0.5 + 2 * (1 - evaluations / self.budget)  # Adaptive cognitive component\n            self.c2 = 0.5 + 2 * (evaluations / self.budget)  # Adaptive social component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05377 with standard deviation 0.03156.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009313319457316283, 0.009276168297461695, 0.009551336019684165, 0.07914539326723513, 0.07874969600298709, 0.08173676300940913, 0.0714812189173466, 0.07117456936167943, 0.07346025702620063]}}
{"id": "da2a8e2a-3ce1-43f6-ad8d-e2f721f63690", "fitness": 0.05506547692123254, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with time-varying DE crossover probability for improved exploration-exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover with adaptive CR\n                self.CR = 0.5 + 0.4 * (1 - evaluations / self.budget) \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 53, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05507 with standard deviation 0.03253.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105250137009247, 0.009276520999149884, 0.00926802883250899, 0.07865670748703424, 0.07875231393391724, 0.08827843244951084, 0.07896133445169495, 0.07117735712646012, 0.07111334687380733]}}
{"id": "f4a1c4a5-b4bf-45d8-9358-5ee1e4ebc358", "fitness": -Infinity, "name": "ImprovedAdaptiveQuantumInspiredPSODE", "description": "Improved Adaptive Quantum-Inspired PSODE with dynamic population size and entropy-based diversity maintenance for robust convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass ImprovedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.dynamic_shrink = True  # Enable dynamic population size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        entropy_threshold = 0.5  # Define a threshold for entropy\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n            if self.dynamic_shrink:\n                diversity = np.std(population, axis=0)\n                entropy = -np.sum(diversity * np.log(diversity + 1e-8))\n                if entropy < entropy_threshold:\n                    self.population_size = max(5, int(self.population_size * 0.75))\n                else:\n                    self.population_size = min(self.initial_population_size, self.population_size + 1)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 54, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (15,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (15,2) (20,2) ')", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "77d8e753-7434-4973-a763-294c4ade9de5", "fitness": -Infinity, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with dynamic parameter tuning and elite strategy for improved exploration and exploitation balance in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.elite_fraction = 0.1  # fraction of elite individuals\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initialize populations\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Dynamic parameter tuning\n            self.w = 0.9 - 0.4 * (evaluations / self.budget)\n            self.F = 0.1 + 0.6 * (1 - evaluations / self.budget)\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(scores)[:num_elites]\n            elite_population = population[elite_indices]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n\n                # Use elite individuals with higher probability\n                if np.random.rand() < 0.7:\n                    a, b, c = elite_population[np.random.choice(num_elites, 3, replace=False)]\n                else:\n                    a, b, c = population[np.random.choice(indices, 3, replace=False)]\n\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 55, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "b50e054f-2d1a-49ed-97ec-930545239db9", "fitness": 0.053029828122460314, "name": "AdaptiveQuantumInspiredPSODE", "description": "Fine-tuned Adaptive Quantum-Inspired PSODE with improved DE mutation strategy and controlled exploration-exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.F = 0.8\n        self.CR = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Adjusted mutation factor\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-0.5, 0.5, (self.population_size, self.dim)) * np.abs(population - global_best_position)  # Adjusted randomness range\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 56, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276280501440914, 0.009267717319800362, 0.07865514412678054, 0.07875084185743997, 0.07866751863859489, 0.07110052259688426, 0.07117545481597187, 0.07110847382874108]}}
{"id": "e1ca0812-7d45-4809-a476-c43e97d89440", "fitness": 0.053095663847111965, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with Self-Adjusting Parameters for Improved Exploration and Exploitation Balance in Black Box Optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        diversity_threshold = 0.001 * np.linalg.norm(ub - lb)\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight and mutation factor based on diversity\n            population_diversity = np.mean(np.std(population, axis=0))\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget) * (population_diversity / diversity_threshold)\n            self.F = np.clip(self.F, 0.1, 1.0)\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * \\\n                           np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05310 with standard deviation 0.03101.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276520999149884, 0.009829824182609692, 0.07865670748703424, 0.07875329531823538, 0.07868012908315425, 0.07110173371522521, 0.07117545481597187, 0.07112065644140675]}}
{"id": "22f5becb-e91a-469e-9366-4f56134c9d2b", "fitness": 0.055106336078759886, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with slight adjustment to DE crossover probability for improved exploration.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.95  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 58, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05511 with standard deviation 0.03280.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276280501440914, 0.009267717319800362, 0.08948726760814663, 0.07875084185743997, 0.07866436602745508, 0.07896012333335412, 0.07117545481597187, 0.07110847382874108]}}
{"id": "3787933c-5361-485d-be3c-65799cff88f2", "fitness": -Infinity, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with dynamic population size adjustment for improved convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n            # Adjust population size dynamically\n            self.population_size = int(20 + 10 * (1 - evaluations / self.budget))\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 59, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (26,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (26,2) (20,2) ')", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "a7ac0f0f-857b-4d18-8333-23380019d350", "fitness": 0.05517602052741306, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with dynamic population adjustment for improved convergence.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n                \n            # Dynamic population adjustment\n            if evaluations % (self.population_size * 5) == 0:\n                self.population_size += 1 if evaluations < self.budget / 2 else -1\n                self.population_size = max(5, min(50, self.population_size))\n           \n        return global_best_position, global_best_score", "configspace": "", "generation": 60, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05518 with standard deviation 0.03270.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.00932421266969119, 0.0098406039768264, 0.08948883096840032, 0.07875231393391724, 0.07866751863859489, 0.07896012333335412, 0.07117545481597187, 0.07110847382874108]}}
{"id": "3f82013d-67f9-4455-8ae5-2a6c326f4b43", "fitness": 0.05303321100588508, "name": "EnhancedQuantumInspiredPSODE", "description": "Enhanced Quantum-Inspired PSODE with dynamic adaptive parameters and parallel DE mutation for improved convergence and diversity.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.9   # initial inertia weight\n        self.min_w = 0.4  # minimum inertia weight\n        self.max_w = 0.9  # maximum inertia weight\n        self.F = 0.8   # initial mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Dynamic adaptive inertia weight and mutation factor\n            self.w = self.max_w - (self.max_w - self.min_w) * (evaluations / self.budget)\n            self.F = np.random.uniform(0.5, 1)  # Randomized F for diversity\n            \n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # Parallel DE mutation and crossover\n            def de_mutation(i):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_score = func(trial)\n                return trial, trial_score\n            \n            with ThreadPoolExecutor() as executor:\n                results = list(executor.map(de_mutation, range(self.population_size)))\n            \n            for i, (trial, trial_score) in enumerate(results):\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266713847112973, 0.009283281503463359, 0.009269274883343392, 0.07865733283113574, 0.07875329531823538, 0.0786706712497347, 0.07110221816256157, 0.07117545481597187, 0.07112065644140675]}}
{"id": "868232e2-2d37-400a-9982-d521dab2ca1b", "fitness": 0.053030722954092106, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with dynamic swarm resizing and diversity preservation for improved exploration and exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.shrink_factor = 0.9  # shrink factor for swarm dynamics\n        self.diversity_threshold = 0.1  # threshold for diversity preservation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n            diversity = np.std(population, axis=0).mean()\n            if diversity < self.diversity_threshold and evaluations < self.budget * 0.5:\n                additional_individuals = int(self.population_size * 0.1)\n                new_population = np.random.uniform(lb, ub, (additional_individuals, self.dim))\n                new_scores = np.array([func(ind) for ind in new_population])\n                evaluations += additional_individuals\n                population = np.vstack((population, new_population))\n                scores = np.hstack((scores, new_scores))\n                self.population_size += additional_individuals\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266668942174205, 0.009276520999149884, 0.009268340345217618, 0.07865687436930069, 0.07875411000410804, 0.07866436602745508, 0.07110044374754654, 0.07117583527806959, 0.07111334687380733]}}
{"id": "2e645338-a89b-4b10-bcd5-008e70064b74", "fitness": 0.057287666720421154, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with improved inertia weight decay for better convergence.  ", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight with improved decay\n            self.w = 0.9 - 0.4 * (evaluations / self.budget)  # Changed decay rate\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 63, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05729 with standard deviation 0.03465.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010632840781465536, 0.009276280501440914, 0.009267717319800362, 0.1008678426877948, 0.07875084185743997, 0.07866436602745508, 0.0858451826636808, 0.07117545481597187, 0.07110847382874108]}}
{"id": "c6d97e29-3438-4800-b86e-40a4a3392525", "fitness": 0.05546261859968576, "name": "AdaptiveQuantumInspiredPSODE", "description": "Refined Adaptive Quantum-Inspired PSODE enhancing global search by slightly altering the crossover probability for DE.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.85  # crossover probability for DE (changed from 0.9 to 0.85)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 64, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05546 with standard deviation 0.03281.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105250137009247, 0.009276520999149884, 0.00926802883250899, 0.08948883096840032, 0.07875329531823538, 0.07868012908315425, 0.07896133445169495, 0.07350952116561205, 0.07112065644140675]}}
{"id": "ff6dd8d5-1772-4b08-8d7e-5cd80b42c7f8", "fitness": 0.05302972630041489, "name": "EnhancedQuantumInspiredPSODE", "description": "Enhanced Quantum-Inspired PSODE with dynamic particle interaction and adaptive exploration for robust black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # Enhanced PSO update with dynamic interaction\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n\n            # Quantum-inspired position update with adaptive exploration\n            exploration_factor = 0.1 + 0.8 * np.exp(-(evaluations/self.budget))\n            q_population = (1 - exploration_factor) * (population + global_best_position) / 2 + exploration_factor * np.random.uniform(lb, ub, (self.population_size, self.dim))\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266556679827453, 0.009276280501440914, 0.009267717319800362, 0.07865572821471323, 0.07875084185743997, 0.07866436602745508, 0.07110097607205101, 0.07117659620226491, 0.07110847382874108]}}
{"id": "739a4e17-360e-41e8-9686-5a3928e9d73c", "fitness": 0.05519951358495864, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with updated crossover probability for improved exploration.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.85 # crossover probability for DE (changed from 0.9 to 0.85)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 66, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.03267.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105096972277794, 0.009276280501440914, 0.009267717319800362, 0.08948726760814663, 0.07875084185743997, 0.07866436602745508, 0.07896012333335412, 0.07117545481597187, 0.07110847382874108]}}
{"id": "d3855400-f9e5-41f3-a526-f205000e0d44", "fitness": 0.09522959118055958, "name": "OptimizedQuantumInspiredPSODE", "description": "Optimized Quantum-Inspired PSODE with dynamic population resizing for adaptive exploration-exploitation balance in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass OptimizedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        \n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Dynamic population resizing\n            if evaluations > self.budget // 2:\n                self.population_size = max(5, self.population_size - 1)\n                population = population[:self.population_size]\n                q_population = q_population[:self.population_size]\n                velocities = velocities[:self.population_size]\n                personal_best_positions = personal_best_positions[:self.population_size]\n                personal_best_scores = personal_best_scores[:self.population_size]\n\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 67, "feedback": "The algorithm OptimizedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09523 with standard deviation 0.12587.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276520999149884, 0.009269274883343392, 0.08948883096840032, 0.07875329531823538, 0.4397621439452576, 0.07896133445169495, 0.07117735712646012, 0.07111091035127426]}}
{"id": "debe4010-7f82-456e-9978-0f91994c72ce", "fitness": 0.05303359195946996, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with stochastic acceptance to enhance exploration in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection with stochastic acceptance\n                trial_score = func(trial)\n                evaluations += 1\n                acceptance_probability = np.exp((scores[i] - trial_score) / (1 + abs(scores[i])))\n                if trial_score < scores[i] or np.random.rand() < acceptance_probability:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 68, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276520999149884, 0.009269274883343392, 0.07865670748703424, 0.07875329531823538, 0.07868012908315425, 0.07110173371522521, 0.07117735712646012, 0.07112065644140675]}}
{"id": "a1a8d4c4-ce03-43ed-80ee-8ae0411399ad", "fitness": -Infinity, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE using dynamic population resizing and elite individual preservation for improved convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.elite_fraction = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + \\\n                           np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n            # Dynamic population resizing\n            elite_count = int(self.elite_fraction * population_size)\n            elite_indices = np.argsort(scores)[:elite_count]\n            new_population_size = max(5, min(self.budget - evaluations, population_size + evaluations // self.budget * 5))\n            elite_population = population[elite_indices]\n            if new_population_size > population_size:\n                additional_population = np.random.uniform(lb, ub, (new_population_size - population_size, self.dim))\n                population = np.vstack((elite_population, additional_population))\n            else:\n                population = elite_population\n            population_size = population.shape[0]\n            velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 69, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (20,2) (2,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (20,2) (2,2) ')", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "d5b6d334-7b59-43f4-a00b-8eaa86f03964", "fitness": 0.05414945527114676, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with dynamic adjustment of crossover probability for improved exploration.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                self.CR = 0.7 + 0.2 * (evaluations / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 70, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05415 with standard deviation 0.03213.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276280501440914, 0.009267717319800362, 0.07865514412678054, 0.07875231393391724, 0.08826266939381167, 0.07110052259688426, 0.07117583527806959, 0.07158811487312733]}}
{"id": "5415ecfe-b183-467c-98da-6cdfb36b59ff", "fitness": 0.056260679532921715, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with slightly increased crossover probability for improved exploration in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.95  # crossover probability for DE (increased from 0.9 to 0.95)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 71, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05626 with standard deviation 0.03363.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276376700524502, 0.009839357925991998, 0.08948883096840032, 0.07875329531823538, 0.0884630152065562, 0.07896133445169495, 0.07117659620226491, 0.07112065644140675]}}
{"id": "f678c60a-c0bc-4a96-b74e-2d42f54b7e3e", "fitness": 0.05526449959608028, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with enhanced DE mutation factor for improved exploration in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.9   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 72, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.03258.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105158238170486, 0.009276520999149884, 0.009829824182609692, 0.08948883096840032, 0.07875329531823538, 0.07866751863859489, 0.07896133445169495, 0.07117735712646012, 0.07112065644140675]}}
{"id": "006113a1-1f25-498a-b081-d50547e32df3", "fitness": 0.053033658612275714, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with dynamic population size and memory-based DE mutation to improve exploration and exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.memory = np.zeros((self.initial_population_size, self.dim))  # Memory for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.initial_population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.initial_population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Dynamic population size\n            population_size = max(5, int(self.initial_population_size * (1 - evaluations / self.budget)))\n\n            # Adaptive parameters\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities[:population_size] = (self.w * velocities[:population_size] +\n                                            self.c1 * r1 * (personal_best_positions[:population_size] - population[:population_size]) +\n                                            self.c2 * r2 * (global_best_position - population[:population_size]))\n            population[:population_size] += velocities[:population_size] * (0.9 + 0.1 * (evaluations / self.budget))\n            population[:population_size] = np.clip(population[:population_size], lb, ub)\n\n            # Quantum-inspired position update\n            q_population[:population_size] = 0.5 * (population[:population_size] + global_best_position) + np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population[:population_size] - global_best_position)\n            q_population[:population_size] = np.clip(q_population[:population_size], lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population[:population_size])))\n                q_scores = np.array(list(executor.map(evaluate, q_population[:population_size])))\n            evaluations += 2 * population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[:population_size][improved_q] = q_population[:population_size][improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation with memory\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                if evaluations % 10 == 0:\n                    self.memory[i] = population[i]  # Update memory with current population every 10 iterations\n                a, b, c = self.memory[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            # Update personal and global best\n            improved = scores < personal_best_scores[:population_size]\n            personal_best_positions[:population_size][improved] = population[:population_size][improved]\n            personal_best_scores[:population_size][improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266683950749699, 0.009276520999149884, 0.009269274883343392, 0.07865702753080117, 0.07875329531823538, 0.07868012908315425, 0.07110198217718078, 0.07117735712646012, 0.07112065644140675]}}
{"id": "2fddd995-019b-46f5-9f6b-7f42ecc9c595", "fitness": 0.053029477832333666, "name": "AdaptiveQuantumInspiredPSODE", "description": "Improved mutation strategy for enhanced diversity and convergence speed.  ", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + np.random.rand() * self.F * (b - c)  # Improved mutation strategy\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 74, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276280501440914, 0.009267717319800362, 0.07865514412678054, 0.07875084185743997, 0.07866436602745508, 0.07110052259688426, 0.07117545481597187, 0.07110847382874108]}}
{"id": "c6ff743a-aa24-4cd0-94e0-4b76987266a8", "fitness": -Infinity, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with dynamic population size adjustment and adaptive crossover probability for improved exploration-exploitation balance in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight and mutation factor\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # Adaptive crossover probability\n            self.CR = 0.7 + 0.3 * (evaluations / self.budget)\n            # Dynamic population size adjustment\n            population_size = self.initial_population_size + int((self.budget - evaluations) / self.budget * 10)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities[:population_size] = (self.w * velocities[:population_size] +\n                                            self.c1 * r1 * (personal_best_positions[:population_size] - population[:population_size]) +\n                                            self.c2 * r2 * (global_best_position - population[:population_size]))\n            population[:population_size] += velocities[:population_size] * (0.9 + 0.1 * (evaluations / self.budget))\n            population[:population_size] = np.clip(population[:population_size], lb, ub)\n\n            # Quantum-inspired position update\n            q_population[:population_size] = 0.5 * (population[:population_size] + global_best_position) + \\\n                                             np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population[:population_size] - global_best_position)\n            q_population[:population_size] = np.clip(q_population[:population_size], lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population[:population_size])))\n                q_scores = np.array(list(executor.map(evaluate, q_population[:population_size])))\n            evaluations += 2 * population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[:population_size][improved_q] = q_population[:population_size][improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[:population_size][improved] = population[:population_size][improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 75, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (29,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (29,2) (20,2) ')", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "46e2b4a7-bbe5-46f7-b1fd-bd0f2c521afa", "fitness": 0.05519951358495864, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE using dynamic population resizing and local search intensification for superior convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.F = 0.8\n        self.CR = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n            \n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n            if evaluations / self.budget > 0.5 and population_size > 10:\n                population_size = int(population_size * 0.9)\n                population = population[:population_size]\n                q_population = q_population[:population_size]\n                velocities = velocities[:population_size]\n                personal_best_positions = personal_best_positions[:population_size]\n                personal_best_scores = personal_best_scores[:population_size]\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.03267.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105096972277794, 0.009276280501440914, 0.009267717319800362, 0.08948726760814663, 0.07875084185743997, 0.07866436602745508, 0.07896012333335412, 0.07117545481597187, 0.07110847382874108]}}
{"id": "4903289e-ff24-498c-a5ed-0652be54bb24", "fitness": 0.053039006020970364, "name": "EnhancedQuantumInspiredPSODE", "description": "Enhanced Quantum-Inspired PSODE with dynamic particle interaction and adaptive memory for superior convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 2.0  # increased cognitive component\n        self.c2 = 1.5  # social component\n        self.w_initial = 0.9   # initial inertia weight\n        self.w_final = 0.4     # final inertia weight\n        self.F_initial = 0.9   # initial mutation factor for DE\n        self.F_final = 0.4     # final mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = self.w_initial - ((self.w_initial - self.w_final) * (evaluations / self.budget))\n            self.F = self.F_initial - ((self.F_initial - self.F_final) * (evaluations / self.budget))\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266670910469399, 0.009276541664074323, 0.009269274883343392, 0.0786568944516085, 0.07875350595642883, 0.07868012908315425, 0.07115755013801417, 0.07117714022783306, 0.07111334687380733]}}
{"id": "3a6384e4-a048-40ef-b8c1-043ea6ce1ec3", "fitness": 0.05321279962613341, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with diversity preservation and adaptive crossover rate for improved convergence.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        diversity_factor = 0.1  # Added diversity factor\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            self.CR = 0.6 + 0.4 * np.mean(personal_best_scores) / global_best_score  # Adaptive crossover rate\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1 + diversity_factor, 1 - diversity_factor, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 78, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05321 with standard deviation 0.03121.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276520999149884, 0.009352993621801198, 0.07865670748703424, 0.07875329531823538, 0.07953465912961999, 0.07110173371522521, 0.07117735712646012, 0.07179527665645424]}}
{"id": "7fbf4b72-63c9-4516-9728-9e410d01048a", "fitness": 0.055653319193907494, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with refined inertia weight adaptation for improved exploration-exploitation balance in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.4 * (evaluations / self.budget)  # Changed from 0.5 to 0.4\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 79, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05565 with standard deviation 0.03359.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.01063290155531238, 0.009276328600982708, 0.009269274883343392, 0.10086939350388802, 0.07875329531823538, 0.07868012908315425, 0.07110053623238444, 0.07117735712646012, 0.07112065644140675]}}
{"id": "f6732ed6-efe5-4843-b704-b03b7e2e993a", "fitness": 0.053033185550430205, "name": "EnhancedAdaptiveQuantumPSODE", "description": "Enhanced Adaptive Quantum PSODE integrating self-adaptive DE parameters and local search for improved convergence accuracy in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.init_F = 0.8\n        self.CR = 0.9\n        self.k_min = 0.5\n        self.k_max = 2.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub - lb), np.abs(ub - lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            self.F = self.init_F * (1 - (evaluations / self.budget))\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                self.w * velocities +\n                self.c1 * r1 * (personal_best_positions - population) +\n                self.c2 * r2 * (global_best_position - population)\n            )\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F = np.random.uniform(self.k_min, self.k_max)\n                mutant = a + F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedAdaptiveQuantumPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276328600982708, 0.009269274883343392, 0.07865639481498343, 0.07875329531823538, 0.07867697647201444, 0.07110173371522521, 0.07117735712646012, 0.07112065644140675]}}
{"id": "6f1a95e9-21db-4f3e-a575-9aa164241451", "fitness": 0.05519951358495864, "name": "EnhancedQuantumInspiredPSODE", "description": "Enhanced Quantum-Inspired PSODE with adaptive exploration-exploitation balance using entropy-based mutation diversity to improve convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.entropy_threshold = 0.5  # threshold for mutation diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        def calculate_entropy(pop):\n            normalized_pop = (pop - lb) / (ub - lb)\n            entropy = -np.sum(normalized_pop * np.log(normalized_pop + 1e-10), axis=1) / np.log(self.dim)\n            return np.mean(entropy)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            if calculate_entropy(population) < self.entropy_threshold:\n                for i in range(self.population_size):\n                    indices = np.arange(self.population_size)\n                    indices = indices[indices != i]\n                    a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                    mutant = a + self.F * (b - c)\n                    mutant = np.clip(mutant, lb, ub)\n\n                    cross_points = np.random.rand(self.dim) < self.CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n                    trial = np.where(cross_points, mutant, population[i])\n\n                    trial_score = func(trial)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        population[i] = trial\n                        scores[i] = trial_score\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.03267.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105096972277794, 0.009276280501440914, 0.009267717319800362, 0.08948726760814663, 0.07875084185743997, 0.07866436602745508, 0.07896012333335412, 0.07117545481597187, 0.07110847382874108]}}
{"id": "1fc1aef1-d6b2-4ff4-b66b-42915b4c7657", "fitness": 0.05303368042937541, "name": "EnhancedQuantumCooperativePSODE", "description": "Enhanced Quantum-Cooperative PSODE with adaptive learning factors and cooperative swarm interactions for improved convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumCooperativePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight and learning factors\n            self.w = 0.4 + 0.5 * (1 - evaluations / self.budget)\n            self.c1 = 1.5 + 1.5 * (1 - evaluations / self.budget)\n            self.c2 = 1.5 + 1.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.6 * (1 - evaluations / self.budget)\n\n            # PSO update with cooperative factor\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.7 + 0.3 * (1 - evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired and cooperative position update\n            q_population = (population + global_best_position) / 2.0 + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation with cooperative influence\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedQuantumCooperativePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.00926667656938951, 0.009276520999149884, 0.009269274883343392, 0.07865714251342737, 0.07875329531823538, 0.07868012908315425, 0.07110207092981202, 0.07117735712646012, 0.07112065644140675]}}
{"id": "ab4b6c8c-9506-4270-8af9-c75e72beedb8", "fitness": 0.056961154695104516, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with improved DE crossover strategy for better exploration in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover (adjusted strategy)\n                cross_points = np.random.rand(self.dim) < (self.CR * 0.5 + 0.5)\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 83, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05696 with standard deviation 0.03393.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105188871116777, 0.009276520999149884, 0.009268340345217618, 0.08948789295224813, 0.07875329531823538, 0.08827843244951084, 0.07896133445169495, 0.07117735712646012, 0.07734202974230697]}}
{"id": "7f5994f0-26be-4a60-93f3-a6f019f4d999", "fitness": 0.053033188535308105, "name": "HybridQuantumInspiredSelfAdaptivePSODE", "description": "Hybrid Quantum-Inspired Self-Adaptive PSODE with dynamic component weight adjustment for improved convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass HybridQuantumInspiredSelfAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_init = 2.5   # initial cognitive component\n        self.c2_init = 0.5   # initial social component\n        self.inertia_weight_init = 0.9\n        self.inertia_weight_final = 0.4\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Dynamic inertia weight, cognitive and social components\n            progress = evaluations / self.budget\n            inertia_weight = self.inertia_weight_init - (self.inertia_weight_init - self.inertia_weight_final) * progress\n            c1 = self.c1_init * (1 - progress) + 0.5 * progress\n            c2 = self.c2_init * (1 - progress) + 2.5 * progress\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          c1 * r1 * (personal_best_positions - population) +\n                          c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 84, "feedback": "The algorithm HybridQuantumInspiredSelfAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.00926656992896413, 0.009276520999149884, 0.009269274883343392, 0.07865586570641014, 0.07875855228940376, 0.07868012908315425, 0.07110107992707992, 0.07117735712646012, 0.07111334687380733]}}
{"id": "54a82ace-c98f-4e2f-b6b4-2e89d0771f82", "fitness": 0.053029477832333666, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with a dynamically tuned crossover probability for better exploration and exploitation in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # Adaptive crossover probability\n            self.CR = 0.5 + 0.4 * (evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 85, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276280501440914, 0.009267717319800362, 0.07865514412678054, 0.07875084185743997, 0.07866436602745508, 0.07110052259688426, 0.07117545481597187, 0.07110847382874108]}}
{"id": "4ff8a19c-2e71-46e0-b2c4-b8ca7be4d03c", "fitness": -Infinity, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with Dynamic Population Size Adjustment for improved convergence.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # Dynamic adjustment of population size\n            self.population_size = max(10, int(20 * (1 - evaluations / self.budget)))\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 86, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (18,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (18,2) (20,2) ')", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "f3e6042b-c1a9-4a71-b4bf-2f6d2bcc1e69", "fitness": -Infinity, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with Dynamic Population Size and Adaptive Parameter Tuning for Improved Black Box Optimization Performance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.max_population_size = 40\n        self.min_population_size = 10\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.dynamic_shrink_factor = 0.95\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # Dynamic population size adjustment\n            dynamic_population_size = int(self.min_population_size + \n                                          (self.max_population_size - self.min_population_size) * \n                                          (1 - evaluations / self.budget))\n            self.population_size = max(self.min_population_size, \n                                       min(dynamic_population_size, self.population_size))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 87, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (19,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (19,2) (20,2) ')", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "0aeabbf2-553a-47b2-84e9-e3bec99b5178", "fitness": 0.053029477832333666, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE enhanced with refined DE mutation strategy for improved exploration and convergence.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b + c - 2 * a) # Slightly refined DE mutation strategy\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 88, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276280501440914, 0.009267717319800362, 0.07865514412678054, 0.07875084185743997, 0.07866436602745508, 0.07110052259688426, 0.07117545481597187, 0.07110847382874108]}}
{"id": "2732777c-6723-4a40-9bbb-63ab069861c9", "fitness": 0.053029477832333666, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced convergence by adjusting the crossover probability based on evaluations.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                self.CR = 0.5 + 0.4 * np.cos(np.pi * evaluations / self.budget)  # Modified line\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 89, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266499416488938, 0.009276280501440914, 0.009267717319800362, 0.07865514412678054, 0.07875084185743997, 0.07866436602745508, 0.07110052259688426, 0.07117545481597187, 0.07110847382874108]}}
{"id": "d53240b7-9eb7-4895-8e21-d436915104f1", "fitness": 0.05608790681825837, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE by introducing an adaptive crossover probability for DE to improve exploration and exploitation balance.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                self.CR = 0.5 + 0.4 * np.sin(np.pi * evaluations / self.budget)  # Adaptive crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 90, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05609 with standard deviation 0.03345.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105158238170486, 0.009276520999149884, 0.009269274883343392, 0.08948883096840032, 0.07875182324175811, 0.08827843244951084, 0.07110173371522521, 0.07117735712646012, 0.07734202974230697]}}
{"id": "997ff7b1-4e3c-43e6-a5ce-5b8b0900a1c6", "fitness": 0.053155053128536904, "name": "EnhancedQuantumInspiredPSODE", "description": "Enhanced Quantum-Inspired PSODE with adaptive inertia, mutation factor, and crossover rate for dynamic exploration and exploitation balance in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        \n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive parameters\n            inertia_weight = 0.9 - (0.5 * evaluations / self.budget)\n            mutation_factor = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            crossover_rate = 0.5 + 0.4 * (evaluations / self.budget)\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05316 with standard deviation 0.03117.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266670910469399, 0.009329046960256271, 0.009269274883343392, 0.0786568944516085, 0.0793387262891071, 0.0786706712497347, 0.07110187887000974, 0.07164409462342936, 0.07111821991887368]}}
{"id": "5b116fae-b722-4d0c-8635-27ec4e93014e", "fitness": -Infinity, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with dynamic population resizing for improved exploration and exploitation in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.min_population_size = 5\n        self.max_population_size = 40\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Population initialization\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Dynamically adjust population size\n            population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - evaluations / self.budget))\n            population_size = max(self.min_population_size, min(self.max_population_size, population_size))\n            # Resize arrays based on new population size\n            if len(population) != population_size:\n                indices = np.random.choice(len(population), population_size, replace=False)\n                population = population[indices]\n                q_population = q_population[indices]\n                velocities = velocities[indices]\n                personal_best_positions = personal_best_positions[indices]\n                personal_best_scores = personal_best_scores[indices]\n\n            # Adaptive inertia weight and mutation factor\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 92, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "672e8d7b-c0df-4cec-bd0f-3bf5c70eafe7", "fitness": 0.05519951358495864, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with varied mutation and crossover strategies for improved global convergence.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # Adjusted shrink factor and adaptive crossover\n            shrink_factor = 0.85 + 0.1 * (1 - evaluations / self.budget)\n            self.CR = 0.8 + 0.1 * (evaluations / self.budget)\n            \n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 93, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.03267.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.010105096972277794, 0.009276280501440914, 0.009267717319800362, 0.08948726760814663, 0.07875084185743997, 0.07866436602745508, 0.07896012333335412, 0.07117545481597187, 0.07110847382874108]}}
{"id": "2aed862c-1733-4959-ae00-deffa1f284bf", "fitness": -Infinity, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-inspired PSODE with Levy Flights and Random Restarts to improve exploration and avoid local minima in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n        self.alpha = 0.01  # scaling factor for Levy flight\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return self.alpha * step\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n\n            # Levy flights for exploration\n            if evaluations < self.budget:\n                levy_population = population + np.array([self.levy_flight() for _ in range(self.population_size)])\n                levy_population = np.clip(levy_population, lb, ub)\n                levy_scores = np.array([func(ind) for ind in levy_population])\n                evaluations += self.population_size\n\n                better_levy = levy_scores < scores\n                population[better_levy] = levy_population[better_levy]\n                scores[better_levy] = levy_scores[better_levy]\n\n                # Update personal and global best again\n                improved = scores < personal_best_scores\n                personal_best_positions[improved] = population[improved]\n                personal_best_scores[improved] = scores[improved]\n                if np.min(scores) < global_best_score:\n                    global_best_position = population[np.argmin(scores)]\n                    global_best_score = np.min(scores]\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 94, "feedback": "An exception occurred: SyntaxError(\"closing parenthesis ']' does not match opening parenthesis '('\", ('<string>', 103, 54, '                    global_best_score = np.min(scores]')).", "error": "SyntaxError(\"closing parenthesis ']' does not match opening parenthesis '('\", ('<string>', 103, 54, '                    global_best_score = np.min(scores]'))", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {}}
{"id": "2cb426f1-8396-410f-b29a-cf01587d4be2", "fitness": 0.054849059661955905, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced global best convergence by dynamically adjusting the dimensionality of crossover in DE mutation.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                self.CR = 0.7 + 0.2 * (evaluations / self.budget)  # Dynamically adjust crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 95, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05485 with standard deviation 0.03257.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276328600982708, 0.009269274883343392, 0.07865545679883124, 0.07929190217271898, 0.08826266939381167, 0.07110100704422062, 0.07117621574016719, 0.07734202974230697]}}
{"id": "fc23a0b9-72b3-435a-84a1-e87870bc6139", "fitness": 0.053033381161951554, "name": "AdaptiveQuantumInspiredPSODE", "description": "Improved local search for better exploration by adding noise to velocity updates.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population) +\n                          np.random.normal(0, 0.1, velocities.shape))  # Added noise for exploration\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 96, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05303 with standard deviation 0.03110.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652950254528, 0.009276520999149884, 0.009268619077910656, 0.07865671125027451, 0.07875329531823538, 0.07868194702876896, 0.07110173566314759, 0.07117735712646012, 0.07111759104336235]}}
{"id": "44a81b00-ae69-440d-857b-524676be41f2", "fitness": 0.05311731494753565, "name": "EnhancedAdaptiveQuantumInspiredPSODE", "description": "Enhanced Adaptive Quantum-Inspired PSODE with dynamic population resizing and adaptive DE parameters for improved convergence in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass EnhancedAdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F_min = 0.1\n        self.F_max = 0.9\n        self.CR = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = population_size\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = self.F_min + (self.F_max - self.F_min) * (1 - evaluations / self.budget)\n            \n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(population_size):\n                indices = np.arange(population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n            # Dynamic population resizing\n            if evaluations < 0.5 * self.budget:\n                population_size = min(int(1.3 * population_size), self.budget - evaluations)\n            else:\n                population_size = max(int(0.7 * population_size), 10)\n\n            # Adjust arrays to new population size\n            if len(population) != population_size:\n                population = np.resize(population, (population_size, self.dim))\n                q_population = np.resize(q_population, (population_size, self.dim))\n                velocities = np.resize(velocities, (population_size, self.dim))\n                personal_best_positions = np.resize(personal_best_positions, (population_size, self.dim))\n                personal_best_scores = np.full(population_size, np.inf)\n                scores = np.full(population_size, np.inf)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05312 with standard deviation 0.03115.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276520999149884, 0.00933610640278515, 0.07865670748703424, 0.07875329531823538, 0.0793789870689694, 0.07110173371522521, 0.07117735712646012, 0.07110847382874108]}}
{"id": "d7962bbf-fdcf-481b-9323-4fa604a539ab", "fitness": 0.05567591430488694, "name": "AdaptiveQuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSODE with adjusted crossover probability to enhance exploration in black box optimization.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update\n            q_population = 0.5 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                self.CR = 0.8 + 0.1 * (evaluations / self.budget)  # Adjusted crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 98, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05568 with standard deviation 0.03307.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276520999149884, 0.009269274883343392, 0.07865545679883124, 0.07875329531823538, 0.0882689746160914, 0.07896133445169495, 0.07117735712646012, 0.07745436196895572]}}
{"id": "5b157037-a914-4fce-907b-2181a160eebe", "fitness": 0.05306555106571573, "name": "AdaptiveQuantumInspiredPSODE", "description": "Enhanced convergence by refining the quantum-inspired position update factor.", "code": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass AdaptiveQuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.F = 0.8   # mutation factor for DE\n        self.CR = 0.9  # crossover probability for DE\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Quantum-inspired initialization\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        q_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-np.abs(ub-lb), np.abs(ub-lb), (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in population])\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evaluations = self.population_size\n        shrink_factor = 0.9\n\n        def evaluate(ind):\n            return func(ind)\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)\n            # Adaptive mutation factor\n            self.F = 0.1 + 0.7 * (1 - evaluations / self.budget)\n            # PSO update with quantum-inspired enhancement\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities * (0.9 + 0.1 * (evaluations / self.budget))\n            population = np.clip(population, lb, ub)\n\n            # Quantum-inspired position update with refined factor\n            q_population = 0.7 * (population + global_best_position) + np.random.uniform(-1, 1, (self.population_size, self.dim)) * np.abs(population - global_best_position)\n            q_population = np.clip(q_population, lb, ub)\n\n            # Parallel evaluation of new positions\n            with ThreadPoolExecutor() as executor:\n                scores = np.array(list(executor.map(evaluate, population)))\n                q_scores = np.array(list(executor.map(evaluate, q_population)))\n            evaluations += 2 * self.population_size\n\n            # Replace with quantum-inspired solutions if better\n            improved_q = q_scores < scores\n            population[improved_q] = q_population[improved_q]\n            scores[improved_q] = q_scores[improved_q]\n\n            # DE mutation\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                # DE crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    population[i] = trial\n                    scores[i] = trial_score\n            \n            # Update personal and global best\n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            if np.min(scores) < global_best_score:\n                global_best_position = population[np.argmin(scores)]\n                global_best_score = np.min(scores)\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 99, "feedback": "The algorithm AdaptiveQuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05307 with standard deviation 0.03113.", "error": "", "parent_ids": ["074d446b-f253-45fa-985d-d2e25f37804b"], "operator": null, "metadata": {"aucs": [0.009266652581220391, 0.009276520999149884, 0.009269274883343392, 0.07865670748703424, 0.07875329531823538, 0.0789677610393662, 0.07110173371522521, 0.07117735712646012, 0.07112065644140675]}}
