{"id": "7684a516-889c-4b2c-bb1c-b2681874943e", "fitness": 0.09326796098187733, "name": "HybridDESA", "description": "A hybrid Differential Evolution and Simulated Annealing algorithm that adaptively balances exploration and exploitation in high-dimensional spaces.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 0, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.04.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.15874597575682836, 0.1372315618981873, 0.12894560203607108, 0.12895675615470337, 0.13172634231929914, 0.12051389728120543, 0.09198956027289262, 0.11871713964267216, 0.09043428797195951, 0.10232006127191884, 0.10184992164842144, 0.09765427197745313, 0.09807203260221353, 0.09167564233845427, 0.09872727159080041]}}
{"id": "c054b503-7dcf-41f2-b405-a2ed4cad9d82", "fitness": 0.0918701438253674, "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive crossover probability based on fitness improvement rate to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Adaptive Crossover\n                improvement_rate = (fitness[i] - best_fitness) / abs(fitness[i] + 1e-10)\n                adaptive_CR = min(1, max(0, self.CR + improvement_rate))\n                trial = np.where(np.random.rand(self.dim) < adaptive_CR, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 1, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.04.", "error": "", "parent_ids": ["7684a516-889c-4b2c-bb1c-b2681874943e"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.14613294767723595, 0.12641776590828557, 0.12860485373979857, 0.1390471936895047, 0.12898732143373304, 0.12051389728120543, 0.09148062718012295, 0.10082136384918339, 0.09043428797195951, 0.10232006127191884, 0.10184992164842144, 0.09765427197745313, 0.09807203260221353, 0.09767064021604355, 0.09959679518580222]}}
{"id": "b5c528c6-7a55-474e-8531-9831edae86e1", "fitness": 0.08893116248457442, "name": "HybridDESA", "description": "Enhanced HybridDESA by refining mutation strategy and dynamic adjustment of crossover probability.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = population[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x4)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                CR_dynamic = self.CR * (1 - eval_count / self.budget)\n                trial = np.where(np.random.rand(self.dim) < CR_dynamic, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 2, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.03.", "error": "", "parent_ids": ["7684a516-889c-4b2c-bb1c-b2681874943e"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.11914562999945355, 0.12196026121770098, 0.11451496240133374, 0.1338168505504327, 0.13312837709736813, 0.12051389728120543, 0.08806974569186987, 0.10082136384918339, 0.09043428797195951, 0.10232006127191884, 0.10184992164842144, 0.09765427197745313, 0.09807203260221353, 0.0897954196657077, 0.09872727159080041]}}
{"id": "c20e9e6c-1f30-4d62-96e2-3602af6d96fe", "fitness": 0.08693580868474796, "name": "HybridDESA", "description": "Improved HybridDESA with dynamic population size adjustment to enhance convergence speed in varying dimensions.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            self.population_size = max(4, int(0.9 * self.population_size))  # Dynamic adjustment\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 3, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.03.", "error": "", "parent_ids": ["7684a516-889c-4b2c-bb1c-b2681874943e"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.11094329703189298, 0.09600107552723736, 0.14377029155069454, 0.11467471031720422, 0.11169649310811058, 0.12051389728120543, 0.09364288342648974, 0.10082136384918339, 0.09043428797195951, 0.10232006127191884, 0.10184992164842144, 0.09765427197745313, 0.09807203260221353, 0.0897954196657077, 0.09872727159080041]}}
{"id": "c7ab9ec3-4540-4930-afdc-5b71b9fa25b8", "fitness": 0.09070290649786457, "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive population size scaling based on the remaining budget to improve diversity and convergence speed.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            # Dynamic adjustment of population size\n            current_population_size = max(5, int(self.population_size * (1 - eval_count / self.budget)))\n            \n            for i in range(current_population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 4, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.04.", "error": "", "parent_ids": ["7684a516-889c-4b2c-bb1c-b2681874943e"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.13526469871737345, 0.13719949941202159, 0.12538834607028881, 0.131549520351118, 0.1252562527738742, 0.12051389728120543, 0.09060769341436281, 0.10082136384918339, 0.09123898445688217, 0.10232006127191884, 0.10184992164842144, 0.09765427197745313, 0.09807203260221353, 0.0897954196657077, 0.09872727159080041]}}
{"id": "ce53f241-c057-49c3-901b-c2a3347f7db8", "fitness": 0.0908388866758233, "name": "HybridDESA", "description": "An enhanced HybridDESA with adaptive crossover probability to dynamically balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Adaptive Crossover\n                current_CR = self.CR * (1 - eval_count / self.budget)\n\n                trial = np.where(np.random.rand(self.dim) < current_CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 5, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.03.", "error": "", "parent_ids": ["7684a516-889c-4b2c-bb1c-b2681874943e"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.11747275755596165, 0.1292388120492325, 0.11988918125842474, 0.12955220004156454, 0.12846678067318984, 0.12051389728120543, 0.0931389646711066, 0.11570383138619555, 0.1012280635217696, 0.10232006127191884, 0.10184992164842144, 0.10284615910579464, 0.09807203260221353, 0.0897954196657077, 0.09889075590929286]}}
{"id": "96d96602-eebc-48af-b2cc-a9b316058761", "fitness": 0.09259435776608654, "name": "HybridDESA", "description": "Enhanced Adaptive HybridDESA by optimizing temperature schedule for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        # Modified temperature schedule for smoother transition\n        self.temperature_schedule = np.logspace(0, -2, budget) * self.initial_temperature\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 6, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.04.", "error": "", "parent_ids": ["7684a516-889c-4b2c-bb1c-b2681874943e"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1375773261879748, 0.1354547552257005, 0.1366150969791895, 0.14754828217707383, 0.13377740742519173, 0.12051389728120543, 0.0880993591626047, 0.10082136384918339, 0.09144602303987759, 0.10232006127191884, 0.10224948525655753, 0.09765427197745313, 0.09925053876593526, 0.0897954196657077, 0.10096497218169076]}}
{"id": "46148501-25de-41ca-a301-a35b815a9218", "fitness": 0.1003587837511543, "name": "HybridDESA", "description": "An enhanced hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameter tuning and elitism to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Adaptive crossover with elitism\n                if np.random.rand() < 0.5: \n                    trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < self.CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 7, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.05.", "error": "", "parent_ids": ["7684a516-889c-4b2c-bb1c-b2681874943e"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.14327457454676784, 0.1298190895028919, 0.21656882574526404, 0.13777318697040264, 0.21292085700347607, 0.12051389728120543, 0.09225964524811903, 0.10082136384918339, 0.09043428797195951, 0.10485970296879166, 0.10377962931115547, 0.09975699589068099, 0.09807203260221353, 0.0897954196657077, 0.09872727159080041]}}
{"id": "5234a2ab-c8e7-47fd-b449-703508998c9b", "fitness": 0.09794647554224203, "name": "HybridDESA", "description": "A refined HybridDESA algorithm enhancing exploration by adjusting the Differential Evolution mutation strategy.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2) + 0.05 * (best_solution - x0)  # Refined mutation\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Adaptive crossover with elitism\n                if np.random.rand() < 0.5: \n                    trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < self.CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 8, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.04.", "error": "", "parent_ids": ["46148501-25de-41ca-a301-a35b815a9218"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.12930886575405653, 0.16080276117284653, 0.12757590114561612, 0.1547270983640413, 0.1217444337543, 0.12386087711168792, 0.09704227265441945, 0.10082136384918339, 0.1284761945507843, 0.10232006127191884, 0.10747464806032347, 0.09800888668187213, 0.11156988918011013, 0.12867009082841374, 0.09872727159080041]}}
{"id": "c92934df-07db-457b-b389-6c3a6207076f", "fitness": 0.6914803783050933, "name": "HybridDESA", "description": "A refined hybrid algorithm incorporating dynamic crossover probability and a new scaling factor for improved exploration.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5: \n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 9, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.38.", "error": "", "parent_ids": ["46148501-25de-41ca-a301-a35b815a9218"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9746495292834813, 0.9234449535587304, 0.9715645077911531, 0.9460443200152298, 0.9885963744822835, 0.7913917466484066, 0.9291497832590655, 0.9271904535376891, 0.79442718175962, 0.9895977339608306, 0.7650745338206967, 0.9306134787472807, 0.8986475205656235, 0.9685209683581159, 0.8628955854391946]}}
{"id": "556753ce-2a27-437d-bee1-b363ce89a6cb", "fitness": 0.6839404333390205, "name": "HybridDESA", "description": "Enhanced Differential Evolution algorithm with a refined scaling factor calculation for improved convergence.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.5 + 0.4 * np.random.rand()  # Updated scaling factor with randomness\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5: \n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 10, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.41.", "error": "", "parent_ids": ["c92934df-07db-457b-b389-6c3a6207076f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9541556616683831, 0.9438023009399392, 0.9456008132882786, 0.9595591711957475, 0.9689779580717903, 0.8932248382439831, 0.9647642046903537, 0.9717136241555798, 0.9698133100461076, 0.22277703256121628, 0.9779458697930592, 0.9449740534929401, 0.9626273907866378, 0.9422403718822627, 0.8888331710896633]}}
{"id": "d6d4c3d4-3019-441e-98ba-984b83d63ec9", "fitness": 0.5823784287441514, "name": "HybridDESA", "description": "A refined hybrid algorithm incorporating dynamic crossover probability, a new scaling factor for improved exploration, and an enhanced population size adjustment strategy.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 7 * dim  # Increased scaling factor\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5: \n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 11, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.58 with standard deviation 0.40.", "error": "", "parent_ids": ["c92934df-07db-457b-b389-6c3a6207076f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9707981067927947, 0.9604594010378383, 0.9876751784197297, 0.8475018190653874, 0.9510524186873085, 0.930895351836455, 0.8287860462789175, 0.9094549320306491, 0.8187698964173836, 0.9644059549954337, 0.20871467829989543, 0.8190517103266632, 0.22421018211044053, 0.7977329639943876, 0.26026103971527625]}}
{"id": "d72fc0d2-2584-49c7-9324-32a15a20d3f6", "fitness": 0.7232398996312224, "name": "HybridDESA", "description": "Enhanced mutation by adapting the scaling factor dynamically based on fitness diversity.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                self.F = 0.5 + 0.4 * fitness_diversity  # Adapted scaling factor based on fitness diversity\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5: \n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 12, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["c92934df-07db-457b-b389-6c3a6207076f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9750733257469344, 0.9488081096957256, 0.9691847966254638, 0.9723326751256096, 0.9886549107043493, 0.9561720923569944, 0.9584085349398244, 0.957791787370436, 0.9258504921736693, 0.8742586127779547, 0.9531987299783338, 0.9577719373772337, 0.9451521798828784, 0.9350392292847296, 0.9793016837098446]}}
{"id": "f0809ef8-d171-4feb-9703-afbf9b99cc15", "fitness": 0.7258643454291825, "name": "HybridDESA", "description": "Improved mutation strategy by introducing a temperature-based scaling factor to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 13, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["d72fc0d2-2584-49c7-9324-32a15a20d3f6"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9844859851394665, 0.9465642716675506, 0.958504680571789, 0.9457822406342797, 0.9439783235713861, 0.9441197809441031, 0.9696529566021633, 0.925459115960816, 0.9686419600164817, 0.9590452283356501, 0.9503279568354159, 0.9680859525964121, 0.9577452203384598, 0.9477842784773022, 0.9793100620179082]}}
{"id": "35896db4-bd00-4d52-8389-e3699af41bb0", "fitness": 0.7258643454291825, "name": "HybridDESA", "description": "Improved selection strategy by adjusting the Simulated Annealing acceptance probability calculation for better exploration. ", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (self.temperature_schedule[eval_count - 1] + 1e-9)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 14, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["f0809ef8-d171-4feb-9703-afbf9b99cc15"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9844859851394665, 0.9465642716675506, 0.958504680571789, 0.9457822406342797, 0.9439783235713861, 0.9441197809441031, 0.9696529566021633, 0.925459115960816, 0.9686419600164817, 0.9590452283356501, 0.9503279568354159, 0.9680859525964121, 0.9577452203384598, 0.9477842784773022, 0.9793100620179082]}}
{"id": "aebf178a-25e8-44a9-9fcd-bf2cafd4e3a3", "fitness": -Infinity, "name": "HybridDESA", "description": "Enhanced exploration by introducing a dynamic population size adjustment based on fitness diversity.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            # Adjust population size based on fitness diversity\n            adjusted_population_size = int(self.population_size * (1 + np.std(fitness) / (np.mean(fitness) + 1e-9)))\n            for i in range(adjusted_population_size):  # Using adjusted_population_size dynamically\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 15, "feedback": "An exception occurred: IndexError('index 125 is out of bounds for axis 0 with size 125').", "error": "IndexError('index 125 is out of bounds for axis 0 with size 125')", "parent_ids": ["f0809ef8-d171-4feb-9703-afbf9b99cc15"], "operator": null, "metadata": {}}
{"id": "9ec7e362-efa8-407d-aa57-75fcfaf9eeec", "fitness": 0.7354412889875033, "name": "HybridDESA", "description": "Enhanced exploration by dynamically adjusting population size based on evaluation progress.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 16, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["f0809ef8-d171-4feb-9703-afbf9b99cc15"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9502214590351756, 0.987287118555754, 0.9503389707602952, 0.988749063530009, 0.9560919637241617, 0.9877306076278276, 0.9544553264633591, 0.988109629797628, 0.9870546727043665, 0.9885143028783944, 0.9565639786857796, 0.9564806866960689, 0.9471721856769348, 0.9557220689519378, 0.9865348497879043]}}
{"id": "0c555e18-1c27-4bc0-a759-9b7b1d0bcc9e", "fitness": 0.7354412889875033, "name": "HybridDESA", "description": "Enhanced exploration by incorporating adaptive scaling factor based on fitness diversity and budget utilization.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 17, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["9ec7e362-efa8-407d-aa57-75fcfaf9eeec"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9502214590351756, 0.987287118555754, 0.9503389707602952, 0.988749063530009, 0.9560919637241617, 0.9877306076278276, 0.9544553264633591, 0.988109629797628, 0.9870546727043665, 0.9885143028783944, 0.9565639786857796, 0.9564806866960689, 0.9471721856769348, 0.9557220689519378, 0.9865348497879043]}}
{"id": "8af9ff6d-85c0-47bf-929e-96622d7d73ba", "fitness": 0.7391285670858434, "name": "HybridDESA", "description": "Improved exploration using adaptive mutation factor and enhanced best solution retention.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 18, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["9ec7e362-efa8-407d-aa57-75fcfaf9eeec"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9919368772451743, 0.9593267948208339, 0.9853125900389054, 0.9894564541897732, 0.9835415683136738, 0.9909657084246407, 0.9580429325893052, 0.9446944685875327, 0.9499315055287695, 0.9603651969981724, 0.9503076113742526, 0.9881281070441543, 0.9872027971646062, 0.98835293266842, 0.987206901854186]}}
{"id": "9a6d7347-7d54-4c38-b023-8c20c2ba6c6b", "fitness": 0.7385770015120741, "name": "HybridDESA", "description": "Enhanced population diversity control and adaptive crossover for improved convergence speed.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.7 * eval_count / self.budget)  # Increased dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 19, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9919368772451743, 0.9576990470603228, 0.9850224082920573, 0.9894372244525912, 0.9534126274568385, 0.9909656702031672, 0.9538606737012936, 0.9569313712175408, 0.9619418174444317, 0.9884143919014741, 0.9219561722284776, 0.9866639603691539, 0.9884147105537892, 0.9883554700056699, 0.9887287132350333]}}
{"id": "94126c02-3554-47d8-97d0-e1c7a6c4faf7", "fitness": 0.7354412889875033, "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive mutation strategies and dynamic adjustment of scaling factors.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor  # Adjusted scaling factor range\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 20, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9502214590351756, 0.987287118555754, 0.9503389707602952, 0.988749063530009, 0.9560919637241617, 0.9877306076278276, 0.9544553264633591, 0.988109629797628, 0.9870546727043665, 0.9885143028783944, 0.9565639786857796, 0.9564806866960689, 0.9471721856769348, 0.9557220689519378, 0.9865348497879043]}}
{"id": "fdf238cc-d51f-4af7-b36e-83ea2f160973", "fitness": 0.7342293616524668, "name": "HybridDESA", "description": "Enhanced dynamic adaptation by refining crossover and mutation strategies for improved convergence.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.4 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.4 + 0.6 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 21, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9604198399926657, 0.9557917661136225, 0.9371305872272306, 0.9891035756297225, 0.9581514143051538, 0.9616565361485079, 0.9881003257666786, 0.9883190492332603, 0.9634849522244661, 0.9511879509603298, 0.9489665561635193, 0.951084898049755, 0.988130160271784, 0.9877076519374541, 0.9875530741507175]}}
{"id": "f32b19c6-0299-4a12-b23b-4a4db332bac6", "fitness": 0.7270377942581359, "name": "HybridDESA", "description": "Improved exploration with modified dynamic crossover probability and elitism mechanism.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * np.sqrt(eval_count / self.budget))  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 22, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9920235196075138, 0.9569634301620092, 0.955648936431704, 0.8366059582320934, 0.9581092192589354, 0.9884737266774285, 0.9542525890293239, 0.9554587042299603, 0.989154261721077, 0.9883649640186779, 0.9583550542172445, 0.9542279626838353, 0.957983166042053, 0.9419721435572811, 0.9853633544191137]}}
{"id": "18f99401-c664-42dc-a4ba-73a8fab84534", "fitness": 0.730779508612423, "name": "HybridDESA", "description": "Enhanced convergence by refining the adaptive mutation factor scaling strategy.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.7 + 0.2 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 23, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9919972968240703, 0.9851825777608442, 0.9464586524110215, 0.9558765457942178, 0.953876106974176, 0.9491230613560623, 0.9544847894938101, 0.9888185589327463, 0.9172769815326783, 0.9594040658708701, 0.9583079749092749, 0.9568698564574107, 0.9871348891709486, 0.9879184538333098, 0.9550614660525559]}}
{"id": "9ea25d0a-af38-4fb1-a5d6-55c79b3f70be", "fitness": 0.7339138909933619, "name": "HybridDESA", "description": "Improved exploration efficiency by introducing an adaptive scaling factor and dynamic elitism in crossover probability.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.4 + 0.6 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 24, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.963922684822366, 0.9562807976451639, 0.9875283947980358, 0.95201428278851, 0.9875164592470722, 0.9615494626281921, 0.9578677808916046, 0.9492869959789388, 0.9561386317526556, 0.9868106947297041, 0.9600221675832947, 0.9883912567975159, 0.9591523192592786, 0.955122998256862, 0.9888739978135794]}}
{"id": "1cacfcec-5e3c-48d9-b899-1e2a0b676992", "fitness": 0.4771327395505768, "name": "HybridDESA", "description": "Enhanced differential mutation using fitness-based adaptive scaling and refined crossover strategy for improved exploration and convergence.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * (1 - temperature_factor)  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * (1 - eval_count / self.budget))  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 25, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.34.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9646744233852695, 0.9707902530503818, 0.4944373394526448, 0.4617915460948969, 0.9751861370644592, 0.33980483401031536, 0.4490774997792343, 0.3704282522729003, 0.4253788707006634, 0.3541199156470164, 0.9617619445390484, 0.5628621995058436, 0.9658553544435997, 0.37055600094963437, 0.7081313252411613]}}
{"id": "2a0b39bd-d33a-4ccf-99c7-6535dfc9737e", "fitness": 0.7367072736433901, "name": "HybridDESA", "description": "Optimized exploration by fine-tuning mutation scaling based on fitness variance and diversity.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.4 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 26, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9565224210847559, 0.9585022587708577, 0.962490456369692, 0.9899435294242674, 0.9878517474194325, 0.9573380776782235, 0.9564667542807765, 0.960618859534486, 0.9849396869451409, 0.9877856823843828, 0.9873791767105252, 0.9551065452884704, 0.9503963790563756, 0.9815855748332616, 0.9894194282126891]}}
{"id": "ec6f734e-16d4-4342-a25d-078fc261813f", "fitness": 0.7327249605287907, "name": "HybridDESA", "description": "Enhanced exploration by a slight increase in the mutation factor's influence on diversity.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.35 * fitness_diversity * temperature_factor  # Adapted scaling factor with slight increase\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 27, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9920121882471635, 0.9596339714771578, 0.9550953422145543, 0.9858521585345571, 0.9351562088437153, 0.9874922555526574, 0.9890254895480365, 0.9503899241496899, 0.9438895647773516, 0.9877588881713864, 0.986241203597554, 0.9497252318582731, 0.9333996744731198, 0.9458659190697504, 0.98516229518638]}}
{"id": "66f10051-e565-46ea-af35-ff2ec8553ba0", "fitness": 0.7352505323909013, "name": "HybridDESA", "description": "Refined adaptive mutation scaling factor enhances exploration efficiency.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.7 + 0.3 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 28, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9875922643771178, 0.9507249883225117, 0.98422829228932, 0.9825651882697402, 0.9642645786040795, 0.9865643404863393, 0.9512586608574598, 0.9887784996246443, 0.9591110186108333, 0.9516303393855655, 0.9576396438861882, 0.9851325456424856, 0.9873315781726005, 0.94626486009166, 0.9541249543230151]}}
{"id": "682b34cf-01f3-4c69-92f3-e7d9e2386318", "fitness": 0.7354611008483702, "name": "HybridDESA", "description": "Enhanced adaptive mutation factor scaling based on fitness variance and temperature.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.65 + 0.25 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 29, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.986174120885466, 0.9551647367166045, 0.9573433188542606, 0.989574303520448, 0.9868731725975759, 0.9623569567304948, 0.9856325352807327, 0.9529543219285521, 0.9557728000483565, 0.9402941814554032, 0.9864643597975837, 0.9582790325585235, 0.9510466275208631, 0.9841270773494566, 0.9893655768486169]}}
{"id": "4873d9f2-1538-4d87-b965-d7b6a0d20bb8", "fitness": 0.12508273631587016, "name": "HybridDESA", "description": "Enhanced the exploration process by incorporating a covariance matrix adaptation mechanism.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n        self.cov_matrix = np.eye(dim)  # Added covariance matrix\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor  # Adapted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                \n                # Apply covariance matrix adaptation\n                trial = np.random.multivariate_normal(trial, self.cov_matrix)  # Incorporate covariance matrix\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 30, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.05.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.14197069600653334, 0.15042336206582374, 0.1373193779988896, 0.17086110770656582, 0.11994513883173885, 0.1945076843214939, 0.1525148194754068, 0.1548118841314453, 0.16864589878031855, 0.1614427477857343, 0.15989489240695487, 0.16792623572343068, 0.16723739020471995, 0.14708654412382316, 0.1392680518800583]}}
{"id": "351e34c1-ba7d-44cf-bde9-cca87671ee7c", "fitness": 0.7401386933415294, "name": "HybridDESA", "description": "Enhanced convergence by integrating a dynamic adjustment of the differential weight factor based on the iteration progress.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 31, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["8af9ff6d-85c0-47bf-929e-96622d7d73ba"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918405934464379, 0.9876806019757647, 0.95450085155944, 0.989291263804005, 0.9849099103280261, 0.990965724251779, 0.9872884045528619, 0.9875426121186763, 0.9451872489860045, 0.9565457186243718, 0.9387541635834278, 0.9881236604146517, 0.9879175526440699, 0.9572520877604738, 0.987174577906132]}}
{"id": "17441118-7eb6-4bb3-a658-dce11e1b82e2", "fitness": 0.6934698758550393, "name": "HybridDESA", "description": "Introduced adaptive scaling factor modulation and added diversity pressure to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  \n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.6 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                diversity_pressure = np.exp(-fitness_diversity * 5)  # Added diversity pressure factor\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget) * diversity_pressure  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 32, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.41.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9606585796931317, 0.2716522321752166, 0.9279528424184649, 0.990830918113144, 0.9925855760830572, 0.8403655272831243, 0.9902353929619662, 0.8973144485672128, 0.9919604717439937, 0.9928919158721567, 0.9151884680203595, 0.953233250264886, 0.9906791592679507, 0.9929156958921137, 0.9931341438695409]}}
{"id": "3d58c9cd-4367-447a-9953-2a7afe43fe97", "fitness": -Infinity, "name": "HybridDESA", "description": "Strengthened adaptive mechanism by introducing an adaptive population size based on fitness variance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((fitness_diversity + 1) * (10 + 5 * self.dim)))  # Change line 1\n\n        return best_solution", "configspace": "", "generation": 33, "feedback": "An exception occurred: IndexError('index 174 is out of bounds for axis 0 with size 125').", "error": "IndexError('index 174 is out of bounds for axis 0 with size 125')", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {}}
{"id": "ae5e0042-f9b3-4208-b50d-e51ef6a15fe7", "fitness": 0.7333139350927076, "name": "HybridDESA", "description": "Enhance convergence by introducing a temperature-aware scaling factor adjustment for differential evolution.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * (1 - temperature_factor) + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 34, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9576293616525726, 0.9875059816374675, 0.9852584123749485, 0.9885615824445081, 0.9599695464408912, 0.9894557798147947, 0.9551731096205766, 0.9505310896673143, 0.9506787773197197, 0.9600399612360934, 0.9601062193009576, 0.9562891414651385, 0.9612698829169336, 0.9488189535764168, 0.9871920075113515]}}
{"id": "1e899498-abc6-4093-85ed-5c8f2ca83f32", "fitness": 0.5407265271089421, "name": "HybridDESA", "description": "Refined DE mutation and crossover strategy with adaptive scaling for improved convergence.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution) + (0.1 * np.random.randn(self.dim))  # Small random perturbation\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 35, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.44.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.2440696257139039, 0.17000223255208335, 0.135421353252015, 0.15776123204176074, 0.1586253783937941, 0.9778930149878192, 0.9884279715212066, 0.9707659655892164, 0.9832943406849497, 0.9805024052737367, 0.9768998499125403, 0.9745815792675082, 0.9743252555322767, 0.980021437247188, 0.9741400053343746]}}
{"id": "d5ffd70e-cafb-4f53-a37f-63e160327d81", "fitness": 0.5806576718708307, "name": "HybridDESA", "description": "Enhanced convergence by adjusting differential weight factor and introducing diversity preservation.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Introduce diversity preservation\n                dynamic_CR = self.CR * (0.9 - 0.4 * fitness_diversity)  # Updated dynamic crossover for diversity\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 36, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.58 with standard deviation 0.43.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9749772057611287, 0.24717516074421075, 0.9709011347598451, 0.9814385643951452, 0.8690104292341677, 0.9812585824602428, 0.9817747168361948, 0.961603303355549, 0.9777613493596823, 0.2303208002399959, 0.9608154188803116, 0.1945172547798325, 0.9804567313576483, 0.9782039551554204, 0.15513993522277447]}}
{"id": "e2d018b6-ce20-4375-af35-ccfadd0e67ce", "fitness": 0.7401386933415294, "name": "HybridDESA", "description": "Improved population diversity by adjusting the initial population generation strategy.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        # Change: Using a Sobol sequence for initial population to enhance diversity\n        population = self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 37, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918405934464379, 0.9876806019757647, 0.95450085155944, 0.989291263804005, 0.9849099103280261, 0.990965724251779, 0.9872884045528619, 0.9875426121186763, 0.9451872489860045, 0.9565457186243718, 0.9387541635834278, 0.9881236604146517, 0.9879175526440699, 0.9572520877604738, 0.987174577906132]}}
{"id": "8fb6296c-572b-495b-a0d2-4b1f66385e37", "fitness": 0.7292857478342604, "name": "HybridDESA", "description": "Improved convergence through adaptive mutation and crossover strategies, with a refined population management approach.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.4 * fitness_diversity * temperature_factor + (0.2 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.6 + 0.4 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 4 * self.dim)))  # Refined population adjustment\n\n        return best_solution", "configspace": "", "generation": 38, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9857816720644342, 0.9753449272024558, 0.9431549075400301, 0.982920380646546, 0.948106632018297, 0.9870246260947532, 0.9400420652811945, 0.9168047181087474, 0.9843588203902012, 0.9469389363753792, 0.985686510435784, 0.9855155120900101, 0.9451927526840711, 0.9445937887188016, 0.9464498121600354]}}
{"id": "e35ea478-9761-4b4e-8330-5995d6a6cacc", "fitness": 0.7313124561304385, "name": "HybridDESA", "description": "Improved exploration by introducing a slight increase in the mutation factor based on the population's diversity.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget) + 0.05 * np.std(population)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 39, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9587895705835221, 0.9564949312087243, 0.9406770123712872, 0.9354761808520918, 0.9862701858292415, 0.955349536812487, 0.9864102149342188, 0.950351338172385, 0.9851942379457698, 0.9881205193637987, 0.9627644794964845, 0.9524932307140397, 0.9880360366980232, 0.9510400183083026, 0.9609827344439268]}}
{"id": "105ae288-3bcd-4f99-8602-8dcccb7ec1aa", "fitness": 0.7330195515152539, "name": "HybridDESA", "description": "Improve convergence by dynamically adapting both the differential weight and crossover probability based on fitness diversity and iteration progress.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.4 + 0.6 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 40, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.988678786133428, 0.9440563366259914, 0.9897212844960731, 0.9895636226404144, 0.9884241007364247, 0.9633257713295402, 0.9590515825971961, 0.9484260570806318, 0.9500976668916423, 0.9516977765584104, 0.9591916689282695, 0.951436400616994, 0.9599204158392118, 0.9602536919218746, 0.9887469730345073]}}
{"id": "183e0a7f-6cff-4500-81f3-d0b9fa1dec9f", "fitness": 0.7336456793586033, "name": "HybridDESA", "description": "Enhanced convergence by integrating a dynamic adjustment of the differential weight factor based on the iteration progress, with an improved initial temperature for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 2.0  # Changed initial temperature\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 41, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9871196342163779, 0.9573749961485802, 0.9400468516088796, 0.9894502322484782, 0.9867337867917506, 0.9856466088539014, 0.956289987154508, 0.9448211956378382, 0.9506738798472028, 0.9873671381583298, 0.9610118388554466, 0.9629179668191625, 0.961236716807141, 0.9485555127184397, 0.9858683464315621]}}
{"id": "d9a479b7-598d-470a-aaa1-9cc2fbb67a6a", "fitness": 0.7283296738877576, "name": "HybridDESA", "description": "Improved mutation strategy by introducing weighted average of best solutions.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                # Improved mutation with weighted influence of best solution\n                mutant = x0 + self.F * (x1 - x2) + 0.1 * self.F * (best_solution - x0)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 42, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9868099649591082, 0.9564168288586686, 0.9866050906745694, 0.9486335163945481, 0.9594818433107918, 0.9590177113684196, 0.9537694812315607, 0.960757673454439, 0.9423475325337713, 0.9519921594473141, 0.9877734906656543, 0.954854788049332, 0.944302357661712, 0.9590397670038152, 0.9469923772669804]}}
{"id": "329ab0d4-882f-4535-83fc-5dfc791fdac6", "fitness": 0.5638408331881435, "name": "HybridDESA", "description": "Introduced adaptive population size reduction based on fitness improvement rate to enhance convergence efficiency.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            improvement_rate = (np.max(fitness) - np.min(fitness)) / (np.max(fitness) + 1e-9)  # New line: Adaptive population reduction\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim) * (1 - improvement_rate)))\n\n        return best_solution", "configspace": "", "generation": 43, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56 with standard deviation 0.44.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918405934464379, 0.9876806019757647, 0.21563792175167962, 0.989291263804005, 0.9849099103280261, 0.990965724251779, 0.9872884045528619, 0.9875426121186763, 0.5005991299293048, 0.18017790056762828, 0.14465175341323866, 0.9881236604146517, 0.9879175526440699, 0.18521616178414824, 0.987174577906132]}}
{"id": "c12e7519-62dc-4cd7-8c2e-808b1b7b3c1e", "fitness": 0.7369710298818832, "name": "HybridDESA", "description": "Improved convergence with adaptive mutation factor and dynamic population diversity control.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.4 + 0.5 * fitness_diversity * temperature_factor + (0.4 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.4 + 0.6 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 44, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9554859245578483, 0.9627317389825647, 0.9592156706149139, 0.9873579854077525, 0.9909809909509478, 0.9618992950777125, 0.9613724566044699, 0.9886529820687893, 0.9612613802349207, 0.9624003312539793, 0.9581138787044637, 0.9581758801497579, 0.988329704335151, 0.9876746245638264, 0.9879688592561009]}}
{"id": "5e8ad63d-8d58-48d2-9e4c-afb588cbdb69", "fitness": 0.7161075887410098, "name": "HybridDESA", "description": "Enhanced diversity and exploitation by introducing adaptive population size and non-linear temperature scaling.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        # Changed to non-linear temperature schedule for better exploration\n        self.temperature_schedule = self.initial_temperature * (self.final_temperature / self.initial_temperature) ** (np.linspace(0, 1, budget) ** 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            # Adjusted adaptive population resizing logic\n            self.population_size = max(5, min(int((1+np.log(eval_count+1)) * (10 + 5 * self.dim) / 10), 10 + 5 * self.dim))\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 45, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.975747265376441, 0.9811519024009906, 0.9516512352592905, 0.9732209177746628, 0.9713227036695903, 0.9669846997762602, 0.9041234341972655, 0.856202459972617, 0.967795806215956, 0.9646389327067821, 0.9077779088238769, 0.8671211454297086, 0.9312184435670255, 0.9573372821293825, 0.9780587426458789]}}
{"id": "76388202-1759-4fc5-91ca-718203c1cc15", "fitness": 0.73770545297306, "name": "HybridDESA", "description": "Utilize adaptive cooling and crossover adjustment for enhanced convergence in Differential Evolution with Simulated Annealing.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.exp(np.linspace(np.log(self.initial_temperature), np.log(self.final_temperature), budget))  # Adaptive cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = 0.5 * self.CR * (1.0 + eval_count / self.budget)  # More aggressive dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 46, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9919311775601117, 0.9882659296146811, 0.9538071188271869, 0.9894405609787806, 0.9600148252475523, 0.9909655655087326, 0.9557065537196079, 0.9498961707963713, 0.9486099673390627, 0.9575138561687997, 0.9498352638971829, 0.9881279592491531, 0.9872938416413439, 0.988350714728032, 0.9865506593101336]}}
{"id": "1243905b-82dd-4a79-8194-dfe2749b9e2e", "fitness": 0.7397040350092395, "name": "HybridDESA", "description": "Improved convergence through adaptive control of the scaling factor based on fitness improvements.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget) * (1.0 + 0.1 * (best_fitness - np.min(fitness)) / (np.abs(best_fitness) + 1e-9))  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 47, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918405934464379, 0.9873463696683091, 0.951504578850627, 0.989291263804005, 0.9840476437423578, 0.9909657431605452, 0.9872887537049325, 0.9875423891804229, 0.9346178619033306, 0.956551220569312, 0.9444540579698707, 0.9881236603434548, 0.9879175533496196, 0.9576155448086999, 0.9871745708083987]}}
{"id": "17b56119-8109-4b74-92f4-1c02e181fb51", "fitness": -Infinity, "name": "HybridDESA", "description": "Incorporate a dynamic adjustment of population size based on both fitness diversity and temperature schedule for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim) * (1 + fitness_diversity)))\n\n        return best_solution", "configspace": "", "generation": 48, "feedback": "An exception occurred: IndexError('index 125 is out of bounds for axis 0 with size 125').", "error": "IndexError('index 125 is out of bounds for axis 0 with size 125')", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {}}
{"id": "907232f3-550e-4b74-b393-287643bc1c8b", "fitness": 0.7401386933415294, "name": "HybridDESA", "description": "Introduced adaptive mutation strategy and diversified exploration mechanism to enhance convergence.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 49, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918405934464379, 0.9876806019757647, 0.95450085155944, 0.989291263804005, 0.9849099103280261, 0.990965724251779, 0.9872884045528619, 0.9875426121186763, 0.9451872489860045, 0.9565457186243718, 0.9387541635834278, 0.9881236604146517, 0.9879175526440699, 0.9572520877604738, 0.987174577906132]}}
{"id": "5a8c21e3-f4c4-4ddc-83f9-390db759126e", "fitness": 0.7320350209462813, "name": "HybridDESA", "description": "Improved exploration and exploitation balance by adjusting mutation and crossover rates.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.4 * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 50, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9871015728001421, 0.9497170348913975, 0.9586388126814208, 0.9875565015290781, 0.9538808274774705, 0.9587057299880302, 0.9859088296715138, 0.9437787295607291, 0.9583841760397999, 0.9870865281970731, 0.9568016093793503, 0.9875444602211899, 0.9611559641259005, 0.9370341940254191, 0.9596065534626443]}}
{"id": "bfa226ed-ac78-44f6-9b42-04e3a7b0afd3", "fitness": 0.7420271765002227, "name": "HybridDESA", "description": "Improved convergence by dynamically adjusting both the differential weight and the crossover probability based on fitness diversity and iteration progress.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 51, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["351e34c1-ba7d-44cf-bde9-cca87671ee7c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918245652168058, 0.9847160601318439, 0.987080072155681, 0.9888260146244321, 0.9855450745857393, 0.9909658425573954, 0.9836113288027077, 0.9564016925188559, 0.9891260196445402, 0.986074558381889, 0.9492342582730595, 0.9566719878018363, 0.9869125650997951, 0.950371482852491, 0.9853831124829134]}}
{"id": "9d01cb90-7cb9-4163-bf54-a0720c9894ed", "fitness": 0.7282277176543981, "name": "HybridDESA", "description": "Improved parameter adaptation by incorporating randomization into differential weight adjustments.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget) * np.random.rand()  # Adjusted scaling factor with randomness\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 52, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9640000213393299, 0.9856418212807186, 0.954227180497421, 0.988159636051953, 0.9539215462925956, 0.9578809360534787, 0.9543620511602008, 0.9532797339910919, 0.9497936160345599, 0.9534469418825933, 0.9277131119496825, 0.9508656790272356, 0.9884908446822063, 0.9578685131398549, 0.9571038248305742]}}
{"id": "81f58bc6-aaf3-4bdc-a38b-66028bdff9ee", "fitness": 0.7343715231606762, "name": "HybridDESA", "description": "Improved convergence by introducing adaptive scaling based on population diversity, enhancing exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.4 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 53, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9510148201113375, 0.958900684828955, 0.9596869609287008, 0.9907257374547108, 0.949173724758527, 0.984018995419699, 0.9878200264141058, 0.9857854926506596, 0.9500864675222744, 0.9635010160882533, 0.9888211386864926, 0.9863497965987228, 0.9599031604624395, 0.9457768244657206, 0.95806672194846]}}
{"id": "4d646bce-35ae-42de-819b-4c01292c9727", "fitness": 0.7282277176543981, "name": "HybridDESA", "description": "Enhanced exploration by introducing a randomized scaling factor adjustment for differential mutation, depending on population diversity.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + np.random.rand() * (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 54, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9640000213393299, 0.9856418212807186, 0.954227180497421, 0.988159636051953, 0.9539215462925956, 0.9578809360534787, 0.9543620511602008, 0.9532797339910919, 0.9497936160345599, 0.9534469418825933, 0.9277131119496825, 0.9508656790272356, 0.9884908446822063, 0.9578685131398549, 0.9571038248305742]}}
{"id": "8a635559-bd7a-494b-941f-0bd290bd66d8", "fitness": 0.7361586258549104, "name": "HybridDESA", "description": "Improved solution refinement by enhancing trial acceptance with a random factor in addition to simulated annealing.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if (trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1])) and np.random.rand() < 0.5:  # Added random factor for acceptance\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 55, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9834669424667715, 0.9806673144463993, 0.9824250485790229, 0.9849756780579413, 0.9523855177236075, 0.9862840478329243, 0.9520000156613868, 0.9705277728167402, 0.9814153100638179, 0.9646947512505829, 0.9417494703101471, 0.9862851392292451, 0.9844694660398985, 0.9454000310857016, 0.9586271166595531]}}
{"id": "bdf47525-40e6-40b0-adb7-bdb5d66a98ba", "fitness": 0.7268389616814984, "name": "HybridDESA", "description": "Enhance adaptability by introducing a dynamic population size adjustment based on the average fitness improvement rate.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n        previous_fitness = best_fitness\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically based on fitness improvement rate\n            fitness_improvement_rate = abs(previous_fitness - best_fitness) / (abs(previous_fitness) + 1e-9)\n            self.population_size = max(5, int((1 - fitness_improvement_rate) * (10 + 5 * self.dim)))\n            previous_fitness = best_fitness\n\n        return best_solution", "configspace": "", "generation": 56, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918245652168058, 0.9279560365884958, 0.9676329421371233, 0.9700534186583468, 0.9838514908630902, 0.9909658425573954, 0.9211718805348845, 0.9552989676830198, 0.9766942720530692, 0.9750842477495951, 0.9356071891298934, 0.9509065059310787, 0.9651801609801773, 0.9079153259149993, 0.9488374927575287]}}
{"id": "9414de39-34d4-47e8-b583-b8a74cda1233", "fitness": 0.7345430213268926, "name": "HybridDESA", "description": "Enhanced exploration by incorporating adaptive neighborhood search and adjusting mutation strategy based on convergence rate.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9\n        self.CR = 0.9\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                self.F *= (1 + 0.1 * np.sin(eval_count / self.budget * np.pi))  # Added adaptive factor\n                mutant = x0 + self.F * (x1 - x2)\n                elite_factor = 0.1 * np.random.rand(self.dim)  # Introduced elite factor for neighborhood search\n                mutant = np.clip(mutant + elite_factor, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 57, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8911581127988831, 0.9832424569489643, 0.9329478113028408, 0.9768834298875676, 0.9700847253653619, 0.9886127204095801, 0.9535282169363539, 0.980359196088653, 0.9768719905759199, 0.9862440934668586, 0.977354747871799, 0.9804058958340018, 0.9721740885267114, 0.9657896952568749, 0.9874043503930158]}}
{"id": "8f077162-c4ca-4941-8d88-361be3712569", "fitness": 0.7418693831208785, "name": "HybridDESA", "description": "Enhanced convergence by incorporating adaptive mutation strength and local search exploitation based on current progress and diversity.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                local_search = np.clip(trial + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n                local_fitness = func(local_search)\n                trial_fitness = func(trial)\n                eval_count += 2\n\n                if local_fitness < trial_fitness:\n                    trial, trial_fitness = local_search, local_fitness\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 58, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9797648675437719, 0.9654708752465264, 0.97874825079035, 0.9793510993680242, 0.9670949408653274, 0.9837270712540065, 0.9824326620941817, 0.9744016704271664, 0.9814890561833921, 0.9804738457081832, 0.9779879369548325, 0.977715743166041, 0.9778403222208628, 0.9823327533671158, 0.9807576723533212]}}
{"id": "28523fb8-afe6-496e-98d2-f18a239bf319", "fitness": 0.7363747480976464, "name": "HybridDESA", "description": "Refined HybridDESA by incorporating dynamic population size scaling based on current diversity to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically based on diversity\n            self.population_size = max(5, int(np.std(fitness) / (np.mean(fitness) + 1e-9) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 59, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918245652168058, 0.9689936456995552, 0.951717449054127, 0.9740325125821344, 0.9643249353660118, 0.9909658425573954, 0.9733644952790615, 0.9877936569285848, 0.9877797032679616, 0.978255690606379, 0.8916430337123202, 0.9699796097753903, 0.9846740938231853, 0.9687527792961044, 0.9755940539134418]}}
{"id": "e2ab673c-c397-4370-a8e1-7a8610ba0ed4", "fitness": 0.7348496430854052, "name": "HybridDESA", "description": "Enhanced Diversity-Controlled Hybrid DESA by implementing an adaptive mutation strategy and a restart mechanism for improved exploration.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.4 + 0.5 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count % (self.budget // 5) == 0:\n                new_pop = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_pop])\n                if np.mean(new_fitness) < np.mean(fitness):\n                    population, fitness = new_pop, new_fitness\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 60, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9545844153987049, 0.9499432393975648, 0.9847412761666403, 0.9871075773002884, 0.9613095671894544, 0.959287122457898, 0.9570390484494707, 0.9888504747630092, 0.9574340276913442, 0.9894402173038133, 0.9523193407765275, 0.9572165829862398, 0.9883691860832743, 0.9867667901293229, 0.9547851007400866]}}
{"id": "709ea552-f6bd-4690-b854-b77859b2e9fe", "fitness": 0.7359406927297892, "name": "HybridDESA", "description": "Enhanced exploration and exploitation by incorporating adaptive learning rates and diversified population strategies.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9\n        self.CR = 0.9\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n        self.learning_rate = 0.5  # Added learning rate parameter\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2) + self.learning_rate * (best_solution - x0)  # Enhanced mutation\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Dynamic population resizing\n            if eval_count % 10 == 0:  # Added intermittent resizing\n                self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 61, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9561769237391539, 0.9431331372757662, 0.9582500394275998, 0.9580175547222335, 0.9601816783431946, 0.9877424223627719, 0.9440368283898412, 0.9840797819315693, 0.9881604315711342, 0.9599128221125297, 0.9885398183649347, 0.9893879351901147, 0.9885176490766678, 0.9881106438652836, 0.9567672933485258]}}
{"id": "d1b2dd68-4dcc-4b0e-9d16-054788c8b719", "fitness": 0.7420271765002227, "name": "HybridDESA", "description": "Enhanced convergence by introducing a dynamic adjustment to the differential weight based on the normalized fitness diversity.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget) + 0.1 * (fitness_diversity - np.min(fitness_diversity))/(np.max(fitness_diversity) - np.min(fitness_diversity) + 1e-9)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 62, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918245652168058, 0.9847160601318439, 0.987080072155681, 0.9888260146244321, 0.9855450745857393, 0.9909658425573954, 0.9836113288027077, 0.9564016925188559, 0.9891260196445402, 0.986074558381889, 0.9492342582730595, 0.9566719878018363, 0.9869125650997951, 0.950371482852491, 0.9853831124829134]}}
{"id": "0c9028b5-0267-4f10-9da6-d48778495fce", "fitness": 0.7343715231606762, "name": "HybridDESA", "description": "Improved convergence by enhancing mutation and selection strategies for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.4 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 63, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9510148201113375, 0.958900684828955, 0.9596869609287008, 0.9907257374547108, 0.949173724758527, 0.984018995419699, 0.9878200264141058, 0.9857854926506596, 0.9500864675222744, 0.9635010160882533, 0.9888211386864926, 0.9863497965987228, 0.9599031604624395, 0.9457768244657206, 0.95806672194846]}}
{"id": "e161042c-7281-4eef-af8d-dd4e3f485ec5", "fitness": 0.7347123014406736, "name": "HybridDESA", "description": "Enhanced the mutation strategy by adding a dynamic scaling factor to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.35 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 64, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9878831120035514, 0.9842421182059827, 0.9559460533061047, 0.985591615413942, 0.9849935624986287, 0.9892649939543309, 0.9572333636953075, 0.9522049006491969, 0.9873684027628231, 0.9592828168285432, 0.9890009576423572, 0.9552545055549382, 0.934457881398135, 0.9455994017162888, 0.958123448308877]}}
{"id": "6fef0c58-73d4-42aa-a883-405870f09d91", "fitness": 0.7380244925496431, "name": "HybridDESA", "description": "Enhanced global exploration by incorporating a new mutation strategy to the Differential Evolution process.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                \n                # New random exploration step added\n                global_random = np.random.uniform(self.lb, self.ub, self.dim)  \n                mutant = (mutant + global_random) / 2.0\n                \n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 65, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9609625901125478, 0.9363357062573985, 0.9777168557033, 0.9636154381200177, 0.957482513836301, 0.9733027957537667, 0.9833401503647303, 0.9885806894094975, 0.9758932969997786, 0.9565451993047458, 0.9749787235627569, 0.9829129291213438, 0.9888828777207795, 0.9897178805927147, 0.9824233092587178]}}
{"id": "324ab448-2b73-4b5e-a002-9a4f886797db", "fitness": 0.7287890848203854, "name": "HybridDESA", "description": "Enhanced fitness and diversity management using adaptive learning rate and refined elitism for improved convergence.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.7 + 0.2 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.6 + 0.4 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 66, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9824665855598939, 0.9855806363292904, 0.979122821099403, 0.990829674319588, 0.9869825896647648, 0.9855825687070543, 0.9599520042169736, 0.9584403359462432, 0.7388378117377835, 0.9582064637801964, 0.9845059616239454, 0.9830146630085532, 0.9475716347829524, 0.9838756925691494, 0.9830133581874481]}}
{"id": "91c271b6-765b-4916-a752-f1259b6d523b", "fitness": 0.7414175783094094, "name": "HybridDESAPlus", "description": "Enhanced convergence by integrating adaptive mutation scaling and dynamic population resizing based on fitness variance to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDESAPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9\n        self.CR = 0.9\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.geomspace(self.initial_temperature, self.final_temperature, budget)  # Changed to geometric schedule\n        self.min_F = 0.4  # Minimum differential weight for scaling\n        self.max_F = 0.9  # Maximum differential weight for scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = self.min_F + (self.max_F - self.min_F) * fitness_diversity * temperature_factor  # Adaptive scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget)**0.5 * (10 + 5 * self.dim)))  # Dynamic resizing with square root scaling\n\n        return best_solution", "configspace": "", "generation": 67, "feedback": "The algorithm HybridDESAPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9847612223919682, 0.9800439991147333, 0.972832156340116, 0.9633155577183236, 0.9856842040056767, 0.9837824326159275, 0.972432815494195, 0.9796381477299785, 0.9818652427825598, 0.9786953361866797, 0.9836886270460782, 0.9632870568434757, 0.9819160537792746, 0.9653313220904064, 0.9832784971743279]}}
{"id": "e6d0755c-7c61-48cc-bdcd-563bc304912a", "fitness": 0.7415704407174329, "name": "HybridDESA", "description": "Enhanced temperature schedule for improved convergence by utilizing an exponential decay factor.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                # Modified to use exponential decay for temperature factor\n                temperature_factor = np.exp(-eval_count / self.budget)  \n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 68, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918247095143639, 0.9847601832610773, 0.9870803880946398, 0.9888260659269402, 0.9855439118985777, 0.9909658440539182, 0.9836112969573689, 0.947220100699736, 0.9891260161924403, 0.986074565470078, 0.9492350291355524, 0.9566755538038022, 0.9869123409583908, 0.9503707751058267, 0.985383138401482]}}
{"id": "1cdd1acd-2974-4a12-9ac2-3b0f0d9db1d6", "fitness": 0.7370253002903623, "name": "HybridDESA", "description": "Improved exploration by diversifying the selection process in mutation and crossover operations to enhance convergence.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation with diverse selection\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                x3 = population[np.random.choice(self.population_size)]  # Added extra random individual to enhance diversity\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2 + x3 - x0)  # Modified mutation to use the random individual\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 69, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9927240057551732, 0.9495967380045727, 0.957761287944835, 0.9588663972881641, 0.9855820681389728, 0.9889401029187757, 0.9879179077213104, 0.984938569445306, 0.988726430445612, 0.9587624925177533, 0.9598334182808457, 0.9884882367481446, 0.9620632098326499, 0.951797761527198, 0.956708484363467]}}
{"id": "fbd7369c-00b7-4b1b-b4ca-808537e715ec", "fitness": 0.7292406523713538, "name": "HybridDESA", "description": "Improved convergence by adjusting the population size dynamically based on the temperature schedule instead of evaluation count.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((self.temperature_schedule[eval_count - 1] / self.initial_temperature) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 70, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918245652168058, 0.985599625080327, 0.9779220691608129, 0.989217358926866, 0.9350729975922424, 0.9909658425573954, 0.9081083478117714, 0.9570514707737217, 0.989357895357422, 0.9570946034881532, 0.9464223129460593, 0.9444738010064114, 0.9328025222544393, 0.9641473480219207, 0.9469533923582607]}}
{"id": "8a7065bd-87d0-4d72-8dbc-425dd850a5c0", "fitness": 0.7374957191901083, "name": "HybridDESA", "description": "Enhanced dynamic adaptation of the crossover probability and mutation strategy for improved convergence through strategic temperature influence and population diversity adjustments for a robust balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * (1 - eval_count / self.budget))  # Update for better exploration balance\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 71, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9857801415927216, 0.9825156242419466, 0.985493972253368, 0.9615031260005267, 0.9792611047343707, 0.9877667069025796, 0.9706693470748091, 0.9556197794853438, 0.9569862229139636, 0.9818886149120514, 0.9795092025447323, 0.9775265080811043, 0.9825125092145872, 0.9533182959147289, 0.9417643330608662]}}
{"id": "5776ed7b-a0d2-4de9-aced-de332001b663", "fitness": -Infinity, "name": "HybridDESA", "description": "Enhanced convergence by integrating adaptive population size and diversity-based learning rates within a differential evolution framework.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size based on diversity\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim) * (1 + fitness_diversity)))\n\n        return best_solution", "configspace": "", "generation": 72, "feedback": "An exception occurred: IndexError('index 126 is out of bounds for axis 0 with size 125').", "error": "IndexError('index 126 is out of bounds for axis 0 with size 125')", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {}}
{"id": "2ebf1a6e-89c2-44e6-9c62-819e92586e62", "fitness": 0.7324380392339188, "name": "HybridDESA", "description": "Enhanced convergence by incorporating adaptive population scaling and improved selection pressure with modified cooling schedule.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.001  # Adjusted final temperature\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjusted adaptive population scaling\n            self.population_size = max(5, int((0.5 + 0.5 * eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 73, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.991824765869422, 0.9550872021025384, 0.9865169973882896, 0.9875424408121735, 0.9442982551834134, 0.9909658448731976, 0.9495729997519404, 0.9599046019643163, 0.9538559381486642, 0.9772790898855435, 0.9521268194302495, 0.9677209228194716, 0.9473169352960239, 0.9329993183615326, 0.9839497579171329]}}
{"id": "bb83052c-8f91-4706-9a18-243409f43919", "fitness": 0.7397380198230322, "name": "HybridDESA", "description": "Improved exploration by incorporating random reinitialization of worst solutions to escape local optima.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomly reinitialize the worst solutions for exploration\n            if np.random.rand() < 0.1:  # 10% chance to reinitialize the worst individuals\n                worst_indices = np.argsort(fitness)[-3:]  # Reinitialize the worst 3 solutions\n                population[worst_indices] = np.random.uniform(self.lb, self.ub, (3, self.dim))\n                fitness[worst_indices] = [func(ind) for ind in population[worst_indices]]\n                eval_count += 3\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 74, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918245652168058, 0.9560261579112221, 0.9865824030000534, 0.9900912707751829, 0.9546489215953552, 0.9909658425573954, 0.9546753546859927, 0.9578507424405823, 0.9821082962679873, 0.9874246007712133, 0.9562931537457711, 0.9880491534938359, 0.9599360882607892, 0.9840607635266478, 0.9864241873373416]}}
{"id": "db67a6af-3173-43af-9812-f6c8aeb69512", "fitness": 0.7366187405720532, "name": "HybridDESA", "description": "Enhanced exploration by introducing adaptive mutation scaling and crossover tuning based on historical performance metrics.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n        historical_best_fitness = best_fitness\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                history_factor = 1.0 if best_fitness < historical_best_fitness else 0.5\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor * history_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    historical_best_fitness = best_fitness\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 75, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9564942251316118, 0.9586642653872014, 0.9562284677911198, 0.9905356397526633, 0.9872245714024523, 0.9590166758254881, 0.956096735195985, 0.9851747664135304, 0.9877389301408613, 0.9880625879182252, 0.9506277375558907, 0.9870792323765845, 0.9594761768196663, 0.9598052980517928, 0.9823506068035237]}}
{"id": "c364825b-156f-429e-9551-6a8c1ade8064", "fitness": 0.7365289409346567, "name": "HybridDESA", "description": "Enhanced convergence using adaptive scaling and crossover adjustments based on fitness trends and periodic perturbation.  ", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9\n        self.CR = 0.9\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n        self.perturbation_interval = 50  # New line: Periodic perturbation parameter\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                trend_factor = (eval_count // self.perturbation_interval) % 2  # New line: Trend factor for periodic adjustment\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget) * (1 + 0.5 * trend_factor)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Added: Trend-based acceptance to enhance exploration\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) * (1 + 0.1 * trend_factor) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 76, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9917808982959508, 0.9866345691856871, 0.9625068970635535, 0.9595728960847623, 0.9469446802095174, 0.9861879313707305, 0.9877619888875521, 0.9586697264918673, 0.9891263884395807, 0.9879373722359649, 0.945294080004183, 0.9560845189531945, 0.9641846413849358, 0.9534639417441356, 0.986629393467051]}}
{"id": "85004f0d-01df-4973-86c1-bc5dffc42b7e", "fitness": -Infinity, "name": "HybridDESA", "description": "Enhance the exploration-exploitation balance by integrating adaptive population size scaling and refining mutation strategies.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  \n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim) * (1 + 0.1 * (1 - fitness_diversity))))\n\n        return best_solution", "configspace": "", "generation": 77, "feedback": "An exception occurred: IndexError('index 125 is out of bounds for axis 0 with size 125').", "error": "IndexError('index 125 is out of bounds for axis 0 with size 125')", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {}}
{"id": "cb3edc7d-e829-4a0f-8d1f-96dc8239e3ec", "fitness": 0.730416955138406, "name": "HybridDESA", "description": "Enhanced solution exploration by integrating a diversity-based temperature factor and adaptive mutation strategies.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count] * (1.0 + fitness_diversity)  # Modified temperature factor\n                adaptive_F = 0.8 if fitness_diversity > 0.5 else 0.5  # Adaptive mutation strategy\n                self.F = adaptive_F + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 78, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9406450585501015, 0.9844277296584756, 0.9547715229289072, 0.9557319286687138, 0.986662428117709, 0.9551385578457227, 0.95870101173023, 0.9460321480013041, 0.9490115199962923, 0.985105024239128, 0.9861130308096251, 0.9881929553201753, 0.9621868477852296, 0.9302398474756316, 0.9575805967664079]}}
{"id": "898e8d37-33d8-4037-99d8-2b6ddbdc7d53", "fitness": 0.7382390082438353, "name": "HybridDESA", "description": "Enhanced adaptation by incorporating diversity-based scaling and crossover adjustment, along with a dynamic population size to maintain exploration-exploitation balance. ", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.4 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)) + 1)\n\n        return best_solution", "configspace": "", "generation": 79, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9602023274292484, 0.9646941827906992, 0.9652783905858574, 0.9907257374547108, 0.9648508171408685, 0.984018995419699, 0.9878200264141058, 0.9857854926506596, 0.9557960297377175, 0.9681672213661403, 0.9888211386864926, 0.9863497965987228, 0.9652727688875684, 0.9640637579005336, 0.9651345869392145]}}
{"id": "b41edda0-934f-4b59-ad09-a702658ecaa9", "fitness": -Infinity, "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive population control and hybrid mutation strategies for diverse exploration and convergence balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.8  # Adjusted Differential weight\n        self.CR = 0.9  # Crossover probability remains same\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            # Adjust population dynamically based on diversity\n            fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n            if fitness_diversity > 0.2:\n                self.population_size = min(self.population_size + 1, 20 + 5 * self.dim)\n            else:\n                self.population_size = max(5, self.population_size - 1)\n            \n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Hybrid mutation strategy with random mutation\n                additional_mutant = x0 + self.F * (x1 - best_solution)\n                additional_mutant = np.clip(additional_mutant, self.lb, self.ub)\n                \n                # Dynamic crossover with random choice between mutants\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < self.CR, mutant, additional_mutant)\n                else:\n                    trial = np.where(np.random.rand(self.dim) < self.CR, additional_mutant, best_solution)\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 80, "feedback": "An exception occurred: IndexError('index 125 is out of bounds for axis 0 with size 125').", "error": "IndexError('index 125 is out of bounds for axis 0 with size 125')", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {}}
{"id": "18efb9e6-aaaa-45b9-8388-762c44e9046f", "fitness": 0.7328883654131593, "name": "HybridDESA", "description": "Enhanced convergence by refining the temperature factor calculation to more effectively balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count] * fitness_diversity  # Refined temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 81, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9564051730695392, 0.9613995310448671, 0.9577837772937401, 0.9590289704702479, 0.9890498294591092, 0.9583760064435262, 0.9897597290081367, 0.956884246397177, 0.9438896810706735, 0.9870669045835225, 0.9451518593757361, 0.9582416017252645, 0.9879101898343657, 0.9886425795707411, 0.950378334042073]}}
{"id": "c68b5106-5b65-4fac-bc2b-7afb51b305fd", "fitness": 0.7420271765002227, "name": "HybridDESA", "description": "Enhanced convergence by integrating an adaptive mutation strategy that scales mutation strength based on iteration progress.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 82, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918245652168058, 0.9847160601318439, 0.987080072155681, 0.9888260146244321, 0.9855450745857393, 0.9909658425573954, 0.9836113288027077, 0.9564016925188559, 0.9891260196445402, 0.986074558381889, 0.9492342582730595, 0.9566719878018363, 0.9869125650997951, 0.950371482852491, 0.9853831124829134]}}
{"id": "cbd1ea60-c9f3-4c33-b84b-2fe147c8be24", "fitness": 0.738559719317044, "name": "HybridDESA", "description": "Enhanced convergence by refining mutation strategy with adaptive scaling factor based on fitness improvement.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor * (best_fitness / (fitness[i] + 1e-9))  # Adjusted scaling factor based on fitness improvement\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 83, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9865349956451017, 0.9605769665782733, 0.9573417653988773, 0.9891501420893211, 0.98802023521563, 0.958356997710032, 0.9866067661559946, 0.9506813591060006, 0.9877611275836714, 0.9881037082131005, 0.967097112079284, 0.9863518853136766, 0.9606289669240134, 0.9886965720997958, 0.9474868913536434]}}
{"id": "2654db9a-bdb7-46b6-98a1-4135e3d2c7cd", "fitness": 0.09132759651321014, "name": "HybridDESA", "description": "Enhanced convergence by integrating adaptive mutation strategies and considering the diversity within the population for more robust exploration.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.4 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5 or np.std(population) > 1.0:  # Added diversity check\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 84, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.04.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1371565677801928, 0.13149273454963717, 0.1360717962167337, 0.12614719421876108, 0.12404439104543208, 0.12051389728120543, 0.09482408808171827, 0.10510291413149786, 0.09427658664758043, 0.10260827304120268, 0.10184992164842144, 0.09806994688863224, 0.09807203260221353, 0.0897954196657077, 0.09872727159080041]}}
{"id": "22fff569-9923-43b0-b9ad-fbec800138bf", "fitness": 0.7335863239902698, "name": "HybridDESA", "description": "Enhanced convergence by integrating adaptive parameter control and a multi-armed bandit approach for balancing exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n        # Initialize exploration-exploitation balance\n        self.exploration_rate = 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n\n                # Adjust F and CR dynamically\n                self.F = 0.5 + 0.4 * np.random.rand()\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n\n                # Multi-armed bandit strategy for exploration-exploitation\n                if np.random.rand() < self.exploration_rate:\n                    mutant = x0 + self.F * (x1 - x2)\n                else:\n                    mutant = x0 + self.F * (best_solution - x0)\n                    \n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n            # Adjust exploration rate\n            self.exploration_rate = 0.5 * (1 - eval_count / self.budget)\n\n        return best_solution", "configspace": "", "generation": 85, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9673340844720673, 0.9250979524554073, 0.9607541286153478, 0.9441883442545822, 0.9588773426628489, 0.9601670252856078, 0.9553486036698549, 0.9896462490233983, 0.9588881033091816, 0.9899900368554526, 0.9891758006937844, 0.9899565849192565, 0.9896038879599912, 0.9365176521914562, 0.988381788562692]}}
{"id": "ebc8b671-72bf-4643-95a1-e9039b5fbcb0", "fitness": -Infinity, "name": "HybridDESA", "description": "Improved convergence by incorporating adaptive scaling of differential weights based on historical performance and introducing a restarting mechanism when stagnation is detected.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9\n        self.CR = 0.9\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n        self.restart_threshold = int(budget * 0.1)  # Restart if no improvement for 10% of budget\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n        last_improvement = eval_count\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                self.F *= (1.0 + 0.1 * (eval_count - last_improvement) / self.budget)  # Adaptive scaling\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        last_improvement = eval_count\n\n                if eval_count >= self.budget or (eval_count - last_improvement) > self.restart_threshold:\n                    population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))  # Restart mechanism\n                    fitness = np.array([func(ind) for ind in population])\n                    eval_count += self.population_size\n                    last_improvement = eval_count\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 86, "feedback": "An exception occurred: IndexError('index 13 is out of bounds for axis 0 with size 13').", "error": "IndexError('index 13 is out of bounds for axis 0 with size 13')", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {}}
{"id": "6895c0ed-e4f3-4991-8fa7-44d1645e2f2b", "fitness": 0.12289575488918505, "name": "HybridDESA", "description": "Enhanced convergence by refining adaptation mechanisms for differential weight and crossover probability based on fitness variance and search progress.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                \n                # Adjusting the scaling factor and crossover probability\n                self.F = 0.6 + 0.3 * fitness_diversity * (1 - eval_count / self.budget) + (0.3 * eval_count / self.budget)  # Modified scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (1.0 - 0.5 * fitness_diversity * eval_count / self.budget)  # Modified dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 87, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.06.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1652035086083743, 0.14657003143581904, 0.26354549688803863, 0.1579347782343088, 0.16546678635649337, 0.13265562015618693, 0.21186448036572303, 0.126035771064823, 0.14819818573851384, 0.11520958659004532, 0.14955789608217596, 0.12549009872075856, 0.11943517282486493, 0.12423769400119777, 0.13871109584191088]}}
{"id": "19fd0424-5217-48c3-b323-99c18ec4dd50", "fitness": 0.15040608865717578, "name": "HybridDESA", "description": "Improved convergence through adaptive temperature modulation and enhanced elitism for balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9\n        self.CR = 0.9\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.001  # Enhanced final temperature for better convergence\n        self.temperature_schedule = np.geomspace(self.initial_temperature, self.final_temperature, budget)  # Geometric schedule\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 88, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.15.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.44048945209924906, 0.6885410260755398, 0.15909270132463393, 0.15874577055093986, 0.1602245935351294, 0.13000372418084338, 0.12888325556952984, 0.11903478268231216, 0.12169402426875464, 0.11387580015613186, 0.12011477521232372, 0.12545313767231736, 0.1197520675249969, 0.10834273095508962, 0.14607503646125752]}}
{"id": "9315af61-340d-4769-b3ba-ceca8e0c8ddc", "fitness": 0.7420271765002227, "name": "HybridDESA", "description": "HybridDESA with adaptive restart to escape local optima by periodically resetting the worst-performing individuals.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n        self.restart_threshold = budget // 10  # Adaptive restart threshold\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n        last_improvement = 0\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count] \n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    last_improvement = eval_count\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count - last_improvement > self.restart_threshold:\n                worst_indices = np.argsort(fitness)[-self.population_size // 3:]\n                population[worst_indices] = np.random.uniform(self.lb, self.ub, (len(worst_indices), self.dim))\n                fitness[worst_indices] = np.array([func(ind) for ind in population[worst_indices]])\n                eval_count += len(worst_indices)\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 89, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918245652168058, 0.9847160601318439, 0.987080072155681, 0.9888260146244321, 0.9855450745857393, 0.9909658425573954, 0.9836113288027077, 0.9564016925188559, 0.9891260196445402, 0.986074558381889, 0.9492342582730595, 0.9566719878018363, 0.9869125650997951, 0.950371482852491, 0.9853831124829134]}}
{"id": "d4c0e7ca-bfc1-4e81-b6cf-ee2beb89d1a2", "fitness": 0.733705516297884, "name": "HybridDESA", "description": "Enhanced temperature adjustment by refining the temperature schedule logarithmically, improving exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        # Updated: Logarithmic temperature schedule adjustment\n        self.temperature_schedule = self.initial_temperature * (self.final_temperature / self.initial_temperature) ** (np.logspace(0, 1, budget) - 1)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 90, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9920137237788474, 0.9872556276670653, 0.9511153700554914, 0.959829659360965, 0.9546017674179699, 0.9882696913919861, 0.9593425538358653, 0.9623253789459305, 0.9872300865449819, 0.9524732054453661, 0.9401993821008231, 0.9596852095462325, 0.9598812748021126, 0.9640709081368706, 0.9880175920527072]}}
{"id": "ebfaf855-b773-4986-be0a-de29c579f4b3", "fitness": 0.7391063302738874, "name": "HybridDESA", "description": "Enhanced diversity and convergence by incorporating adaptive mutation scaling and varied population influence.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.4 * fitness_diversity * temperature_factor + (0.2 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 91, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.985968394738232, 0.9593624430431587, 0.9858607185594157, 0.9897884153577112, 0.9866235457167272, 0.9867803885022127, 0.9583860215929119, 0.9595284222879639, 0.9387419850593431, 0.9844346727028812, 0.9888320387023847, 0.9622420994780448, 0.9581405691309355, 0.9830373577865905, 0.986600637944769]}}
{"id": "d2ff2576-7eb4-43e9-8053-330f574f47dd", "fitness": 0.7365292133741026, "name": "HybridDESA", "description": "Enhanced selection pressure by modifying the acceptance criteria with a more aggressive dynamic temperature adjustment.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.0001  # More aggressive cooling\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (self.temperature_schedule[eval_count - 1] * 0.5)):  # More aggressive selection\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 92, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918247859425585, 0.9588590756317523, 0.9580869178478502, 0.9884308539334332, 0.9870394308783206, 0.9899640880867769, 0.9880943140850879, 0.955702303779203, 0.9597617560964179, 0.9882493831228658, 0.9446364872055648, 0.9578651677780016, 0.9504182212448304, 0.9569340517860974, 0.9869185351888257]}}
{"id": "67fa4d9f-f582-46b7-932f-8a554474f64d", "fitness": 0.7386181903879273, "name": "HybridDESA", "description": "Enhanced convergence by integrating adaptive inertia in mutation and adaptive elitism in selection, balancing exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  \n        self.CR = 0.9  \n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        inertia = 0.5  \n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count] \n                self.F = 0.6 + inertia * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  \n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  \n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                acceptance_probability = np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1])\n                if trial_fitness < fitness[i] or np.random.rand() < acceptance_probability:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 93, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9863785650902964, 0.9873020087813738, 0.9516697543651729, 0.9885617642214855, 0.9586858745840209, 0.9628905347184068, 0.9871538035861112, 0.9592642680973547, 0.9877750975636305, 0.9930819303203899, 0.9588049531660043, 0.9868171867654524, 0.9867277950229264, 0.9570527920416128, 0.9523985845598433]}}
{"id": "950a2c0f-80b5-4391-b5c9-5895d69f98ac", "fitness": 0.7401040092472465, "name": "HybridDESA", "description": "Enhanced exploitation and exploration balance by refining parameter updates with adaptive feedback mechanisms.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.2 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.4 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 94, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9918540002969364, 0.9864029955428965, 0.9855846908884548, 0.952194196958914, 0.9869372494338093, 0.9909659806928216, 0.9544364662726733, 0.9595127213409691, 0.9891251945952249, 0.9879821478405102, 0.9557933989292261, 0.9578237229150098, 0.985502945286557, 0.988474017998256, 0.9616915610782084]}}
{"id": "3854efad-efc5-4859-b77b-ee2a951a3163", "fitness": 0.7305008902758271, "name": "HybridDESA", "description": "Enhanced adaptive learning by introducing non-linear adjustments to differential weight and crossover probability for improved diversity and convergence.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.5 + 0.4 * np.tanh(fitness_diversity * temperature_factor) + (0.3 * eval_count / self.budget)  # Non-linear scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.6 + 0.4 * np.sin(fitness_diversity * eval_count / self.budget))  # Non-linear dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 95, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9856454145523148, 0.9608234507312756, 0.9520755722480573, 0.9431355594438056, 0.9618656820585381, 0.9681157749552249, 0.9533739848243292, 0.9552989669161595, 0.9830269341542724, 0.9602430951187476, 0.9867649521221616, 0.9877450459474605, 0.9526756469049231, 0.933211350872122, 0.9582174797926811]}}
{"id": "a39a14b5-dc96-4c3a-a9ae-30d3b47845a4", "fitness": 0.7287890848203854, "name": "HybridDESA", "description": "Fine-tuned the scaling factor and crossover probability to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.7 + 0.2 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.6 + 0.4 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 96, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9824665855598939, 0.9855806363292904, 0.979122821099403, 0.990829674319588, 0.9869825896647648, 0.9855825687070543, 0.9599520042169736, 0.9584403359462432, 0.7388378117377835, 0.9582064637801964, 0.9845059616239454, 0.9830146630085532, 0.9475716347829524, 0.9838756925691494, 0.9830133581874481]}}
{"id": "fe652705-64ef-4d5b-9c21-907cf1a63613", "fitness": 0.7299839670789471, "name": "HybridDESA", "description": "Enhance convergence by incorporating an adaptive mutation strategy and a progressive elitism approach for improved diversity handling and solution refinement.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.initial_F = 0.8  # Initial differential weight\n        self.final_F = 0.4   # Final differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n        self.dynamic_CR_factor = 0.4  # Added for dynamic CR\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation with adaptive F\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                self.F = self.initial_F + (self.final_F - self.initial_F) * (eval_count / self.budget)\n\n                temperature_factor = self.temperature_schedule[eval_count]\n                self.F += 0.2 * fitness_diversity * temperature_factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Progressive elitism in crossover\n                dynamic_CR = self.CR * (0.5 + self.dynamic_CR_factor * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.3 and i != best_index:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 97, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9575202121442958, 0.9898093010153506, 0.9337865408010192, 0.9606856330700755, 0.9884260748237126, 0.9890254040108332, 0.950124144948766, 0.9576603595688886, 0.9553252168061654, 0.9437452600982882, 0.987144193960398, 0.9538769193431328, 0.956200322365337, 0.9555292847652644, 0.9530215789829485]}}
{"id": "eca2ecd9-e656-4f14-b7b0-f9703958403d", "fitness": 0.7335394485166887, "name": "HybridDESA", "description": "Introduced adaptive mutation scaling factor adjustment to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]  # Adding a temperature factor\n                self.F = 0.5 + 0.4 * fitness_diversity * temperature_factor + (0.3 * eval_count / self.budget)  # Adjusted scaling factor\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover probability with elitism\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)  # Updated dynamic crossover\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adjust population size dynamically\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 98, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9860701376449887, 0.9547027762407446, 0.9874069426647537, 0.958166270612613, 0.98809639508118, 0.9495500627810707, 0.9543030245030337, 0.9568305495676532, 0.9587255916754608, 0.9877465579134804, 0.986832187974838, 0.9603059171435219, 0.9546991939628525, 0.9603173435274033, 0.9592371241657142]}}
{"id": "f096b88d-b40e-46a2-9f17-d2cbbec3a247", "fitness": 0.7215233890481393, "name": "HybridDESA", "description": "Enhanced convergence by introducing adaptive mutation scaling based on iteration progress and diversity in gene pool using cosine annealing.", "code": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 + 5 * dim\n        self.F = 0.9  # Updated Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.01\n        self.temperature_schedule = np.linspace(self.initial_temperature, self.final_temperature, budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index].copy()\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n                temperature_factor = self.temperature_schedule[eval_count]\n                # Adjusted scaling factor with cosine annealing\n                self.F = 0.6 + 0.3 * fitness_diversity * temperature_factor + (0.3 * (1 + np.cos(np.pi * eval_count / self.budget)) / 2)\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * fitness_diversity * eval_count / self.budget)\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, population[i])\n                else:\n                    trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, best_solution)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[eval_count - 1]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update the best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population_size = max(5, int((eval_count / self.budget) * (10 + 5 * self.dim)))\n\n        return best_solution", "configspace": "", "generation": 99, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["bfa226ed-ac78-44f6-9b42-04e3a7b0afd3"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9576467976349288, 0.9460706674279141, 0.9533723931270934, 0.9551592341655586, 0.9539721780132534, 0.9608747806489351, 0.9464119186375293, 0.9416153640540642, 0.9501331223635308, 0.9547342561201374, 0.9431932082334162, 0.9576035373742313, 0.9495874565446621, 0.9497334137369646, 0.9425605580061012]}}
