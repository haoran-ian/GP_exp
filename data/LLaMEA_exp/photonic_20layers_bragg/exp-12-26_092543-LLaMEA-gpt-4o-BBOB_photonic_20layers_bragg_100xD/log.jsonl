{"id": "f0a60331-17d9-4880-a5e1-35c860d3d247", "fitness": 0.06461439440296546, "name": "APDE", "description": "Adaptive Parallel Differential Evolution (APDE) that dynamically adjusts mutation and crossover rates to explore and exploit the search space efficiently.", "code": "import numpy as np\n\nclass APDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover\n                mutant = r1 + self.F * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n            \n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR\n            self.F = np.clip(0.5 + 0.3 * np.random.randn(), 0, 1)\n            self.CR = np.clip(0.5 + 0.3 * np.random.randn(), 0, 1)\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 0, "feedback": "The algorithm APDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06461 with standard deviation 0.05869.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.14003820305078463, 0.14386542185795537, 0.14293587811571473, 0.0525820736036825, 0.04812310592504687, 0.05248486707350519, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "2e609589-de6c-400a-9be8-133cea994418", "fitness": -Infinity, "name": "APDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) with self-adapting population size for improved exploration and convergence balance.", "code": "import numpy as np\n\nclass APDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover\n                mutant = r1 + self.F * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n            \n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR\n            self.F = np.clip(0.5 + 0.3 * np.random.randn(), 0, 1)\n            self.CR = np.clip(0.5 + 0.3 * np.random.randn(), 0, 1)\n            \n            # Self-adapting population size\n            self.population_size = int(np.clip(self.population_size * (1 + np.random.randn() * 0.1), 4, 20 * self.dim))\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 1, "feedback": "An exception occurred: IndexError('index 202 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 202 is out of bounds for axis 0 with size 200')", "parent_ids": ["f0a60331-17d9-4880-a5e1-35c860d3d247"], "operator": null, "metadata": {}}
{"id": "e7b3afab-ddc4-46dc-adb0-548b5c9fa86f", "fitness": 0.08747789506517704, "name": "APDE", "description": "Adaptive Parallel Differential Evolution (APDE) with strategic initialization and adaptive scaling to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass APDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover\n                mutant = r1 + self.F * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n            \n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR\n            self.F = np.clip(0.5 + 0.3 * np.random.randn(), 0, 1)\n            self.CR = np.clip(0.5 + 0.2 * np.random.randn(), 0, 1)  # Slight adjustment to CR adaptation\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 2, "feedback": "The algorithm APDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08748 with standard deviation 0.10295.", "error": "", "parent_ids": ["f0a60331-17d9-4880-a5e1-35c860d3d247"], "operator": null, "metadata": {"aucs": [0.33677497387587685, 0.1428307686213428, 0.14899390952601899, 0.052762489514081135, 0.05269684272389952, 0.05174207132537423, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9c9d9809-306b-44b7-9def-5bc8ecdcd3e2", "fitness": 0.06648058626403351, "name": "APDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) with strategic diversity maintenance for improved convergence and robustness.", "code": "import numpy as np\n\nclass APDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover\n                mutant = r1 + self.F * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n            \n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR\n            self.F = np.clip(0.5 + 0.3 * np.random.randn(), 0, 1)\n            self.CR = np.clip(0.5 + 0.2 * np.random.randn(), 0, 1)  # Slight adjustment to CR adaptation\n\n            # Introduce diversity by random reinitialization of worst individual\n            worst_index = np.argmax(fitness)\n            if evaluations + 1 < self.budget:\n                self.pop[worst_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[worst_index] = func(self.pop[worst_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 3, "feedback": "The algorithm APDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06648 with standard deviation 0.06048.", "error": "", "parent_ids": ["e7b3afab-ddc4-46dc-adb0-548b5c9fa86f"], "operator": null, "metadata": {"aucs": [0.15186591406862537, 0.1428307686213428, 0.14455535038989153, 0.0484074235356059, 0.0506292274865332, 0.05853659227430297, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a1d40b4e-a5e4-49d3-9d16-8b2417894fc4", "fitness": 0.06517524063449259, "name": "EAPDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) with dynamic population size and adaptive mutation strategies for improved convergence.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.max_population_size = 20 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.initial_population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(len(self.pop)):\n                # Dynamic population size adjustment\n                if evaluations > self.budget / 2 and len(self.pop) < self.max_population_size:\n                    self.pop = np.vstack((self.pop, lb + (ub - lb) * np.random.rand(dim)))\n\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(len(self.pop)) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation with adaptive F\n                F_dynamic = self.F * (1 - (evaluations / self.budget))\n                mutant = r1 + F_dynamic * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR\n            self.F = np.clip(self.F + 0.05 * (np.mean(fitness) - np.min(fitness)), 0, 1)\n            self.CR = np.clip(self.CR + 0.1 * np.random.randn(), 0, 1)\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 4, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06518 with standard deviation 0.05854.", "error": "", "parent_ids": ["e7b3afab-ddc4-46dc-adb0-548b5c9fa86f"], "operator": null, "metadata": {"aucs": [0.13603747903774233, 0.1467813715709967, 0.14366035505139285, 0.053044945475253846, 0.05377744674149254, 0.05177556783355519, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "864b1089-d091-44bb-b91d-5bd18aa3bb50", "fitness": 0.06797348633475545, "name": "EAPDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) incorporating local search intensification and adaptive parameter control to improve convergence and solution quality.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover\n                mutant = r1 + self.F * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n\n                # Local search intensification\n                if evaluations < self.budget and np.random.rand() < 0.1:\n                    local_step = 0.05 * (ub - lb) * np.random.randn(self.dim)\n                    local_candidate = np.clip(trial + local_step, lb, ub)\n                    local_fitness = func(local_candidate)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        new_pop[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR\n            self.F = np.clip(0.5 + 0.3 * np.random.randn(), 0.1, 0.9)  # Ensuring F stays within a reasonable range\n            self.CR = np.clip(0.5 + 0.2 * np.random.randn(), 0.1, 1)  # More exploration in CR adaptation\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 5, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06797 with standard deviation 0.06298.", "error": "", "parent_ids": ["e7b3afab-ddc4-46dc-adb0-548b5c9fa86f"], "operator": null, "metadata": {"aucs": [0.1633709889287046, 0.14311053678974495, 0.1485611628084047, 0.050275338064552866, 0.051842810372240034, 0.05310054004915199, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "14488721-af0d-4fda-bbcb-77acda1ed7f1", "fitness": 0.06504462084348445, "name": "APDE", "description": "Enhanced APDE with fine-tuned crossover rate adaptation for improved convergence.", "code": "import numpy as np\n\nclass APDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover\n                mutant = r1 + self.F * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n            \n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR\n            self.F = np.clip(0.5 + 0.3 * np.random.randn(), 0, 1)\n            self.CR = np.clip(0.9 + 0.1 * np.random.randn(), 0, 1)  # Fine-tuned CR adaptation\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 6, "feedback": "The algorithm APDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06504 with standard deviation 0.05889.", "error": "", "parent_ids": ["e7b3afab-ddc4-46dc-adb0-548b5c9fa86f"], "operator": null, "metadata": {"aucs": [0.1425491538796485, 0.14307633026266153, 0.1429508192789436, 0.04782089037016457, 0.053132218631238515, 0.05437217516870352, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c04bdcfe-6b00-4828-b4b3-6c934a16babb", "fitness": 0.06454448301830078, "name": "EAPDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) with dynamic population size and self-adaptive mutation strategy to improve convergence efficiency.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        current_population_size = self.initial_population_size\n        self.pop = lb + (ub - lb) * np.random.rand(current_population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = current_population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(current_population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(current_population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Dynamic mutation factor based on fitness diversity\n                diversity = np.std(fitness)\n                adaptive_F = self.F + 0.5 * np.tanh(diversity)\n\n                # Mutation and crossover\n                mutant = r1 + adaptive_F * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adjust population size dynamically\n            if evaluations < self.budget / 2:\n                current_population_size = max(4, current_population_size - 1)  # Reduce size to intensify search\n\n            # Adaptive adjustments of F and CR\n            self.F = np.clip(0.5 + 0.3 * np.random.randn(), 0, 1)\n            self.CR = np.clip(0.5 + 0.2 * np.random.randn(), 0, 1)\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 7, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06454 with standard deviation 0.05859.", "error": "", "parent_ids": ["e7b3afab-ddc4-46dc-adb0-548b5c9fa86f"], "operator": null, "metadata": {"aucs": [0.13738238939260894, 0.14204803149734524, 0.14661900849358434, 0.05180688631113928, 0.05003508560838854, 0.05150894586164079, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "16111f6d-6b7a-4fdc-9306-f666f91a58fa", "fitness": 0.06704234918178603, "name": "APDE", "description": "Revised APDE with dynamic population size and enhanced mutation factor for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass APDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 50)  # Dynamic population size cap\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover\n                self.F = np.clip(0.4 + 0.4 * np.random.rand(), 0, 1)  # Enhanced adaptive mutation factor\n                mutant = r1 + self.F * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n            \n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR\n            self.CR = np.clip(0.5 + 0.2 * np.random.randn(), 0, 1)  # Slight adjustment to CR adaptation\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 8, "feedback": "The algorithm APDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06704 with standard deviation 0.06074.", "error": "", "parent_ids": ["e7b3afab-ddc4-46dc-adb0-548b5c9fa86f"], "operator": null, "metadata": {"aucs": [0.14297468042357342, 0.15559608022476146, 0.14293587811571473, 0.05218574705210266, 0.05401353642524109, 0.054175220394681145, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8cecce03-a34d-47e6-80bf-512ed14d903d", "fitness": -Infinity, "name": "EAPDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) introduces adaptive population size and dynamic mutation factor adjustment to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.initial_population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n        current_population_size = self.initial_population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(current_population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(current_population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover\n                dynamic_F = self.F * (1 - evaluations / self.budget)\n                mutant = r1 + dynamic_F * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_pop[i] = self.pop[i]\n            \n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR\n            self.F = np.clip(0.5 + 0.3 * np.random.randn(), 0, 1)\n            self.CR = np.clip(0.5 + 0.2 * np.random.randn(), 0, 1)\n\n            # Dynamic population size adjustment\n            if evaluations < self.budget * 0.5:\n                current_population_size = min(current_population_size + 1, self.initial_population_size * 2)\n            else:\n                current_population_size = max(current_population_size - 1, self.initial_population_size // 2)\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 9, "feedback": "An exception occurred: IndexError('index 200 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 200 is out of bounds for axis 0 with size 200')", "parent_ids": ["e7b3afab-ddc4-46dc-adb0-548b5c9fa86f"], "operator": null, "metadata": {}}
{"id": "b7f1bb98-23a1-4509-9987-b296258a2dfa", "fitness": 0.0887088798848516, "name": "EAPDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) with self-adaptive dynamic parameters and population diversity measures for improved convergence and robustness.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 10, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08871 with standard deviation 0.10411.", "error": "", "parent_ids": ["e7b3afab-ddc4-46dc-adb0-548b5c9fa86f"], "operator": null, "metadata": {"aucs": [0.3406400001864247, 0.14398353924174334, 0.15157010145075334, 0.05339445021900513, 0.05017409862769029, 0.05711772923804781, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "54fa792a-72ee-4a5e-88a4-dc4581169682", "fitness": 0.06580390128286177, "name": "EAPDE_DB", "description": "Enhanced Adaptive Parallel Differential Evolution with Diversity Boost (EAPDE-DB) incorporates periodic niche-based selection and targeted mutation strategies to maintain diversity and improve convergence.", "code": "import numpy as np\n\nclass EAPDE_DB:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity through niche-based selection and targeted mutation\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                niche_indices = np.random.choice(range(self.population_size), size=int(self.population_size * 0.1), replace=False)\n                for index in niche_indices:\n                    self.pop[index] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[index] = func(self.pop[index])\n                    evaluations += 1\n\n            # Targeted mutation based on fitness rank\n            ranked_indices = np.argsort(fitness)\n            for i in range(int(self.population_size * 0.05)):  # top 5% are aggressively mutated\n                index = ranked_indices[i]\n                targeted_mutant = lb + (ub - lb) * np.random.rand(self.dim)\n                targeted_fitness = func(targeted_mutant)\n                evaluations += 1\n                if targeted_fitness < fitness[index]:\n                    self.pop[index] = targeted_mutant\n                    fitness[index] = targeted_fitness\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 11, "feedback": "The algorithm EAPDE_DB got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06580 with standard deviation 0.05936.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1398274156656525, 0.14061751136493428, 0.1513414377568929, 0.05339445021900513, 0.04875215015308865, 0.05680214638618264, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "4916547b-ddd6-458f-a4e1-7897abf58ddf", "fitness": 0.0674308583311889, "name": "EAPDE_LF", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) with Levy Flight mutation and adaptive scaling to foster exploration and exploitation balance.", "code": "import numpy as np\n\nclass EAPDE_LF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1/L)\n        return step\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation with Levy Flight\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                levy_step = self.levy_flight(1.5)\n                mutant = r1 + F_local * (r2 - r3) + levy_step\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 12, "feedback": "The algorithm EAPDE_LF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06743 with standard deviation 0.06226.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.13902827269739337, 0.1453779305313332, 0.16500754690388253, 0.05352357411183584, 0.04969268397850801, 0.052747716757747365, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e8f36bff-256f-4b84-b379-9b11e00d4fcf", "fitness": 0.06720757014053008, "name": "EAPDEPlus", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE+) with dynamic learning rates and elitism, improving convergence speed and solution quality through adaptive parameter tuning and elite retention mechanisms.", "code": "import numpy as np\n\nclass EAPDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.learning_rate_F = 0.1\n        self.learning_rate_CR = 0.05\n        self.pop = None\n        self.bounds = None\n        self.elite = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        # Determine elite individual initially\n        best_index = np.argmin(fitness)\n        self.elite = self.pop[best_index].copy()\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + self.learning_rate_F * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + self.learning_rate_CR * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Update elite individual if a better candidate is found\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < func(self.elite):\n                self.elite = self.pop[current_best_index].copy()\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = (1 - self.learning_rate_F) * self.F + self.learning_rate_F * np.mean([x[0] for x in successful_mutations])\n                self.CR = (1 - self.learning_rate_CR) * self.CR + self.learning_rate_CR * np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        return self.elite", "configspace": "", "generation": 13, "feedback": "The algorithm EAPDEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06721 with standard deviation 0.06106.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1408890638737793, 0.14714664144455325, 0.1555485343162939, 0.054707825067768945, 0.053054678487524876, 0.05202138807485057, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7c3b452e-3892-44b8-8d2b-85615c04b769", "fitness": 0.06612130711349312, "name": "EAPDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) with improved adaptive mutation strategy and population diversity maintenance.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations]) + 0.01  # added constant to increase diversity\n                self.CR = np.median([x[1] for x in successful_mutations])  # change mean to median\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 14, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06612 with standard deviation 0.05960.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.13843090140659964, 0.14080016535573903, 0.15418982994688057, 0.05513965247594288, 0.05308586056652309, 0.05194535426975311, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "2898a425-bebd-4dce-b0ba-ec239965df41", "fitness": 0.0685634083643486, "name": "EAPDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) with improved mutation strategy for increased exploration and convergence speed.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select four distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 4, replace=False)\n                r1, r2, r3, r4 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3 + r4 - self.pop[i])\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 15, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06856 with standard deviation 0.06225.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1387437398800475, 0.16790110739150887, 0.14348982887029038, 0.05949682748725582, 0.05306559401489053, 0.05287357763514444, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "d25e8d4e-7370-41ea-8263-21dcd46a8319", "fitness": 0.06413291217837416, "name": "APDE_DLR", "description": "Adaptive Parallel Differential Evolution with Dynamic Learning Rate (APDE-DLR) incorporates an adaptive learning rate and multi-strategy mutation to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass APDE_DLR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation strategies\n                F_local = np.clip(self.F + self.learning_rate * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + self.learning_rate * np.random.randn(), 0, 1)\n                if np.random.rand() < 0.5:\n                    mutant = r1 + F_local * (r2 - r3)  # DE/rand/1\n                else:\n                    best = self.pop[np.argmin(fitness)]\n                    mutant = r1 + F_local * (best - r1) + F_local * (r2 - r3)  # DE/best/2\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            # Adapt learning rate\n            self.learning_rate = max(0.01, self.learning_rate * 0.99)\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 16, "feedback": "The algorithm APDE_DLR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06413 with standard deviation 0.05837.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.13720185702027088, 0.14417794468298462, 0.14293587811571473, 0.050193456619279875, 0.04980664689842407, 0.051380426268693435, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "19f2d8fc-c8ce-4bb2-8870-60624794e0f7", "fitness": 0.06747067147390545, "name": "EAPDE_LR", "description": "Enhanced Adaptive Parallel Differential Evolution with Adaptive Learning Rate (EAPDE-LR) introduces individual learning rates for mutation factors and crossover rates, dynamically tuned based on historical success to enhance convergence and robustness.", "code": "import numpy as np\n\nclass EAPDE_LR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = np.ones(self.population_size) * 0.5  # individual mutation factors\n        self.CR = np.ones(self.population_size) * 0.9  # individual crossover rates\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = [[] for _ in range(self.population_size)]\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F[i] + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR[i] + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations[i].append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            for i in range(self.population_size):\n                if successful_mutations[i]:\n                    self.F[i] = np.mean([x[0] for x in successful_mutations[i]])\n                    self.CR[i] = np.mean([x[1] for x in successful_mutations[i]])\n                    successful_mutations[i].clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 17, "feedback": "The algorithm EAPDE_LR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06747 with standard deviation 0.06114.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.1545495635508124, 0.1513414377568929, 0.056081503438087155, 0.05304357229971468, 0.05249586982900556, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "f348cb92-f3a0-4d9f-9c7c-1a7cb19c430b", "fitness": 0.06760133458079774, "name": "EAPDE2", "description": "Enhanced Adaptive Parallel Differential Evolution 2.0 (EAPDE2) with self-adaptive dynamic parameters, population diversity measures, and hybrid local search for improved convergence and robustness.", "code": "import numpy as np\n\nclass EAPDE2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = 0.9 * self.F + 0.1 * np.mean([x[0] for x in successful_mutations])\n                self.CR = 0.9 * self.CR + 0.1 * np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            # Hybrid local search integration\n            if evaluations < self.budget and np.random.rand() < 0.2:\n                best_index = np.argmin(fitness)\n                local_search_point = self.pop[best_index] + 0.01 * np.random.randn(self.dim)\n                local_search_point = np.clip(local_search_point, lb, ub)\n                local_fitness = func(local_search_point)\n                evaluations += 1\n\n                if local_fitness < fitness[best_index]:\n                    self.pop[best_index] = local_search_point\n                    fitness[best_index] = local_fitness\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 18, "feedback": "The algorithm EAPDE2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06760 with standard deviation 0.06084.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1433035803350622, 0.1484082744466274, 0.15140779742477906, 0.05776272534507032, 0.053455868571122056, 0.05257376510451883, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "18081926-6b04-4721-ba61-a27f2ce20872", "fitness": 0.06731625548058728, "name": "EAPDE", "description": "Enhanced EAPDE with adaptive mutation factor based on success ratio for better convergence.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = 0.9 * self.F + 0.1 * np.mean([x[0] for x in successful_mutations])  # Change 1\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 19, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06732 with standard deviation 0.06130.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.14287975510197803, 0.1511922016545092, 0.1513414377568929, 0.054815753080560414, 0.052736725462651735, 0.051380426268693435, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6bf75874-3608-48a5-86a2-d4ec9c797060", "fitness": 0.06607233419188581, "name": "EAPDE", "description": "EAPDE with adaptive scaling factor and periodic mutation reset for enhanced exploration.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            # Introduce periodic mutation factor reset for exploration\n            if evaluations % (self.population_size * 5) == 0:\n                self.F = 0.5  \n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 20, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06607 with standard deviation 0.06034.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.14286745650742216, 0.14398353924174334, 0.1513414377568929, 0.05339445021900513, 0.05017409862769029, 0.05139002537421866, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fc482469-2b6f-4481-b3c4-50d8b8543c75", "fitness": 0.06716751321784793, "name": "EAPDE", "description": "Enhanced Adaptive Parallel Differential Evolution (EAPDE) with strategic initial population diversification for improved convergence through greater exploration.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population with a more diverse strategy within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = np.random.uniform(lb, ub, (self.population_size, self.dim))  # Changed to uniform distribution\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 21, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06717 with standard deviation 0.06080.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1467677001833917, 0.14398353924174334, 0.15157010145075334, 0.05339445021900513, 0.05017409862769029, 0.05711772923804781, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "69c157aa-c091-4d51-a459-883a8810ea25", "fitness": 0.06422893963575997, "name": "ADDE", "description": "Adaptive Dynamic Differential Evolution (ADDE) with oscillating mutation factor and adaptive crossover for enhanced exploration-exploitation balance and dynamic diversity maintenance.", "code": "import numpy as np\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # base mutation factor\n        self.CR = 0.9  # base crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n        oscillation_period = 100\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Oscillating mutation factor\n                F_local = np.clip(self.F * (1 + np.sin(2 * np.pi * evaluations / oscillation_period)), 0, 1)\n                CR_local = np.clip(self.CR + 0.1 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 22, "feedback": "The algorithm ADDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06423 with standard deviation 0.05821.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.13744788021782994, 0.14291861526458205, 0.1431435695878004, 0.051873819259456555, 0.049060331658102085, 0.05211624073406884, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "de0b1b30-04f3-4184-b0c2-7249dfc34a91", "fitness": -Infinity, "name": "QADE", "description": "Quantum-inspired Adaptive Differential Evolution (QADE) enhances EAPDE by integrating quantum-inspired superposition and interference principles to efficiently explore and exploit the search space, aiming for improved convergence and diversified solutions.", "code": "import numpy as np\n\nclass QADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        def quantum_inspired_superposition():\n            return np.random.rand(self.population_size, self.dim) < 0.5\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = quantum_inspired_superposition()\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                interference_index = np.random.randint(self.population_size)\n                self.pop[interference_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[interference_index] = func(self.pop[interference_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 23, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {}}
{"id": "0577fa44-b544-4b41-be6d-f33c4048e9ea", "fitness": 0.0870132699815987, "name": "ODEAPDE", "description": "Optimized Diversity-Enhanced Adaptive Parallel Differential Evolution (ODEAPDE) with dynamic diversity control and feedback-driven parameter tuning for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ODEAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n        self.diversity_threshold = 0.2  # Diversity threshold for introducing random individuals\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            current_diversity = np.mean([np.linalg.norm(self.pop[i] - self.pop[j]) for i in range(self.population_size) for j in range(i + 1, self.population_size)])\n            if current_diversity < self.diversity_threshold:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 24, "feedback": "The algorithm ODEAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08701 with standard deviation 0.10023.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.3262248279962151, 0.1436162496515646, 0.1513414377568929, 0.05339445021900513, 0.05033153372198429, 0.05671093048872633, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "163c4798-ddaa-42fe-ba0c-7ea238477503", "fitness": 0.06451931506130118, "name": "EAPDEv2", "description": "Enhanced Adaptive Parallel Differential Evolution with Adaptive Perturbation and Dynamic Population Control for improved exploration and convergence.", "code": "import numpy as np\n\nclass EAPDEv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation with adaptive perturbation based on fitness diversity\n                fitness_diff = np.std(fitness)\n                adaptive_scale = 1.0 if fitness_diff < 1e-5 else min(1.0, 0.1/fitness_diff)\n                F_local = np.clip(self.F + adaptive_scale * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Dynamic population control to maintain diversity\n            diversity = np.mean(np.std(self.pop, axis=0))\n            if diversity < 1e-3 and evaluations < self.budget:\n                new_individuals = np.clip(lb + (ub - lb) * np.random.rand(self.population_size // 10, self.dim), lb, ub)\n                for ind in new_individuals:\n                    if evaluations < self.budget:\n                        self.pop = np.vstack((self.pop, ind))\n                        fitness = np.append(fitness, func(ind))\n                        evaluations += 1\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 25, "feedback": "The algorithm EAPDEv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06452 with standard deviation 0.05841.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.13801899801123396, 0.14061751136493428, 0.14617734625480927, 0.047205541016612895, 0.05577401263542692, 0.051380426268693435, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "03bbe0fb-447e-4337-8fb2-2aa55ebc3ff4", "fitness": 0.06691393014676893, "name": "ADDE", "description": "Adaptive Dynamic Differential Evolution (ADDE) blends dynamic population resizing and adaptive learning of control parameters to enhance exploration-exploitation balance and improve convergence.", "code": "import numpy as np\n\nclass ADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success and adaptive learning\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Introduce dynamic population resizing\n            if evaluations < self.budget:\n                diversity = np.std(self.pop)\n                if diversity < 0.1 and self.population_size > self.initial_population_size / 2:\n                    self.population_size = max(self.initial_population_size // 2, 5)\n                    indices = np.argsort(fitness)[:self.population_size]\n                    self.pop = self.pop[indices]\n                    fitness = fitness[indices]\n                elif diversity > 0.5 and self.population_size < self.initial_population_size * 2:\n                    extra_pop_size = min(self.initial_population_size // 2, self.budget - evaluations)\n                    extra_pop = lb + (ub - lb) * np.random.rand(extra_pop_size, self.dim)\n                    extra_fitness = np.array([func(ind) for ind in extra_pop])\n                    evaluations += extra_pop_size\n                    self.pop = np.vstack((self.pop, extra_pop))\n                    fitness = np.append(fitness, extra_fitness)\n                    self.population_size += extra_pop_size\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 26, "feedback": "The algorithm ADDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06691 with standard deviation 0.05932.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.14034614349299768, 0.1411891973058913, 0.1513414377568929, 0.059314881009091436, 0.05113084951239477, 0.05740286224365243, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "864e8c89-b22b-413d-82c1-b900a180b6f4", "fitness": 0.0665046280330463, "name": "EAPDE", "description": "Improved EAPDE with adaptive population diversity control for enhanced convergence and exploration balance.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.15:  # Increased randomness probability for diversity\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 27, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06650 with standard deviation 0.06090.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1467677001833917, 0.14398353924174334, 0.1513414377568929, 0.05339445021900513, 0.05017409862769029, 0.051380426268693435, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c96bb8d4-1c71-401e-bcd7-b265202ca507", "fitness": 0.06716751321784793, "name": "EAPDE_TVP", "description": "Enhanced Adaptive Differential Evolution with Time-Varying Population and Fitness Diversity Measures (EAPDE-TVP) utilizes dynamic population resizing and fitness diversity enhancements to improve convergence and robustness.", "code": "import numpy as np\n\nclass EAPDE_TVP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 5 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.initial_population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(len(self.pop)):\n                indices = np.random.choice([idx for idx in range(len(self.pop)) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(len(self.pop))\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            if len(self.pop) > self.min_population_size:\n                diversity = np.std(fitness)\n                if diversity < 1e-5:\n                    removal_count = max(1, int(0.05 * len(self.pop)))\n                    worst_indices = np.argsort(fitness)[-removal_count:]\n                    self.pop = np.delete(self.pop, worst_indices, axis=0)\n                    fitness = np.delete(fitness, worst_indices)\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 28, "feedback": "The algorithm EAPDE_TVP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06717 with standard deviation 0.06080.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1467677001833917, 0.14398353924174334, 0.15157010145075334, 0.05339445021900513, 0.05017409862769029, 0.05711772923804781, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fd9e3e36-c333-410f-a066-76d19d665699", "fitness": 0.06757358258049752, "name": "EAPDE_Enhanced", "description": "Enhanced Adaptive Parallel Differential Evolution with Success-Based Parameter Adaptation and Adaptive Population Resizing for Optimized Convergence and Solution Diversity.", "code": "import numpy as np\n\nclass EAPDE_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n                # Adjust population size based on success rate\n                success_rate = len(successful_mutations) / self.population_size\n                if success_rate < 0.1:\n                    self.population_size = max(int(self.population_size * 0.9), 4)\n                elif success_rate > 0.5 and self.population_size < self.initial_population_size:\n                    self.population_size = min(int(self.population_size * 1.1), self.initial_population_size)\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 29, "feedback": "The algorithm EAPDE_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06757 with standard deviation 0.06145.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.14891847967483351, 0.1465126342359977, 0.1513414377568929, 0.05339445021900513, 0.05136546169035472, 0.05512977964739385, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "40fd0659-a52c-4f24-85ac-9ca618371640", "fitness": 0.0654691332137355, "name": "ImprovedEAPDE", "description": "Improved EAPDE with adaptive learning of crossover strategies and dynamic scaling of mutation factors for enhanced convergence and diversity maintenance.", "code": "import numpy as np\n\nclass ImprovedEAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.evaluations = 0\n        self.successful_mutations = []\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        self.evaluations = self.population_size\n\n        while self.evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n\n            # Adaptive mutation scaling based on generation progress\n            generation_progress = self.evaluations / self.budget\n            dynamic_F = self.F * (1 - generation_progress)\n\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Apply mutation and crossover with dynamic scaling\n                F_local = np.clip(dynamic_F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Adaptive learning of crossover strategies\n                if np.random.rand() < 0.5:\n                    trial = np.where(np.random.rand(self.dim) < CR_local, mutant, self.pop[i])\n                else:\n                    trial = mutant  # Full trial as mutant\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Update F and CR based on successful trials\n            if self.successful_mutations:\n                self.F = np.mean([x[0] for x in self.successful_mutations])\n                self.CR = np.mean([x[1] for x in self.successful_mutations])\n                self.successful_mutations.clear()\n\n            # Occasionally introduce random individuals\n            if self.evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                self.evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 30, "feedback": "The algorithm ImprovedEAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06547 with standard deviation 0.05948.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.13831312869506673, 0.14537074533358452, 0.14870381444241754, 0.05245973572303775, 0.05116620227416391, 0.05170857245534921, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c7824795-8bef-4fee-ba29-866b3860aa5e", "fitness": 0.06550007193167724, "name": "EAPDE", "description": "Enhanced EAPDE with diversity reinforcement and fitness-based adaptive scaling to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            mean_fitness = np.mean(fitness)  # New line\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Fitness-based Adaptive F and CR\n                F_local = np.clip(self.F * (fitness[i] / mean_fitness), 0, 1)  # Changed line\n                CR_local = np.clip(self.CR * (fitness[i] / mean_fitness), 0, 1)  # Changed line\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Enhanced diversity reinforcement\n            if evaluations < self.budget and np.random.rand() < 0.15:  # Modified line\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 31, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06550 with standard deviation 0.05989.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.14527770867295997, 0.14481071917110855, 0.14484734743537053, 0.05425762551652824, 0.04742682032043466, 0.051380426268693435, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "f4711e2a-d914-48ba-9f88-33c1f9b972cc", "fitness": 0.06712935102602399, "name": "EAPDE", "description": "Introduced a dynamic scaling factor to improve diversity in EAPDE's random individual generation.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                scaling_factor = np.random.rand()  # Dynamic scaling factor for diversity\n                self.pop[rand_index] = lb + scaling_factor * (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 32, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06713 with standard deviation 0.06075.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1467677001833917, 0.1436162496515646, 0.15157010145075334, 0.05339445021900513, 0.05019792849145355, 0.05711772923804781, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5bda8b64-cb5c-4228-b6fb-20f2f010d3a0", "fitness": 0.06469787274110773, "name": "EAPDE", "description": "Slightly increased mutation rate and added elitism to retain the best solution.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.6  # increased mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        best_index = np.argmin(fitness)\n        best_solution = self.pop[best_index]\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Elitism: Retain the best solution found\n            current_best_index = np.argmin(fitness)\n            if fitness[current_best_index] < fitness[best_index]:\n                best_index = current_best_index\n                best_solution = self.pop[best_index]\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        return best_solution", "configspace": "", "generation": 33, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06470 with standard deviation 0.05703.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.13281417873507362, 0.14108583353825765, 0.14293587811571473, 0.05559597854328446, 0.05261000400679605, 0.05573898173084324, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "78b60263-e075-4a6d-b2e4-28a2e8141705", "fitness": 0.06716751321784793, "name": "EAPDE_DEEB", "description": "Enhanced Adaptive Parallel Differential Evolution with Dynamic Exploration-Exploitation Balance (EAPDE-DEEB), incorporating a strategy to dynamically adjust the balance between exploration and exploitation to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EAPDE_DEEB:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.exploration_weight = 0.5\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F, CR, and exploration weight based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                self.exploration_weight = min(1.0, max(0.1, self.exploration_weight + 0.01 * (len(successful_mutations) / self.population_size - 0.2)))\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally if exploration weight is high\n            if evaluations < self.budget and np.random.rand() < self.exploration_weight * 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 34, "feedback": "The algorithm EAPDE_DEEB got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06717 with standard deviation 0.06080.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1467677001833917, 0.14398353924174334, 0.15157010145075334, 0.05339445021900513, 0.05017409862769029, 0.05711772923804781, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "27aa6bfb-3cf7-40b3-a9b4-82ad8673ffe2", "fitness": 0.06675515541032821, "name": "EAPDE_V2", "description": "Enhanced Adaptive Parallel Differential Evolution with Dynamic Subpopulation Diversity and Adaptive Parameter Tuning for improved performance on diverse optimization landscapes.", "code": "import numpy as np\n\nclass EAPDE_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.subpop_size = max(2, self.population_size // 5)  # size for subpopulation\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select subpopulation for local adaptation\n                subpop_indices = np.random.choice(self.population_size, self.subpop_size, replace=False)\n                r1, r2, r3 = self.pop[np.random.choice(subpop_indices, 3, replace=False)]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 35, "feedback": "The algorithm EAPDE_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06676 with standard deviation 0.05841.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.14080778278628325, 0.14387243641243763, 0.14293587811571473, 0.05357315870595447, 0.06151341961950618, 0.056593723053057765, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c4858f17-426e-4ea2-abf0-18667918f1cf", "fitness": 0.0662900366901163, "name": "EAPDE", "description": "EAPDE with enhanced mutation strategy and adaptive population control for improved convergence (Score: Updated).", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 5, replace=False)  # Changed to 5\n                r1, r2, r3, r4, r5 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3) + F_local * (r4 - r5)  # Enhanced mutation strategy\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 36, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06629 with standard deviation 0.05828.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1404064808560208, 0.14312419623190797, 0.14293587811571473, 0.05450245877017634, 0.05602157014565057, 0.05811974609157644, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e578d45d-b5b1-4347-bcf1-f04b4f9c6061", "fitness": 0.0676447065742857, "name": "EAPDE", "description": "Enhanced Adaptive Parallel Differential Evolution with strategic mutation factor adaptation and population reset for improved exploration and convergence.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations]) * 0.9  # Slight reduction for fine-tuning F\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 37, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06764 with standard deviation 0.05976.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1429524207078532, 0.14234499915548793, 0.1513414377568929, 0.05832803646256213, 0.054753712916457475, 0.057581752169317824, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "db89ac09-c1af-46d2-b051-69599189fe17", "fitness": 0.06518526424866333, "name": "OEAPDE", "description": "Optimized Enhanced Adaptive Parallel Differential Evolution (OEAPDE) incorporating a diversity-preserving mechanism and a learning-based parameter adaptation strategy for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass OEAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with adaptive F and CR based on success rate\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                if np.random.rand() < 0.5:\n                    mutant = r1 + F_local * (r2 - r3)\n                else:\n                    mutant = r1 - F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Update F and CR based on successful history with learning rate adaptation\n            if successful_mutations:\n                self.F = 0.9 * self.F + 0.1 * np.mean([x[0] for x in successful_mutations])\n                self.CR = 0.9 * self.CR + 0.1 * np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Dynamic diversity preservation\n            if evaluations < self.budget and np.random.rand() < 0.2:\n                diversity_indices = np.random.choice(self.population_size, size=self.population_size // 5, replace=False)\n                for idx in diversity_indices:\n                    self.pop[idx] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[idx] = func(self.pop[idx])\n                    evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 38, "feedback": "The algorithm OEAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06519 with standard deviation 0.05883.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.13879170260563034, 0.14138753381227898, 0.14805621419425263, 0.053319043580800196, 0.052196742368485594, 0.05141614167652242, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "2fa09f12-6b03-47d6-b669-266b8a4f39a1", "fitness": -Infinity, "name": "EPDE", "description": "Enhanced Parallel Differential Evolution (EPDE) integrates adaptive control parameters and adaptive population size with spatial clustering for improved exploration and convergence efficiency.", "code": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.initial_population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            # Clustering for diversity maintenance\n            num_clusters = max(2, self.initial_population_size // 10)\n            kmeans = KMeans(n_clusters=num_clusters, n_init=1)\n            cluster_labels = kmeans.fit_predict(self.pop)\n\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.initial_population_size):\n                # Select individuals within the same cluster for mutation\n                cluster_indices = np.where(cluster_labels == cluster_labels[i])[0]\n                if len(cluster_indices) < 3:\n                    continue\n\n                indices = np.random.choice(cluster_indices, 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Adaptive population resizing\n            if evaluations < self.budget and np.random.rand() < 0.05:\n                new_size = np.random.randint(self.initial_population_size - 2, self.initial_population_size + 3)\n                self.pop = self.pop[np.random.choice(self.pop.shape[0], new_size, replace=False)]\n                fitness = fitness[np.random.choice(fitness.shape[0], new_size, replace=False)]\n                self.initial_population_size = new_size\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.pop.shape[0])\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 39, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {}}
{"id": "ce6c99d1-1c7d-49d1-a850-1f6a32988785", "fitness": 0.1604679408998887, "name": "EAPDE", "description": "Enhanced Differential Evolution with dynamic population size based on success history for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 40, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16047 with standard deviation 0.27036.", "error": "", "parent_ids": ["b7f1bb98-23a1-4509-9987-b296258a2dfa"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14061751136493428, 0.15238705583039025, 0.9066403822198074, 0.04922592832907369, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8273f2f7-9c8f-46af-bde7-b7ab1986161b", "fitness": 0.06522249650925077, "name": "EAPDEPlusPlus", "description": "EAPDE++. Enhanced Adaptive Population Differential Evolution with dynamic learning rate adaptation and elite selection for improved convergence.", "code": "import numpy as np\n\nclass EAPDEPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.elite_ratio = 0.1  # Ratio of elite individuals\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            # Select elite individuals based on current fitness\n            elite_size = max(1, int(self.elite_ratio * self.population_size))\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_pop = self.pop[elite_indices]\n\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly, including elite individuals\n                indices = np.random.choice(elite_indices, min(3, elite_size), replace=False)\n                if len(indices) < 3:\n                    additional_indices = np.random.choice([idx for idx in range(self.population_size) if idx not in indices], 3 - len(indices), replace=False)\n                    indices = np.concatenate((indices, additional_indices))\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 41, "feedback": "The algorithm EAPDEPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06522 with standard deviation 0.05846.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14166828716302837, 0.1417219136050134, 0.14293587811571473, 0.053374321203063624, 0.05079589353445724, 0.05500617496197968, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "30861441-681a-451a-a83f-12ca79c79cec", "fitness": 0.0650615688602475, "name": "EAPDEv2", "description": "EAPDEv2: Enhanced Adaptive Population Differential Evolution with Success-Based Learning Rates and Diversity Initiatives incorporating fitness-based dynamic F and CR values for superior convergence.", "code": "import numpy as np\n\nclass EAPDEv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.min_pop_size = 5 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with fitness-based adaptive F and CR\n                F_local = np.clip(np.random.normal(np.mean(fitness) / (fitness[i] + 1e-8), 0.1), 0.1, 1)\n                CR_local = np.clip(np.random.normal(self.CR, 0.05), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Adjust population size based on success\n            if evaluations < self.budget:\n                success_rate = len(successful_mutations) / self.population_size\n                self.population_size = max(self.min_pop_size, int(self.population_size * (1 + (success_rate - 0.2))))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 42, "feedback": "The algorithm EAPDEv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06506 with standard deviation 0.05836.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13999231455747618, 0.1409648272101376, 0.14442929349987021, 0.05046059291302585, 0.05682666529302438, 0.051380426268693435, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fd593bd6-46bc-4989-a152-c655211843c6", "fitness": -Infinity, "name": "EAPDE", "description": "Enhanced Adaptive Differential Evolution with localized niching for improved diversity and convergence. ", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly using niching strategy\n                distances = np.linalg.norm(self.pop - self.pop[i], axis=1)\n                prob = 1 / (distances + 1e-9)\n                prob[i] = 0\n                indices = np.random.choice(np.arange(self.population_size), 3, replace=False, p=prob/np.sum(prob))\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 43, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {}}
{"id": "bb255e93-9e4e-4ca0-a8e7-011a3439328b", "fitness": 0.0847631231728006, "name": "ADE_TDI", "description": "Adaptive Differential Evolution with temporal diversity injection and self-tuning strategy for enhanced exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass ADE_TDI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n        diversity_injection_interval = max(1, self.budget // (10 * self.population_size))\n        \n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            if evaluations < self.budget and evaluations % diversity_injection_interval == 0:\n                rand_indices = np.random.choice(self.population_size, size=self.dim, replace=False)\n                for rand_index in rand_indices:\n                    self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[rand_index] = func(self.pop[rand_index])\n                    evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 44, "feedback": "The algorithm ADE_TDI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08476 with standard deviation 0.09665.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.31204166330070593, 0.1429383213838249, 0.1513414377568929, 0.054604240601590526, 0.0481477316906771, 0.052294713821514294, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "3dd8eacd-1a69-4cbe-aabd-61119b2bbcf0", "fitness": 0.06634955244495629, "name": "EAPDE", "description": "Enhanced Differential Evolution with dynamic population size and adaptive random restart mechanism for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals more frequently\n            if evaluations < self.budget and np.random.rand() < 0.2:  # Changed from 0.1 to 0.2\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 45, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06635 with standard deviation 0.05997.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14049925109272576, 0.144460973999746, 0.1513414377568929, 0.05339445021900513, 0.05033336497208074, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "10bcaf07-0c7b-4073-bcd8-1e968b64784b", "fitness": 0.06666128204190014, "name": "EAPDE", "description": "Enhanced Differential Evolution with random reinitialization of the worst individual to prevent stagnation.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                worst_index = np.argmax(fitness)  # Change: reinitialize worst individual\n                self.pop[worst_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[worst_index] = func(self.pop[worst_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 46, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06666 with standard deviation 0.05982.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14496463572390828, 0.15238705583039025, 0.05564857385371802, 0.051610682614292025, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "bd44f64f-be8e-4d25-9726-efff55a1b9ca", "fitness": 0.0666328089582589, "name": "EnhancedAdaptiveDE", "description": "Adaptive Differential Evolution with dynamic population and self-regulating mutation factor and crossover rate to enhance convergence and solution diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Start with a moderate population size\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n        diversity_threshold = 1e-5\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n                F_local = np.clip(self.F + 0.2 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.1 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                diversity_measure = np.std(self.pop, axis=0).mean()\n                if diversity_measure < diversity_threshold:\n                    self.population_size = min(self.budget - evaluations, self.population_size + 5)\n                    new_inds = lb + (ub - lb) * np.random.rand(self.population_size - len(self.pop), self.dim)\n                    new_fitness = np.array([func(ind) for ind in new_inds])\n                    self.pop = np.vstack((self.pop, new_inds))\n                    fitness = np.concatenate((fitness, new_fitness))\n                    evaluations += len(new_inds)\n                else:\n                    self.population_size = max(5, int(self.population_size * (1 - len(successful_mutations) / self.population_size)))\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06663 with standard deviation 0.05919.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14958898685699384, 0.13696593100038312, 0.14519504700746544, 0.05371113464169419, 0.05249878909361627, 0.06023539202417749, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "804147d3-9ee8-43d7-8ee3-99dd7d9322ff", "fitness": 0.06591329552587877, "name": "EAPDE", "description": "Enhanced Differential Evolution with dynamic population size and adaptive mutation factor scaling for improved search efficiency.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0.1, 1.5) # Changed\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 48, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06591 with standard deviation 0.05927.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14061751136493428, 0.15238705583039025, 0.05564857385371802, 0.04922592832907369, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5aa203ea-50c9-43c8-af96-7c6067fcd077", "fitness": 0.0656046941732971, "name": "CADE", "description": "CADE: Cluster-enhanced Adaptive Differential Evolution uses clustering to preserve diversity and adapt crossover/mutation based on subpopulations.", "code": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass CADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            # Use clustering to identify subpopulations\n            num_clusters = max(2, self.population_size // (5 * self.dim))\n            kmeans = KMeans(n_clusters=num_clusters)\n            labels = kmeans.fit_predict(self.pop)\n            \n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals from the same cluster\n                cluster_indices = np.where(labels == labels[i])[0]\n                if len(cluster_indices) < 3:\n                    cluster_indices = np.random.choice(self.population_size, 3, replace=False)\n                \n                indices = np.random.choice(cluster_indices[cluster_indices != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 49, "feedback": "The algorithm CADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06560 with standard deviation 0.05870.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.142584883659423, 0.14261317902392778, 0.14293587811571473, 0.049058228862218, 0.05655400656740006, 0.05519607133099047, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "90b61517-aaf9-411a-b42b-0dfe37e43dfa", "fitness": 0.0655554405078269, "name": "ADPC_MDM", "description": "Adaptive Differential Evolution with Dynamic Population Control and Multi-Directional Mutation (ADPC-MDM) for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass ADPC_MDM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_init = 0.5\n        self.CR_init = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F_init + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR_init + 0.05 * np.random.randn(), 0, 1)\n\n                # Multi-Directional Mutation\n                mutant1 = r1 + F_local * (r2 - r3)\n                mutant2 = r1 + F_local * (self.pop[i] - r2)\n                mutant1 = np.clip(mutant1, lb, ub)\n                mutant2 = np.clip(mutant2, lb, ub)\n\n                cross_points1 = np.random.rand(self.dim) < CR_local\n                cross_points2 = np.random.rand(self.dim) < CR_local\n                \n                if not np.any(cross_points1):\n                    cross_points1[np.random.randint(0, self.dim)] = True\n                if not np.any(cross_points2):\n                    cross_points2[np.random.randint(0, self.dim)] = True\n\n                trial1 = np.where(cross_points1, mutant1, self.pop[i])\n                trial2 = np.where(cross_points2, mutant2, self.pop[i])\n\n                trial1_fitness = func(trial1)\n                trial2_fitness = func(trial2)\n                evaluations += 2\n\n                # Selection\n                if trial1_fitness < fitness[i] or trial2_fitness < fitness[i]:\n                    if trial1_fitness < trial2_fitness:\n                        new_pop[i] = trial1\n                        fitness[i] = trial1_fitness\n                        successful_mutations.append((F_local, CR_local))\n                    else:\n                        new_pop[i] = trial2\n                        fitness[i] = trial2_fitness\n                        successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F_init = np.mean([x[0] for x in successful_mutations])\n                self.CR_init = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 50, "feedback": "The algorithm ADPC_MDM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06556 with standard deviation 0.05991.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1421105971693084, 0.14999750921832722, 0.14293587811571473, 0.05034773623935718, 0.05064528184143602, 0.05246196198629871, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "d7c24280-5cba-40f2-bcae-6ddd2903ffe9", "fitness": 0.06761945334887635, "name": "EAPDE", "description": "Improved exploration by increasing mutation factor adaptation sensitivity.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.2 * np.random.randn(), 0, 1)  # Changed from 0.1 to 0.2\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 51, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06762 with standard deviation 0.06085.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14294773072420042, 0.1534297583696944, 0.14676641591602047, 0.05382031501593598, 0.053274097737453174, 0.05683676237658286, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "1f625d59-9122-4295-ad5c-4daf82fa4936", "fitness": 0.06457784608997161, "name": "HADE", "description": "Hybrid Adaptive Differential Evolution with Fitness-Based Dynamic Scaling and Crossover Rates for Enhanced Convergence and Diversity Maintenance.", "code": "import numpy as np\n\nclass HADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Fitness-based adaptive mutation and crossover\n                F_local = 1 - (fitness[i] / (np.max(fitness) + 1e-9)) * self.F\n                CR_local = (fitness[i] / (np.max(fitness) + 1e-9)) * self.CR\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.clip(np.mean([x[0] for x in successful_mutations]), 0.1, 0.9)\n                self.CR = np.clip(np.mean([x[1] for x in successful_mutations]), 0.1, 0.9)\n                successful_mutations.clear()\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Diversity maintenance through random introduction\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 52, "feedback": "The algorithm HADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06458 with standard deviation 0.05794.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13796710122576672, 0.14114871894101355, 0.14321422693479602, 0.04986179107493838, 0.051142411007713884, 0.05636636562551611, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "3f7d7648-990c-4267-bfc1-a0d906fe10ec", "fitness": 0.06621530733605435, "name": "EAPDE", "description": "Enhanced Differential Evolution with adaptive mutation factor variation and elitist preservation strategy for improved convergence.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0.4, 0.9)  # Adjusted range for F\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 53, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06622 with standard deviation 0.06006.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14385794146266395, 0.14149973814381533, 0.1513414377568929, 0.05339445021900513, 0.050943418488352044, 0.053400779953760025, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "f1a3cecb-316f-40e6-b444-7496e90ea3d6", "fitness": 0.06707629720371937, "name": "EAPDE", "description": "Enhanced Adaptive Population Differential Evolution with dynamic recombination strategy for improved exploration and convergence.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing guided random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                self.pop[rand_index] += 0.1 * np.random.randn(self.dim)  # Added strategy for diversity\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 54, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06708 with standard deviation 0.06019.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14770783986153035, 0.15238705583039025, 0.05564857385371802, 0.05260261493304297, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "41197896-1565-4d7c-ab68-fe4492bcc3d9", "fitness": 0.06689541222423113, "name": "EAPDE", "description": "Improved dynamic mutation factor updating for better adaptation to function landscapes.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations]) * 0.95  # Introduced scaling factor for better exploration-exploitation balance\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 55, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06690 with standard deviation 0.05949.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13904260602467589, 0.14356444692424053, 0.1513414377568929, 0.057567072759165505, 0.05759218083443607, 0.05145096571866947, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e54bfa95-3ac8-4534-8b6c-1494dafd0263", "fitness": 0.06703671743006162, "name": "EAPDE", "description": "Enhanced Self-Adaptive Differential Evolution with dynamic mutation scaling and diversity preservation.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Dynamic mutation scaling using population diversity\n                diversity_scaling = np.std(self.pop, axis=0).mean()\n                F_local = np.clip(self.F + 0.1 * np.random.randn() * diversity_scaling, 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 56, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06704 with standard deviation 0.06026.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14679586284546875, 0.1454470790471467, 0.14682025406384258, 0.050062339935670996, 0.05468027046843771, 0.05802465050998806, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5e648e64-4cc0-4283-ac0a-3868c82e4ccd", "fitness": 0.06714590052665995, "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with diversity-driven restart and local search intensification for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.initial_population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        self.evaluations = self.initial_population_size\n        successful_mutations = []\n        stagnation_counter = 0\n\n        while self.evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.pop.shape[0]):\n                indices = np.random.choice([idx for idx in range(self.pop.shape[0]) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                    stagnation_counter = 0\n                else:\n                    new_pop[i] = self.pop[i]\n                    stagnation_counter += 1\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            if stagnation_counter > 100:\n                self._diversity_restart(lb, ub, fitness)\n                stagnation_counter = 0\n\n            if self.evaluations < self.budget and np.random.rand() < 0.05:\n                self._intensify_local_search(func, lb, ub, fitness)\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]\n\n    def _diversity_restart(self, lb, ub, fitness):\n        indices = np.random.choice(self.pop.shape[0], size=int(0.2 * self.pop.shape[0]), replace=False)\n        self.pop[indices] = lb + (ub - lb) * np.random.rand(len(indices), self.dim)\n        for idx in indices:\n            fitness[idx] = func(self.pop[idx])\n            self.evaluations += 1\n\n    def _intensify_local_search(self, func, lb, ub, fitness):\n        best_idx = np.argmin(fitness)\n        for _ in range(5):\n            perturbation = 0.1 * (ub - lb) * np.random.randn(self.dim)\n            candidate = np.clip(self.pop[best_idx] + perturbation, lb, ub)\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n\n            if candidate_fitness < fitness[best_idx]:\n                self.pop[best_idx] = candidate\n                fitness[best_idx] = candidate_fitness", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06715 with standard deviation 0.06075.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1467677001833917, 0.1436162496515646, 0.15157010145075334, 0.05339445021900513, 0.05034687399717708, 0.05711772923804781, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6cda35fd-c173-40ad-aef9-b2ee73b3c61f", "fitness": 0.06668182322372752, "name": "EAPDE", "description": "Enhanced Differential Evolution with adaptive mutation and crossover rates fine-tuned for better convergence.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.05 * np.random.rand(), 0.1, 0.9)\n                CR_local = np.clip(self.CR + 0.02 * np.random.rand(), 0.1, 0.9)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 58, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06668 with standard deviation 0.06021.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14082093911337845, 0.15356857869148222, 0.14362332919067777, 0.05252126755065423, 0.05483574125957058, 0.05326655320778462, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6b491e04-4568-468e-9fc8-ec9ab8475fd8", "fitness": 0.06561291112851, "name": "EAPDE", "description": "Enhanced Differential Evolution with an improved self-adaptive strategy for better parameter tuning.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.1 * np.random.randn(), 0, 1)  # Modified CR adaptation\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 59, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06561 with standard deviation 0.05902.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1379292996791882, 0.14061751136493428, 0.1510714892837669, 0.05451997814694287, 0.053030773315538626, 0.05184714836621929, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "80533089-1b6a-4d70-b920-7396b5e789ef", "fitness": 0.06553562127037954, "name": "EAPDE", "description": "Enhanced Differential Evolution with diversity preservation and adaptive mutation strategies.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                self.population_size = max(5 * self.dim, int(10 * self.dim * (len(successful_mutations) + 1) / self.population_size))  # Changed\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            if evaluations < self.budget and np.random.rand() < 0.05:  # Added\n                diversity_index = np.random.randint(self.population_size)  # Added\n                self.pop[diversity_index] = lb + (ub - lb) * np.random.rand(self.dim)  # Added\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 60, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06554 with standard deviation 0.05928.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14147096119527092, 0.1513414377568929, 0.05339445021900513, 0.050362553760775475, 0.05352709211083495, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "efed3922-c5c9-471c-bf44-9b4e2355d5da", "fitness": 0.06634955244495629, "name": "EAPDE", "description": "Enhanced Adaptive Parameter and Diversity Control in Differential Evolution to Improve Convergence and Solution Quality.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n                \n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                self.population_size = max(5 * self.dim, min(int(12 * self.dim * len(successful_mutations) / self.population_size), self.population_size))\n\n            if evaluations < self.budget and np.random.rand() < 0.2:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 61, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06635 with standard deviation 0.05997.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14049925109272576, 0.144460973999746, 0.1513414377568929, 0.05339445021900513, 0.05033336497208074, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "18d4ad46-0673-4d73-bb3b-6f30b21aa6ab", "fitness": 0.06579711573993462, "name": "EAPDE", "description": "EAPDE with adaptive probability to maintain diversity based on convergence speed.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1 * (1 - evaluations / self.budget):  # Adjusted probability\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 62, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06580 with standard deviation 0.05910.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14061751136493428, 0.1513414377568929, 0.05564857385371802, 0.04922592832907369, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6791c486-341b-4d3c-8d16-1d27184503be", "fitness": 0.06448397271323604, "name": "EAPDEv2", "description": "EAPDEv2: Improved Enhanced Adaptive Population Differential Evolution utilizing adaptive F and CR from Cauchy and Gaussian distributions for enhanced exploration and convergence efficiency.", "code": "import numpy as np\n\nclass EAPDEv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with adaptive F and CR using Cauchy and Gaussian distributions\n                F_local = np.clip(self.F + np.random.standard_cauchy() * 0.1, 0, 1)\n                CR_local = np.clip(self.CR + np.random.randn() * 0.05, 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 63, "feedback": "The algorithm EAPDEv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06448 with standard deviation 0.05808.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13864555495403263, 0.14061751136493428, 0.14372510108370262, 0.048159518594072526, 0.05573766461464358, 0.051970403807738874, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c4784575-d69c-4e82-8749-81f08fac2ff4", "fitness": 0.0662236259864755, "name": "ADED", "description": "Adaptive Differential Evolution with dynamic restart mechanism and local exploration boost for enhanced convergence speed and robustness.", "code": "import numpy as np\n\nclass ADED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.restart_threshold = 0.1  # threshold for restarting strategy\n        self.local_exploration_boost = 0.2  # additional exploration boost factor\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n        best_fitness = np.min(fitness)\n        no_improvement_count = 0\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Restart strategy if no improvement\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness < best_fitness:\n                best_fitness = current_best_fitness\n                no_improvement_count = 0\n            else:\n                no_improvement_count += 1\n\n            if no_improvement_count > self.restart_threshold * self.budget / self.population_size:\n                self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n                fitness = np.array([func(ind) for ind in self.pop])\n                evaluations += self.population_size\n                no_improvement_count = 0\n\n            # Local exploration boost\n            if evaluations < self.budget and np.random.rand() < self.local_exploration_boost:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 64, "feedback": "The algorithm ADED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06622 with standard deviation 0.05945.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1404828230943841, 0.14061751136493428, 0.1513414377568929, 0.06242226760871916, 0.04826816778465581, 0.051380426268693435, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e4ecd322-d23b-4c7d-88b8-dbbb8d1e059c", "fitness": 0.06499980038459102, "name": "AdaptiveEAPDE", "description": "Adaptive Differential Evolution with success-based parameter modulation and multi-strategy mutation for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveEAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 5, replace=False)\n                r1, r2, r3, r4, r5 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n\n                if np.random.rand() < 0.5:\n                    mutant = r1 + F_local * (r2 - r3)\n                else:\n                    mutant = r1 + F_local * ((r2 + r3) / 2 - r4 - r5) / 2\n\n                mutant = np.clip(mutant, lb, ub)\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                diversity_factor = len(successful_mutations) / self.population_size\n                self.population_size = max(5 * self.dim, int(10 * self.dim * diversity_factor))\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 65, "feedback": "The algorithm AdaptiveEAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06500 with standard deviation 0.05935.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13661305160445947, 0.15094379010662617, 0.14293587811571473, 0.049848887531601105, 0.0469320323299226, 0.05622456377299523, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "abc3dff7-8311-478e-b0d1-b7134e802f1f", "fitness": 0.0659156323111428, "name": "EAPDE", "description": "EAPDE with refined random diversity introduction to enhance global exploration.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.15:  # Change 1: Increase the probability of diversity\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 66, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06592 with standard deviation 0.05963.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14049925109272576, 0.14061751136493428, 0.15238705583039025, 0.05339445021900513, 0.04922592832907369, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "82680e75-6837-45b9-903f-7f7ce33d67cd", "fitness": 0.06506140121568293, "name": "EAPDE", "description": "Refined EAPDE with adaptive mutation and crossover influenced by fitness variance and periodic random reinitialization for diversity.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            fitness_variance = np.var(fitness)  # Calculate fitness variance\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn() * fitness_variance, 0, 1)  # Adapt F based on variance\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals periodically\n            if evaluations < self.budget and evaluations % (self.population_size // 2) == 0:\n                for _ in range(int(0.1 * self.population_size)):\n                    rand_index = np.random.randint(self.population_size)\n                    self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[rand_index] = func(self.pop[rand_index])\n                    evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 67, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06506 with standard deviation 0.05903.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14199089838866097, 0.14448686690305113, 0.14293587811571473, 0.053735661383966016, 0.04830016418756056, 0.05260314196219318, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a7fc0eef-e275-4772-b733-cabecb666bc6", "fitness": 0.06711883877936398, "name": "AEDES", "description": "Adaptive Enhanced Differential Evolution with dynamic strategies selector based on success history and a diversity booster to improve convergence and robustness in optimization.", "code": "import numpy as np\n\nclass AEDES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.5\n        self.CR_base = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F_base + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR_base + 0.05 * np.random.randn(), 0, 1)\n\n                if np.random.rand() < 0.5:\n                    mutant = r1 + F_local * (r2 - r3)\n                else:\n                    mutant = r1 - F_local * (r2 - r3)\n\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, self.pop[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F_base = np.mean([x[0] for x in successful_mutations])\n                self.CR_base = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                \n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            if evaluations < self.budget and np.random.rand() < 0.2:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 68, "feedback": "The algorithm AEDES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06712 with standard deviation 0.06009.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.15155144181182056, 0.14176660798643814, 0.1447542383181094, 0.05478701967752997, 0.05403929946367858, 0.05567094175669929, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c7ca280b-a33c-4387-bfc2-5ee3bf57c029", "fitness": 0.06581617767658596, "name": "EAPDE", "description": "Refined EAPDE with periodic reset of mutation factor for enhanced diversity and exploration.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            # Periodically reset F to reintroduce diversity\n            if evaluations % (self.population_size * 10) == 0:\n                self.F = 0.5\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 69, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06582 with standard deviation 0.05945.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.140441622882866, 0.14061751136493428, 0.1513414377568929, 0.053602604791350705, 0.04922592832907369, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5b067f81-e946-488a-bd4a-c778b4db3451", "fitness": 0.06777453981479918, "name": "ADERefined", "description": "Adaptive Differential Evolution with self-tuning mutation and crossover rates and adaptive population size refinement based on historical successes and diversity maintenance.", "code": "import numpy as np\n\nclass ADERefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with refined self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0.1, 0.9)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0.1, 0.9)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success rate; increase if high success\n                success_rate = len(successful_mutations) / self.population_size\n                if success_rate > 0.1:\n                    self.population_size = min(20 * self.dim, int(self.population_size * 1.1))\n                else:\n                    self.population_size = max(5 * self.dim, int(self.population_size * 0.9))\n\n            # Maintain diversity: occasionally introduce random individuals\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 70, "feedback": "The algorithm ADERefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06777 with standard deviation 0.05916.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14222113154356986, 0.15218241137875466, 0.06337905913819863, 0.057306310078273026, 0.05515784980376004, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "46ed48ab-7d18-4187-982b-91f807dac20c", "fitness": 0.06761945334887635, "name": "EAPDE", "description": "EAPDE with improved mutation factor dynamics for enhanced exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.2 * np.random.randn(), 0, 1)  # Modified line\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 71, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06762 with standard deviation 0.06085.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14294773072420042, 0.1534297583696944, 0.14676641591602047, 0.05382031501593598, 0.053274097737453174, 0.05683676237658286, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c0842a2e-8d73-4968-9cea-21ac29e91cb2", "fitness": 0.06597942562671075, "name": "EAPDE", "description": "Enhanced Differential Evolution with dynamic population size based on success history; additional diversity by adaptive mutation factor and smarter random reinitialization.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim) * 0.5  # diversify with adaptive mutation factor\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 72, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06598 with standard deviation 0.05926.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14067146787420226, 0.15238705583039025, 0.05564857385371802, 0.049767142727293545, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "4152fe13-210d-4176-8a83-8bf56de9a7a9", "fitness": 0.06590594004802897, "name": "EADETM", "description": "Enhanced Adaptive Differential Evolution with Elite Preservation and Temporal Memory for improved convergence and diversity.", "code": "import numpy as np\n\nclass EADETM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.best_solution = None\n        self.temporal_memory = []\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Track the best solution found so far\n            current_best_index = np.argmin(fitness)\n            current_best_solution = self.pop[current_best_index]\n            if self.best_solution is None or fitness[current_best_index] < func(self.best_solution):\n                self.best_solution = current_best_solution\n                self.temporal_memory.append(self.best_solution)\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            # Employ temporal memory to refine search if stagnation is detected\n            if len(self.temporal_memory) > 1 and np.allclose(self.temporal_memory[-2], self.temporal_memory[-1]):\n                self.pop[np.random.randint(self.population_size)] = self.best_solution + 0.1 * np.random.randn(self.dim)\n                self.pop = np.clip(self.pop, lb, ub)\n\n        # Return the best solution found\n        return self.best_solution", "configspace": "", "generation": 73, "feedback": "The algorithm EADETM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06591 with standard deviation 0.05926.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14061751136493428, 0.15235429495080288, 0.055629540240397235, 0.04922193155006971, 0.05560608593542016, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "68ede349-aa43-46c9-9564-43547d3e04ae", "fitness": 0.06572900035522143, "name": "EAPDE", "description": "Enhanced Differential Evolution with stochastic F and CR adaptation and increased mutation diversity for improved global exploration.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0.3, 0.9)  # Change 1\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0.2, 1)  # Change 2\n                mutant = r1 + F_local * (r2 - r3) + 0.1 * np.random.randn(self.dim)  # Change 3\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 74, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06573 with standard deviation 0.05898.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14010570887929463, 0.14681441228264402, 0.14293587811571473, 0.050099212566495854, 0.05691684479171821, 0.053188946561125605, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8462da80-1582-46b5-afae-7969721f8d75", "fitness": 0.06591329552587877, "name": "EADE", "description": "Enhanced Adaptive Differential Evolution with historical learning and adaptive population control for improved convergence and robustness.", "code": "import numpy as np\n\nclass EADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n        historical_success = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                    historical_success.append(trial_fitness)\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on historical success rate\n                if len(historical_success) > 0:\n                    success_rate = len(historical_success) / evaluations\n                    self.population_size = max(5 * self.dim, int(10 * self.dim * success_rate))\n                    self.pop = self.pop[:self.population_size]\n                    fitness = fitness[:self.population_size]\n                    historical_success.clear()\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 75, "feedback": "The algorithm EADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06591 with standard deviation 0.05927.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14061751136493428, 0.15238705583039025, 0.05564857385371802, 0.04922592832907369, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "cb835875-5a4c-4760-9d34-ef2859950208", "fitness": 0.06392355917721593, "name": "AEDE", "description": "Adaptive Ensemble Differential Evolution (AEDE) employs a diverse set of mutation strategies and adaptive parameters to balance exploration and exploitation dynamically throughout the optimization process.", "code": "import numpy as np\n\nclass AEDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.mutation_strategies = ['rand', 'best', 'current-to-best']\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                strategy = np.random.choice(self.mutation_strategies)\n                if strategy == 'rand':\n                    indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                    r1, r2, r3 = self.pop[indices]\n                    mutant = r1 + self.F * (r2 - r3)\n                elif strategy == 'best':\n                    best_idx = np.argmin(fitness)\n                    indices = np.random.choice([idx for idx in range(self.population_size) if idx != i and idx != best_idx], 2, replace=False)\n                    r2, r3 = self.pop[indices]\n                    mutant = self.pop[best_idx] + self.F * (r2 - r3)\n                elif strategy == 'current-to-best':\n                    best_idx = np.argmin(fitness)\n                    indices = np.random.choice([idx for idx in range(self.population_size) if idx != i and idx != best_idx], 1, replace=False)\n                    r1 = self.pop[indices[0]]\n                    mutant = self.pop[i] + self.F * (self.pop[best_idx] - self.pop[i]) + self.F * (r1 - self.pop[i])\n\n                mutant = np.clip(mutant, lb, ub)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((self.F, self.CR))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.clip(np.mean([x[0] for x in successful_mutations]) + 0.1 * np.random.randn(), 0.1, 0.9)\n                self.CR = np.clip(np.mean([x[1] for x in successful_mutations]) + 0.05 * np.random.randn(), 0.1, 0.9)\n                successful_mutations.clear()\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 76, "feedback": "The algorithm AEDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06392 with standard deviation 0.05762.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13088265214093897, 0.14530934164466758, 0.14293587811571473, 0.0513702951021916, 0.04981925602569004, 0.05349460956574059, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "56195f26-fdcf-4413-8720-b0237d99a28b", "fitness": 0.06591329552587877, "name": "EAPDE", "description": "Enhanced Differential Evolution with adaptive mutation factor scaling for improved convergence speed and solution quality.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 77, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06591 with standard deviation 0.05927.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14061751136493428, 0.15238705583039025, 0.05564857385371802, 0.04922592832907369, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7c4e280e-8cbd-4bec-9634-8848a9968614", "fitness": -Infinity, "name": "DynamicADE", "description": "Dynamic Adaptive Differential Evolution with stochastic selection and diversity preservation to enhance convergence behavior.", "code": "import numpy as np\n\nclass DynamicADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n        history = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Stochastic selection based on fitness ranking\n                probabilities = np.exp(-np.argsort(np.argsort(fitness)))\n                probabilities /= probabilities.sum()\n                indices = np.random.choice(self.population_size, 3, replace=False, p=probabilities)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0.4, 0.9)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0.8, 1.0)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                    history.append(evaluations)\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                success_rate = len(history) / self.population_size\n                if success_rate > 0.2:\n                    self.population_size = min(20 * self.dim, int(self.population_size * 1.2))\n                else:\n                    self.population_size = max(5 * self.dim, int(self.population_size * 0.8))\n                history.clear()\n\n            # Preserve diversity by introducing new random individuals\n            if evaluations < self.budget:\n                num_randoms = int(0.1 * self.population_size)\n                random_indices = np.random.choice(self.population_size, num_randoms, replace=False)\n                for ri in random_indices:\n                    self.pop[ri] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[ri] = func(self.pop[ri])\n                    evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 78, "feedback": "An exception occurred: IndexError('index 227 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 227 is out of bounds for axis 0 with size 200')", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {}}
{"id": "2706e247-c1d4-4ef2-9790-94f63a192b90", "fitness": 0.08692240285370624, "name": "EAPDE", "description": "EAPDE with enhanced mutation strategy using global best influence for improved convergence speed.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            best_idx = np.argmin(fitness)\n            best_individual = self.pop[best_idx]\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3) + 0.1 * (best_individual - self.pop[i])  # changed line\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 79, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08692 with standard deviation 0.09733.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.3171091198149424, 0.14703732741698916, 0.14564751125258746, 0.05254936902324492, 0.05249113503924718, 0.06596716313634521, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "bf586f85-d242-49dd-b17e-23a0b2693712", "fitness": 0.06583100093206011, "name": "EAPDEPlus", "description": "EAPDE+ introduces adaptive memory for mutation and crossover rates with random immigrant strategies to enhance exploration in dynamic environments.", "code": "import numpy as np\n\nclass EAPDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.memory_size = 5\n        self.F_memory = [self.F] * self.memory_size\n        self.CR_memory = [self.CR] * self.memory_size\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with adaptive F and CR from memory\n                mem_idx = np.random.randint(0, self.memory_size)\n                F_local = np.clip(self.F_memory[mem_idx] + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR_memory[mem_idx] + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                new_F = np.mean([x[0] for x in successful_mutations])\n                new_CR = np.mean([x[1] for x in successful_mutations])\n                self.F_memory[mem_idx] = new_F\n                self.CR_memory[mem_idx] = new_CR\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Introduce random immigrants to maintain diversity\n            if evaluations < self.budget and np.random.rand() < 0.15:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 80, "feedback": "The algorithm EAPDEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06583 with standard deviation 0.05804.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13960806790893987, 0.14061751136493428, 0.1442248622947363, 0.058374716399387516, 0.054089299663618196, 0.054064550756924956, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "04974642-c4b6-41d2-aedc-5be4c0452c7d", "fitness": 0.0665965474348937, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Fitness-based Scaling dynamically adjusts mutation and crossover parameters based on trial success, improving adaptive exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with fitness-based scaling\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments based on success history and fitness scaling\n            if successful_mutations:\n                success_rate = len(successful_mutations) / self.population_size\n                self.F = np.mean([x[0] for x in successful_mutations]) * (1 + success_rate)\n                self.CR = np.mean([x[1] for x in successful_mutations]) * (1 + success_rate)\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * success_rate))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 81, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06660 with standard deviation 0.05979.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14100685928613776, 0.14074630624866935, 0.15357342207531277, 0.05339445021900513, 0.05488640768921438, 0.05426148139570408, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "98a3dfd2-c85e-4c32-a07b-9a0f5ff18ad6", "fitness": 0.06659895679223754, "name": "ADETM", "description": "Adaptive Differential Evolution with Temporal Memory (ADETM) retains successful strategies over generations for enhanced search efficiency and convergence.", "code": "import numpy as np\n\nclass ADETM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.memory_size = 5  # size of the temporal memory\n        self.memory = []  # memory to store successful (F, CR) pairs\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            successful_mutations = []\n            \n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                if self.memory and np.random.rand() < 0.9:  # Use memory with a probability\n                    F_local, CR_local = self.memory[np.random.randint(len(self.memory))]\n                else:\n                    F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                    CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                self.memory.extend(successful_mutations)\n                if len(self.memory) > self.memory_size:\n                    self.memory = self.memory[-self.memory_size:]\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 82, "feedback": "The algorithm ADETM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06660 with standard deviation 0.06007.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14157713735667432, 0.14440931156293435, 0.1513414377568929, 0.05339445021900513, 0.05402866279403984, 0.05313961144059143, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "38485071-683b-4334-8bff-34d86d4eadaa", "fitness": 0.0653393441868989, "name": "EAPDE", "description": "Improved exploration by adjusting mutation factor through chaotic variable initialization.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = np.random.rand()  # chaotic initialization for F\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 83, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06534 with standard deviation 0.05850.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14683183205098616, 0.13664993183020713, 0.14289726865133312, 0.05363091579706236, 0.05013849002028581, 0.05640565933221575, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "4bc5b5de-8c31-42fc-88a4-b2067bf72fb1", "fitness": 0.06591329552587877, "name": "EAPDE", "description": "Enhanced Adaptive Differential Evolution using success-based learning rate and early stopping based on stagnation detection.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n        stagnation_counter = 0  # New line: Track stagnation\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                    stagnation_counter = 0  # Reset stagnation on success\n                else:\n                    new_pop[i] = self.pop[i]\n                    stagnation_counter += 1  # Increment stagnation\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            # Early stopping if stagnation is detected\n            if stagnation_counter > 2 * self.population_size:  # New line: Early stopping condition\n                break  # New line: Break loop on stagnation\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 84, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06591 with standard deviation 0.05927.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14061751136493428, 0.15238705583039025, 0.05564857385371802, 0.04922592832907369, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "dd38fdc8-6e75-4ee2-b9a0-9ca703d41bc6", "fitness": 0.06630563650504134, "name": "EAPDE", "description": "Enhanced Adaptive Differential Evolution with dynamic population control and learning-based parameter adaptation to improve convergence.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.successful_mutations = []\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0.1, 0.9)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0.1, 0.9)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if self.successful_mutations:\n                self.F = np.mean([x[0] for x in self.successful_mutations])\n                self.CR = np.mean([x[1] for x in self.successful_mutations])\n                self.successful_mutations.clear()\n\n            # Adjust population size dynamically based on performance\n            if evaluations % (self.initial_population_size // 2) == 0:\n                avg_fitness = np.mean(fitness)\n                diversity = np.std(fitness)\n                if diversity < 0.01 * avg_fitness:\n                    self.population_size = max(5 * self.dim, int(self.population_size * 0.9))\n                elif diversity > 0.05 * avg_fitness:\n                    self.population_size = min(20 * self.dim, int(self.population_size * 1.1))\n                self.pop = np.resize(self.pop, (self.population_size, self.dim))\n                fitness = np.resize(fitness, self.population_size)\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 85, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06631 with standard deviation 0.05964.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14005165342834036, 0.14282472670575208, 0.1513414377568929, 0.05347678100499553, 0.05111921474679848, 0.05643691490259295, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fe0782ec-457f-4ff1-a775-b6c7bad5b082", "fitness": 0.06698188220783666, "name": "ADE_DEEC", "description": "Adaptive Differential Evolution with Dynamic Exploration-Exploitation Control (ADE-DEEC) that refines evolution parameters dynamically based on diversity and fitness trends for improved convergence.", "code": "import numpy as np\n\nclass ADE_DEEC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n        diversity_threshold = 1e-5\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n\n            # Calculate the population diversity\n            mean_pop = np.mean(self.pop, axis=0)\n            diversity = np.mean(np.linalg.norm(self.pop - mean_pop, axis=1))\n\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Check to inject new individuals to maintain diversity\n            if evaluations < self.budget and diversity < diversity_threshold:\n                for j in range(int(0.1 * self.population_size)):\n                    rand_index = np.random.randint(self.population_size)\n                    self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[rand_index] = func(self.pop[rand_index])\n                    evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 86, "feedback": "The algorithm ADE_DEEC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06698 with standard deviation 0.06038.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1396088166574322, 0.14828749051702506, 0.1513414377568929, 0.05806143120609486, 0.0484212697689288, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "42c58cad-5b5a-4f01-9031-84e37381b07a", "fitness": 0.0666695896395073, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution leverages historical success to dynamically tune mutation and crossover rates, with strategic population diversity maintenance for enhanced global search.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0.1, 0.9)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0.1, 0.9)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                self.population_size = max(5 * self.dim, int(self.initial_population_size * (1 + len(successful_mutations) / self.population_size)))\n\n            if evaluations < self.budget and np.random.rand() < 0.2:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 87, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06667 with standard deviation 0.06069.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.14479558093141986, 0.14365267494389178, 0.1525785619770439, 0.05339445021900513, 0.05134693074053176, 0.052758107943673416, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "f3f50042-2054-4f2a-a67e-ab0d2a928f72", "fitness": 0.06587480859968531, "name": "HADE", "description": "Hybrid Adaptive Differential Evolution combining Success-based Population Dynamics and Diversity Injection for enhanced performance in black-box optimization.", "code": "import numpy as np\n\nclass HADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            # Periodic re-initialization to avoid local optima\n            if evaluations % (self.budget // 10) == 0:\n                for j in range(int(0.2 * self.population_size)):\n                    rand_index = np.random.randint(self.population_size)\n                    self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[rand_index] = func(self.pop[rand_index])\n                    evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 88, "feedback": "The algorithm HADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06587 with standard deviation 0.05911.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14093974392801245, 0.1513414377568929, 0.053821625299800946, 0.05448233394391078, 0.052564040077914265, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8f5a5cbb-09ae-4c42-bf4f-b042fc76a34d", "fitness": 0.06657012363927853, "name": "RADE", "description": "Refined Adaptive Differential Evolution (RADE) introduces adaptive learning rates for mutation and crossover, with diversity enhancement through catastrophic resets for robust black-box optimization.", "code": "import numpy as np\n\nclass RADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n        self.catastrophic_reset_probability = 0.05\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Catastrophic reset to enhance diversity\n            if evaluations < self.budget and np.random.rand() < self.catastrophic_reset_probability:\n                reset_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.1), replace=False)\n                for idx in reset_indices:\n                    self.pop[idx] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[idx] = func(self.pop[idx])\n                    evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 89, "feedback": "The algorithm RADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06657 with standard deviation 0.05916.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.1420889769338548, 0.1513414377568929, 0.05564857385371802, 0.05471153385424832, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "b87d2c9c-cdb3-40c3-8e84-433b895b39df", "fitness": 0.06506304225931597, "name": "ADEAM", "description": "Adaptive Differential Evolution with Adaptive Memory Mechanism for improved parameter tuning and diversity maintenance.", "code": "import numpy as np\n\nclass ADEAM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.memory_size = 5  # memory for adaptive parameters\n        self.F_memory = [self.F] * self.memory_size\n        self.CR_memory = [self.CR] * self.memory_size\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F_memory[np.random.randint(self.memory_size)] + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR_memory[np.random.randint(self.memory_size)] + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F_memory.pop(0)\n                self.CR_memory.pop(0)\n                self.F_memory.append(np.mean([x[0] for x in successful_mutations]))\n                self.CR_memory.append(np.mean([x[1] for x in successful_mutations]))\n                successful_mutations.clear()\n\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 90, "feedback": "The algorithm ADEAM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06506 with standard deviation 0.05828.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13901779304906714, 0.14061751136493428, 0.14537045284877437, 0.05236579714651002, 0.05508217217288214, 0.051613653751676036, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8dd6220d-c2ad-4ccc-8196-f70fb880197a", "fitness": 0.06461912703551703, "name": "EADE", "description": "Enhanced Adaptive Differential Evolution (EADE) introduces a memory-based strategy to dynamically adjust population size and control parameters F and CR based on success history, with periodic diversity boosting through random immigrants.", "code": "import numpy as np\n\nclass EADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n        self.memory_size = 5  # Memory size for storing successful parameters\n        self.memory_index = 0\n        self.success_memory = np.zeros((self.memory_size, 2))  # Store F and CR\n        self.success_counter = 0\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                    # Store successful F and CR\n                    self.success_memory[self.memory_index] = [F_local, CR_local]\n                    self.memory_index = (self.memory_index + 1) % self.memory_size\n                    self.success_counter += 1\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if self.success_counter > 0:\n                self.F = np.mean(self.success_memory[:self.success_counter % self.memory_size, 0])\n                self.CR = np.mean(self.success_memory[:self.success_counter % self.memory_size, 1])\n                self.success_counter = 0\n\n            # Adjust population size based on success\n            if evaluations < self.budget:\n                success_rate = self.memory_index / self.memory_size\n                new_population_size = max(5 * self.dim, int(10 * self.dim * success_rate))\n                if new_population_size != self.population_size:\n                    self.population_size = new_population_size\n                    self.pop = np.resize(self.pop, (self.population_size, self.dim))\n                    fitness = np.resize(fitness, self.population_size)\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 91, "feedback": "The algorithm EADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06462 with standard deviation 0.05947.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1386528782550308, 0.14050118893967667, 0.15091802782371533, 0.05292195921135956, 0.04767203231027206, 0.05090605677959881, 0.0, 0.0, 0.0]}}
{"id": "79665497-970e-434b-a7a4-b98dd45d0313", "fitness": 0.06591329552587877, "name": "EAPDE", "description": "Enhanced Adaptive Mutation Strategy for Differential Evolution by introducing variance analysis in mutation factors.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn() * (1 if np.var(fitness) > 0.1 else -1), 0, 1)  # Modified line\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 92, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06591 with standard deviation 0.05927.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14061751136493428, 0.15238705583039025, 0.05564857385371802, 0.04922592832907369, 0.055616493964156244, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9a811157-a80d-47e2-9ea9-4ac0687c8f4b", "fitness": 0.06738380797871751, "name": "EAPDE", "description": "Enhanced Dynamic Differential Evolution with adaptive mutation factor and random restart mechanism for improved convergence.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.2 * np.random.randn(), 0, 1)  # Adjusted mutation strategy\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n            # Random restart mechanism to escape local optima\n            if evaluations < self.budget and np.random.rand() < 0.05:  # New addition\n                self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n                fitness = np.array([func(ind) for ind in self.pop])\n                evaluations += self.population_size\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 93, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06738 with standard deviation 0.06095.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1437071489823657, 0.1534297583696944, 0.1463247770157461, 0.05253117709040489, 0.053274097737453174, 0.05568731261279358, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "4fef430f-bde6-475f-bff5-918bcdc4d3f7", "fitness": 0.06628603980562743, "name": "EAPDE", "description": "Enhanced Differential Evolution with dynamic mutation factor adjustment from the success history for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations]) * 0.9  # Slightly decrease F\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 94, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06629 with standard deviation 0.05900.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1382240963906366, 0.14061751136493428, 0.1513414377568929, 0.05552674790461576, 0.057984138564874055, 0.051380426268693435, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "0e47ac7b-ce49-4456-994f-7113dc7b12ba", "fitness": -Infinity, "name": "AdaptiveEAPDE", "description": "Adaptive Differential Evolution with Dynamic Population Resizing and Success-Based Parameter Tuning to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveEAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.min_population_size = 5 * dim\n        self.max_population_size = 15 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n            # Dynamic population resizing based on success rate\n            success_rate = len(successful_mutations) / self.population_size\n            if success_rate < 0.2 and self.population_size < self.max_population_size:\n                self.population_size += int(0.1 * self.population_size)\n            elif success_rate > 0.5 and self.population_size > self.min_population_size:\n                self.population_size -= int(0.1 * self.population_size)\n\n            # Maintain diversity\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 95, "feedback": "An exception occurred: IndexError('index 203 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 203 is out of bounds for axis 0 with size 200')", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {}}
{"id": "799f9150-cedf-4345-981a-37b8ff5aa497", "fitness": 0.08773297251073009, "name": "EAPDE", "description": "Enhanced Adaptive Differential Evolution with modified mutation and crossover to improve convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass EAPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with self-adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0.1, 0.9)  # Slight modification for stability\n                mutant = r1 + F_local * (r2 - r3) + 0.5 * (self.pop[np.random.randint(self.population_size)] - self.pop[i])  # Modified mutation\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by introducing random individuals occasionally\n            if evaluations < self.budget and np.random.rand() < 0.1:\n                rand_index = np.random.randint(self.population_size)\n                self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                fitness[rand_index] = func(self.pop[rand_index])\n                evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 96, "feedback": "The algorithm EAPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08773 with standard deviation 0.09832.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.31975324915871883, 0.14264655932001924, 0.15254871640992151, 0.047925335746718534, 0.05080574889403233, 0.07441714306716052, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "4779f054-bc36-40dd-bd19-be9e8f3351d8", "fitness": 0.06589327281414543, "name": "EADE", "description": "Enhanced Adaptive Differential Evolution (EADE) with adaptive mutation strategies and periodic reinitialization for improved exploration and faster convergence.", "code": "import numpy as np\n\nclass EADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Adaptive mutation strategy\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                if np.random.rand() < 0.5:\n                    mutant = r1 + F_local * (r2 - r3)\n                else:\n                    mutant = r1 + F_local * (self.pop[i] - r2) + F_local * (r3 - r2)\n\n                mutant = np.clip(mutant, lb, ub)\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n\n                # Adjust population size adaptively\n                self.population_size = max(5 * self.dim, int(10 * self.dim * (1 + len(successful_mutations) / self.population_size)))\n\n            # Periodic reinitialization to enhance exploration\n            if evaluations < self.budget and evaluations % (self.population_size * 2) == 0:\n                for _ in range(int(self.population_size * 0.1)):\n                    rand_index = np.random.randint(self.population_size)\n                    self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[rand_index] = func(self.pop[rand_index])\n                    evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 97, "feedback": "The algorithm EADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06589 with standard deviation 0.05987.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13971488545953248, 0.14692561189805464, 0.14863137491266987, 0.05184469903790523, 0.05223737208974921, 0.05218551192939769, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "3c9d1933-0349-43ae-8e3b-9eb890e00f1f", "fitness": 0.06686325668811177, "name": "EnhancedADE", "description": "Enhanced Adaptive Differential Evolution with success-based parameter scaling and enhanced diversity control for optimized exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            if successful_mutations:\n                self.F = np.mean([x[0] for x in successful_mutations])\n                self.CR = np.mean([x[1] for x in successful_mutations])\n                successful_mutations.clear()\n                self.population_size = int(max(5 * self.dim, 10 * self.dim * (1 + len(successful_mutations) / self.population_size)))\n\n            if evaluations < self.budget and np.random.rand() < 0.2:  # increased diversity rate\n                rand_indices = np.random.choice(self.population_size, size=max(1, int(0.05 * self.population_size)), replace=False)\n                for rand_index in rand_indices:\n                    self.pop[rand_index] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[rand_index] = func(self.pop[rand_index])\n                    evaluations += 1\n\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06686 with standard deviation 0.06086.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.1467677001833917, 0.1442260581406274, 0.1513414377568929, 0.05339445021900513, 0.05076554351429685, 0.053774120378792145, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e77cfb0f-2016-40ad-accf-6bc617fe8858", "fitness": 0.06791942362313835, "name": "EAPDE_Refined", "description": "Introducing an adaptive learning rate for mutation and crossover rates based on success trajectory and enhancing diversity through periodic reinitialization of the worst individuals.", "code": "import numpy as np\n\nclass EAPDE_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.pop = None\n        self.bounds = None\n\n    def __call__(self, func):\n        # Initialize the population randomly within the bounds\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        lb, ub = self.bounds\n        self.pop = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        successful_mutations = []\n\n        while evaluations < self.budget:\n            new_pop = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                # Select three distinct individuals randomly\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                r1, r2, r3 = self.pop[indices]\n\n                # Mutation and crossover with adaptive F and CR\n                F_local = np.clip(self.F + 0.1 * np.random.randn(), 0.1, 1)\n                CR_local = np.clip(self.CR + 0.05 * np.random.randn(), 0.1, 1)\n                mutant = r1 + F_local * (r2 - r3)\n                mutant = np.clip(mutant, lb, ub)\n\n                cross_points = np.random.rand(self.dim) < CR_local\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Evaluate trial and perform selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_pop[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations.append((F_local, CR_local))\n                else:\n                    new_pop[i] = self.pop[i]\n\n            self.pop = new_pop\n\n            # Adaptive adjustments of F and CR based on success history\n            if successful_mutations:\n                F_values, CR_values = zip(*successful_mutations)\n                self.F = np.clip(np.mean(F_values) + 0.1 * np.std(F_values), 0.1, 1)\n                self.CR = np.clip(np.mean(CR_values) + 0.05 * np.std(CR_values), 0.1, 1)\n                successful_mutations.clear()\n                # Adjust population size based on success\n                self.population_size = max(5 * self.dim, int(10 * self.dim * len(successful_mutations) / self.population_size))\n\n            # Maintain diversity by periodically reinitializing worst individuals\n            if evaluations < self.budget and evaluations % (self.population_size // 2) == 0:\n                worst_indices = np.argsort(-fitness)[:self.dim]\n                for idx in worst_indices:\n                    self.pop[idx] = lb + (ub - lb) * np.random.rand(self.dim)\n                    fitness[idx] = func(self.pop[idx])\n                    evaluations += 1\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return self.pop[best_index]", "configspace": "", "generation": 99, "feedback": "The algorithm EAPDE_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06792 with standard deviation 0.06012.", "error": "", "parent_ids": ["ce6c99d1-1c7d-49d1-a850-1f6a32988785"], "operator": null, "metadata": {"aucs": [0.13878998880719218, 0.14811560452629835, 0.1513414377568929, 0.05339445021900513, 0.05171355508634756, 0.06641977621250927, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
