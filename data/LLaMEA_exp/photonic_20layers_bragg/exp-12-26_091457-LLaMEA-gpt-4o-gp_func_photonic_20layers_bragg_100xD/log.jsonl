{"id": "3ce8ca7a-fc83-4810-85af-406783872972", "fitness": 0.09394052140841685, "name": "PSO_DE_Optimizer", "description": "A novel combination of Particle Swarm Optimization (PSO) and Differential Evolution (DE) that adaptively switches between exploration and exploitation phases based on swarm diversity.", "code": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.random.rand(self.population_size, self.dim)\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.5  # Scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness of particles\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                # Update personal best\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                # Update global best\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.particles, axis=0))\n\n            # Switch between PSO and DE according to the diversity\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            # Evaluate the trial vector\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                # Replace if the trial vector is better\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    # Update personal and global bests\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 0, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.11381219548189925, 0.11382299089824399, 0.11383543036882415, 0.07344195644069695, 0.07343113736356399, 0.07345088744521411, 0.09455314738782927, 0.09454895110883688, 0.09456799618064315]}}
{"id": "298f466d-435b-45fe-ba87-8d35f66b096f", "fitness": 0.09394182822155249, "name": "PSO_DE_Optimized", "description": "A refined combo of PSO and DE with dynamic parameter tuning that adjusts inertia and scaling factors based on convergence rate.", "code": "import numpy as np\n\nclass PSO_DE_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Dynamic scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n        else:\n            self.w = min(0.9, self.w * 1.01)\n            self.F = max(0.4, self.F * 0.99)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 1, "feedback": "The algorithm PSO_DE_Optimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["3ce8ca7a-fc83-4810-85af-406783872972"], "operator": null, "metadata": {"aucs": [0.11379699533623444, 0.11383819921402183, 0.11384138942224997, 0.07343653124333471, 0.07343657346756682, 0.0734530135657423, 0.09454385083217542, 0.09455826092498076, 0.09457163998766616]}}
{"id": "6874796d-4243-439e-9f0b-1a7896421a38", "fitness": -Infinity, "name": "EnhancedPSO_DE", "description": "An enhanced PSO-DE hybrid with adaptive strategy selection based on fitness improvement rate and diversity, featuring strengthened exploitation and exploration through balanced parameter adjustments.", "code": "import numpy as np\n\nclass EnhancedPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 2.0  # Cognitive coefficient for PSO\n        self.c2 = 2.0  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.no_improvement_steps = 0\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n                    self.no_improvement_steps = 0\n                else:\n                    self.no_improvement_steps += 1\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._adaptive_parameter_update(diversity)\n\n            if self.no_improvement_steps < 10:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _adaptive_parameter_update(self, diversity):\n        # Adaptively adjust parameters based on improvement rate and diversity\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n            self.c1 = max(1.5, self.c1 * 0.98)\n            self.c2 = min(2.0, self.c2 * 1.02)\n        else:\n            self.w = min(0.9, self.w * 1.01)\n            self.F = max(0.4, self.F * 0.99)\n            self.c1 = min(2.0, self.c1 * 1.02)\n            self.c2 = max(1.5, self.c2 * 0.98)\n\n        if diversity < 0.05:\n            self.CR = max(0.5, self.CR * 0.98)\n        else:\n            self.CR = min(0.9, self.CR * 1.02)\n\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 2, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["298f466d-435b-45fe-ba87-8d35f66b096f"], "operator": null, "metadata": {}}
{"id": "523d15e4-ae81-4c04-a8f7-ad7429fbfd3e", "fitness": 0.09392671869625865, "name": "HybridAdaptivePSO_DE", "description": "Hybrid Adaptive PSO-DE with Local Search, dynamically balancing exploration and exploitation by incorporating local search in stagnating solutions for enhanced convergence.", "code": "import numpy as np\n\nclass HybridAdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.local_search_prob = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if self.eval_count < self.budget and np.random.rand() < self.local_search_prob:\n                self._local_search(bounds, func)\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n        else:\n            self.w = min(0.9, self.w * 1.01)\n            self.F = max(0.4, self.F * 0.99)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _local_search(self, bounds, func):\n        for i in np.argsort(self.fitness)[:int(0.1 * self.population_size)]:\n            local_candidate = self.particles[i] + np.random.randn(self.dim) * 0.01\n            local_candidate = np.clip(local_candidate, *bounds)\n            if self.eval_count < self.budget:\n                local_fitness = func(local_candidate)\n                self.eval_count += 1\n\n                if local_fitness < self.fitness[i]:\n                    self.particles[i] = local_candidate\n                    self.fitness[i] = local_fitness\n\n                    if local_fitness < self.best_fitness:\n                        self.best_fitness = local_fitness\n                        self.global_best = local_candidate", "configspace": "", "generation": 3, "feedback": "The algorithm HybridAdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09393 with standard deviation 0.01649.", "error": "", "parent_ids": ["298f466d-435b-45fe-ba87-8d35f66b096f"], "operator": null, "metadata": {"aucs": [0.11379597857852408, 0.11379904305179511, 0.11381251170989293, 0.07343616753479543, 0.07342258687081138, 0.0734426901170856, 0.09454322813514127, 0.09453430118182915, 0.09455396108645298]}}
{"id": "0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f", "fitness": 0.09394790796583624, "name": "PSO_DE_Optimized", "description": "Enhanced dynamic parameter adjustment to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass PSO_DE_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Dynamic scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n        else:\n            self.w = min(0.9, self.w * 1.02)  # Slightly increased adjustment factor\n            self.F = max(0.4, self.F * 0.99)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 4, "feedback": "The algorithm PSO_DE_Optimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["298f466d-435b-45fe-ba87-8d35f66b096f"], "operator": null, "metadata": {"aucs": [0.11382125270154553, 0.11383724160859066, 0.11384588589590583, 0.07344518955664114, 0.07343623176994163, 0.07345461794017738, 0.09455868732239436, 0.0945576753357994, 0.09457438956153019]}}
{"id": "78be1d00-306d-45ad-b689-0c932e986a28", "fitness": 0.0939292259985928, "name": "AdaptivePSO_DE", "description": "Introduced a dual adaptive mechanism leveraging swarm intelligence and mutation sensitivity to dynamically balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.mutation_sensitivity = 0.1 # New parameter for mutation sensitivity\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._adaptive_update_parameters(diversity)\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _adaptive_update_parameters(self, diversity):\n        # Dual adaptive mechanism adjusting PSO and DE parameters\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (1 - self.mutation_sensitivity))\n            self.F = min(0.9, self.F * (1 + self.mutation_sensitivity))\n        else:\n            self.w = min(0.9, self.w * (1 + self.mutation_sensitivity))\n            self.F = max(0.4, self.F * (1 - self.mutation_sensitivity))\n\n        # Adjust mutation sensitivity based on diversity\n        self.mutation_sensitivity = 0.1 if diversity > 0.2 else 0.2\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09393 with standard deviation 0.01649.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.11375984249594528, 0.11383724160859066, 0.11382189702453971, 0.07342326366450436, 0.07343623176994163, 0.07344604998721671, 0.09452112046871453, 0.0945576753357994, 0.09455971163208288]}}
{"id": "14ccc5f3-52b8-405c-b683-151cc26d496a", "fitness": 0.09393572361278815, "name": "PSO_DE_Adaptive", "description": "Integrate adaptive parameter scaling and collaborative crossover to enhance exploration-exploitation balance in hybrid PSO-DE.", "code": "import numpy as np\n\nclass PSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._adaptive_update(diversity)\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _adaptive_update(self, diversity):\n        if self.best_fitness < self.prev_best_fitness:\n            scale = 1 + 0.1 * (1 - np.exp(-diversity))  # Emphasize diversity\n            self.w = max(0.4, self.w * 0.99 / scale)\n            self.F = min(0.9, self.F * 1.01 * scale)\n        else:\n            scale = 1 - 0.1 * diversity\n            self.w = min(0.9, self.w * 1.02 * scale)\n            self.F = max(0.4, self.F * 0.99 / scale)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 6, "feedback": "The algorithm PSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.11378923641304284, 0.11383848320818579, 0.11382095111291868, 0.07343375966032717, 0.07343667478741411, 0.07344572430258922, 0.09453910303294477, 0.09455843457441881, 0.09455914542325194]}}
{"id": "a2f23f2a-cf12-46eb-8697-681fa96814c8", "fitness": -Infinity, "name": "PSO_DE_Optimized", "description": "Improved diversity handling through adaptive particle count in PSO-DE algorithm.", "code": "import numpy as np\n\nclass PSO_DE_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Dynamic scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1 + self.eval_count / self.budget:  # Adjusted condition\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n        else:\n            self.w = min(0.9, self.w * 1.02)  # Slightly increased adjustment factor\n            self.F = max(0.4, self.F * 0.99)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 7, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {}}
{"id": "633536ec-460a-48d8-a88c-0214018ee6ce", "fitness": -Infinity, "name": "PSO_DE_Optimized", "description": "Introduced adaptive crossover probability (CR) for DE based on diversity to enhance convergence speed.", "code": "import numpy as np\n\nclass PSO_DE_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Dynamic scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n        else:\n            self.w = min(0.9, self.w * 1.02)  # Slightly increased adjustment factor\n            self.F = max(0.4, self.F * 0.99)\n        self.CR = np.clip(diversity * 10, 0.4, 0.9)  # Adaptive crossover probability\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 8, "feedback": "An exception occurred: NameError(\"name 'diversity' is not defined\").", "error": "NameError(\"name 'diversity' is not defined\")", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {}}
{"id": "9455939e-3114-4a29-a413-8aab5191bfad", "fitness": 0.09394651649222799, "name": "AdaptivePSO_DE", "description": "Introduce adaptive learning rates and nonlinear dynamic parameter adjustment for improved convergence in mixed-swarm metaheuristics.", "code": "import numpy as np\n\nclass AdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.learning_rate = 0.1  # New parameter for adaptive learning rate\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(func, bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Use nonlinear functions for dynamic parameter adjustment\n        improvement_ratio = (self.prev_best_fitness - self.best_fitness) / max(1.0, abs(self.prev_best_fitness))\n        lr_adjustment = np.tanh(self.learning_rate * improvement_ratio)\n        self.w = max(0.4, self.w * (1 - lr_adjustment))\n        self.F = min(0.9, self.F * (1 + lr_adjustment))\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, func, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 9, "feedback": "The algorithm AdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.11382761578812983, 0.11383724160859066, 0.1138331540308819, 0.07344746082961895, 0.07343623176994163, 0.07345008035228573, 0.09456257922965927, 0.0945576753357994, 0.0945666094851445]}}
{"id": "25712e8d-6a39-4d5a-91a2-aee5f01e5673", "fitness": 0.09394790796583624, "name": "PSO_DE_Optimized", "description": "Introduced a condition to dynamically increase the population size if diversity drops below a threshold to enhance exploration.", "code": "import numpy as np\n\nclass PSO_DE_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Dynamic scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n                if diversity < 0.05:  # New condition to increase population size\n                    self.population_size = min(100, self.population_size + 5)  # Increase population size\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n        else:\n            self.w = min(0.9, self.w * 1.02)  # Slightly increased adjustment factor\n            self.F = max(0.4, self.F * 0.99)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 10, "feedback": "The algorithm PSO_DE_Optimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.11382125270154553, 0.11383724160859066, 0.11384588589590583, 0.07344518955664114, 0.07343623176994163, 0.07345461794017738, 0.09455868732239436, 0.0945576753357994, 0.09457438956153019]}}
{"id": "b7d165fa-00ca-4a9c-9223-83ec097d7a6c", "fitness": 0.09394790796583624, "name": "PSO_DE_Optimized", "description": "Introduced different scaling factor and crossover probability update conditions for adaptive exploration and exploitation balance.", "code": "import numpy as np\n\nclass PSO_DE_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Dynamic scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.05)  # Changed scaling factor adjustment\n        else:\n            self.w = min(0.9, self.w * 1.02)\n            self.F = max(0.4, self.F * 0.97)  # Changed scaling factor adjustment\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 11, "feedback": "The algorithm PSO_DE_Optimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.11382125270154553, 0.11383724160859066, 0.11384588589590583, 0.07344518955664114, 0.07343623176994163, 0.07345461794017738, 0.09455868732239436, 0.0945576753357994, 0.09457438956153019]}}
{"id": "94f6ba91-b169-4216-93b6-07938facecc0", "fitness": 0.09394790796583624, "name": "PSO_DE_Optimized", "description": "Introduced adaptive CR based on improvement rate for better balance in DE crossover.", "code": "import numpy as np\n\nclass PSO_DE_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Dynamic scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n            self.CR = min(1.0, self.CR * 1.05)  # Adaptive CR based on improvement\n        else:\n            self.w = min(0.9, self.w * 1.02)  # Slightly increased adjustment factor\n            self.F = max(0.4, self.F * 0.99)\n            self.CR = max(0.4, self.CR * 0.95)  # Decrease CR if no improvement\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 12, "feedback": "The algorithm PSO_DE_Optimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.11382125270154553, 0.11383724160859066, 0.11384588589590583, 0.07344518955664114, 0.07343623176994163, 0.07345461794017738, 0.09455868732239436, 0.0945576753357994, 0.09457438956153019]}}
{"id": "133cd252-e36c-4d91-a222-d1dfb535dea2", "fitness": 0.09392273262895158, "name": "Hybrid_Adaptive_Optimization", "description": "Hybrid Metaheuristic with Adaptive Population Strategy and Dynamic Operator Selection to Enhance Convergence.", "code": "import numpy as np\n\nclass Hybrid_Adaptive_Optimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.init_w = 0.9  # Initial inertia weight for PSO\n        self.final_w = 0.4  # Final inertia weight for PSO\n        self.c1 = 2.0  # Cognitive coefficient for PSO\n        self.c2 = 2.0  # Social coefficient for PSO\n        self.F = 0.8  # Scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.dynamic_op_switch = False\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            # Evaluate fitness and update personal/global bests\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            # Evaluate diversity and adapt strategy\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters(diversity)\n\n            if self.dynamic_op_switch:\n                self._pso_update(bounds)\n            else:\n                self._de_update(func, bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self, diversity):\n        # Dynamic inertia weight for PSO based on evaluations\n        self.w = self.init_w - (self.init_w - self.final_w) * (self.eval_count / self.budget)\n        if self.best_fitness < self.prev_best_fitness * 0.999:\n            self.dynamic_op_switch = not self.dynamic_op_switch\n        # Adjust DE parameters based on diversity\n        if diversity < 0.1:\n            self.F = min(0.9, self.F * 1.02)\n            self.CR = min(0.9, self.CR * 1.02)\n        else:\n            self.F = max(0.4, self.F * 0.98)\n            self.CR = max(0.4, self.CR * 0.98)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, func, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 13, "feedback": "The algorithm Hybrid_Adaptive_Optimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09392 with standard deviation 0.01648.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.11378846344126448, 0.1137507868358143, 0.11383487149995763, 0.07344346555084547, 0.07341742236100213, 0.07345067846644615, 0.09453863296823861, 0.09451262796971005, 0.09456764456728539]}}
{"id": "b3a7f2dd-dad2-467f-9a16-aa97c5ffade1", "fitness": 0.09394082158319944, "name": "PSO_DE_Optimized", "description": "Introduced an adaptive adjustment factor for the DE scaling factor to enhance convergence speed.", "code": "import numpy as np\n\nclass PSO_DE_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Dynamic scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * (1.01 + 0.01 * np.random.rand()))  # Modified line\n        else:\n            self.w = min(0.9, self.w * 1.02)  # Slightly increased adjustment factor\n            self.F = max(0.4, self.F * 0.99)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 14, "feedback": "The algorithm PSO_DE_Optimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.11380639138671989, 0.11383448205446367, 0.11383112826671482, 0.07343988522860345, 0.073435238033001, 0.07344934011973558, 0.0945495979311789, 0.09455597846426311, 0.0945653527641146]}}
{"id": "c40bd42e-9183-4669-b1e3-3b85589136c8", "fitness": -Infinity, "name": "AdaptivePSO_DE", "description": "Adaptive hybrid PSO-DE algorithm with strategic leader selection to enhance convergence and robustness.", "code": "import numpy as np\n\nclass AdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.leader_index = 0  # Index to switch leaders\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            self._dynamic_update_parameters()\n            self._switch_leader_strategy()\n\n            self._pso_update(bounds)\n            self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Adjust PSO inertia weight and DE scaling factor based on fitness improvement\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n        else:\n            self.w = min(0.9, self.w * 1.02)\n            self.F = max(0.4, self.F * 0.99)\n        self.prev_best_fitness = self.best_fitness\n\n    def _switch_leader_strategy(self):\n        # Use leader switching to avoid premature convergence\n        if self.eval_count % (self.budget // 10) == 0:\n            self.leader_index = (self.leader_index + 1) % self.population_size\n            self.global_best = self.particles[self.leader_index]\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 15, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {}}
{"id": "6d79d13a-defb-4fd8-9b77-3ea4914d6397", "fitness": -Infinity, "name": "PSO_DE_Optimized", "description": "Incorporate adaptive learning rates in PSO velocity update to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass PSO_DE_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Dynamic scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n        else:\n            self.w = min(0.9, self.w * 1.02)  # Slightly increased adjustment factor\n            self.F = max(0.4, self.F * 0.99)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        lr = 0.5  # New adaptive learning rate\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (lr * self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 16, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {}}
{"id": "8de6179d-1648-4d45-a4a3-b6627c4a46d6", "fitness": 0.09394726411332949, "name": "PSO_DE_Adaptive", "description": "Adaptive blend of PSO and DE with a focus on maintaining diversity through random reinitialization when stuck in local optima.", "code": "import numpy as np\n\nclass PSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.stagnation_counter = 0\n        self.stagnation_limit = 10  # Number of iterations to detect stagnation\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                fitness_value = func(self.particles[i])\n                self.eval_count += 1\n\n                if fitness_value < self.fitness[i]:\n                    self.fitness[i] = fitness_value\n                    self.personal_best[i] = self.particles[i]\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = self.particles[i]\n                    self.stagnation_counter = 0\n                else:\n                    self.stagnation_counter += 1\n\n            diversity = np.mean(np.std(self.particles, axis=0))\n            self._dynamic_update_parameters()\n\n            if self.stagnation_counter > self.stagnation_limit:\n                self._reinitialize_population(bounds)\n                self.stagnation_counter = 0\n\n            if diversity > 0.1:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _dynamic_update_parameters(self):\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.99)\n            self.F = min(0.9, self.F * 1.01)\n        else:\n            self.w = min(0.9, self.w * 1.02)\n            self.F = max(0.4, self.F * 0.99)\n        self.prev_best_fitness = self.best_fitness\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _reinitialize_population(self, bounds):\n        # Reinitialize a portion of the population to escape local optima\n        num_reinit = int(self.population_size * 0.2)\n        reinit_indices = np.random.choice(self.population_size, num_reinit, replace=False)\n        self.particles[reinit_indices] = np.random.uniform(bounds[0], bounds[1], (num_reinit, self.dim))\n        self.velocities[reinit_indices] = np.zeros((num_reinit, self.dim))", "configspace": "", "generation": 17, "feedback": "The algorithm PSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.113828405878584, 0.11383329061715741, 0.11383976047064015, 0.07344774257800035, 0.07343481963401488, 0.07345241390257828, 0.09456306219916188, 0.09455525684397947, 0.094570624895849]}}
{"id": "8bd77f55-f0fa-43f3-9f30-c242825d19a9", "fitness": 0.09394894445929147, "name": "Adaptive_Hybrid_PSO_DE", "description": "Utilizes an adaptive hybrid PSO-DE approach with diversity-driven parameter tuning and a novel exploration-exploitation dynamic.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.97)\n            self.F = min(0.9, self.F * 1.03)\n        else:\n            self.w = min(0.9, self.w * 1.03)\n            self.F = max(0.4, self.F * 0.97)\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 18, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["0c7b3f61-14d2-4ac7-aa68-1c6dc0dc560f"], "operator": null, "metadata": {"aucs": [0.11382814494160409, 0.11383724160859066, 0.11384372161985068, 0.07344764990624164, 0.07343623176994163, 0.07345385556725448, 0.09456290308523818, 0.0945576753357994, 0.0945730762991025]}}
{"id": "27bbeb45-7bd6-4d1b-ad2b-b0f878c0337b", "fitness": 0.0939349993254341, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "This algorithm enhances the adaptive hybrid PSO-DE with a multi-phase exploration-exploitation mechanism and adaptive learning rates for improved convergence.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.adaptive_lr = 0.01  # Initial learning rate for parameter adaptation\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w - self.adaptive_lr)\n            self.F = min(0.9, self.F + self.adaptive_lr)\n            self.adaptive_lr *= 0.99  # Gradually reduce the learning rate\n        else:\n            self.w = min(0.9, self.w + self.adaptive_lr)\n            self.F = max(0.4, self.F - self.adaptive_lr)\n            self.adaptive_lr *= 1.01  # Slightly increase the learning rate\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 19, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09393 with standard deviation 0.01649.", "error": "", "parent_ids": ["8bd77f55-f0fa-43f3-9f30-c242825d19a9"], "operator": null, "metadata": {"aucs": [0.11379209277317981, 0.11383724160859066, 0.11381602801335267, 0.07343477779443175, 0.07343623176994163, 0.07344396541377951, 0.09454084861284007, 0.0945576753357994, 0.09455613260699147]}}
{"id": "05e95d33-29b3-4989-979c-0f87f77c7a22", "fitness": -Infinity, "name": "Adaptive_Hybrid_PSO_DE", "description": "Improved the diversity threshold for dynamic exploration-exploitation balance in Adaptive Hybrid PSO-DE.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.2  # Adjusted diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.97)\n            self.F = min(0.9, self.F * 1.03)\n        else:\n            self.w = min(0.9, self.w * 1.03)\n            self.F = max(0.4, self.F * 0.97)\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 20, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8bd77f55-f0fa-43f3-9f30-c242825d19a9"], "operator": null, "metadata": {}}
{"id": "e022e4e3-9fa2-4187-9167-2635fef9ff9f", "fitness": 0.09394894445929147, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduces a self-adaptive mechanism for dynamically adjusting DE crossover probability (CR) based on population diversity.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight, DE scaling factor, and DE crossover probability\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.97)\n            self.F = min(0.9, self.F * 1.03)\n            self.CR = min(0.9, self.CR * (1 + 0.1 * diversity))  # Line changed\n        else:\n            self.w = min(0.9, self.w * 1.03)\n            self.F = max(0.4, self.F * 0.97)\n            self.CR = max(0.1, self.CR * (1 - 0.1 * diversity))  # Line changed\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 21, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["8bd77f55-f0fa-43f3-9f30-c242825d19a9"], "operator": null, "metadata": {"aucs": [0.11382814494160409, 0.11383724160859066, 0.11384372161985068, 0.07344764990624164, 0.07343623176994163, 0.07345385556725448, 0.09456290308523818, 0.0945576753357994, 0.0945730762991025]}}
{"id": "90937428-61f8-499c-b8b6-d3c0eae25502", "fitness": 0.09394894445929147, "name": "Adaptive_Cluster_Hybrid_PSO_DE", "description": "Introduces an adaptive synergy between PSO and DE using population clustering for improved exploitation and exploration balance.", "code": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass Adaptive_Cluster_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.num_clusters = 5\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            diversity = self._calculate_diversity()\n            if diversity > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n            if diversity < self.div_threshold * 1.5:\n                self._cluster_particles()\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.97)\n            self.F = min(0.9, self.F * 1.03)\n        else:\n            self.w = min(0.9, self.w * 1.03)\n            self.F = max(0.4, self.F * 0.97)\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _cluster_particles(self):\n        kmeans = KMeans(n_clusters=self.num_clusters, random_state=42).fit(self.particles)\n        cluster_centers = kmeans.cluster_centers_\n\n        for i, center in enumerate(cluster_centers):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(center)\n            self.eval_count += 1\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = center", "configspace": "", "generation": 22, "feedback": "The algorithm Adaptive_Cluster_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["8bd77f55-f0fa-43f3-9f30-c242825d19a9"], "operator": null, "metadata": {"aucs": [0.11382814494160409, 0.11383724160859066, 0.11384372161985068, 0.07344764990624164, 0.07343623176994163, 0.07345385556725448, 0.09456290308523818, 0.0945576753357994, 0.0945730762991025]}}
{"id": "17f1e43b-bfb5-406e-be0d-a7290024c11c", "fitness": 0.09394894445929147, "name": "Enhanced_Hybrid_PSO_DE", "description": "Introduces a multi-phase dynamic strategy combining adaptive weighting, self-adaptive mutation, and diversity-guided hybridization to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.phase_switch = 0.5  # Phase switching factor\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            # Multi-phase strategy to balance exploration and exploitation\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamic update with phase switching\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * 0.97)\n            self.F = min(0.9, self.F * 1.03)\n        else:\n            self.w = min(0.9, self.w * 1.03)\n            self.F = max(0.4, self.F * 0.97)\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 23, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["8bd77f55-f0fa-43f3-9f30-c242825d19a9"], "operator": null, "metadata": {"aucs": [0.11382814494160409, 0.11383724160859066, 0.11384372161985068, 0.07344764990624164, 0.07343623176994163, 0.07345385556725448, 0.09456290308523818, 0.0945576753357994, 0.0945730762991025]}}
{"id": "869cd657-d612-462e-8a59-28099552bcdd", "fitness": 0.09395035091748588, "name": "Adaptive_Hybrid_PSO_DE", "description": "Incorporates a stochastic inertia weight adjustment in PSO and mutation factor adaptation in DE to enhance convergence and exploration.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))  # Stochastic adjustment\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))  # Adaptive mutation factor\n        else:\n            self.w = min(0.9, self.w * 1.03)\n            self.F = max(0.4, self.F * 0.97)\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 24, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["8bd77f55-f0fa-43f3-9f30-c242825d19a9"], "operator": null, "metadata": {"aucs": [0.11382298182918671, 0.11383582865665842, 0.11385671778259199, 0.0734458054148106, 0.07343572986116731, 0.07345850324443859, 0.09455974353083685, 0.09455681363925972, 0.09458103429842268]}}
{"id": "ae0032fc-de1e-4954-ba24-6081fa137ca9", "fitness": 0.09393618132754217, "name": "Adaptive_Hybrid_PSO_DE", "description": "Integrates an adaptive crossover probability in DE to further balance exploration and exploitation.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))  # Stochastic adjustment\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))  # Adaptive mutation factor\n            self.CR = min(0.9, self.CR * (1.02 + 0.02 * np.random.rand()))  # Adaptive crossover probability\n        else:\n            self.w = min(0.9, self.w * 1.03)\n            self.F = max(0.4, self.F * 0.97)\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 25, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["869cd657-d612-462e-8a59-28099552bcdd"], "operator": null, "metadata": {"aucs": [0.11381742987911658, 0.11382780800283854, 0.11380554485993055, 0.0734438242194515, 0.0734328558609012, 0.07344021373295495, 0.0945563483110049, 0.09455189645886553, 0.09454971062281581]}}
{"id": "4de72628-8744-4383-bd4d-895a92928c01", "fitness": 0.0939508979665516, "name": "Adaptive_Hybrid_PSO_DE", "description": "Enhances balance between exploration and exploitation by introducing adaptive learning rates and dynamic diversity control.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 26, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["869cd657-d612-462e-8a59-28099552bcdd"], "operator": null, "metadata": {"aucs": [0.11382298182918671, 0.11383832965332275, 0.11385671778259199, 0.0734458054148106, 0.07343662259008454, 0.07345850324443859, 0.09455974353083685, 0.09455834335526969, 0.09458103429842268]}}
{"id": "9572106a-e316-4c5d-b077-43105f0a1e72", "fitness": 0.09393809500030655, "name": "Enhanced_Env_Adaptive_Hybrid_PSO_DE", "description": "Enhance exploration-exploitation balance with environment-adaptive parameter tuning and dynamic swarm intelligence strategies.", "code": "import numpy as np\n\nclass Enhanced_Env_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.adaptive_c1_c2 = True  # Enable adaptive PSO coefficients\n        self.learning_factor = 0.1  # Learning factor for dynamic adjustment\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        improvement = self.best_fitness < self.prev_best_fitness\n\n        # Adaptive adjustment of PSO parameters: w, c1, c2\n        if improvement:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            if self.adaptive_c1_c2:\n                self.c1 = max(1.0, self.c1 * (1.05 - 0.05 * diversity))\n                self.c2 = max(1.0, self.c2 * (1.05 - 0.05 * diversity))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            if self.adaptive_c1_c2:\n                self.c1 = min(2.0, self.c1 * (0.95 + 0.05 * diversity))\n                self.c2 = min(2.0, self.c2 * (0.95 + 0.05 * diversity))\n\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 27, "feedback": "The algorithm Enhanced_Env_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11381528173389832, 0.11382060714711228, 0.11382369961955185, 0.07344305889193481, 0.07343027767472021, 0.07344664537264267, 0.09455503591535008, 0.09454748399865265, 0.09456076464889607]}}
{"id": "df14e333-2164-45b8-aeb4-049e66bd6f69", "fitness": -Infinity, "name": "Refined_Adaptive_Hybrid_PSO_DE", "description": "Enhances exploration-exploitation balance by integrating adaptive velocity control, parameter control with sigmoid scaling, and niche-based diversity preservation.", "code": "import numpy as np\n\nclass Refined_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Introduce sigmoid scaling for updating PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        progress = 1 - (self.best_fitness / self.prev_best_fitness if self.prev_best_fitness != np.inf else 0)\n        sigmoid = lambda x: 1 / (1 + np.exp(-10 * (x - 0.5)))\n\n        self.w = 0.4 + 0.5 * sigmoid(progress + diversity)\n        self.F = 0.4 + 0.5 * sigmoid(progress - diversity)\n\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 28, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {}}
{"id": "0035e1fc-6216-46b8-a937-64749e5e1491", "fitness": 0.09395077767063773, "name": "Enhanced_Hybrid_PSO_DE", "description": "Introduces an adaptive swarm-size strategy and enhanced mutation to improve convergence and performance in dynamic landscapes.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n            self._adjust_population_size()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            # Enhanced mutation using adaptive factor\n            adaptive_F = self.F * (1 + 0.1 * (self.best_fitness / (self.fitness[i] + 1e-12)))\n            mutant_vector = x0 + adaptive_F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _adjust_population_size(self):\n        # Decrease population size if convergence stagnates\n        if self.eval_count / self.budget > 0.5 and self.best_fitness >= self.prev_best_fitness:\n            self.population_size = max(10, self.population_size - 1)\n            self.particles = self.particles[:self.population_size]\n            self.velocities = self.velocities[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n            self.personal_best = self.personal_best[:self.population_size]", "configspace": "", "generation": 29, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11382182175425526, 0.11383893966208025, 0.11385671778259199, 0.07344539151592044, 0.07343684023789465, 0.07345850324443859, 0.09455903417524181, 0.09455871636489388, 0.09458103429842268]}}
{"id": "452306d7-2dd7-489a-a61e-7c55e2b38bb5", "fitness": 0.09394405694641123, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduces adaptive population size and mutation strategies to balance exploration and exploitation efficiently.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.max_population_size = 100\n        self.min_population_size = 20\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n            self._adaptive_population_size()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _adaptive_population_size(self):\n        # Adjust population size based on convergence speed\n        if self.best_fitness < self.prev_best_fitness:\n            self.population_size = max(self.min_population_size, int(self.population_size * 0.95))\n        else:\n            self.population_size = min(self.max_population_size, int(self.population_size * 1.05))\n        if self.population_size != len(self.particles):\n            self.particles = np.resize(self.particles, (self.population_size, self.dim))\n            self.velocities = np.resize(self.velocities, (self.population_size, self.dim))\n            self.fitness = np.resize(self.fitness, self.population_size)\n            self.personal_best = np.resize(self.personal_best, (self.population_size, self.dim))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 30, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11381333836902496, 0.11382936302106694, 0.11384404698926454, 0.07344236627622092, 0.07343342268913489, 0.07345398156601046, 0.0945538483746875, 0.09455285973857064, 0.09457328549372024]}}
{"id": "4168e0fd-5a78-4fe1-80ce-f3bc25586980", "fitness": 0.09392532661299542, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Introduces perturbation-based diversity enhancement and adaptive learning rates to improve convergence stability and solution robustness.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.perturbation_strength = 0.05\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._adaptive_learning()\n            self._apply_perturbation(bounds)\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _adaptive_learning(self):\n        improvement = self.prev_best_fitness - self.best_fitness\n        if improvement > 0:\n            self.w = max(0.4, self.w - 0.05 * improvement)\n            self.F = min(0.9, self.F + 0.05 * improvement)\n        else:\n            self.w = min(0.9, self.w + 0.02)\n            self.F = max(0.4, self.F - 0.02)\n        self.CR = 0.5 + 0.1 * np.random.rand()\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _apply_perturbation(self, bounds):\n        for i in range(self.population_size):\n            perturbation = self.perturbation_strength * np.random.randn(self.dim)\n            self.particles[i] += perturbation\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 31, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09393 with standard deviation 0.01649.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11378127563268614, 0.11379970808735018, 0.11382018471235511, 0.07343091779796385, 0.07342281724619526, 0.07344543811748716, 0.09453423360377256, 0.0945347007031232, 0.09455866361602538]}}
{"id": "e6139d7c-00f7-4cab-b10f-386fb0d52311", "fitness": 0.0939358242312757, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce a dynamic crossover probability in DE update to enhance adaptability to problem landscapes.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        # Dynamic crossover probability for DE\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = max(0.5, self.CR * (1.05 + 0.05 * np.random.rand()))  # Adjust CR\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = min(0.9, self.CR * (0.95 - 0.05 * np.random.rand()))  # Adjust CR\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 32, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11381991644005063, 0.11379856603659688, 0.11383066829002919, 0.07344471460261193, 0.07342241065629751, 0.07344918544206502, 0.09455787210128075, 0.0945340032767289, 0.09456508123582041]}}
{"id": "c8a1a567-e5c4-4279-9e4b-e5f96948e604", "fitness": -Infinity, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Introduce a learning component to adaptively adjust control parameters based on past performance and current diversity for enhancing exploration and exploitation balance.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.learning_rate = 0.1  # New learning rate for parameter adjustment\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._adaptive_parameter_update()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _adaptive_parameter_update(self):\n        diversity = self._calculate_diversity()\n        improvement = self.prev_best_fitness - self.best_fitness\n\n        # Adaptive update using learning component\n        self.w = max(0.4, self.w + self.learning_rate * (improvement - diversity))\n        self.F = max(0.4, self.F + self.learning_rate * (diversity - improvement))\n\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 33, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {}}
{"id": "b385a910-bdc3-40c1-955c-c65594bf6965", "fitness": 0.0939358242312757, "name": "Enhanced_Adaptive_PSO_DE", "description": "Integrates adaptive inertia weight with a self-adaptive crossover strategy to improve convergence speed and robustness.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertial weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(0.9, self.CR * (1 + 0.05 * np.random.rand()))  # Adaptive CR\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.1, self.CR * (0.9 - 0.05 * np.random.rand()))  # Adaptive CR\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 34, "feedback": "The algorithm Enhanced_Adaptive_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11381991644005063, 0.11379856603659688, 0.11383066829002919, 0.07344471460261193, 0.07342241065629751, 0.07344918544206502, 0.09455787210128075, 0.0945340032767289, 0.09456508123582041]}}
{"id": "ac51a9de-dd39-4048-98b8-01846d3930e6", "fitness": 0.09392901928427745, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Integrates adaptive particle velocities and elite mutation strategies to enhance convergence and exploration balance.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 2.0  # Cognitive coefficient for PSO (slightly increased for better exploration)\n        self.c2 = 2.0  # Social coefficient for PSO (slightly increased for better exploration)\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            # Adaptive velocity clamping\n            vel_max = 0.1 * (bounds[1] - bounds[0])\n            self.velocities[i] = np.clip(self.velocities[i], -vel_max, vel_max)\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 4, replace=False)\n            x0, x1, x2, x3 = self.particles[indices]\n\n            # Elite mutation strategy\n            mutant_vector = x0 + self.F * (x1 - x2) + 0.5 * (self.global_best - x3)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 35, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09393 with standard deviation 0.01649.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11376500867184192, 0.11379585289685767, 0.11385716106885979, 0.07342510384734857, 0.07342144517596161, 0.0734586672834937, 0.09452427630966465, 0.09453234687568135, 0.09458131142878778]}}
{"id": "97f1022e-bd89-4bc1-9b72-05832b2712c4", "fitness": 0.0939508979665516, "name": "Adaptive_Hybrid_PSO_DE", "description": "Incorporate adaptive crossover probability adjustment to enhance diversity and convergence rate.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n        self.CR = max(0.5, 0.9 - diversity)  # Adaptive crossover probability\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 36, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11382298182918671, 0.11383832965332275, 0.11385671778259199, 0.0734458054148106, 0.07343662259008454, 0.07345850324443859, 0.09455974353083685, 0.09455834335526969, 0.09458103429842268]}}
{"id": "2652ff79-e868-4d90-bbab-f0be14e4748a", "fitness": 0.09394045644940907, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Enhances balance between exploration and exploitation by introducing adaptive learning rates, dynamic diversity control, and a hybrid mutation strategy.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            # Add stochastic perturbation to enhance exploration\n            self.particles += np.random.normal(0, 0.01, self.particles.shape)\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 5, replace=False)\n            x0, x1, x2, x3, x4 = self.particles[indices]\n\n            # Hybrid mutation: mix DE/rand/1 with DE/best/2 strategy\n            mutant_vector = x0 + self.F * (x1 - x2) + self.F * (x3 - x4)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 37, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11379958917585609, 0.11383917369149488, 0.11383156497295688, 0.07343745807366775, 0.0734369230493056, 0.07344948916797489, 0.09454543832941742, 0.09455885875784309, 0.09456561282616505]}}
{"id": "a300113e-55eb-4363-a5d1-177498155afa", "fitness": 0.09395738803036256, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive population size to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 38, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["4de72628-8744-4383-bd4d-895a92928c01"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "2b7dd128-69ae-4a6b-b530-d877835ca712", "fitness": -Infinity, "name": "Enhanced_Hybrid_PSO_DE", "description": "Introduce adaptive learning strategies for PSO and DE to enhance convergence in dynamic landscapes.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.dynamic_c1 = lambda f: 2.5 - 2.0 * f  # Adaptive cognitive factor\n        self.dynamic_c2 = lambda f: 0.5 + 2.0 * f  # Adaptive social factor\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        progress = 1.0 - self.best_fitness / self.prev_best_fitness if self.prev_best_fitness != np.inf else 0\n        self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n        self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        self.c1 = self.dynamic_c1(progress)\n        self.c2 = self.dynamic_c2(progress)\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 39, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {}}
{"id": "a3459350-1cab-4ab0-aa71-7bb1c78b7372", "fitness": 0.09395738803036256, "name": "Adaptive_Hybrid_PSO_DE", "description": "Improve balance between exploration and exploitation by introducing adaptive mutation in DE strategy.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n            adaptive_F = self.F + 0.1 * np.random.randn()  # Changed line for adaptive mutation\n            mutant_vector = x0 + adaptive_F * (x1 - x2)  # Changed line to use adaptive_F\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 40, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "e356a942-95e5-40a5-bd2d-64f0d8c13fc8", "fitness": 0.09393779226570494, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive learning rates and a chaos-based mutation operator to enhance exploration and convergence efficiency.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.learning_rate = np.random.rand(self.population_size, self.dim)\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.learning_rate += 0.01 * (1 - diversity)  # Adaptive learning rate\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.learning_rate -= 0.01 * diversity\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.learning_rate[i] * self.velocities[i]  # Use adaptive learning rate\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            mutant_vector = self._chaos_mutation(mutant_vector, bounds)  # Apply chaos-based mutation\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _chaos_mutation(self, vector, bounds):\n        # Simple chaos-based mutation using logistic map\n        logistic_map = 4.0 * np.random.rand(self.dim) * (1 - np.random.rand(self.dim))\n        chaos_vector = vector + logistic_map * (bounds[1] - bounds[0]) * 0.01\n        return np.clip(chaos_vector, *bounds)", "configspace": "", "generation": 41, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11377607812346668, 0.11381454266759816, 0.11386742799074334, 0.07342911115958617, 0.0734281269817213, 0.07346234530758844, 0.09453110418177668, 0.09454378919677098, 0.09458760478209272]}}
{"id": "1232b1ac-5d1b-411f-b0bc-59975a0e5042", "fitness": 0.09392398482120264, "name": "Adaptive_Hybrid_PSO_DE", "description": "Integrate dynamic crossover rate adjustment and enhanced diversity measure for improved convergence.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(0.9, self.CR + 0.05 * np.random.rand())  # Dynamic CR adjustment\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.5, self.CR - 0.05 * (1 - diversity))  # Dynamic CR adjustment\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.linalg.norm(self.particles - self.global_best, axis=1))  # Enhanced diversity measure\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 42, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09392 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11377268575521804, 0.11380314486999121, 0.11381916603681053, 0.07342791641050261, 0.07342403630315397, 0.07344505391906364, 0.09452904593870015, 0.09453679482510435, 0.09455801933227925]}}
{"id": "34d3fc99-a3f5-48d5-b725-53097eae3ddf", "fitness": 0.09393571146895241, "name": "Adaptive_Enhanced_PSO_DE", "description": "Introduce a diversity-preserving mechanism and adaptive learning coefficients to enhance exploration and exploitation trade-offs.", "code": "import numpy as np\n\nclass Adaptive_Enhanced_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 80))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            diversity = self._calculate_diversity()\n            if diversity > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n                if diversity < self.div_threshold / 2:  # Add diversity-preservation mechanism\n                    self._jitter_particles(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.3, self.w * (0.93 + 0.07 * np.random.rand()))\n            self.F = min(0.95, self.F * (1.05 + 0.02 * np.random.rand()))\n            self.c1 = max(1.0, self.c1 * 0.9)  # Adaptive cognitive component\n            self.c2 = min(2.5, self.c2 * 1.1)  # Adaptive social component\n        else:\n            self.w = min(0.9, self.w * (1.05 - 0.05 * diversity))\n            self.F = max(0.5, self.F * (0.95 + 0.05 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _jitter_particles(self, bounds):\n        jitter = np.random.normal(0, 0.1, self.particles.shape)\n        self.particles += jitter\n        self.particles = np.clip(self.particles, *bounds)", "configspace": "", "generation": 43, "feedback": "The algorithm Adaptive_Enhanced_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11382428542832856, 0.11379901431112949, 0.11382530503463784, 0.07344627850523122, 0.07342258432813265, 0.07344728261340772, 0.09456054862540964, 0.0945342915775016, 0.09456181279679299]}}
{"id": "9c562777-2dfa-4d31-a2de-e5deade9398a", "fitness": 0.09394484566809605, "name": "Adaptive_Hybrid_PSO_DE", "description": "Enhance adaptive mechanisms by refining inertia weight and scaling factor adjustments for improved convergence.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  \n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  \n        self.c1 = 1.5  \n        self.c2 = 1.5  \n        self.F = 0.8  \n        self.CR = 0.7  \n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  \n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.92 + 0.1 * np.random.rand()))  # Adjusted inertia weight update\n            self.F = min(0.9, self.F * (1.05 + 0.02 * np.random.rand()))  # Adjusted scaling factor update\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.02 * diversity))  # Adjusted inertia weight update\n            self.F = max(0.4, self.F * (0.95 + 0.03 * (1 - diversity)))  # Adjusted scaling factor update\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 44, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11383841152056018, 0.1137931089652785, 0.11385876482722135, 0.07345137371563193, 0.07342046485261156, 0.07345926147856763, 0.09456924322573268, 0.09453066765589069, 0.09458231477136991]}}
{"id": "e7a5362b-67d6-4a17-8b4f-a2bbe7e2b8b0", "fitness": 0.09393974970746768, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive crossover probability for differential evolution within a hybrid PSO-DE framework to enhance convergence.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight, DE scaling factor, and DE crossover probability\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(0.9, self.CR * (1.02 + 0.02 * np.random.rand()))  # Added line for adaptive crossover\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.5, self.CR * (0.98 - 0.02 * diversity))  # Added line for adaptive crossover\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 45, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380326828313225, 0.11381713484907197, 0.11384661207414493, 0.07343883943885132, 0.07342903417506419, 0.07345489354032797, 0.09454775836068996, 0.0945453559916789, 0.09457485065424764]}}
{"id": "1438a590-631e-42f7-92dc-910b6a60d216", "fitness": 0.09394005005546896, "name": "Adaptive_Hybrid_PSO_DE_Improved", "description": "Enhance the exploration and exploitation balance by dynamically adjusting the DE crossover probability and PSO coefficient based on diversity and convergence trends.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(0.9, self.CR + 0.05 * np.random.rand())\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.5, self.CR * (0.95 - 0.05 * np.random.rand()))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 46, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11382691878402817, 0.11382174417243296, 0.11381973784872546, 0.07344728087303587, 0.07343069324719687, 0.07344527554081015, 0.09456222340187725, 0.09454818948863564, 0.09455838714247833]}}
{"id": "835d275a-cba4-4f0b-8abf-c59a24d70ac2", "fitness": 0.09394348966464618, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce a feedback mechanism to dynamically adjust the diversity threshold, improving the balance between exploration and exploitation.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n            self.div_threshold = max(0.05, min(0.2, self.div_threshold * (1 + 0.1 * np.random.rand())))\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 47, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11382327408472936, 0.11383514078768597, 0.11382565338151263, 0.07344597115998996, 0.07343548635458785, 0.07344744047547602, 0.09455998529233922, 0.0945563950053313, 0.09456206044016324]}}
{"id": "52ae421e-e9bc-4d47-8ee6-119b22fb91c6", "fitness": 0.09393361451518405, "name": "Refined_Adaptive_Hybrid_PSO_DE", "description": "Enhance exploration by employing a chaotic sequence for parameter control and integrating a local search strategy for fine-tuning.", "code": "import numpy as np\n\nclass Refined_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.chaotic_sequence = self._init_chaotic_sequence()\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n                self._local_search(bounds, func)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        chaotic_value = self.chaotic_sequence[self.eval_count % len(self.chaotic_sequence)]\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * chaotic_value))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * chaotic_value))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _local_search(self, bounds, func):\n        for i in range(self.population_size):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            candidate = self.particles[i] + perturbation\n            candidate = np.clip(candidate, *bounds)\n            if self.eval_count < self.budget:\n                candidate_fitness = func(candidate)\n                self.eval_count += 1\n                if candidate_fitness < self.fitness[i]:\n                    self.particles[i] = candidate\n                    self.fitness[i] = candidate_fitness\n                    if candidate_fitness < self.best_fitness:\n                        self.best_fitness = candidate_fitness\n                        self.global_best = candidate\n\n    def _init_chaotic_sequence(self):\n        chaotic_sequence = []\n        x = 0.7\n        for _ in range(1000):\n            x = 4 * x * (1 - x)  # logistic map\n            chaotic_sequence.append(x)\n        return chaotic_sequence", "configspace": "", "generation": 48, "feedback": "The algorithm Refined_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09393 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11377645130569969, 0.11382856268755381, 0.11383419051828092, 0.07342901123329637, 0.07343313623715242, 0.07345046122024179, 0.09453109331128051, 0.09455236942006728, 0.09456725470308358]}}
{"id": "ba102087-5ed6-4a48-9722-2cbf1877633a", "fitness": 0.0939548289675912, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce diversity-driven adaptive parameters and local search intensification to refine convergence.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.local_search_probability = 0.2\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n            if np.random.rand() < self.local_search_probability:\n                self._local_search(bounds, func)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _local_search(self, bounds, func):\n        # Intensify search around the current best solution with Gaussian perturbation\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            candidate = np.clip(self.global_best + perturbation, *bounds)\n            candidate_fitness = func(candidate)\n            self.eval_count += 1\n\n            if candidate_fitness < self.best_fitness:\n                self.best_fitness = candidate_fitness\n                self.global_best = candidate", "configspace": "", "generation": 49, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384010483605977, 0.11383844867650761, 0.1138573561590539, 0.07345197905399037, 0.07343666573537833, 0.07345875753128583, 0.09457027987194377, 0.09455841683626953, 0.09458145200783175]}}
{"id": "f65a3af7-0376-432a-b09a-a24a4095c8f7", "fitness": 0.0939464921532798, "name": "Adaptive_Hybrid_PSO_DE", "description": "Enhance parameter adaptation and diversity control by introducing mutation strategies and adaptive coefficients for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 2.0  # Adjusted for improved convergence\n        self.c2 = 2.0  # Adjusted for improved convergence\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(0.8, self.CR * 1.05)  # Adaptive crossover probability\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.5, self.CR * 0.95)  # Adaptive crossover probability\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            # Introduce additional mutation strategy\n            mutant_vector = x0 + self.F * (x1 - x2) + self.F * (np.mean(self.particles, axis=0) - x0)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 50, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.1138184825450953, 0.1138422516570019, 0.11383716144620326, 0.07344417919048218, 0.07343802594140791, 0.07345153073739608, 0.09455697095425175, 0.09456074572958473, 0.09456908117809504]}}
{"id": "a80143ff-7c32-4a42-af7c-edb8a058d7a2", "fitness": 0.09395738803036256, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Enhance convergence by integrating adaptive selection pressure and convergence zones to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.convergence_zone = 0.05  # Convergence zone to switch strategies\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self, bounds):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n        if self._calculate_convergence() < self.convergence_zone:\n            self._selective_pressure_update(bounds)\n        else:\n            if diversity > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _calculate_convergence(self):\n        return np.mean(np.abs(self.global_best - self.particles))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _selective_pressure_update(self, bounds):\n        # Introduce selective pressure by emphasizing exploration or exploitation based on the convergence\n        for i in range(self.population_size):\n            pressure_factor = 1 + np.random.rand() * (1 - self._calculate_convergence())\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] * pressure_factor +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)", "configspace": "", "generation": 51, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "8c5756f0-3875-4267-b464-f774a2cb235d", "fitness": 0.09394457486741109, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce differential evolution mutation strategies and adaptive inertia weight to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_crossover_mutation(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        self.w = (0.5 + 0.4 * np.random.rand())  # Adaptive inertia weight\n        if self.best_fitness < self.prev_best_fitness:\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_crossover_mutation(self, bounds):\n        indices = np.random.choice(self.population_size, 3 * self.population_size, replace=True).reshape(-1, 3)\n        for i, (a, b, c) in enumerate(indices):\n            if self.eval_count >= self.budget:\n                break\n            mutant_vector = self.particles[a] + self.F * (self.particles[b] - self.particles[c])\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n            trial_fitness = func(trial_vector)\n            self.eval_count += 1\n\n            if trial_fitness < self.fitness[i]:\n                self.particles[i] = trial_vector\n                self.fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.global_best = trial_vector", "configspace": "", "generation": 52, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384120564179145, 0.11379519750729095, 0.11385264695590869, 0.07345237135103277, 0.07342121392657464, 0.07345707111716859, 0.094570952514755, 0.09453194878910809, 0.09457856600306958]}}
{"id": "a50184f1-5174-44f0-a938-9eedb6bdfe33", "fitness": 0.09394351920166882, "name": "Refined_Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive velocity and mutation strategies to enhance convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass Refined_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._adaptive_parameter_adjustment()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._adaptive_pso_update(bounds)\n            else:\n                self._adaptive_de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _adaptive_parameter_adjustment(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.05 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.01 * np.random.rand()))\n            self.CR = min(0.9, self.CR * (1.02 + 0.01 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.5, self.CR * (0.98 + 0.02 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _adaptive_pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            adaptive_velocity = self.w * self.velocities[i] + self.c1 * r1 * (self.personal_best[i] - self.particles[i]) + self.c2 * r2 * (self.global_best - self.particles[i])\n            self.velocities[i] = adaptive_velocity\n            self.particles[i] += adaptive_velocity\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _adaptive_de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 53, "feedback": "The algorithm Refined_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.1138427515247844, 0.11380626010894279, 0.11383524440200976, 0.07345293353056315, 0.07342515566406294, 0.07345082483507293, 0.09457190859085685, 0.09453870786678176, 0.09456788629194479]}}
{"id": "764d4ab4-8f32-4c1a-a443-95eb2902da92", "fitness": 0.09393790432552879, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive learning coefficients for cognitive and social components, and incorporate a restart mechanism when stagnation occurs, to enhance exploration and exploitation balance in adaptive hybrid PSO-DE.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 2.0  # Initial cognitive coefficient for PSO\n        self.c2 = 2.0  # Initial social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.stagnation_count = 0  # Counter for stagnation\n        self.stagnation_limit = int(budget / 10)  # Limit for stagnation\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n            if self.stagnation_count > self.stagnation_limit:\n                self._restart_population(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n                self.stagnation_count = 0  # Reset stagnation counter\n            else:\n                self.stagnation_count += 1\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.c1 = max(1.5, self.c1 * (0.95 + 0.1 * np.random.rand()))\n            self.c2 = max(1.5, self.c2 * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.c1 = min(2.5, self.c1 * (1.03 - 0.03 * diversity))\n            self.c2 = min(2.5, self.c2 * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _restart_population(self, bounds):\n        self.particles = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.stagnation_count = 0", "configspace": "", "generation": 54, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11378949807678118, 0.11381312993077541, 0.11385608146695347, 0.07343378797900735, 0.07342760733024045, 0.07345827983314246, 0.09453919617077455, 0.09454290921223196, 0.09458064892985218]}}
{"id": "84eb2938-8ce4-4714-8fb4-251db98e5195", "fitness": 0.09393974970746768, "name": "Adaptive_Hybrid_PSO_DE", "description": "Adjust crossover probability dynamically to enhance adaptability based on diversity.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(0.9, self.CR * (1.05 + 0.05 * np.random.rand()))  # Changed line for dynamic CR adjustment\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 55, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380326828313225, 0.11381713484907197, 0.11384661207414493, 0.07343883943885132, 0.07342903417506419, 0.07345489354032797, 0.09454775836068996, 0.0945453559916789, 0.09457485065424764]}}
{"id": "0d0654ef-8e91-48d8-8b1e-33eda5258ba7", "fitness": 0.0939220402161372, "name": "Refined_Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive learning rates and dynamic inertia strategy to enhance convergence through speed and precision balance.", "code": "import numpy as np\n\nclass Refined_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.adaptive_c1 = 2.5\n        self.adaptive_c2 = 0.5\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w - 0.1 * np.random.rand())\n            self.F = min(0.9, self.F + 0.02 * np.random.rand())\n            self.adaptive_c1 = max(0.5, self.adaptive_c1 - 0.1)\n            self.adaptive_c2 = min(2.5, self.adaptive_c2 + 0.1)\n        else:\n            self.w = min(0.9, self.w + 0.1 * np.random.rand())\n            self.F = max(0.4, self.F - 0.02 * np.random.rand())\n            self.adaptive_c1 = min(2.5, self.adaptive_c1 + 0.1)\n            self.adaptive_c2 = max(0.5, self.adaptive_c2 - 0.1)\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.adaptive_c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.adaptive_c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 56, "feedback": "The algorithm Refined_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09392 with standard deviation 0.01648.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11379804618994094, 0.11382233917854134, 0.11376581827631138, 0.07343684141265594, 0.07343091545081082, 0.0734260166098254, 0.09454442642056404, 0.09454856357088781, 0.09452539483569711]}}
{"id": "e2e95198-0a71-4cb3-b81e-9eb0d4fea637", "fitness": 0.09394463920892, "name": "Adaptive_Hybrid_PSO_DE_Improved", "description": "Introduce dynamic population adaptation and local search enhancements to boost diversity and convergence speed in hybrid PSO-DE.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n            \n            if self.eval_count % 10 == 0:\n                self._local_search(bounds, func)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _local_search(self, bounds, func):\n        for i in np.random.choice(self.population_size, 3, replace=False):\n            if self.eval_count >= self.budget:\n                break\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            candidate = self.particles[i] + perturbation\n            candidate = np.clip(candidate, *bounds)\n            candidate_fitness = func(candidate)\n            self.eval_count += 1\n\n            if candidate_fitness < self.fitness[i]:\n                self.particles[i] = candidate\n                self.fitness[i] = candidate_fitness\n\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.global_best = candidate", "configspace": "", "generation": 57, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380901477403615, 0.1138248824557555, 0.11385542406138682, 0.0734408899321688, 0.07343182025457617, 0.07345806528206955, 0.09455127251107887, 0.09455011602566665, 0.09458026758354154]}}
{"id": "48920266-6f36-4440-a512-655138dc4f75", "fitness": 0.09393541963555735, "name": "Refined_Adaptive_Hybrid_PSO_DE", "description": "Introduce dynamic parameter tuning and adaptive mutation strategy to refine the balance between exploration and exploitation.", "code": "import numpy as np\n\nclass Refined_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor with learning rate\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * self.learning_rate))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * self.learning_rate))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            # Adaptive mutation strategy\n            mutation_factor = self.F * (1 + np.random.rand() * self.learning_rate)\n            mutant_vector = x0 + mutation_factor * (x1 - x2)\n            \n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 58, "feedback": "The algorithm Refined_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380969534585583, 0.11381074295427873, 0.1138269977527292, 0.07344092902974253, 0.07342677470934289, 0.07344786356305544, 0.09455147993640478, 0.09454146929764773, 0.09456282413095907]}}
{"id": "05b69d7d-d58b-4855-940a-96697d2de969", "fitness": 0.09393367256439, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce a success-based parameter adaptation scheme to dynamically adjust exploration and exploitation balance.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.success_count = 0\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n                self.success_count += 1\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Adapt PSO inertia weight and DE scaling factor based on success rate\n        success_rate = self.success_count / max(1, self.population_size)\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (1.0 - success_rate))\n            self.F = min(0.9, self.F * (1.0 + success_rate))\n        else:\n            self.w = min(0.9, self.w * (1.0 + success_rate))\n            self.F = max(0.4, self.F * (1.0 - success_rate))\n        self.prev_best_fitness = self.best_fitness\n        self.success_count = 0\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 59, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09393 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11379908656973736, 0.11381653229935795, 0.1138238460066977, 0.07343713614731084, 0.07342882648380034, 0.07344674384993599, 0.09454498478597506, 0.09454499508158343, 0.09456090185511135]}}
{"id": "627109d0-95e2-42ca-a40d-7cf044b6ef9a", "fitness": 0.09395738803036256, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Enhance convergence by incorporating adaptive learning rates and mutation strategies for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.learning_rate_decay = 0.95  # Decay factor for learning rates\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (self.learning_rate_decay + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.CR = np.clip(self.CR * (1.1 - diversity), 0.5, 0.9)\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 60, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "020f5de6-08a0-4e43-8622-f37a1915e1c2", "fitness": 0.09394841906052459, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Enhance exploration-exploitation balance through adaptive inertia and scaling factors based on fitness improvement and diversity.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  \n        self.c1 = 1.5  \n        self.c2 = 1.5  \n        self.F = 0.8  \n        self.CR = 0.7  \n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  \n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        fitness_improvement = self.prev_best_fitness - self.best_fitness\n        if fitness_improvement > 0:\n            self.w = max(0.4, self.w * (0.9 + 0.1 * np.random.rand() * (1 - diversity)))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand() * diversity))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 61, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11383768028594488, 0.11381557519335739, 0.11385335011066045, 0.07345111356950762, 0.07342850059135542, 0.07345732740746136, 0.0945687968692841, 0.09454442595327694, 0.09457900156387311]}}
{"id": "ad009093-df06-4219-b7dd-8e8b4beaeac3", "fitness": -Infinity, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Enhanced Adaptive Hybrid PSO-DE with Adaptive Momentum for improved convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.momentum = 0.5  # Initial momentum\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._adaptive_momentum()\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _adaptive_momentum(self):\n        # Update momentum based on fitness improvement\n        if self.best_fitness < self.prev_best_fitness:\n            self.momentum = min(0.9, self.momentum * 1.05)\n        else:\n            self.momentum = max(0.3, self.momentum * 0.95)\n        self.prev_best_fitness = self.best_fitness\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.momentum * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 62, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {}}
{"id": "6a9b2c8e-c31f-4395-bc98-f4c52fcd3f82", "fitness": 0.09394166710065831, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce a random restart mechanism to improve exploration.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n            if np.random.rand() < 0.01:  # Introduce random restart mechanism  # <-- Changed line\n                self.particles = np.random.rand(self.population_size, self.dim)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 63, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11381494383181956, 0.11383514078768597, 0.11382565338151263, 0.07344299561433476, 0.07343548635458785, 0.07344744047547602, 0.09455488801501344, 0.0945563950053313, 0.09456206044016324]}}
{"id": "044873a2-94de-45a4-8abb-46910a82cdc1", "fitness": 0.0939381625915469, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive learning rates for PSO and DE components to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        delta_fitness = self.prev_best_fitness - self.best_fitness\n        improvement_rate = delta_fitness / self.prev_best_fitness if self.prev_best_fitness != np.inf else 1\n        \n        self.w = 0.9 - improvement_rate * 0.5\n        self.F = 0.5 + improvement_rate * 0.4\n\n        self.w = np.clip(self.w, 0.4, 0.9)\n        self.F = np.clip(self.F, 0.4, 0.9)\n        \n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 64, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.1137930094098617, 0.11383398786515397, 0.11383845065258924, 0.07343595693315963, 0.07343368451087529, 0.07345703327175912, 0.09454031117605366, 0.09454683769964367, 0.09456419180482578]}}
{"id": "1d3363e3-5a9f-4f6a-93cb-c4e661432f45", "fitness": -Infinity, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive parameter tuning and a dynamic switching mechanism based on convergence speed to enhance performance in varying optimization landscapes.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.convergence_threshold = 1e-6  # Convergence speed threshold\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n            convergence_speed = abs(self.best_fitness - self.prev_best_fitness)\n\n            if convergence_speed < self.convergence_threshold:\n                self._de_update(bounds)\n            elif self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n            self.prev_best_fitness = self.best_fitness\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 65, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {}}
{"id": "353a9ea9-103b-4d4a-94d2-d56aa092b4b3", "fitness": -Infinity, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Introduce dynamic exploration-exploitation balance and learning rate adaptation to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.learning_rate = 0.1  # New parameter for dynamic learning rate\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        \n        # Adjust learning rate based on progress\n        progression = (self.prev_best_fitness - self.best_fitness) / max(1e-10, self.prev_best_fitness)\n        self.learning_rate = min(0.2, max(0.01, self.learning_rate + 0.05 * progression))\n        \n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.learning_rate * self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 66, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {}}
{"id": "7da1a616-549c-413f-918b-e281d3470e2c", "fitness": 0.09395534831604033, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Enhance exploration-exploitation balance by introducing opposition-based learning and adaptive inertia weight adjustment in the hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n    \n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n            \n            self._opposition_based_learning(func, bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n    \n    def _opposition_based_learning(self, func, bounds):\n        opp_particles = bounds[1] - self.particles + bounds[0]\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(opp_particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.particles[i] = opp_particles[i]\n                self.fitness[i] = fitness_value\n\n                if fitness_value < self.best_fitness:\n                    self.best_fitness = fitness_value\n                    self.global_best = opp_particles[i]", "configspace": "", "generation": 67, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11383701580637784, 0.11383016092447318, 0.11387115089297029, 0.0734508414421069, 0.0734336986329297, 0.07346368304096429, 0.09456835450521728, 0.09455333860129023, 0.09458989099803328]}}
{"id": "8272976e-bd44-4bb0-9fa7-1647d64c58b5", "fitness": 0.09395738803036256, "name": "Improved_Adaptive_Hybrid_PSO_DE", "description": "Introduce a mutation strategy based on fitness diversity to maintain population diversity and prevent early convergence.", "code": "import numpy as np\n\nclass Improved_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n            fitness_diversity = self._calculate_fitness_diversity()\n\n            if fitness_diversity > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _calculate_fitness_diversity(self):\n        return np.std(self.fitness)\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 68, "feedback": "The algorithm Improved_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "3d299b78-0954-4cf7-ab7f-e1609ae677d1", "fitness": 0.09392615910657037, "name": "Adaptive_Hybrid_PSO_DE", "description": "Enhance exploration and exploitation balance through adaptive inertia and scaling factor based on evaluation performance.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.8  # Adjusted inertia weight for PSO\n        self.c1 = 1.6  # Adjusted cognitive coefficient for PSO\n        self.c2 = 1.4  # Adjusted social coefficient for PSO\n        self.F = 0.85  # Adjusted scaling factor for DE\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.96 + 0.08 * np.random.rand()))  # Slightly adjusted for more balance\n            self.F = min(0.9, self.F * (1.01 + 0.03 * np.random.rand()))  # Slightly adjusted\n        else:\n            self.w = min(0.9, self.w * (1.04 - 0.02 * diversity))  # Slightly adjusted for more balance\n            self.F = max(0.45, self.F * (0.96 + 0.02 * (1 - diversity)))  # Slightly adjusted\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 69, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09393 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11376313184922049, 0.1138208622004584, 0.11382108623608977, 0.07342428750796093, 0.07343037952924059, 0.07344579964036979, 0.0945229777732437, 0.09454765118017949, 0.09455925604237014]}}
{"id": "51c76426-12a3-4cf7-9935-910c3d013a1c", "fitness": 0.09395738803036256, "name": "Refined_Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive mutation strategies and enhanced parameter tuning for improved convergence in challenging optimization landscapes.", "code": "import numpy as np\n\nclass Refined_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.mutation_scaling = 0.2  # Additional mutation scaling factor\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 5, replace=False)\n            x0, x1, x2, x3, x4 = self.particles[indices]\n\n            # Using a blend of DE/rand/1 and DE/best/2 strategies with mutation scaling\n            mutant_vector = x0 + self.F * (x1 - x2) + self.mutation_scaling * (x3 - x4)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 70, "feedback": "The algorithm Refined_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "32a24663-c5b6-4a74-a047-891c1d808541", "fitness": 0.09395630250897709, "name": "Adaptive_Hybrid_PSO_DE", "description": "Enhance the exploration capability of Adaptive_Hybrid_PSO_DE by introducing a random reinitialization mechanism for particles with stagnant fitness.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.stagnation_counter = np.zeros(self.population_size)  # Added line for stagnation counting\n        self.stagnation_limit = 10  # Added line for stagnation limit\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n            self._random_reinitialization(bounds)  # Added line for reinitialization\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n                self.stagnation_counter[i] = 0  # Reset stagnation counter on improvement\n            else:\n                self.stagnation_counter[i] += 1  # Increment stagnation counter\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _random_reinitialization(self, bounds):  # Added function for reinitialization\n        for i in range(self.population_size):\n            if self.stagnation_counter[i] > self.stagnation_limit:\n                self.particles[i] = np.random.rand(self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                self.stagnation_counter[i] = 0\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 71, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11383561156317545, 0.11385182596575216, 0.11385521129179421, 0.07345037547608813, 0.07344144072361602, 0.07345798931544822, 0.09456753189769385, 0.09456659892850627, 0.09458013741871951]}}
{"id": "afc403fe-40fe-49d0-8843-53081df859ea", "fitness": 0.09393974970746768, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive crossover probability and use elitism to retain the best solution across generations.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        best_solution = None  # Introduced to retain the best solution\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n                \n            if self.global_best is not None:  # Ensure best solution is retained\n                best_solution = self.global_best\n\n        return best_solution\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(0.9, self.CR * (1.02 + 0.02 * np.random.rand()))  # Adaptive CR update\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.5, self.CR * (0.97 + 0.03 * (1 - diversity)))  # Adaptive CR update\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 72, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380326828313225, 0.11381713484907197, 0.11384661207414493, 0.07343883943885132, 0.07342903417506419, 0.07345489354032797, 0.09454775836068996, 0.0945453559916789, 0.09457485065424764]}}
{"id": "05e93f87-8ff8-4144-af6b-1b0bb0a82d2b", "fitness": 0.09392451977949262, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Incorporate dynamic subgrouping and adaptive crossover to enhance convergence speed and solution quality in a hybrid PSO-DE framework.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.subgroup_size = max(5, self.population_size // 4)\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._subgroup_pso_update(bounds)\n            else:\n                self._adaptive_de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.CR = 0.6 + 0.4 * diversity\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _subgroup_pso_update(self, bounds):\n        for start in range(0, self.population_size, self.subgroup_size):\n            end = start + self.subgroup_size\n            subgroup = self.particles[start:end]\n            subgroup_best = np.min(self.fitness[start:end])\n            for i in range(start, min(end, self.population_size)):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                local_best = subgroup[np.argmin(self.fitness[start:end])]\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                      self.c2 * r2 * (local_best - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _adaptive_de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 73, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09392 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.113764735473742, 0.11380754477110244, 0.11382528756755228, 0.07342491582156219, 0.07342562539852993, 0.07344726134075386, 0.09452401589196446, 0.09453950516734222, 0.09456178658288428]}}
{"id": "e5a01550-a810-462d-871d-496dd039187f", "fitness": 0.09393287041480697, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Enhance adaptive hybrid PSO-DE by introducing a learning component to adjust parameters based on past performance and diversity trends.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        improvement_rate = (self.prev_best_fitness - self.best_fitness) / max(1.0, abs(self.prev_best_fitness))\n        self.w = max(0.4, min(0.9, self.w - self.learning_rate * (improvement_rate - 0.1)))\n        self.F = max(0.4, min(0.9, self.F + self.learning_rate * (0.1 - improvement_rate)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 74, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09393 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11376966155212953, 0.11380626975406571, 0.11385988410285097, 0.07342656957792515, 0.07342517235863166, 0.07345964447930398, 0.0945269221174101, 0.09453872746591496, 0.0945829823250306]}}
{"id": "e12b9653-8a41-4be3-8074-cb8b7accdbde", "fitness": 0.09393612756287564, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Implement an adaptive evolutionary approach leveraging time-varying parameters for enhanced convergence in hybrid PSO-DE.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.initial_w = 0.9\n        self.final_w = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.initial_F = 0.8\n        self.final_F = 0.4\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        progression = self.eval_count / self.budget\n        self.w = self.initial_w - (self.initial_w - self.final_w) * progression\n        self.F = self.initial_F + (self.final_F - self.initial_F) * progression\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 75, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11376779189002406, 0.113836160420272, 0.113846693596103, 0.07342596728065631, 0.07343584183304885, 0.07345492989402247, 0.09452584525532037, 0.09455700989212446, 0.09457490800430923]}}
{"id": "287f913b-c024-4e69-817c-83257a98179a", "fitness": -Infinity, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce learning rate annealing to dynamically adjust exploration and exploitation balance.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        # Adjusted inertia weight and scaling factor with annealing\n        anneal_rate = max(0.4, 1.0 - (self.eval_count / self.budget))\n        self.w *= anneal_rate\n        self.F *= anneal_rate\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 76, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {}}
{"id": "e132e2d1-5ccf-431d-bea2-8f9004b268f8", "fitness": 0.09392215552182855, "name": "Enhanced_Hybrid_PSO_DE", "description": "Enhance exploration by incorporating a diversity-guided mutation mechanism and adaptive learning rates in PSO-DE hybrid algorithm.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  \n        self.c1 = 1.5  \n        self.c2 = 1.5  \n        self.F = 0.8  \n        self.CR = 0.7  \n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.c1 = max(1.0, self.c1 * (1.1 + 0.1 * np.random.rand()))\n            self.c2 = max(1.0, self.c2 * (1.1 + 0.1 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.c1 = min(1.5, self.c1 * (0.9 + 0.1 * np.random.rand()))\n            self.c2 = min(1.5, self.c2 * (0.9 + 0.1 * np.random.rand()))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            # Introduce diversity-guided mutation by considering mean of the population\n            mean_particle = np.mean(self.particles, axis=0)\n            mutant_vector = x0 + self.F * (x1 - x2) + 0.1 * (mean_particle - x0)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 77, "feedback": "The algorithm Enhanced_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09392 with standard deviation 0.01648.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11379208906038718, 0.11378346695207286, 0.1138112540268913, 0.07343464878404571, 0.07341702867330357, 0.07344223532536753, 0.09454071514870677, 0.09452477591307507, 0.09455318581260697]}}
{"id": "541a210a-ea3a-472e-a029-02cc690b458f", "fitness": 0.09395738803036256, "name": "Adaptive_Hybrid_PSO_DE", "description": "Improve convergence by introducing adaptive mutation strategies and a dynamic learning strategy to balance exploration and exploitation.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(func, bounds)\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, func, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n            mutant_vector = np.clip(x0 + self.F * (x1 - x2), *bounds)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 78, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "d69ae1d4-0cda-4cd2-9248-434bd72f49a2", "fitness": -Infinity, "name": "Adaptive_Hybrid_PSO_DE", "description": "Incorporate adaptive learning rates and mutation in PSO-DE to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        learning_rate = 0.1  # Added adaptive learning rate\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters(learning_rate)\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds, learning_rate)\n            else:\n                self._de_update(bounds, learning_rate)\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self, learning_rate):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            learning_rate *= 1.1  # Adjust learning rate based on improvement\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            learning_rate *= 0.9  # Adjust learning rate when stagnating\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds, learning_rate):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i])) * learning_rate\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds, learning_rate):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2) * learning_rate\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 79, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {}}
{"id": "054a9497-a52d-4cbc-b612-ceb98c479e0b", "fitness": 0.0939485046569189, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Introducing a dynamic restart mechanism based on stagnation detection to enhance global exploration in the adaptive hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.stagnation_counter = 0\n        self.restart_threshold = int(self.budget / 20)\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n            self._check_stagnation()\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n                self.stagnation_counter = 0\n            else:\n                self.stagnation_counter += 1\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector\n\n    def _check_stagnation(self):\n        if self.stagnation_counter >= self.restart_threshold:\n            self._restart_population()\n            self.stagnation_counter = 0\n\n    def _restart_population(self):\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.personal_best = np.copy(self.particles)", "configspace": "", "generation": 80, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11383386544082774, 0.11385182596575216, 0.11382131126174977, 0.07344975222132422, 0.07344144072361602, 0.07344588479773129, 0.09456646391801937, 0.09456659892850627, 0.09455939865474317]}}
{"id": "adef6030-e551-4880-84be-7a653a94e070", "fitness": 0.09392381251815607, "name": "Adaptive_Hybrid_PSO_DE", "description": "Refine exploration-exploitation balance by introducing dynamic adaptation of DE crossover rate and integrating adaptive learning rates in PSO.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(1.0, self.CR * (1.03 + 0.03 * np.random.rand()))  # Dynamic CR update\n            self.c1 = max(1.0, self.c1 * (1.1 - 0.1 * np.random.rand()))  # Adaptive learning rate\n            self.c2 = max(1.0, self.c2 * (1.1 - 0.1 * np.random.rand()))  # Adaptive learning rate\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 81, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09392 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.1137859593338002, 0.11379505746048701, 0.11381321579564674, 0.07343259097108645, 0.07342114788179044, 0.07344297189349303, 0.09453709965057344, 0.09453184654428426, 0.09455442313224305]}}
{"id": "45d0e6f5-3240-4e35-b630-81d40c136293", "fitness": 0.09393974970746768, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive crossover probability in DE and self-adaptive PSO parameters based on fitness improvement trend.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        improvement = self.prev_best_fitness - self.best_fitness\n        if improvement > 0:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(0.9, self.CR * (1.02 + 0.02 * np.random.rand()))  # Changed line for adaptive CR\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.4, self.CR * (0.97 + 0.03 * (1 - diversity)))  # Changed line for adaptive CR\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 82, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380326828313225, 0.11381713484907197, 0.11384661207414493, 0.07343883943885132, 0.07342903417506419, 0.07345489354032797, 0.09454775836068996, 0.0945453559916789, 0.09457485065424764]}}
{"id": "0021b133-3043-4346-9540-03b2c62c2fdd", "fitness": 0.09395738803036256, "name": "Adaptive_Hybrid_PSO_DE", "description": "Enhance exploitation by adjusting the Differential Evolution (DE) scaling factor for more aggressive local search.  ", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(1.0, self.F * (1.02 + 0.05 * np.random.rand()))  # Adjusted line\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 83, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "51f54389-3a78-49c8-b7c1-f6bc6cdec691", "fitness": 0.09393722982874056, "name": "Adaptive_Hybrid_PSO_DE", "description": "Enhance the adaptive control of parameters and introduce a diversity-preserving mechanism to improve convergence and prevent premature convergence.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.15  # Adjusted diversity threshold\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(1.0, self.F * (1.05 + 0.05 * np.random.rand()))  # Increased scaling factor adjustment\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.95 + 0.05 * (1 - diversity)))  # Refined scaling factor adjustment\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        diversity = np.mean(np.std(self.particles, axis=0))\n        return diversity + 0.01 * np.random.rand()  # Add slight randomness to maintain diversity\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 84, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11382341836480825, 0.11378668598460973, 0.1138453828140612, 0.07344600073301155, 0.07341818500793584, 0.07345447376016923, 0.09456005106422205, 0.09452675235530328, 0.09457411837454388]}}
{"id": "42ba47e2-c22b-43aa-b4ad-d68aecd7049d", "fitness": 0.09393974970746768, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive crossover probability in DE for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = min(0.9, self.CR * (1.02 + 0.02 * np.random.rand()))  # Adaptive CR for better exploration\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 85, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380326828313225, 0.11381713484907197, 0.11384661207414493, 0.07343883943885132, 0.07342903417506419, 0.07345489354032797, 0.09454775836068996, 0.0945453559916789, 0.09457485065424764]}}
{"id": "bf314f25-5d42-4952-ba9b-cc89e973fb43", "fitness": 0.09395738803036256, "name": "Adaptive_Hybrid_PSO_DE", "description": "Optimize the dynamic adjustment of parameters by modifying the scaling factor update in DE to improve convergence.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.05 + 0.02 * np.random.rand()))  # Modified line\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 86, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "41eb945f-64f2-4425-bf44-92349cc7fafb", "fitness": -Infinity, "name": "Adaptive_Hybrid_PSO_DE", "description": "Improve the balance of exploration and exploitation by introducing a novel inertia weight schedule and adaptive crossover rate.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w_min = 0.4  # Changed to reflect dynamic range\n        self.w_max = 0.9  # Changed to reflect dynamic range\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR_min = 0.5  # New lower bound for crossover rate\n        self.CR_max = 0.9  # New upper bound for crossover rate\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = self.w_min + (self.w_max - self.w_min) * np.random.rand()  # New inertia schedule\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.CR = self.CR_min + (self.CR_max - self.CR_min) * (1 - diversity)  # Adaptive CR\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 87, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {}}
{"id": "6a06558f-a4ab-4d7b-bedf-60166787b1d6", "fitness": 0.09394661691355008, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive velocity factor in PSO and adjust crossover rate in DE for enhanced convergence.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.4, self.CR * (0.97 + 0.03 * np.random.rand()))  # Adjust crossover rate\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            velocity_factor = 0.5 + 0.5 * np.random.rand()  # Adaptive velocity factor\n            self.velocities[i] = (self.w * self.velocities[i] * velocity_factor +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 88, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11379989388864864, 0.11384097710565699, 0.11385778132787128, 0.07343737391062799, 0.07343756965363968, 0.07345888133343315, 0.0945454270058419, 0.09455996477520123, 0.09458168322102989]}}
{"id": "888b4f54-a23a-4a50-96ce-fa6ae669d3a9", "fitness": 0.0939495594959085, "name": "Adaptive_Hybrid_PSO_DE", "description": "Adjust PSO parameters to improve convergence speed in Adaptive_Hybrid_PSO_DE.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.7  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 89, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11383475751456107, 0.11385182596575216, 0.11382523930465138, 0.07345006986455827, 0.07344144072361602, 0.0734472900055595, 0.09456700873918067, 0.09456659892850627, 0.09456180441679118]}}
{"id": "b47ce420-e42b-41ca-904b-60fe32c021ed", "fitness": 0.09394143554105663, "name": "Adaptive_Hybrid_PSO_DE_V2", "description": "Introduce adaptive inertia weight and scaling factor dynamically for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.94 + 0.1 * np.random.rand()))  # Adjusted inertia weight adaptation\n            self.F = min(0.9, self.F * (1.03 + 0.02 * np.random.rand()))  # Adjusted scaling factor adaptation\n        else:\n            self.w = min(0.9, self.w * (1.02 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.96 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 90, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11382458927758465, 0.11381078106791631, 0.11383931160841454, 0.07344644052606075, 0.07342678652855839, 0.0734523159217022, 0.094560789626154, 0.09454149076358231, 0.09457041454953652]}}
{"id": "d50d968a-7eb7-45d8-9745-a3b1d168ea13", "fitness": 0.09393974970746768, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce a dynamic crossover probability for DE to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight, DE scaling factor, and DE crossover probability\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = max(0.6, self.CR * (1.01 + 0.01 * np.random.rand())) # Changed line for dynamic crossover probability\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 91, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380326828313225, 0.11381713484907197, 0.11384661207414493, 0.07343883943885132, 0.07342903417506419, 0.07345489354032797, 0.09454775836068996, 0.0945453559916789, 0.09457485065424764]}}
{"id": "1ae99be2-361b-4ab6-87c0-82030119c98a", "fitness": -Infinity, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Introduce dynamic leadership and adaptive exploration-exploitation balance in hybrid PSO-DE to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n        self.leader_switch_prob = 0.3\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if np.random.rand() < self.leader_switch_prob:\n                self.global_best = self.personal_best[np.argmin(self.fitness)]\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        fitness_improvement = (self.prev_best_fitness - self.best_fitness) / self.prev_best_fitness\n        self.w = 0.4 + 0.5 * np.exp(-fitness_improvement)\n        self.c1, self.c2 = 1.5 + 0.5 * np.random.rand(2)\n        self.F = 0.4 + 0.5 * np.random.rand()\n        self.CR = 0.6 + 0.4 * np.random.rand()\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 92, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {}}
{"id": "5e030b15-85ef-4e48-bc9b-d628e5ad128e", "fitness": 0.09393974970746768, "name": "Enhanced_Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive inertia and crossover rates based on diversity to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = max(0.5, self.CR * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = min(0.9, self.CR * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 93, "feedback": "The algorithm Enhanced_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380326828313225, 0.11381713484907197, 0.11384661207414493, 0.07343883943885132, 0.07342903417506419, 0.07345489354032797, 0.09454775836068996, 0.0945453559916789, 0.09457485065424764]}}
{"id": "cb0b0364-6c1a-4a92-a82d-2ebdd4814e56", "fitness": 0.09393974970746768, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive mutation and crossover rates in DE for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = np.clip(self.F * (1.02 + 0.02 * np.random.rand()), 0.4, 1.0)\n            self.CR = np.clip(self.CR * (1.1 + 0.1 * np.random.rand()), 0.1, 0.9)\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.1, self.CR * (0.9 - 0.1 * diversity))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 94, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380326828313225, 0.11381713484907197, 0.11384661207414493, 0.07343883943885132, 0.07342903417506419, 0.07345489354032797, 0.09454775836068996, 0.0945453559916789, 0.09457485065424764]}}
{"id": "8fd49375-7c00-47e9-874d-799197d55b87", "fitness": 0.09393974970746768, "name": "Adaptive_Hybrid_PSO_DE", "description": "Enhance exploration by periodically adjusting the DE crossover probability based on fitness stagnation.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n            self.CR = max(0.5, self.CR - 0.1 * np.random.rand())  # Adjust CR based on fitness improvement\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 95, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11380326828313225, 0.11381713484907197, 0.11384661207414493, 0.07343883943885132, 0.07342903417506419, 0.07345489354032797, 0.09454775836068996, 0.0945453559916789, 0.09457485065424764]}}
{"id": "fa400628-322c-41b1-9698-67ab71dcdce1", "fitness": 0.09395738803036256, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce adaptive crossover probability to enhance exploration-exploitation balance in DE phase.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n            self.CR = max(0.5, self.CR * (1.05 - 0.05 * diversity))  # Modified line for adaptive crossover\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 96, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "efaeced3-871a-4fce-825e-5b460e0888a2", "fitness": 0.09394357246520602, "name": "Improved_Adaptive_Hybrid_PSO_DE", "description": "Implement a feedback loop to adjust exploration-exploitation balance by considering historical performance trends and diversity metrics.", "code": "import numpy as np\n\nclass Improved_Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n        self.improvement_trend = []  # To track improvement over iterations\n        self.window_size = 10  # Window size for improvement trend\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n        \n        if self.eval_count % self.population_size == 0:\n            # Update improvement trend\n            improvement = self.prev_best_fitness - self.best_fitness\n            self.improvement_trend.append(improvement)\n            if len(self.improvement_trend) > self.window_size:\n                self.improvement_trend.pop(0)\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        trend = np.mean(self.improvement_trend) if self.improvement_trend else 0\n\n        if trend > 0:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + self.F * (x1 - x2)\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 97, "feedback": "The algorithm Improved_Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.01649.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.1138042583288531, 0.11385182596575216, 0.11382836450822464, 0.07343918355166101, 0.07344144072361602, 0.0734484076152857, 0.09454835449976606, 0.09456659892850627, 0.09456371806518915]}}
{"id": "c955ac88-ea15-4e42-83ae-72290cefa266", "fitness": 0.09395738803036256, "name": "Adaptive_Hybrid_PSO_DE", "description": "Introduce a dynamic mutation strategy for DE to enhance exploration capabilities.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  # Changed line for adaptive population size\n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.F = 0.8  # Initial scaling factor for DE\n        self.CR = 0.7  # Crossover probability for DE\n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  # Diversity threshold for switching\n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        # Dynamically adjust PSO inertia weight and DE scaling factor\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            # Change: Dynamic mutation by varying F factor based on diversity\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x0, x1, x2 = self.particles[indices]\n\n            mutant_vector = x0 + (self.F + 0.1 * self._calculate_diversity()) * (x1 - x2)  # Increase mutation range\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 98, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
{"id": "79389e06-6984-4f66-a5cf-e897acbad539", "fitness": 0.09395738803036256, "name": "Adaptive_Hybrid_PSO_DE", "description": "Enhance exploration by introducing adaptive mutation strategies and tournament selection in DE.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / 100))  \n        self.particles = np.random.rand(self.population_size, self.dim)\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.personal_best = np.copy(self.particles)\n        self.global_best = None\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.w = 0.9  \n        self.c1 = 1.5  \n        self.c2 = 1.5  \n        self.F = 0.8  \n        self.CR = 0.7  \n        self.prev_best_fitness = np.inf\n        self.div_threshold = 0.1  \n\n    def __call__(self, func):\n        bounds = (func.bounds.lb, func.bounds.ub)\n        while self.eval_count < self.budget:\n            self._evaluate_fitness(func)\n            self._dynamic_update_parameters()\n\n            if self._calculate_diversity() > self.div_threshold:\n                self._pso_update(bounds)\n            else:\n                self._de_update(bounds)\n\n        return self.global_best\n\n    def _evaluate_fitness(self, func):\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            fitness_value = func(self.particles[i])\n            self.eval_count += 1\n\n            if fitness_value < self.fitness[i]:\n                self.fitness[i] = fitness_value\n                self.personal_best[i] = self.particles[i]\n\n            if fitness_value < self.best_fitness:\n                self.best_fitness = fitness_value\n                self.global_best = self.particles[i]\n\n    def _dynamic_update_parameters(self):\n        diversity = self._calculate_diversity()\n        if self.best_fitness < self.prev_best_fitness:\n            self.w = max(0.4, self.w * (0.95 + 0.1 * np.random.rand()))\n            self.F = min(0.9, self.F * (1.02 + 0.02 * np.random.rand()))\n        else:\n            self.w = min(0.9, self.w * (1.03 - 0.03 * diversity))\n            self.F = max(0.4, self.F * (0.97 + 0.03 * (1 - diversity)))\n        self.prev_best_fitness = self.best_fitness\n\n    def _calculate_diversity(self):\n        return np.mean(np.std(self.particles, axis=0))\n\n    def _pso_update(self, bounds):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            self.velocities[i] = (self.w * self.velocities[i] +\n                                  self.c1 * r1 * (self.personal_best[i] - self.particles[i]) +\n                                  self.c2 * r2 * (self.global_best - self.particles[i]))\n            self.particles[i] += self.velocities[i]\n            self.particles[i] = np.clip(self.particles[i], *bounds)\n\n    def _de_update(self, bounds):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 5, replace=False)  # Changed for tournament selection\n            x0 = self.particles[indices[np.argmin(self.fitness[indices])]]  # Tournament selection\n            x1, x2 = self.particles[indices[1:3]]\n\n            mutant_vector = x0 + self.F * (x1 - x2) + 0.5 * (self.global_best - x0)  # Adaptive mutation\n            crossover = np.random.rand(self.dim) < self.CR\n            trial_vector = np.where(crossover, mutant_vector, self.particles[i])\n            trial_vector = np.clip(trial_vector, *bounds)\n\n            if self.eval_count < self.budget:\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.particles[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.global_best = trial_vector", "configspace": "", "generation": 99, "feedback": "The algorithm Adaptive_Hybrid_PSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.01650.", "error": "", "parent_ids": ["a300113e-55eb-4363-a5d1-177498155afa"], "operator": null, "metadata": {"aucs": [0.11384177378886373, 0.11385182596575216, 0.11385401185082189, 0.07345257457207521, 0.07344144072361602, 0.07345756167930884, 0.09457130045374185, 0.09456659892850627, 0.0945794043105771]}}
