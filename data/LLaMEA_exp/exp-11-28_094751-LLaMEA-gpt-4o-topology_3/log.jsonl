{"id": "586f4983-acbf-4b87-9b66-909883944270", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) leverages quantum superposition principles to explore search space adaptively with differential evolution mechanisms.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 0, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/pipes2fig.py\", line 139, in evaluate_demo\n    algorithm(problem)\n  File \"<string>\", line 40, in __call__\n  File \"<string>\", line 18, in mutate\nIndexError: index 46 is out of bounds for axis 0 with size 23\n.", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/pipes2fig.py\", line 139, in evaluate_demo\n    algorithm(problem)\n  File \"<string>\", line 40, in __call__\n  File \"<string>\", line 18, in mutate\nIndexError: index 46 is out of bounds for axis 0 with size 23\n", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "32ee83b6-956e-4e74-ab8b-285f29cc08f4", "fitness": -Infinity, "name": "QIADE", "description": "Improved QIADE with dynamic parameters adjustment for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            dynamic_F = 0.5 + 0.3 * np.sin(evaluations / self.budget * np.pi) # dynamic F\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, dynamic_F)  # adjusted F\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 1, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "2b9ab36e-7af2-4885-9505-3c5b2be7bc28", "fitness": -Infinity, "name": "QIADE", "description": "Improved QIADE with error handling and dynamic parameter tuning.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)  # Changed here\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if evaluations < self.budget:  # Ensure evaluations do not exceed budget\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 2, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "df5592d3-e6e7-4418-90d8-22e2d3f280fc", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) with enhanced mutation strategy and dynamic scaling factor.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def dynamic_scaling_factor(self, evaluations):\n        return 0.8 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        CR = 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = self.dynamic_scaling_factor(evaluations)\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 3, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "bb1cbc0a-e50e-49f8-bbc4-cf2fa311608d", "fitness": -Infinity, "name": "QIADE", "description": "QIADE+ refines mutation and selection to enhance robustness against index errors in differential evolution.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.max():\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 4, "feedback": "An exception occurred: IndexError('index 42 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 42 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "734f7b37-f28f-4e78-850f-0edb27a9655e", "fitness": -Infinity, "name": "QIADE", "description": "QIADE-R improves the mutation strategy by ensuring unique selection of indices, preventing out-of-bound errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 5, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "dab284d3-1c0d-43ac-bbfb-becc73cc23ae", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Selection Corrects Indexing to Avoid Errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.max():  # Fixed from np.argmin to max()\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 6, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "3f927db2-e17d-4f0c-b709-da6ef7baed33", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) utilizes quantum superposition and adaptive differential evolution to navigate complex search spaces effectively.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(len(population), 3, replace=False)  # Changed range to len(population)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.max():  # Changed comparison logic\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 7, "feedback": "An exception occurred: IndexError('index 42 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 42 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "7ff19663-9cc4-4c3f-baa1-4dc59c4f8aad", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (QIADE) fixes mutation selection to prevent out-of-bound index errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 8, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "b06b9f97-d4a8-4155-8e8c-4eb71d76f7dd", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced QIADE with adaptive mutation strategy to prevent index errors and improve optimization performance.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)  # Changed range(self.population_size) to range(len(population))\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 9, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "fa47da17-6946-497a-984f-3e4cdd24313d", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced QIADE with improved mutation strategy for stability and bounded index selection.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 10, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "0d622205-2e5e-40b2-97ce-b493c1a3f7c1", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) leverages quantum superposition principles with improved mutation stability to explore search space adaptively with differential evolution mechanisms.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)  # line changed\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:  # line changed\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 11, "feedback": "An exception occurred: IndexError('index 42 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 42 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "38e6def9-a9f8-47ab-8828-a5edf5c32394", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) is refined to handle population indexing errors by ensuring index selection remains within bounds.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 12, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "a3b7363a-de32-4963-928e-4bee57db5684", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (QIADE) improves diversity with adaptive mutation scaling and robust selection.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F, i):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        F = 0.5 + (0.9 - 0.5) * (i / self.population_size)  # Adaptive F\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.max():  # Robust selection\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F, i)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 13, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "cc93983c-d35a-41a8-b95d-8ef5709e8287", "fitness": -Infinity, "name": "QIADE", "description": "Improved QIADE algorithm now uses more robust mutation and selection strategies to enhance performance within the budget constraints.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(self.population_size, 3, replace=False)  # Fixed index out of bounds error\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        worst_idx = scores.argmax()  # Updated to ensure replacement of the worst\n        if trial_score < scores[worst_idx]:\n            population[worst_idx] = trial\n            scores[worst_idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 14, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "f1a69346-7521-44fa-ba7a-107fdd5e9f76", "fitness": -Infinity, "name": "QIADE", "description": "Improved QIADE with bounded random selection for mutation to prevent index errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population[:min(self.population_size, len(population))], F)  # Line changed\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 15, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "d8af520f-289f-4206-9f81-bb9f9a0aaa3b", "fitness": -Infinity, "name": "QIADE", "description": "Improved QIADE now uses a safer population index selection and adaptive mutation factor for robust optimization.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < np.max(scores):\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            F, CR = 0.5 + 0.3*(1-evaluations/self.budget), 0.9\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 16, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "0538f64e-2bd4-473a-a3ce-57f49bbe1966", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced QIADE algorithm improves population update and mutation boundary to avoid index errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return np.clip(a + F * (b - c), *self.bounds)  # Ensure mutation stays within bounds\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.min():  # Use min() instead of argmin() for selection\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 17, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "8a09f548-de8e-43cf-a452-1a9aebdb568a", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (QIADE) includes dynamic population size adjustment to improve search robustness.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(budget / (10 * dim)))  # Adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 18, "feedback": "An exception occurred: IndexError('index 23 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 23 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "62646597-26a3-4fcf-81cd-14dd5ef645ef", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) utilizes adaptive scaling based on median instead of mean for quantum superposition to enhance robustness.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.median(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 19, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "03edbf55-d433-4ced-bdfb-62a470cba2cd", "fitness": -Infinity, "name": "QIADE", "description": "Improved QIADE with dynamic scaling of mutation factor and enhanced selection strategy.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.max():\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                adaptive_F = 0.5 + 0.3 * np.random.rand()  # Dynamic F\n                mutant = self.mutate(population, adaptive_F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 20, "feedback": "An exception occurred: IndexError('index 41 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 41 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "7559c70a-58c7-441d-b229-e05fdf4718be", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) utilizes quantum superposition with adjusted mutation indices to explore search space adaptively with differential evolution mechanisms.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs[0]], population[idxs[1]], population[idxs[2]]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 21, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "b6ecd74a-6d73-4fdc-a14b-c275728f745e", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) with improved mutation using a corrected indexing strategy to prevent out-of-bound errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                # Ensure indexes are within bounds\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 22, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "fc27bced-1577-4a90-b4e9-f6a5cb34635b", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced QIADE with improved mutation strategy and error handling for robust performance on black box optimization.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return np.clip(a + F * (b - c), *self.bounds)  # Improved mutation with bounds\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 23, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "1597ce31-b038-46f2-b3a3-5cf579ae0391", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) enhances exploration by fixing index selection and includes a scaling factor and crossover rate adaptation.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)  # Fixed index selection\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9  # Initial values\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.1 * np.random.rand()  # Adapt F\n                CR = 0.9 - 0.2 * np.random.rand()  # Adapt CR\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 24, "feedback": "An exception occurred: IndexError('index 43 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 43 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "94303163-11f7-4b53-969a-d0b7dd4533ea", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (EQIADE) introduces dynamic population size adjustment and an improved mutation strategy to increase robustness and performance.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)  # Fixed mutation index range\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if evaluations % (self.budget // 10) == 0:  # Dynamic adjustment of population\n                self.population_size = min(self.population_size + 1, 100)  # Increment size\n                population = np.vstack((population, self.initialize_population()[:1]))  # Add new member\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 25, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "c335b610-314a-42b9-8a8b-2731c53106fa", "fitness": -Infinity, "name": "QIADE", "description": "Refined QIADE with dynamic population size and improved mutation strategy to enhance exploration and avoid index errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // (2 * dim))\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return np.clip(a + F * (b - c), *self.bounds)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = self.population_size\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 26, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "c59538ec-8424-447f-a7a4-3b6954a7c400", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced QIADE with improved mutation strategy and dynamic population size adjustment.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)  # Change 1\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            self.population_size = int(50 * (1 - evaluations / self.budget)) + 5  # Change 2\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 27, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "7d1d5e24-5486-492e-89c4-d599acc0be65", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (EQIADE) uses a safer mutation strategy to prevent index errors and improves search balance.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.min():\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 28, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "005e3a24-98ae-4a82-bb0e-2a3127a1fc2b", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (EQIADE) incorporates enhanced mutation strategies to address boundary issues and improve convergence.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + F * (b - c)\n        return np.clip(mutant, *self.bounds)  # Ensure mutant stays within bounds\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:  # Consider replacing worst individual\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 29, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "b6c85280-471e-42e0-858c-ec72e1e71924", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) using boundary-aware mutation to prevent index errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs[:3]]  # Ensure idxs[:3]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 30, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "70e5d1c9-bfb5-4c1d-b6bf-0424a6c7e08a", "fitness": -Infinity, "name": "QIADE", "description": "Improved Quantum-Inspired Adaptive Differential Evolution fixes index selection and optimizes trial replacement.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < np.max(scores):  # Change 1\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 31, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "cbe17e5a-42e4-45ed-ac27-486f0e1c387b", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) with Enhanced Mutation Strategy to prevent index errors and ensure robust exploration.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        while len(set(idxs)) < 3: # Ensure unique indices\n            idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 32, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "879ee409-767b-4be3-b45e-a8b50d23f61f", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) leverages quantum superposition principles to explore search space adaptively with differential evolution mechanisms, with enhanced mutation strategy and score update logic to fix indices error.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c) + np.random.normal(0, 0.1, self.dim)  # Enhanced mutation\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.max():  # Improved score update logic\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 33, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "0d791d34-0473-40c2-8ff7-e334f0a7abb2", "fitness": -Infinity, "name": "QIADE", "description": "Improved QIADE with dynamic F and CR selection to enhance convergence reliability.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = np.random.uniform(0.4, 0.9)  # Dynamic F\n                CR = np.random.uniform(0.8, 1.0) # Dynamic CR\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 34, "feedback": "An exception occurred: IndexError('index 34 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 34 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "d17938bd-047a-458b-99ac-e68362b92169", "fitness": -Infinity, "name": "QIADE", "description": "Refined QIADE resolves index out-of-bounds errors in mutation selection by ensuring valid indices.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 35, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "f8c1cdc9-f035-415f-b48b-a570d7c9e3b2", "fitness": -Infinity, "name": "QIADE", "description": "Improved Quantum-Inspired Adaptive Differential Evolution (QIADE) with enhanced mutation strategy handling out-of-bounds indices.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            # Ensure population size consistency by updating if needed\n            if len(population) < self.population_size:\n                new_inds = self.initialize_population()[:self.population_size-len(population)]\n                population = np.vstack((population, new_inds))\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 36, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "2ba0fb06-4e3f-4669-a9b7-aaa5d6e2eb4a", "fitness": -Infinity, "name": "QIADE", "description": "Improved Quantum-Inspired Adaptive DE with enhanced mutation strategy and boundary handling.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Modified mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return np.clip(a + F * (b - c), *self.bounds)  # Ensure mutation is within bounds\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 37, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "1e036ef7-c671-42ba-a48a-be12030cc25a", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution with a revised mutation strategy for improved robustness.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)  # Use len(population) for robustness\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 38, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "3be629ff-b599-4d5e-b938-ec3656c19a50", "fitness": -Infinity, "name": "QIADE", "description": "Improved QIADE with enhanced mutation strategy to prevent out-of-bounds indexing.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return np.clip(a + F * (b - c), *self.bounds)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 39, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "1e4c0ea9-4ab9-4b6c-b659-8ede96ef400e", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (QIADE) with a corrected mutation index selection to prevent out-of-bounds errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(self.population_size, 3, replace=False)  # Ensure indexes are within bounds\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 40, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "736f25c1-10af-408c-bbbd-21a5a67cd0c2", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (EQIADE) incorporates a dynamic mutation factor and robust selection to improve optimization efficiency.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.2 * (1 - evaluations / self.budget)  # Dynamic F\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 41, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "641d5b36-3b28-4ac8-8d24-50fe81ac20c3", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (QIADE) adjusts mutation strategies dynamically to improve exploration and convergence.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c) + np.random.normal(0, 0.1, self.dim)  # Enhanced mutation strategy\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 42, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "58395967-b43f-4f96-9d72-f899e4db0e7b", "fitness": -Infinity, "name": "QIADE", "description": "Enhance QIADE by adjusting mutation strategy with boundary checks to avoid index errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return np.clip(a + F * (b - c), *self.bounds)  # Added boundary check\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 43, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "4fb5604d-8365-4154-9bac-558bd073fcf0", "fitness": -Infinity, "name": "QIADE", "description": "Improved Quantum-Inspired Adaptive Differential Evolution (IQIADE) enhances the mutation strategy by incorporating a dynamic adaptation of the differential weight factor.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.5 * (self.budget - evaluations) / self.budget  # Dynamically adjust F\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 44, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "d3b754fd-3325-4a3d-bdac-dded4ba17994", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) refines mutation strategy and improves robustness.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.7, 0.8  # Modified mutation factor F and crossover rate CR\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 45, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "b4726769-ee5b-47bf-aaf3-565c39d17b8c", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced QIADE with population size validation to prevent index errors during mutation in large dimensions.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(3, 50)  # Ensure minimum population size of 3\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 46, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "3f4523c6-a691-4512-9a75-563e9eb36526", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (QIADE) with dynamic population size adaption to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if evaluations % 10 == 0:  # every 10 evaluations, adjust population size\n                self.population_size = max(10, self.population_size - 1)\n                population = population[:self.population_size]\n                scores = scores[:self.population_size]\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 47, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "40dddede-8776-46c6-9b0d-ced28b8ce802", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (EQIADE) with improved mutation strategy to prevent index errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                # Ensure mutate indices are valid\n                if len(population) >= 3:\n                    mutant = self.mutate(population, F)\n                    trial = self.crossover(target, mutant, CR)\n                    trial = np.clip(trial, *self.bounds)\n                    trial_score = func(trial)\n                    evaluations += 1\n                    self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 48, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "fed08697-5676-4305-b428-61909f409c39", "fitness": -Infinity, "name": "QIADE", "description": "Refined QIADE with improved mutation and population handling to prevent out-of-bounds errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        a_idx = np.random.randint(self.population_size)  # Adding a_idx to ensure bounds\n        return population[a_idx] + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 49, "feedback": "An exception occurred: IndexError('index 29 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 29 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "fa281317-3afe-4562-b172-418a3573c540", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) now includes a dynamic adjustment of population size for better exploration control.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.clip(50 + dim // 2, 20, 100))  # Changed line\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 50, "feedback": "An exception occurred: IndexError('index 57 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 57 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "fbda6014-ec75-4420-9dfd-034a6a7af0fe", "fitness": -Infinity, "name": "QIADE", "description": "Enhanced Quantum-Inspired Adaptive Differential Evolution (EQIADE) introduces a dynamic mutation strategy and an improved selection mechanism to ensure more robust exploration and exploitation of the search space.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c) + np.random.normal(0, 0.1, self.dim)  # Added Gaussian noise\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        worst_idx = scores.argmax()  # Select the worst current solution\n        if trial_score < scores[worst_idx]:\n            population[worst_idx] = trial\n            scores[worst_idx] = trial_score\n        elif np.random.rand() < 0.1:  # Allow occasional replacement to escape local optima\n            random_idx = np.random.randint(self.population_size)\n            population[random_idx] = trial\n            scores[random_idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 51, "feedback": "An exception occurred: IndexError('index 36 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 36 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "fa15cc3c-47f5-4c3b-87c7-ce06b0999b1e", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) refines mutation by ensuring unique index selection and bounds mutation factor for stability.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + np.clip(F, 0.1, 0.9) * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 52, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "550d9f8a-eb13-400b-b2db-4b8a3970ec33", "fitness": -Infinity, "name": "QIADE", "description": "Improved Quantum-Inspired Adaptive Differential Evolution (IQIADE) with enhanced mutation strategy for better exploration.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c) + np.random.uniform(-0.5, 0.5, self.dim)  # Modified mutation\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 53, "feedback": "An exception occurred: IndexError('index 34 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 34 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "73da2290-e122-432f-90a8-4efcaae47dfc", "fitness": -Infinity, "name": "QIADE", "description": "Improved Quantum-Inspired Adaptive Differential Evolution with adjusted mutation selection to prevent index errors.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=True)  # Changed 'replace=False' to 'replace=True'\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 54, "feedback": "An exception occurred: IndexError('index 43 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 43 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "f8552035-7d7d-4ff4-a38a-3787818d36ff", "fitness": -Infinity, "name": "QIADE", "description": "Optimized mutation function to handle dynamic population size constraints in Quantum-Inspired Adaptive Differential Evolution.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)  # Adjusted to handle dynamic population size\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 55, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "2c371bbe-464d-42d4-b407-34339fb8389d", "fitness": -Infinity, "name": "QIADE", "description": "Improved QIADE with enhanced selection mechanism and dynamic parameter adjustment.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.max():\n            idx = np.argmax(scores)  # Use max to find worst score\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.1 * (evaluations / self.budget)  # Dynamic F adjustment\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 56, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "b691b985-e996-45a1-b688-e0a7a95a8e47", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) leverages quantum superposition principles with improved mutation and selection strategies to explore search space adaptively with differential evolution mechanisms.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed the range to [-0.5, 0.5]\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores.max():  # Changed condition to use scores.max()\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 57, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "561cdecc-034f-4898-bcfc-7c99a359f445", "fitness": -Infinity, "name": "QIADE", "description": "Improved Quantum-Inspired Adaptive Differential Evolution with dynamic adaptation of F and CR parameters to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.4 + 0.5 * np.random.rand()  # Dynamic F\n                CR = 0.5 + 0.4 * np.random.rand()  # Dynamic CR\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 58, "feedback": "An exception occurred: IndexError('index 34 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 34 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "6f45b9d1-3a47-4286-916f-5c58913badb5", "fitness": -Infinity, "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) leverages quantum superposition principles to explore search space adaptively with differential evolution mechanisms, with a fixed mutation index error corrected.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-1, 1, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(len(population)), 3, replace=False)  # Changed here\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 59, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 23')", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {}}
{"id": "cfe98f1d-2aea-426e-a96b-4e5d97e2c290", "fitness": 0.14800269874484268, "name": "QIADE", "description": "Enhanced QIADE with dynamic population size adjustment and mutation strategy update to improve robustness.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 60, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.10.", "error": "", "parent_ids": ["586f4983-acbf-4b87-9b66-909883944270"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.3746682554495707, 0.12743184053782586, 0.1377213516252317, 0.1328720009837705, 0.1536385932647757, 0.17070125175405482, 0.14597824556287964, 0.1816518741388332, 0.15637803567094144, 0.16712512371691768, 0.4191578286482399, 0.13956640545558852, 0.16657712260394741, 0.15259656597643823, 0.16619058463337144]}}
{"id": "013ecc7a-3613-4444-800c-eec89ac889e7", "fitness": 0.2092633166574986, "name": "QIADE", "description": "Improved trial vector selection by utilizing differential evolution strategy with adaptive crossover probability for better exploration.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        F, CR = 0.5, 0.9\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0)  # Adaptive CR\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 61, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.23.", "error": "", "parent_ids": ["cfe98f1d-2aea-426e-a96b-4e5d97e2c290"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.12485471561423211, 0.14600548803490976, 0.1402095529394224, 0.1449247247201848, 0.1331108059948657, 0.15289858740764994, 0.24467213251867947, 0.15954795663183363, 0.14771037033565515, 0.7651739900698378, 0.18192687149160025, 0.3944603393555114, 0.18047048711671987, 0.1511508211154171, 0.9503505949289862]}}
{"id": "68171b01-babb-486e-8cb3-578b8f4d1c5d", "fitness": 0.21235446555528728, "name": "QIADE", "description": "Enhanced exploration by dynamically adjusting the mutation factor based on population diversity.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.3 * np.std(population) / np.sqrt(self.dim)  # Dynamically adjust mutation factor\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0)  # Adaptive CR\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 62, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.23.", "error": "", "parent_ids": ["013ecc7a-3613-4444-800c-eec89ac889e7"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.11901753473395538, 0.13629753609128004, 0.16201688559473115, 0.11805096088308487, 0.14304433942390382, 0.17108105382267103, 0.23641620112735784, 0.158903163457219, 0.14447317750857502, 0.7623102477004843, 0.6911996075686067, 0.15542278737952264, 0.15402910141693305, 0.16051009382675918, 0.7665177256961958]}}
{"id": "a041094d-9ea4-4655-b578-aec4828b550d", "fitness": 0.15614297424635912, "name": "QIADE", "description": "Enhanced exploration by dynamically adjusting the mutation factor based on population diversity and using adaptive differential scaling.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.3 * np.std(population) / np.sqrt(self.dim)  # Dynamically adjust mutation factor\n                F *= 1.2  # Apply adaptive differential scaling (1 line change)\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0)  # Adaptive CR\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 63, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.15.", "error": "", "parent_ids": ["68171b01-babb-486e-8cb3-578b8f4d1c5d"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.11805288426194915, 0.12807686632462245, 0.1458262211656024, 0.1439710959339927, 0.13117854790036276, 0.1468695598375589, 0.16287185205759325, 0.15806135569376534, 0.15117890146330148, 0.2586344247607759, 0.15972671045371045, 0.14807857307297057, 0.19219617516597198, 0.15809289437517604, 0.7522445275853628]}}
{"id": "74eaaeda-ea08-40ad-8bfd-b1c4751e119b", "fitness": 0.21347904437035364, "name": "QIADE", "description": "Enhanced exploration by adjusting the mutation factor scaling based on population diversity.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.4 * np.std(population) / np.sqrt(self.dim)  # Changed mutation factor scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0)  # Adaptive CR\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 64, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_ids": ["68171b01-babb-486e-8cb3-578b8f4d1c5d"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.12156854250929594, 0.11862671175975681, 0.13746914369590568, 0.14256974328695393, 0.16640381464909781, 0.15083151968790354, 0.3553269494390564, 0.18392878086199693, 0.14494296093807657, 0.7587448081079198, 0.16171438491550016, 0.15623105664497072, 0.5869164360855574, 0.1552533500966824, 0.7612537898539321]}}
{"id": "6c963674-0f70-4756-b9a2-aed7c71aa195", "fitness": 0.18211588334779263, "name": "QIADE", "description": "Improved exploration by adjusting the crossover rate based on population diversity.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.4 * np.std(population) / np.sqrt(self.dim)  # Changed mutation factor scaling\n                mutant = self.mutate(population, F)\n                CR = 0.9 - 0.4 * np.std(population) / np.sqrt(self.dim)  # Changed crossover rate\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 65, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_ids": ["74eaaeda-ea08-40ad-8bfd-b1c4751e119b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.18202752507328446, 0.9015597241831772, 0.11401030516345534, 0.12325744327552579, 0.1297265106895994, 0.36843788967970137, 0.1492148505284664, 0.16401520756313004, 0.2050823877870258, 0.21326440608242458, 0.22212902085699127, 0.16654442611533493, 0.1617079067805718, 0.18460762545856257, 0.18893354284413566]}}
{"id": "978e6676-ba8a-4578-8109-bc30b6b46dc8", "fitness": 0.29068455632536194, "name": "QIADE", "description": "Fine-tuned mutation factor scaling and initialized population closer to bounds for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.8, self.bounds[1] * 0.8, (self.population_size, self.dim))  # Modified initialization\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.4 * np.std(population) / np.sqrt(self.dim)  # Changed mutation factor scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0)  # Adaptive CR\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 66, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.30.", "error": "", "parent_ids": ["74eaaeda-ea08-40ad-8bfd-b1c4751e119b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.148678245821097, 0.14445412734715313, 0.18169556757434635, 0.19956203307872988, 0.14422446798212918, 0.1967784286274319, 0.9444732852998613, 0.7787450831470231, 0.2549400644943395, 0.1462325429465937, 0.45689687420643876, 0.9442589488815856, 0.7834933931076989, 0.1526480769438393, 0.16881109217450507]}}
{"id": "3c6652cb-aeba-4dd1-b8d0-10fa7a218d5b", "fitness": 0.20721181736623015, "name": "QIADE", "description": "Introduced dynamic adjustment of crossover probability CR based on iteration progress to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.8, self.bounds[1] * 0.8, (self.population_size, self.dim))  # Modified initialization\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.4 * np.std(population) / np.sqrt(self.dim)  # Changed mutation factor scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0) * (1 - evaluations / self.budget)  # Adaptive CR based on evaluations\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 67, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_ids": ["978e6676-ba8a-4578-8109-bc30b6b46dc8"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1708602474800266, 0.4269446073992976, 0.1288369921925394, 0.1316671627130318, 0.15190845582316537, 0.15113821829649832, 0.21865056521399606, 0.7813230982786232, 0.1543406032396114, 0.15490618179737303, 0.25183727399038447, 0.1640987653310465, 0.7841461948208654, 0.153571851721227, 0.1522072341524512]}}
{"id": "a4c2b8e1-cab7-443f-8e11-02418f9bebba", "fitness": 0.21428256098719672, "name": "QIADE", "description": "Enhanced adaptive mutation factor scaling by incorporating median of population diversity for better balance.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.8, self.bounds[1] * 0.8, (self.population_size, self.dim))  # Modified initialization\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.4 * np.median(np.std(population, axis=0)) / np.sqrt(self.dim)  # Change mutation factor scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0)  # Adaptive CR\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 68, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_ids": ["978e6676-ba8a-4578-8109-bc30b6b46dc8"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.12125720072156576, 0.291707019106599, 0.1188758420292193, 0.12549686264218152, 0.24795024528269805, 0.16533870579026488, 0.4687767468608963, 0.7818951198153974, 0.1629054233931314, 0.1581324237226267, 0.14538417971321926, 0.19059268525233408, 0.7934273533348006, 0.15604833926276196, 0.19006417794177166]}}
{"id": "a5d303cd-eb93-469f-b0a1-66be943904ed", "fitness": 0.23178124956144003, "name": "QIADE", "description": "Further refined mutation factor scaling for enhanced exploitation of local optima.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.8, self.bounds[1] * 0.8, (self.population_size, self.dim))  # Modified initialization\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.6 + 0.3 * np.std(population) / np.sqrt(self.dim)  # Further refined mutation factor scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0)  # Adaptive CR\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 69, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.26.", "error": "", "parent_ids": ["978e6676-ba8a-4578-8109-bc30b6b46dc8"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.13659010040416064, 0.12912796677786453, 0.1378030870512027, 0.1276863339431804, 0.1296720447023859, 0.2069194574477855, 0.2198208438856213, 0.7793766524065475, 0.1457186108882872, 0.14871852377757533, 0.19445910642554876, 0.9443353605281903, 0.7760627852961675, 0.15988522150737894, 0.23165000131243785]}}
{"id": "e6f2d8d8-615f-4b7a-9bf2-6b67e5634c61", "fitness": 0.20277663571827825, "name": "QIADE", "description": "Improved trial selection by incorporating tournament selection to maintain diversity.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.5 * dim))  # Changed to dynamically adjust population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.8, self.bounds[1] * 0.8, (self.population_size, self.dim))  # Modified initialization\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)  # Changed mutation range\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        tournament_indices = np.random.choice(range(self.population_size), 2, replace=False)\n        if trial_score < scores[tournament_indices].max():\n            idx = tournament_indices[np.argmax(scores[tournament_indices])]\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.4 * np.std(population) / np.sqrt(self.dim)  # Changed mutation factor scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0)  # Adaptive CR\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 70, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.22.", "error": "", "parent_ids": ["978e6676-ba8a-4578-8109-bc30b6b46dc8"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1520523600762388, 0.13341126171208717, 0.12776319549940196, 0.1456553329835395, 0.6448719781967942, 0.9556144510807146, 0.14414445217462457, 0.25305644585006093, 0.25911091038515033, 0.13680686687748267, 0.19612817868549692, 0.17233373738493074, 0.21984338389775582, 0.19012772776701492, 0.15681353691980526]}}
{"id": "40258ce7-e220-488d-bc3b-d41b0503ef73", "fitness": 0.2150035582043357, "name": "QIADE", "description": "Refine the population size calculation to improve diversity during search.", "code": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, int(0.6 * dim))  # Refined population size for better diversity\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.8, self.bounds[1] * 0.8, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmin(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + 0.4 * np.std(population) / np.sqrt(self.dim)\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.5, 1.0)\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 71, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.24.", "error": "", "parent_ids": ["978e6676-ba8a-4578-8109-bc30b6b46dc8"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.14848237876975057, 0.14619459129531576, 0.14712392128758767, 0.133819542599518, 0.13497697179897206, 0.1851442570366062, 0.14424351026215032, 0.15259414279143313, 0.8985386894690719, 0.1994690993665338, 0.20355992573195525, 0.4238335596966294, 0.14385862293452722, 0.8979528527569419, 0.17248020341525339]}}
{"id": "cbe422e2-0fe2-4a73-83b1-95224f9d07cb", "fitness": 0.743912223836912, "name": "ImprovedQIADE", "description": "Introducing an adaptive local-global search switch and dynamic population adjustments for enhanced convergence precision.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.3 * self.budget)  # Local search in the first 30% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if local_search else 0.6) * np.std(population) / np.sqrt(self.dim)  # Adaptive scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 72, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["978e6676-ba8a-4578-8109-bc30b6b46dc8"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9776292893894853, 0.9870976914362468, 0.989847273426033, 0.9750843309184417, 0.983440389645685, 0.9793990283186715, 0.9811855794298648, 0.9815910549416409, 0.9795034933656208, 0.9738392689008617, 0.9782466821592102, 0.9748753983093967, 0.982706633637686, 0.9741702610753635, 0.9918292069095676]}}
{"id": "d8469a91-6326-4c44-a471-b478c59226dd", "fitness": 0.16956975368717755, "name": "ImprovedQIADE", "description": "Introducing a dynamic mutation factor and crossover rate based on iteration progress for enhanced convergence.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.3 * self.budget)  # Local search in the first 30% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if local_search else 0.6) * np.std(population) / np.sqrt(self.dim) \n                F *= (1 - evaluations / self.budget)  # Dynamic scaling based on progress\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9) * (evaluations / self.budget)  # Dynamic CR based on progress\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 73, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_ids": ["cbe422e2-0fe2-4a73-83b1-95224f9d07cb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1108599280747663, 0.11532367840730828, 0.5871374898862618, 0.11569341582320025, 0.10224260780265915, 0.15118490378826988, 0.14561373067073002, 0.1381830904263609, 0.43974775991171566, 0.12350366564702453, 0.1312550733745984, 0.14121932346241117, 0.14553615886206017, 0.6211549751861002, 0.1549403775456183]}}
{"id": "48c655b3-258b-4e14-af4e-9c43df5fa8dc", "fitness": 0.4462474940435179, "name": "ImprovedQIADE", "description": "Enhanced with adaptive crossover probability and dynamic mutation scaling based on population diversity for improved convergence.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        diversity = np.mean(np.std(population, axis=0))  # Calculate population diversity\n        F = 0.1 + 0.5 * diversity  # Dynamic mutation scaling\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        diversity = np.std(mutant - target)  # Calculate diversity for adaptive CR\n        CR = 0.3 + 0.6 * (1 - np.exp(-diversity))  # Adaptive crossover probability\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.3 * self.budget)  # Local search in the first 30% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if local_search else 0.6) * np.std(population) / np.sqrt(self.dim)  # Adaptive scaling\n                mutant = self.mutate(population, F)\n                trial = self.crossover(target, mutant, CR=0.5)  # CR is now adaptive\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 74, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.40.", "error": "", "parent_ids": ["cbe422e2-0fe2-4a73-83b1-95224f9d07cb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9136958948647163, 0.13784081086567168, 0.9625383132676112, 0.14356848020880097, 0.9436875582014466, 0.15859237397631343, 0.9105769442089332, 0.15399965389544157, 0.8776558865165959, 0.12618479742967703, 0.776607381505727, 0.8931024837088939, 0.8750854032488773, 0.12185859284995126, 0.7621564112472341]}}
{"id": "965b8d59-2bec-46fe-8445-592570549c75", "fitness": 0.743912223836912, "name": "ImprovedQIADE", "description": "Fine-tuning crossover points in DE to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR  # Fine-tuned crossover probability\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.3 * self.budget)  # Local search in the first 30% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if local_search else 0.6) * np.std(population) / np.sqrt(self.dim)  # Adaptive scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 75, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["cbe422e2-0fe2-4a73-83b1-95224f9d07cb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9776292893894853, 0.9870976914362468, 0.989847273426033, 0.9750843309184417, 0.983440389645685, 0.9793990283186715, 0.9811855794298648, 0.9815910549416409, 0.9795034933656208, 0.9738392689008617, 0.9782466821592102, 0.9748753983093967, 0.982706633637686, 0.9741702610753635, 0.9918292069095676]}}
{"id": "c40635df-4c48-4cce-ade2-ba9c6fab94bc", "fitness": 0.7333749793020541, "name": "ImprovedQIADE", "description": "Enhanced local-global balance and mutation diversity for ImprovedQIADE.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c) + np.random.normal(0, 0.1, self.dim)  # Added Gaussian noise for diversity\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.25 * self.budget)  # Local search in the first 25% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.6 + (0.2 if local_search else 0.7) * np.std(population) / np.sqrt(self.dim)  # Adjusted adaptive scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 76, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["cbe422e2-0fe2-4a73-83b1-95224f9d07cb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9670800559643798, 0.9741641197661377, 0.9331186726460208, 0.96743974439841, 0.9379302424189837, 0.9640429377408201, 0.9604709181015461, 0.9604521186643171, 0.9876927372749582, 0.970218253082166, 0.9739725919125063, 0.9746832989896893, 0.9768765892986039, 0.9716063872778069, 0.9799520236302705]}}
{"id": "e2fd193d-79ab-4d0c-804b-0deda1a61959", "fitness": 0.735006559284374, "name": "ImprovedQIADE", "description": "Introducing a strategic dynamic crossover point adjustment and refined mutation strategy for enhanced solution diversity and convergence.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c) * 0.9  # Slightly reduced mutation step\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < (CR + np.std(mutant) / self.dim)  # Dynamic CR adjustment\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.3 * self.budget)  # Local search in the first 30% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if local_search else 0.6) * np.std(population) / np.sqrt(self.dim)  # Adaptive scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 77, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["cbe422e2-0fe2-4a73-83b1-95224f9d07cb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9414643259190977, 0.9554511624784008, 0.9525704179852144, 0.9835155210805308, 0.9768514886136738, 0.9818981523952827, 0.9826113939027982, 0.9669129919390411, 0.9580924330051747, 0.9631611734005006, 0.9745630221999837, 0.9698286933086558, 0.9920788151449675, 0.9624204292205034, 0.9709122702191879]}}
{"id": "f69d564f-b5b9-4328-b5fa-42ee68033764", "fitness": 0.5350099969580996, "name": "ImprovedQIADE", "description": "Enhanced the mutation strategy by incorporating diversity preservation, and adjusted the crossover for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        diversity_factor = np.std(population, axis=0)  # Added diversity factor\n        return a + F * (b - c + diversity_factor)  # Incorporated diversity factor in mutation\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.3 * self.budget)  # Local search in the first 30% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if local_search else 0.6) * np.std(population) / np.sqrt(self.dim)  # Adaptive scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.4, 0.9)  # Modified CR range for better exploration\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 78, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.37.", "error": "", "parent_ids": ["cbe422e2-0fe2-4a73-83b1-95224f9d07cb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.30149947580926073, 0.8741997538934227, 0.20816679220625933, 0.8716448034669848, 0.25841293593012726, 0.8283455108501762, 0.866830483322939, 0.9060717787474372, 0.7956741966489752, 0.25079576818320826, 0.8764549110394633, 0.8401802253987463, 0.8811045410221053, 0.9054655434819279, 0.867554324286493]}}
{"id": "1c69727f-2c1e-4708-85b5-ae9a54ca56ee", "fitness": 0.7420691583223689, "name": "ImprovedQIADE", "description": "Enhanced adaptive mutation and crossover rates for improved convergence robustness in diverse scenarios.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.3 * self.budget)  # Local search in the first 30% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if local_search else 0.6) * np.mean(np.abs(population)) / np.sqrt(self.dim)  # Modified F\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.4, 0.8)  # Adjusted CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 79, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["cbe422e2-0fe2-4a73-83b1-95224f9d07cb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.974816902959419, 0.9845774139740596, 0.9856475846409496, 0.9759712600526756, 0.9826384889470676, 0.9735406621331514, 0.9791443451155459, 0.9670862026849436, 0.9764754064751853, 0.9717226600601898, 0.9751391124541565, 0.9807223697564067, 0.9803200588921347, 0.9797083856216604, 0.9860734178053657]}}
{"id": "a6fda30e-0a1f-484f-9760-8a6e4cc0d4dd", "fitness": 0.743912223836912, "name": "ImprovedQIADE", "description": "Adjust the mutation process and better integrate local-global search strategies to enhance convergence precision.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return np.clip(a + F * (b - c), *self.bounds)  # Added clipping to mutation\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.3 * self.budget)  # Local search in the first 30% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if local_search else 0.7) * np.std(population) / np.sqrt(self.dim)  # Slightly increased adaptive scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)  # Adjusted line\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 80, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["cbe422e2-0fe2-4a73-83b1-95224f9d07cb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9776292893894853, 0.9870976914362468, 0.989847273426033, 0.9750843309184417, 0.983440389645685, 0.9793990283186715, 0.9811855794298648, 0.9815910549416409, 0.9795034933656208, 0.9738392689008617, 0.9782466821592102, 0.9748753983093967, 0.982706633637686, 0.9741702610753635, 0.9918292069095676]}}
{"id": "6c37c5ce-9999-4ef6-9951-4d94fe41f94f", "fitness": 0.744229512801019, "name": "ImprovedQIADE", "description": "Enhanced the adaptive mutation factor and refined local-global search switch to improve convergence balance.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim)  # Adaptive scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 81, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["cbe422e2-0fe2-4a73-83b1-95224f9d07cb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9806933583412152, 0.975657839977631, 0.9724485339306275, 0.9803587148791917, 0.9892125759355237, 0.9784918591288921, 0.9853064072059661, 0.9711950194679609, 0.9763502032882067, 0.9772889818959318, 0.9821742531512614, 0.9871704845861431, 0.9878223849050266, 0.9898965675249752, 0.9827241769273611]}}
{"id": "da87c858-09f6-4c06-a53d-edb1901535a2", "fitness": 0.7351081611740135, "name": "ImprovedQIADE", "description": "Fine-tuned the crossover probability range for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim)  # Adaptive scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.4, 0.95)  # Fine-tuned crossover probability range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 82, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["6c37c5ce-9999-4ef6-9951-4d94fe41f94f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9810057652245685, 0.9739828133114825, 0.9593691802869807, 0.9700170938366601, 0.9579580029616009, 0.9915189827027497, 0.9719079869782103, 0.9718832924269646, 0.9645734659379718, 0.9618286337175683, 0.9791394188591662, 0.9559507120368678, 0.9564658976216764, 0.9713393593559639, 0.9674237233473689]}}
{"id": "d034ec8c-ccb3-46d5-8a7b-6dec9e68016f", "fitness": 0.7471150076042091, "name": "ImprovedQIADE", "description": "Enhanced adaptive mutation factor by adding a dynamic element based on evaluation progress for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 83, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["6c37c5ce-9999-4ef6-9951-4d94fe41f94f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9839404615986511, 0.9950675788312672, 0.9701257132812134, 0.9924602109532027, 0.9778564728582008, 0.986939001502782, 0.9896208897101285, 0.9775568022200677, 0.9837991145488123, 0.9861355251395344, 0.9873375306879414, 0.9883855063720671, 0.9899441318495557, 0.9762685412243916, 0.9890637764319007]}}
{"id": "fa09f55f-c972-480b-b4fb-8ac5d60a6493", "fitness": 0.742937897488412, "name": "ImprovedQIADE", "description": "Enhanced adaptive mutation factor by boosting mutation diversity through increased variability in early stages for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 84, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9756991509491025, 0.9652812103038376, 0.985757583872826, 0.9745501271441914, 0.9790308188940972, 0.9762341603376272, 0.9908993778876736, 0.9854361966907698, 0.9922679949755581, 0.9802387672402035, 0.9773787915275611, 0.9682996826388834, 0.9836842885414339, 0.9735058225930111, 0.9826950812969946]}}
{"id": "ec1950df-9f2a-456e-9f89-cfde4cfdee5b", "fitness": 0.7470342116218038, "name": "ImprovedQIADE", "description": "Enhanced exploration by modifying the initialization range for a more diverse starting population.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 85, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9905512804819084, 0.980746214709817, 0.982730711198726, 0.9842297439844799, 0.9848033529514446, 0.9889918973323679, 0.9886321152542152, 0.9813028528486805, 0.9853882543892531, 0.9846182168562673, 0.9851550343324492, 0.9920610724613828, 0.9806673415521334, 0.984082921386298, 0.978924327822188]}}
{"id": "ccea242d-3fb2-4fc4-8a5f-6148d6aabf63", "fitness": 0.7467111553727512, "name": "ImprovedQIADE", "description": "Refine the crossover strategy by introducing a dynamic crossover rate influenced by the evaluation progress to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9) * (1 - evaluations / self.budget)  # Modified CR to depend on the evaluation progress\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 86, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9842114700390575, 0.9950675788312672, 0.972736866276587, 0.9909641485330707, 0.981491688949377, 0.9897212464894581, 0.9912103528502312, 0.9745370342244088, 0.9739864067790698, 0.9745419901562647, 0.989368947548493, 0.9898873234794693, 0.993408430240815, 0.9776966428532203, 0.9875940853297666]}}
{"id": "d52d1b2b-6a1a-47fd-b25a-6f8fd1f693f2", "fitness": 0.7470342116218038, "name": "ImprovedQIADE", "description": "Adjusted the initialization bounds for a denser initial population, enhancing exploration capabilities.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 87, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9905512804819084, 0.980746214709817, 0.982730711198726, 0.9842297439844799, 0.9848033529514446, 0.9889918973323679, 0.9886321152542152, 0.9813028528486805, 0.9853882543892531, 0.9846182168562673, 0.9851550343324492, 0.9920610724613828, 0.9806673415521334, 0.984082921386298, 0.978924327822188]}}
{"id": "9a911811-7f3a-48b4-a93d-2adec89931ee", "fitness": 0.7467111553727512, "name": "ImprovedQIADE", "description": "Enhanced crossover strategy by adjusting CR based on evaluation to improve convergence.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9) * (1 - evaluations / self.budget)  # Adjusted CR to improve convergence\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 88, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9842114700390575, 0.9950675788312672, 0.972736866276587, 0.9909641485330707, 0.981491688949377, 0.9897212464894581, 0.9912103528502312, 0.9745370342244088, 0.9739864067790698, 0.9745419901562647, 0.989368947548493, 0.9898873234794693, 0.993408430240815, 0.9776966428532203, 0.9875940853297666]}}
{"id": "8ba7d086-f2e1-4190-8f68-793ea65e5459", "fitness": 0.745590430823567, "name": "ImprovedQIADE", "description": "Enhanced dynamic mutation strategy to foster better diversity and convergence.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.25 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 89, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9867273954504479, 0.9950675490350133, 0.9758795266024712, 0.9819957482214616, 0.9759698061534865, 0.9709293932344282, 0.9794112774186936, 0.9801388169649494, 0.983795133334195, 0.9827745458447471, 0.9873451873647646, 0.9893883384025031, 0.9878989398329715, 0.9839482366140755, 0.9827398271226668]}}
{"id": "e8177e2a-54f1-45bc-88b3-758503b3f5e3", "fitness": 0.7300133990891176, "name": "ImprovedQIADE", "description": "Introduced a fine-tuning step by adjusting the crossover rate based on the diversity of the population to enhance convergence.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9 * np.std(population))  # Modified CR range with diversity factor\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 90, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.954375676463738, 0.937353478834717, 0.953558902796078, 0.9483200789968005, 0.9718746381104607, 0.9711913284796956, 0.9676853081970275, 0.9765074791491296, 0.980175345571614, 0.9495931774049631, 0.9493328818612958, 0.9399272396429288, 0.9558712655062855, 0.9930776987803296, 0.9836245871128219]}}
{"id": "73cfbd7c-d1f1-4848-8223-211d1f130a62", "fitness": 0.7462263810759178, "name": "ImprovedQIADE", "description": "Added diversity mechanism by modifying standard deviation scaling for F to enhance exploration.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                # Modified line for improved diversity in search\n                F = 0.5 + (0.15 if local_search else 0.55) * np.std(population, axis=0).mean() / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 91, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9793257172659675, 0.9840311315077735, 0.9833233498452963, 0.9902723667566277, 0.988759030530991, 0.988181559929169, 0.9768507144752332, 0.9790935438854526, 0.9847880736833026, 0.9796117517965885, 0.9855752952886584, 0.9890833920130838, 0.9799527573899725, 0.9914743466557082, 0.9764056956200639]}}
{"id": "83d36b97-c23a-49d1-b6c8-5361ee574f58", "fitness": 0.7471150076042091, "name": "ImprovedQIADE", "description": "Enhanced exploration by modifying the mutation strategy to incorporate diversity in the direction vectors through an increased standard deviation in the normal distribution.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.5, self.dim)  # Used normal distribution with increased std for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.3, 0.9)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 92, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9839404615986511, 0.9950675788312672, 0.9701257132812134, 0.9924602109532027, 0.9778564728582008, 0.986939001502782, 0.9896208897101285, 0.9775568022200677, 0.9837991145488123, 0.9861355251395344, 0.9873375306879414, 0.9883855063720671, 0.9899441318495557, 0.9762685412243916, 0.9890637764319007]}}
{"id": "29252e9a-bb80-4d99-945d-6226adf73fcc", "fitness": 0.7485343405003716, "name": "ImprovedQIADE", "description": "Adjusted the crossover probability (CR) range to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.35, 0.75)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 93, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["d034ec8c-ccb3-46d5-8a7b-6dec9e68016f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9889244901473505, 0.9959696772123565, 0.9787295933936273, 0.9926327039494544, 0.9768134626065017, 0.993290460566191, 0.9808128864486289, 0.9800019302785973, 0.9889984218067251, 0.9811561105713519, 0.9843363089106385, 0.9931378079089412, 0.9920554295853562, 0.9890752660428386, 0.9869533657044066]}}
{"id": "92c2d305-0c7d-494d-8a57-0c9593b9fd46", "fitness": 0.7392934966159678, "name": "ImprovedQIADE", "description": "Introduced a dynamic crossover probability (CR) that adapts based on evaluation ratio for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.clip(0.6 * (1 - evaluations / self.budget), 0.35, 0.75)  # Dynamic CR based on evaluations\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 94, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["29252e9a-bb80-4d99-945d-6226adf73fcc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9805192211360227, 0.968187724637195, 0.9836100766310375, 0.9649180490424067, 0.9626762414575696, 0.9533825935521674, 0.9797736088190028, 0.9855701787068988, 0.9874496502422287, 0.9689356509577419, 0.9788116469935887, 0.9697113641024685, 0.9728078559551204, 0.9763036813320873, 0.9854134938793525]}}
{"id": "d5d4e3f2-d44b-4713-901f-6788b1d6f466", "fitness": 0.7322711812592899, "name": "ImprovedQIADE", "description": "Enhanced parameter adaptation and improved global search through adaptive population dynamics and mutation strategies.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(6, int(0.8 * dim))  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.8, self.bounds[1] * 0.8, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.25, self.dim)  # Adjusted mutation strength\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            adapt_threshold = 0.5 * self.budget  # Change in strategy at half budget\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.2 if evaluations < adapt_threshold else 0.6) * np.std(population) / np.sqrt(self.dim) + 0.3 * (evaluations / self.budget)  # Dynamic scaling\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.4, 0.8)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if evaluations >= adapt_threshold:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 95, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["29252e9a-bb80-4d99-945d-6226adf73fcc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9686375690892374, 0.9637332288306626, 0.9373665466655535, 0.9503119291205493, 0.9718407730645896, 0.9774696195098996, 0.9632737979555579, 0.9596033497270506, 0.9788957187689462, 0.9761410571071383, 0.9463304192313335, 0.9721302861363896, 0.9787011298627017, 0.9557563147356568, 0.9774329905060645]}}
{"id": "102929e7-7dcb-4b91-acc9-7d8d483e759c", "fitness": 0.7464486569386244, "name": "ImprovedQIADE", "description": "Improved exploration by expanding the CR range to enhance diversity in crossover operations.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.25, 0.85)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 96, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.41.", "error": "", "parent_ids": ["29252e9a-bb80-4d99-945d-6226adf73fcc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9951465919043965, 0.9918702076538193, 0.9715177980134193, 0.9848612502008093, 0.9818767113033692, 0.9893294980868849, 0.991755854505047, 0.9807443279379875, 0.9744186128218679, 0.989037220492679, 0.9784468544523848, 0.969072469073439, 0.9838533781432975, 0.9866307002335348, 0.9926127690750856]}}
{"id": "279ac47f-2a00-4085-8acf-473d4339d8ef", "fitness": 0.7386445047894553, "name": "ImprovedQIADE", "description": "Enhanced mutation function by incorporating a momentum term to improve convergence speed.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        momentum = 0.1  # Added momentum term\n        return a + F * (b - c) + momentum * (b - a)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = np.random.uniform(0.35, 0.75)  # Modified CR range\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 97, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["29252e9a-bb80-4d99-945d-6226adf73fcc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.972782168937066, 0.9645676966441706, 0.9774499104221049, 0.9768395004164434, 0.9646442246588826, 0.9795852385902453, 0.9656022138291701, 0.9689651462486687, 0.9685674214514979, 0.9729718424456546, 0.9648475663653668, 0.9764820537699475, 0.992963125380897, 0.9842042789210428, 0.9746188128334828]}}
{"id": "0a392db4-bd50-4b20-a346-6dfed1336bcc", "fitness": 0.7153565600049971, "name": "ImprovedQIADE", "description": "Introduced an adaptive crossover probability strategy to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))  # Increased population size\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))  # Adjusted bounds\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)  # Used normal distribution for mutation\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)  # Local search in the first 40% of evaluations\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.2 * (evaluations / self.budget)  # Adaptive scaling with dynamic element\n                mutant = self.mutate(population, F)\n                CR = 0.7 - 0.3 * (evaluations / self.budget)  # Adaptive crossover probability\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 98, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.39.", "error": "", "parent_ids": ["29252e9a-bb80-4d99-945d-6226adf73fcc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9243816575353337, 0.9202657098591618, 0.960048073993657, 0.9687381735652083, 0.96515827933828, 0.9013865104860618, 0.9497324763803889, 0.9584544028828326, 0.9266418445927262, 0.9707127318605753, 0.9208021882859206, 0.968066112401337, 0.9379298020638855, 0.9734069748838299, 0.8936073670962781]}}
{"id": "4c2b28e1-a806-46e1-9b8e-9012649fa1f3", "fitness": 0.7421404699268177, "name": "ImprovedQIADE", "description": "Introduced adaptive crossover and mutation strategies to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, int(0.6 * dim))\n        self.bounds = (-5.0, 5.0)\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0] * 0.9, self.bounds[1] * 0.9, (self.population_size, self.dim))\n\n    def quantum_superposition(self, population):\n        return np.mean(population, axis=0) + np.random.normal(0, 0.3, self.dim)\n\n    def mutate(self, population, F):\n        idxs = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[idxs]\n        return a + F * (b - c)\n\n    def crossover(self, target, mutant, CR):\n        cross_points = np.random.rand(self.dim) < CR\n        return np.where(cross_points, mutant, target)\n\n    def select(self, population, scores, trial, trial_score):\n        if trial_score < scores[np.argmax(scores)]:\n            idx = scores.argmax()\n            population[idx] = trial\n            scores[idx] = trial_score\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        scores = np.array([func(ind) for ind in population])\n        evaluations = 0\n        while evaluations < self.budget:\n            local_search = evaluations < (0.4 * self.budget)\n            for i, target in enumerate(population):\n                if evaluations >= self.budget:\n                    break\n                F = 0.5 + (0.1 if local_search else 0.5) * np.std(population) / np.sqrt(self.dim) + 0.3 * (evaluations / self.budget)\n                mutant = self.mutate(population, F)\n                CR = 0.35 + 0.4 * (1 - scores.min() / (scores.max() + 1e-9))  # Adaptive CR\n                trial = self.crossover(target, mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n                trial_score = func(trial)\n                evaluations += 1\n                self.select(population, scores, trial, trial_score)\n            if not local_search:\n                population = np.apply_along_axis(self.quantum_superposition, 0, population)\n        best_idx = scores.argmin()\n        return population[best_idx], scores[best_idx]", "configspace": "", "generation": 99, "feedback": "The algorithm ImprovedQIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.41.", "error": "", "parent_ids": ["29252e9a-bb80-4d99-945d-6226adf73fcc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9749655097600521, 0.9847203268432178, 0.985929237397321, 0.9935781729055606, 0.9667580073646383, 0.9775743751506366, 0.9773098140222, 0.9744514834191486, 0.9650239220953255, 0.9824291683876348, 0.9809398825790767, 0.9833486847889016, 0.9770940867293152, 0.9772671939505579, 0.9736206382682988]}}
