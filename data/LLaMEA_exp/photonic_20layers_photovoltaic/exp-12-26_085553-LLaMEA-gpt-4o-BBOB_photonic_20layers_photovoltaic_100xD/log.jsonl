{"id": "1d3144b4-49e8-4a96-a059-02c150563fdb", "fitness": 0.07082143215201088, "name": "HybridDE_SA", "description": "The algorithm combines differential evolution and simulated annealing to adaptively explore and exploit the search space.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + 0.8 * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < 0.9\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):  # Inner loop iterations for SA\n            candidate = current_best + np.random.normal(0, 0.1, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            if candidate_fitness < current_best_fitness or \\\n               np.exp((current_best_fitness - candidate_fitness) / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95  # Cooling schedule for SA\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 0, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07082 with standard deviation 0.05290.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.012875142936775719, 0.015194330659675681, 0.014897621361003255, 0.053433464842395084, 0.05860429461325023, 0.05790337500276832, 0.13959642489781832, 0.14238073366746118, 0.14250750138695012]}}
{"id": "0c9f2199-e193-4a9f-aecf-6bb7ab5ab32e", "fitness": 0.07199563962111173, "name": "EnhancedHybridDE_SA", "description": "Integrate a dynamic adaptation of mutation and crossover rates with enhanced local search using adaptive simulated annealing to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07200 with standard deviation 0.05284.", "error": "", "parent_ids": ["1d3144b4-49e8-4a96-a059-02c150563fdb"], "operator": null, "metadata": {"aucs": [0.013444081668787522, 0.01966746953108578, 0.01296531109963761, 0.056560491135491664, 0.060959933066577654, 0.057044040881931046, 0.14432737514899596, 0.14018789079090366, 0.14280416326659473]}}
{"id": "bb54d396-549a-4aa5-8cff-44d17102b05a", "fitness": -Infinity, "name": "EnhancedHybridDE_SA", "description": "Introduce adaptive population resizing and gradient-based mutation to dynamically balance diversity and convergence speed in evolutionary search.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.min_pop_size = 4 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        mutant += np.random.normal(0, 0.01, self.dim)  # Gradient-based mutation tweak\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def resize_population(self):\n        # Resize population based on performance\n        if np.std(self.fitness) < 1e-5:\n            new_size = max(self.min_pop_size, int(0.8 * self.pop_size))\n        else:\n            new_size = min(20 * self.dim, int(1.2 * self.pop_size))\n        if new_size != self.pop_size:\n            self.population = self.population[:new_size]\n            self.fitness = self.fitness[:new_size]\n            self.pop_size = new_size\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95\n\n            self.resize_population()\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 2, "feedback": "An exception occurred: IndexError('index 200 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 200 is out of bounds for axis 0 with size 200')", "parent_ids": ["0c9f2199-e193-4a9f-aecf-6bb7ab5ab32e"], "operator": null, "metadata": {}}
{"id": "3b8fdf87-c809-46e6-9546-3925c47d27fe", "fitness": 0.09435307338676523, "name": "EnhancedHybridDE_SA", "description": "Fine-tune the cooling schedule of the adaptive simulated annealing by adjusting the temperature decay rate and enhancing the initial population diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92  # Adjusted temperature decay rate\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09435 with standard deviation 0.06414.", "error": "", "parent_ids": ["0c9f2199-e193-4a9f-aecf-6bb7ab5ab32e"], "operator": null, "metadata": {"aucs": [0.2129392852265264, 0.019517470991671226, 0.0129415043237745, 0.05737588729495746, 0.06082802518837371, 0.058256058249089415, 0.14432737514899596, 0.14018789079090366, 0.14280416326659473]}}
{"id": "952de44a-c4b8-4311-8252-4eea32c8979e", "fitness": 0.07712780533035836, "name": "ChaosPerturbedHybridDE_SA", "description": "Improve the exploration-exploitation balance by integrating a chaos theory-based perturbation mechanism and dynamically adjusting mutation and crossover based on population diversity.", "code": "import numpy as np\n\nclass ChaosPerturbedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.chaos_param = 0.75\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def chaos_perturbation(self):\n        self.chaos_param *= 3.57 * (1 - self.chaos_param)\n        return self.chaos_param\n\n    def diversity_control(self):\n        diversity = np.std(self.population, axis=0).mean()\n        scale_factor = 0.5 + (1.5 * (1 - diversity))\n        crossover_prob = 0.8 + (0.2 * diversity)\n        return scale_factor, crossover_prob\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor, crossover_prob = self.diversity_control()\n                mutant = self.mutate(i, scale_factor)\n                chaotic_factor = self.chaos_perturbation()\n                trial = self.crossover(self.population[i], mutant * chaotic_factor, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 4, "feedback": "The algorithm ChaosPerturbedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07713 with standard deviation 0.05097.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.019053224899072796, 0.030307689631484558, 0.01765148082375778, 0.060153619610664566, 0.053832459322288306, 0.081121577067642, 0.14626498820177636, 0.1410864898900802, 0.14467871852645864]}}
{"id": "e5e568b0-3d41-428e-9c25-2803693a4c85", "fitness": 0.07211661708704652, "name": "EnhancedHybridDE_SA_LF", "description": "Improve search efficiency by dynamically adjusting population and integrating Levy Flights for enhanced exploration.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_LF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def levy_flight(self, current_best):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return current_best + 0.01 * step * (current_best - self.lb)\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            if evaluations / self.budget > 0.5:\n                best_solution = self.levy_flight(best_solution)\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedHybridDE_SA_LF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07212 with standard deviation 0.05299.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.013162954720501885, 0.018485569161684645, 0.012663274725878582, 0.05502874318299367, 0.06082802518837371, 0.06149674792096771, 0.14432737514899596, 0.14025270046742777, 0.14280416326659473]}}
{"id": "9eb23b7d-a514-4d80-8ddb-0751b5d85b54", "fitness": 0.07302557394620718, "name": "EnhancedHybridDE_SA", "description": "Introduce dynamic population resizing and adaptive parameter tuning to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.dynamic_scale = True  # New dynamic scaling flag\n        self.min_pop_size = 4 * self.dim  # Minimum population size\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0) if self.dynamic_scale else 0.7  # Adjusted\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n            # New dynamic population resizing\n            if evaluations % 100 == 0 and self.pop_size > self.min_pop_size:\n                self.pop_size -= 2 * self.dim\n\n        return best_solution, best_fitness", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07303 with standard deviation 0.05435.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.01315144900905929, 0.018018388133289376, 0.012432870490230452, 0.05755596117176087, 0.05527696153407691, 0.0648341454066027, 0.14432737514899574, 0.14628982797548462, 0.1453431866463647]}}
{"id": "9611d8ad-39a3-4d4c-9dfc-42446b39c595", "fitness": 0.07205136995624445, "name": "RefinedHybridDE_SA", "description": "Integrate a dynamic adaptation of population size and mutation strategies based on convergence trends to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.max_pop_size = 20 * self.dim\n        self.min_pop_size = 5 * self.dim\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub, pop_size):\n        self.population = np.random.uniform(lb, ub, (pop_size, self.dim))\n        self.fitness = np.full(pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(len(self.population)))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def adapt_population_size(self):\n        if self.fitness.std() < 1e-3:\n            new_size = max(self.min_pop_size, int(len(self.population) * 0.9))\n        else:\n            new_size = min(self.max_pop_size, int(len(self.population) * 1.1))\n        if new_size != len(self.population):\n            selected_indices = np.argsort(self.fitness)[:new_size]\n            self.population = self.population[selected_indices]\n            self.fitness = self.fitness[selected_indices]\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub, self.initial_pop_size)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n\n            self.evaluate_population(func)\n            evaluations += len(self.population)\n\n            for i in range(len(self.population)):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            self.adapt_population_size()\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 7, "feedback": "The algorithm RefinedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07205 with standard deviation 0.05251.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.013419259028851882, 0.024056597875143138, 0.012760158023609747, 0.05737588729495746, 0.05527493992805399, 0.058256058249089415, 0.14432737514899596, 0.14018789079090366, 0.14280416326659473]}}
{"id": "ff0fc343-c6bb-4d24-9c00-b9e9bab99c71", "fitness": 0.07217970503582909, "name": "EnhancedHybridDE_SA_Swarm", "description": "Improve solution quality by incorporating adaptive parameter control and swarm intelligence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Swarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.global_best = None\n        self.global_best_fitness = np.inf\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def update_global_best(self):\n        current_best_idx = np.argmin(self.fitness)\n        current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n        if current_best_fitness < self.global_best_fitness:\n            self.global_best, self.global_best_fitness = current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + np.random.rand() * 0.5  # Adaptive mutation rate\n                crossover_prob = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            self.update_global_best()\n\n            if self.global_best_fitness < np.inf:\n                self.global_best, self.global_best_fitness = self.adaptive_simulated_annealing(self.global_best, self.global_best_fitness)\n\n            self.temperature *= 0.92  # Adjusted temperature decay rate\n\n            if evaluations >= self.budget:\n                break\n\n        return self.global_best, self.global_best_fitness", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedHybridDE_SA_Swarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07218 with standard deviation 0.05281.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.01337897006810107, 0.019517470991671226, 0.0129415043237745, 0.05737588729495746, 0.06082802518837371, 0.058256058249089415, 0.14432737514899596, 0.14018789079090366, 0.14280416326659473]}}
{"id": "a5e84fc5-9ee1-4304-812d-6d2bd288e6ca", "fitness": 0.07345939828497514, "name": "EnhancedHybridDE_SA", "description": "Integrate a multi-strategy mutation mechanism and adaptive crossover probabilities to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        strategies = [\n            lambda a, b, c: self.population[a] + scale_factor * (self.population[b] - self.population[c]),\n            lambda a, b, c: self.population[a] + scale_factor * (self.population[b] - self.population[c]) + scale_factor * (self.population[a] - self.population[c])\n        ]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        chosen_strategy = np.random.choice(strategies)\n        mutant = chosen_strategy(a, b, c)\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = 0.5 + 0.5 * ((self.budget - evaluations) / self.budget) # Adaptive crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07346 with standard deviation 0.05663.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.011756165276757158, 0.014757142171291648, 0.013452511704860837, 0.06264601733118813, 0.05571332272164842, 0.057860375456386226, 0.1378755068543337, 0.14018789079090366, 0.16688565225740648]}}
{"id": "7b909eae-91c3-464c-89a9-c2a0b69510d0", "fitness": 0.0746004188190109, "name": "EnhancedHybridDE_SA_LocalSearch", "description": "Introduce a self-adaptive parameter strategy and integrate a local search phase, enhancing convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_LocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def local_search(self, candidate, candidate_fitness):\n        for _ in range(3):\n            perturbation = np.random.normal(0, 0.05, self.dim)\n            new_candidate = candidate + perturbation\n            new_candidate = np.clip(new_candidate, self.lb, self.ub)\n            new_fitness = self.func(new_candidate)\n            if new_fitness < candidate_fitness:\n                candidate, candidate_fitness = new_candidate, new_fitness\n        return candidate, candidate_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            if np.random.rand() < 0.3:  # 30% chance to perform local search\n                best_solution, best_fitness = self.local_search(best_solution, best_fitness)\n\n            self.temperature *= 0.92  # Adjusted temperature decay rate\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedHybridDE_SA_LocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07460 with standard deviation 0.05438.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.013338258954438742, 0.01987402551897366, 0.013343563465675334, 0.05932403430010458, 0.06637084557805772, 0.05977965319188128, 0.14468158117649565, 0.1402525233918086, 0.15443928379366256]}}
{"id": "3440bc42-5eec-4901-82e0-7b6a2215e0b2", "fitness": 0.07192761086658842, "name": "EnhancedHybridDE_SA", "description": "Improve population diversity by introducing Gaussian noise in the initialization phase.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim)) + np.random.normal(0, 0.01, (self.pop_size, self.dim))  # Introduce Gaussian noise\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92  # Adjusted temperature decay rate\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07193 with standard deviation 0.05234.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.012382673754019247, 0.015436932844969387, 0.020790958899411405, 0.0635651222051713, 0.0504076151858166, 0.05981625092686338, 0.1401123398416496, 0.13806824395767836, 0.14676836018371642]}}
{"id": "dc6e28ad-5efe-4ad9-bb77-5655310e20a4", "fitness": 0.07306739107156174, "name": "EnhancedHybridDE_SA", "description": "Leverage a multi-phase adaptive strategy combining DE with adaptively scheduled simulated annealing and dynamic population size adjustment.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.adaptive_cooling_rate = 0.95\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(len(self.population)))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        pop_size = self.initial_pop_size\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += pop_size\n\n            for i in range(pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= self.adaptive_cooling_rate  # Adaptive temperature decay\n\n            pop_size = int(pop_size * 0.95)  # Gradual reduction of population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07307 with standard deviation 0.05266.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.013800111776125279, 0.019995613632783682, 0.01366852117724826, 0.056221086396101794, 0.06539755856574558, 0.060208973494449425, 0.14532260054410473, 0.14018789079090366, 0.1428041632665933]}}
{"id": "e9b90592-186d-4110-9cf4-9b08bffc7302", "fitness": 0.07343619093006329, "name": "EnhancedHybridDE_SA_Adaptive", "description": "Introduce a self-adaptive strategy that dynamically adjusts mutation and crossover rates based on population diversity, while incorporating an elite preservation mechanism to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def calculate_diversity(self):\n        pairwise_distances = np.sum((self.population[np.newaxis, :, :] - self.population[:, np.newaxis, :])**2, axis=2)\n        max_distance = np.max(pairwise_distances)\n        avg_distance = np.mean(pairwise_distances)\n        return avg_distance / max_distance if max_distance > 0 else 0\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        elite_solution = None\n        elite_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            diversity = self.calculate_diversity()\n            scale_factor = 0.5 + 0.5 * diversity\n            crossover_prob = 0.7 + 0.3 * (1 - diversity)\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            if current_best_fitness < elite_fitness:\n                elite_solution, elite_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n        return elite_solution, elite_fitness", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedHybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07344 with standard deviation 0.05378.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.01305775815374155, 0.015089105705803685, 0.016162445928842528, 0.06507704251646251, 0.053832459322288306, 0.06435465995183676, 0.13966265467455974, 0.14800487441205956, 0.14568471770497493]}}
{"id": "0d8edcf7-0a94-4115-a7f4-14bd9f4fe937", "fitness": -Infinity, "name": "EnhancedHybridDE_LF_SA", "description": "Integrate Lvy Flights to enhance exploration and refine temperature decay dynamically for balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_LF_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.temperature_decay = 0.92\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def levy_flight(self, current_best):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return current_best + step\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0) \n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            if evaluations < 0.5 * self.budget: \n                best_solution = self.levy_flight(best_solution)\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= self.temperature_decay\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 14, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {}}
{"id": "5f57360d-6507-4b9d-9fab-d0f9cb370bf1", "fitness": 0.09695464924359509, "name": "EnhancedHybridDE_SA", "description": "Introduce a non-linear temperature decay rate and dynamic population size adaption for improved convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09695 with standard deviation 0.06270.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.20991799010379453, 0.020543577347015618, 0.015423729238919104, 0.06892843601285292, 0.05903711103410647, 0.06445534717403234, 0.1443273751489912, 0.14628982797548862, 0.14366844915715504]}}
{"id": "39423513-ac6d-4657-b756-9f889a9fea04", "fitness": 0.07753280012293612, "name": "EnhancedHybridDE_SA", "description": "Introduce adaptive crossover rate modification and refined temperature decay for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                # Changed line: Adaptive crossover rate based on evaluations\n                crossover_prob = 0.8 + 0.2 * (1 - evaluations / self.budget)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            # Changed line: Adjusted temperature decay formula for smoother transitions\n            self.temperature *= 0.94 + 0.06 * np.tanh(0.05 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07753 with standard deviation 0.05331.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013046981559853954, 0.015748899058196653, 0.014953752253907826, 0.07622285204089063, 0.0659559193838255, 0.07824286122557633, 0.1380879966588755, 0.15047115401068623, 0.1450647849146124]}}
{"id": "b380f12d-73d4-4835-b2a4-bb03b71f317f", "fitness": 0.0743947704439667, "name": "EnhancedHybridDE_SA", "description": "Introduce a dynamic mutation strategy and enhance adaptive simulated annealing acceptance criteria to improve convergence stability.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            acceptance_prob = np.exp(delta_fitness / (self.temperature / (1 + np.abs(delta_fitness))))  # Enhanced acceptance\n            if delta_fitness > 0 or acceptance_prob > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.4, 0.9)  # Dynamic mutation strategy\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07439 with standard deviation 0.05195.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013697996124563017, 0.02086500522381951, 0.017893037212304064, 0.06612330990848048, 0.06192986846705417, 0.060360492363060736, 0.13859381433252171, 0.14167507801670964, 0.14841433234718693]}}
{"id": "7b13a900-f175-46df-a9ba-3b3a25f0e0df", "fitness": 0.07691406522784039, "name": "EnhancedHybridDE_SA", "description": "Apply dynamic crossover rate and adaptive mutation strategy for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.6, 1.2)  # Adjusted for adaptability\n                crossover_prob = 0.8 + 0.2 * np.sin(0.1 * evaluations / self.budget * np.pi)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07691 with standard deviation 0.05468.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013859559776290942, 0.014732422558393354, 0.012443913929109152, 0.0709635647997594, 0.06573424173949183, 0.07456172214494972, 0.1430141223707846, 0.14018789079090366, 0.15672914894088086]}}
{"id": "6cc90f17-8173-4347-857d-6f91ba298c8c", "fitness": 0.07503447808002899, "name": "EnhancedHybridDE_SA", "description": "Introduce dynamic mutation rate adaption based on population diversity for improved exploration in EnhancedHybridDE_SA.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            # Dynamic mutation rate based on population diversity\n            diversity = np.std(self.population, axis=0).mean()\n            self.mutation_rate = 0.5 + 0.5 * (1 - diversity / (self.ub - self.lb).mean())\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07503 with standard deviation 0.05314.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.01263644963169952, 0.020543577347015618, 0.015423729238919104, 0.06892843601285292, 0.05903711103410647, 0.06445534717403234, 0.1443273751489912, 0.14628982797548862, 0.14366844915715504]}}
{"id": "93b98fe4-4d4d-4aba-bf4e-1dca3be8bee0", "fitness": 0.0740389664089585, "name": "ImprovedAdaptiveHybridDE_SA", "description": "Combine adaptive learning rates with a stochastic constraint handling mechanism to enhance exploration and exploitation in a dynamic environment.", "code": "import numpy as np\n\nclass ImprovedAdaptiveHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def adaptive_parameters(self):\n        return 0.5 + 0.5 * np.tanh(0.1 * self.evaluations / self.budget)\n\n    def stochastic_constraint_handling(self, trial):\n        if np.random.rand() < self.constraint_prob:\n            trial = np.random.uniform(self.lb, self.ub, self.dim)\n        return trial\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        self.evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        self.constraint_prob = 0.1\n\n        while self.evaluations < self.budget:\n            self.evaluate_population(func)\n            self.evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = self.adaptive_parameters()\n                crossover_prob = self.adaptive_parameters()\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial = self.stochastic_constraint_handling(trial)\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * self.evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n            self.constraint_prob = 0.1 + 0.1 * np.sin(0.1 * self.evaluations / self.budget)\n\n            if self.evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 20, "feedback": "The algorithm ImprovedAdaptiveHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07404 with standard deviation 0.05212.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.014428120973721814, 0.017944148510409152, 0.013957736715893176, 0.06373985046217223, 0.060221337980867484, 0.07091417051194504, 0.13444693169040856, 0.14819089944825603, 0.142507501386953]}}
{"id": "d709eaa6-64a9-49cd-9486-d6048800c66f", "fitness": 0.0750269248683102, "name": "EnhancedHybridDE_SA", "description": "Incorporate adaptive learning rates and elite preservation to enhance exploration and exploitation balance in the optimization process.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.init_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.init_pop_size, self.dim))\n        self.fitness = np.full(self.init_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.init_pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.init_pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        learning_rate = 0.5\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.init_pop_size\n\n            elite_size = int(self.elite_fraction * self.init_pop_size)\n            elite_indices = np.argsort(self.fitness)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            for i in range(self.init_pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n                # Incorporate elite information\n                if i in elite_indices:\n                    elite_member = elite_population[np.random.randint(elite_size)]\n                    trial = learning_rate * trial + (1 - learning_rate) * elite_member\n                    trial_fitness = func(trial)\n                    evaluations += 1\n                    self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.init_pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07503 with standard deviation 0.05027.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.019347272849151498, 0.019199418052548545, 0.017663596302969653, 0.06332404802333935, 0.07245265537950041, 0.06183872927705847, 0.13459219628546315, 0.14018789079090366, 0.14663651685385704]}}
{"id": "9f8d7b25-d05b-4935-ad74-d044daa50035", "fitness": 0.07684801374020975, "name": "EnhancedHybridDE_SA", "description": "Implement exponential decay in temperature and enhance crossover probability for faster convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.85, 1.0)  # Enhanced crossover probability (change 1)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= np.exp(-0.05 * evaluations / self.budget)  # Exponential temperature decay (change 2)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07685 with standard deviation 0.04839.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.02665236816200034, 0.03642393629881602, 0.01366061404658081, 0.055720613284405585, 0.058620616463661235, 0.07919960557690375, 0.13865897765166335, 0.14018789079090366, 0.142507501386953]}}
{"id": "14c526d6-51c7-4e12-b037-23d1a5dc14e8", "fitness": 0.07536030048676551, "name": "EnhancedHybridDE_SA", "description": "Introduce adaptive crossover and scale factor strategies based on population diversity to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                diversity = np.std(self.population, axis=0).mean()\n                scale_factor = np.random.uniform(0.5, 1.0) * (1 + 0.1 * diversity)  # Adaptive scale factor\n                crossover_prob = np.random.uniform(0.8, 1.0) * (1 - 0.1 * diversity)  # Adaptive crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07536 with standard deviation 0.05345.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.014239860639234103, 0.015532082426283123, 0.018607163328035803, 0.0725309497063169, 0.05709418721391768, 0.06445534717403234, 0.13915958866321965, 0.14846536028099822, 0.1481581649488517]}}
{"id": "f612708f-2eec-4948-aeed-b859217dfd29", "fitness": 0.07298500495797539, "name": "EnhancedHybridDE_SA", "description": "Integrate an adaptive differential mutation strategy and flexible crossover probability for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.random.rand()  # Adaptive scale factor\n                crossover_prob = 0.7 + 0.3 * np.random.rand()  # Flexible crossover probability\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07299 with standard deviation 0.05261.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013996266466596352, 0.015488233667482532, 0.01405145756399706, 0.06162566645356149, 0.06130480883691991, 0.06445534717403234, 0.13755376517300988, 0.14588199789922596, 0.142507501386953]}}
{"id": "df3caf94-bbcf-4ce6-8ffa-15230e845642", "fitness": 0.07145533957067075, "name": "EnhancedHybridDE_SA_Opposition", "description": "Introduce adaptive step size control and opposition-based learning for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Opposition:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def opposition_based_learning(self):\n        opp_population = self.lb + self.ub - self.population\n        opp_population = np.clip(opp_population, self.lb, self.ub)\n        opp_fitness = np.array([self.func(ind) for ind in opp_population])\n        return opp_population, opp_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        step_size = 0.1\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            # Opposite learning\n            opp_population, opp_fitness = self.opposition_based_learning()\n            combined_population = np.vstack((self.population, opp_population))\n            combined_fitness = np.hstack((self.fitness, opp_fitness))\n            best_indices = np.argpartition(combined_fitness, self.pop_size)[:self.pop_size]\n            self.population, self.fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor + step_size)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            step_size *= 0.95  # Adaptive step size control\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedHybridDE_SA_Opposition got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07146 with standard deviation 0.05135.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.015669097743745253, 0.015915263917513522, 0.014551615584374566, 0.06717688774705588, 0.052016133389111596, 0.06050892277977482, 0.13294786964103478, 0.14137638721771162, 0.14293587811571473]}}
{"id": "170ea8e4-0510-480f-bd57-4fc6c66ec604", "fitness": 0.07347314947553368, "name": "EnhancedHybridDE_SA", "description": "Enhance convergence by increasing mutation diversity with a variable scale factor range.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.4, 1.2)  # Adjusted scale factor range\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07347 with standard deviation 0.05133.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.015520993901239288, 0.022406024370998034, 0.014990851788458492, 0.06004550008317211, 0.059485991225352586, 0.06445534717403234, 0.139782757423892, 0.14051430510125762, 0.1440565742114006]}}
{"id": "5d4b1677-abdc-47f0-8f06-8ebbffe491b1", "fitness": -Infinity, "name": "EnhancedHybridDE_LevySA", "description": "Enhance the exploration-exploitation balance by integrating a Lvy flight mechanism in mutation and introducing adaptive crossover rates based on diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDE_LevySA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def levy_flight(self, size, beta=1.5):\n        sigma_u = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                   (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma_u, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def mutate(self, target_idx):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        levy_step = self.levy_flight(self.dim)\n        mutant = self.population[a] + self.mutation_rate * (self.population[b] - self.population[c]) + levy_step\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, diversity_factor):\n        crossover_prob = self.crossover_rate * (1 + diversity_factor)\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            diversity = np.std(self.population, axis=0)\n            diversity_factor = np.mean(diversity) / (self.ub - self.lb)\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant, diversity_factor)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 27, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {}}
{"id": "bb279dc3-4e64-4095-91b1-fe3a142d5136", "fitness": 0.08345442868429813, "name": "EnhancedHybridDE_SA", "description": "Enhanced cooling and dynamic parameter adaptation for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.6, 1.2)  # Modified scale factor range\n                crossover_prob = np.random.uniform(0.85, 1.0)  # Modified crossover probability range\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08345 with standard deviation 0.05125.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.11244925814057549, 0.015532082426283123, 0.01312991200162339, 0.05399199750115169, 0.05738458933269208, 0.06445534717403234, 0.15145127940446834, 0.14018789079090366, 0.142507501386953]}}
{"id": "6ad1b09d-2f62-4679-94c1-7c49c3044ffa", "fitness": 0.06907903206147122, "name": "EnhancedHybridDE_StochasticTunneling", "description": "Enhance convergence by introducing a multi-phase optimization strategy combining DE with stochastic tunneling and adaptive parameter tuning.", "code": "import numpy as np\n\nclass EnhancedHybridDE_StochasticTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(5, int(10 * self.dim))\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1.0\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def stochastic_tunneling(self, candidate, candidate_fitness):\n        g = np.exp(-candidate_fitness / self.temperature)\n        return g, candidate, candidate_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            g, tunneling_solution, tunneling_fitness = self.stochastic_tunneling(best_solution, best_fitness)\n            if g > np.random.rand():\n                best_solution, best_fitness = tunneling_solution, tunneling_fitness\n\n            self.temperature *= 0.9 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedHybridDE_StochasticTunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06908 with standard deviation 0.05424.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.011990921779448493, 0.01665878958348166, 0.01233315241309585, 0.045261828364884904, 0.0530322971629108, 0.05464901592801408, 0.1443273751489974, 0.1406537449058124, 0.1428041632665954]}}
{"id": "7bd87502-1407-4cbc-aa41-6909ff56fb3c", "fitness": 0.08384240591953535, "name": "EnhancedHybridDE_SA_Refined", "description": "Integrate a self-adaptive mutation strategy and incorporate a cooperative approach among population members to enhance explorative capabilities and convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def cooperative_mutation(self, target_idx):\n        partner_idx = np.random.choice([i for i in range(self.pop_size) if i != target_idx])\n        partner = self.population[partner_idx]\n        scale_factor = np.random.uniform(0.5, 1.0)\n        return self.mutate(target_idx, scale_factor) * 0.5 + partner * 0.5\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                if np.random.rand() < 0.5:\n                    mutant = self.mutate(i, np.random.uniform(0.5, 1.0))\n                else:\n                    mutant = self.cooperative_mutation(i)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedHybridDE_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08384 with standard deviation 0.04685.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.024021546471524102, 0.03563674920064952, 0.031608706328707936, 0.07344362961431095, 0.08458243055802905, 0.07316320665350307, 0.1486410214689643, 0.14097686159317613, 0.142507501386953]}}
{"id": "b11ebf59-df03-4e5a-9a16-9cfefed62ef4", "fitness": 0.07555597237488106, "name": "EnhancedHybridDE_SA", "description": "Enhance dynamic scaling of mutation and crossover rates to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.6, 1.2)  # Changed from 0.5 to 0.6 and 1.0 to 1.2\n                crossover_prob = np.random.uniform(0.9, 1.2)  # Changed from 0.8 to 0.9 and 1.0 to 1.2\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07556 with standard deviation 0.05320.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.015131219965601517, 0.015532082426283123, 0.015373896197558912, 0.0698513428036247, 0.05715956495040464, 0.0746274106863114, 0.13722129486760404, 0.1525994380895882, 0.142507501386953]}}
{"id": "75920e9e-83f7-4edb-8067-58479d85960a", "fitness": 0.07763271303790503, "name": "EnhancedHybridDE_SA", "description": "Integrate adaptive differential evolution with variable mutation and crossover strategies, while combining simulated annealing with entropy-based cooling for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        scale_factor = np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        crossover_prob = np.random.uniform(0.6, 1.0)\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            acceptance_prob = np.exp(delta_fitness / self.temperature)\n            if delta_fitness > 0 or acceptance_prob > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def entropy_based_cooling(self, evaluations):\n        return 0.9 + 0.1 * np.tanh(0.01 * np.log1p(evaluations))\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= self.entropy_based_cooling(evaluations)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07763 with standard deviation 0.05344.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.012836470649042364, 0.015544513340687405, 0.013933554600604525, 0.07398983677520721, 0.07199089319224916, 0.07652595311525356, 0.13761722502094753, 0.1504339612059301, 0.14582200944122337]}}
{"id": "a296f6f9-77ac-4d76-92e3-2d4195084b39", "fitness": 0.07503447808002899, "name": "RefinedHybridDE_SA", "description": "Combine differential evolution with adaptive simulated annealing and introduce self-adaptive control parameters for more efficient exploration and exploitation.", "code": "import numpy as np\n\nclass RefinedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def self_adaptive_parameters(self):\n        self.mutation_rate = np.random.uniform(0.5, 1.0)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                self.self_adaptive_parameters()\n                mutant = self.mutate(i, self.mutation_rate)\n                trial = self.crossover(self.population[i], mutant, self.crossover_rate)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 33, "feedback": "The algorithm RefinedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07503 with standard deviation 0.05314.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.01263644963169952, 0.020543577347015618, 0.015423729238919104, 0.06892843601285292, 0.05903711103410647, 0.06445534717403234, 0.1443273751489912, 0.14628982797548862, 0.14366844915715504]}}
{"id": "0e789b94-76b9-480b-84a0-02610dba2797", "fitness": 0.08060146164094878, "name": "EnhancedHybridDE_SA_Improved", "description": "Implement a multi-phase mutation strategy and adaptive learning rate to enhance convergence precision and robustness.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, phase):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        if phase == 1:\n            scale_factor = np.random.uniform(0.5, 1.0)\n        else:\n            scale_factor = np.random.uniform(0.7, 1.2)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, phase):\n        if phase == 1:\n            crossover_prob = np.random.uniform(0.8, 0.9)\n        else:\n            crossover_prob = np.random.uniform(0.9, 1.0)\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            phase = 1 if evaluations < self.budget * 0.5 else 2\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i, phase)\n                trial = self.crossover(self.population[i], mutant, phase)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedHybridDE_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08060 with standard deviation 0.05440.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.019511740518602383, 0.015534172039137317, 0.014142972820248567, 0.0743420269288253, 0.07598916039540726, 0.07844863802225654, 0.14262233780789257, 0.15574606952041947, 0.14907603671574954]}}
{"id": "e45b89dd-ebab-4735-92f2-713c0107dc33", "fitness": -Infinity, "name": "EnhancedHybridDE_SA", "description": "Incorporate an adaptive mutation scale and enhanced annealing acceptance criteria for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature * (1 - self.budget/1000), self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            acceptance_prob = np.exp(delta_fitness / (self.temperature * (1 + np.abs(delta_fitness))))\n            if delta_fitness > 0 or acceptance_prob > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.3, 0.9)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 35, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {}}
{"id": "c1ce9b2e-f2cd-4d79-9ba5-3599e4799e1e", "fitness": 0.09692702343808854, "name": "EnhancedHybridDE_SA_v2", "description": "Introducing adaptive mutation and crossover rates based on convergence speed and adaptive cooling schedule in Simulated Annealing for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        convergence_speed = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0) * convergence_speed\n                crossover_prob = np.random.uniform(0.8, 1.0) * (1 - convergence_speed)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n                convergence_speed = 0.5\n            else:\n                convergence_speed = min(1.0, convergence_speed + 0.1)\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Adaptive cooling schedule\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedHybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09693 with standard deviation 0.06295.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.2123955347421096, 0.020044046569425933, 0.01488636941278132, 0.05908798387502445, 0.06015719917907136, 0.07582692997246132, 0.1437230208849828, 0.1437146249199871, 0.142507501386953]}}
{"id": "5a698545-5a8c-4293-8501-8b5c4aaf44e7", "fitness": 0.07424781939429684, "name": "EnhancedHybridDE_SA", "description": "Refine EnhancedHybridDE_SA by introducing the levy flight mutation and adaptive crossover rate based on population diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=size)\n        v = np.random.normal(0, 1, size=size)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + self.levy_flight(self.dim)\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_crossover_rate(self):\n        diversity = np.std(self.population, axis=0).mean()\n        self.crossover_rate = 0.8 + 0.2 * (1 - diversity / (self.ub - self.lb).mean())\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                self.adaptive_crossover_rate()\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, self.crossover_rate)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07425 with standard deviation 0.05397.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013980099558438042, 0.015202187233383069, 0.013751741509237525, 0.07213267146466451, 0.05785508712330101, 0.06067072856546585, 0.14476965499293848, 0.14236328634744044, 0.1475049177538026]}}
{"id": "502ad78e-6326-4b30-903a-08541e8e6262", "fitness": 0.07308272776710129, "name": "EnhancedHybridDE_SA_Refined", "description": "Integrate a self-adaptive control parameter mechanism and elitist selection strategy to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.scale_factor = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.crossover_prob = np.random.uniform(0.8, 1.0, self.pop_size)\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.scale_factor[target_idx] * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, target_idx):\n        cross_points = np.random.rand(self.dim) < self.crossover_prob[target_idx]\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant, i)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n                # Self-adaptive mechanism\n                if trial_fitness < self.fitness[i]:\n                    self.scale_factor[i] = np.random.uniform(0.5, 1.0)\n                    self.crossover_prob[i] = np.random.uniform(0.8, 1.0)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedHybridDE_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07308 with standard deviation 0.05306.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.015138865427960169, 0.015040114487679945, 0.014063324429911206, 0.058347057749498776, 0.0664204796779263, 0.059789727659463776, 0.14076606937937775, 0.1405005998627752, 0.14767831122931852]}}
{"id": "9969f221-6141-432e-93c5-917063794fd1", "fitness": 0.07620404803522024, "name": "EnhancedHybridDE_SA", "description": "Introduce a dynamic mutation scaling and temperature scaling factor to enhance exploration and convergence balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + np.random.rand() * (1.0 - 0.5 * evaluations / self.budget)  # Dynamic scaling\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget) * (1 - evaluations / (2 * self.budget)) # Adjusted non-linear temp decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07620 with standard deviation 0.05392.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.01396915971169943, 0.02206699941216239, 0.014327175025627747, 0.05243799470069943, 0.07607618697946839, 0.06722376325733348, 0.14967928471725078, 0.14754836712578756, 0.142507501386953]}}
{"id": "0662e0f5-479a-42bf-86a8-6b154afe1453", "fitness": 0.07817461672918431, "name": "EnhancedHybridDE_SA", "description": "Introduce a diversity-preserving mutation strategy and adaptive crossover rate for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        centroid = np.mean(self.population, axis=0)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + 0.1 * (centroid - self.population[a])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = 0.8 + 0.2 * np.tanh(0.1 * evaluations / self.budget) # Adaptive crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07817 with standard deviation 0.05453.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.01652937703875368, 0.019297694411840483, 0.014362432911484091, 0.07602526455138614, 0.0640780272999043, 0.06706470055350866, 0.1442471245742022, 0.1588618935563757, 0.1431050356652036]}}
{"id": "8adf09c6-8bdb-49ec-8103-29199f8d7f97", "fitness": 0.07756596970516398, "name": "EnhancedHybridDE_SA", "description": "Introduce adaptive mutation scaling and dynamic crossover probability for enhanced convergence capabilities.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.4, 1.2)  # Line changed: Adaptive mutation scaling\n                crossover_prob = 0.8 + 0.2 * (1 - evaluations / self.budget)  # Line changed: Dynamic crossover probability\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07757 with standard deviation 0.05415.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013486173893265674, 0.015932877967450687, 0.018543648165039395, 0.07602526455138614, 0.061002601730342776, 0.07084208266148284, 0.15054064262262612, 0.14921293436792915, 0.142507501386953]}}
{"id": "c4848fee-898e-4292-9107-b151e283e6c8", "fitness": -Infinity, "name": "ImprovedHybridDE_SA", "description": "Integrate adaptive differential evolution with stochastic rank-based selection and temperature-controlled mutation rate for enhanced diversity and convergence.", "code": "import numpy as np\n\nclass ImprovedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def stochastic_rank_selection(self):\n        ranks = np.argsort(self.fitness)\n        selection_probs = (2.0 / self.pop_size) * (self.pop_size - ranks) / (self.pop_size + 1)\n        return np.random.choice(ranks, p=selection_probs)\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = self.stochastic_rank_selection()\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 42, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {}}
{"id": "49069e26-0dfc-42ea-ad46-5bc1d772f409", "fitness": 0.10988849984077362, "name": "EnhancedHybridDE_SA", "description": "Introduce a dynamic non-linear scale factor adjustment to enhance exploration.  ", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Dynamic non-linear scale factor adjustment\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10989 with standard deviation 0.07970.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.292946109291058, 0.015944308556707032, 0.016335637534589775, 0.07602526455138614, 0.07390534542108429, 0.08739113955883027, 0.1436269556854589, 0.14018789079090366, 0.1426338471769445]}}
{"id": "2cfcc463-19f7-4cbe-b156-fc2b98574f83", "fitness": 0.07467488526326013, "name": "EnhancedHybridDE_SA", "description": "Enhance selection and mutation interaction with feedback from candidate solutions.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            if np.random.rand() < 0.2:  # Increased selection pressure\n                self.mutation_rate += 0.05  # Encourage exploration\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Dynamic non-linear scale factor adjustment\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07467 with standard deviation 0.04909.", "error": "", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {"aucs": [0.023100484350398798, 0.02082450613728748, 0.017549407334845002, 0.06341883984541796, 0.0628076270988095, 0.06724285302528976, 0.13061343723990348, 0.141471299084165, 0.14504551325322423]}}
{"id": "076cac1c-ed1f-40e9-aba3-6a189f617093", "fitness": 0.07064031057414198, "name": "AdaptiveMultiPhaseOptimizer", "description": "Introduce adaptive multi-phase strategy with dynamic exploration-exploitation balance and local search intensification using neighborhood perturbation.", "code": "import numpy as np\n\nclass AdaptiveMultiPhaseOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def neighborhood_perturbation(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.02, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            if candidate_fitness < current_best_fitness:\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                phase = evaluations / self.budget\n                scale_factor = 0.5 + 0.5 * np.sin(np.pi * phase)  # Adaptive scale factor\n                crossover_prob = 0.8 + 0.2 * (1 - phase)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.neighborhood_perturbation(best_solution, best_fitness)\n\n            self.temperature *= 0.95 + 0.05 * np.tanh(0.1 * evaluations / self.budget)  # Adaptive temperature decay\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 45, "feedback": "The algorithm AdaptiveMultiPhaseOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07064 with standard deviation 0.05472.", "error": "", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {"aucs": [0.013525116552920102, 0.014431037387787948, 0.012525247225223413, 0.053544724377945885, 0.0510429247159242, 0.05767291349419823, 0.14621623402782524, 0.1442970959985027, 0.14250750138695012]}}
{"id": "7ee5bee0-7467-46ce-8da0-f15c95170ef6", "fitness": 0.07813087900305242, "name": "EnhancedHybridDE_SA", "description": "Introduce a small probabilistic mutation for better local search precision.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Dynamic non-linear scale factor adjustment\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n            if np.random.rand() < 0.05:  # Introduce probabilistic mutation for precision\n                mutation_step = np.random.normal(0, 0.01, self.dim)\n                best_solution = np.clip(best_solution + mutation_step, self.lb, self.ub)\n                best_fitness = func(best_solution)\n\n        return best_solution, best_fitness", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07813 with standard deviation 0.05217.", "error": "", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {"aucs": [0.013701720677572138, 0.016557687438955804, 0.016553811591284995, 0.07533358031501725, 0.07481239810814011, 0.07639130062667687, 0.1428678467848612, 0.14158341737272595, 0.14537614811223742]}}
{"id": "b7a5dd2c-f7b4-4fca-936b-1e4c7b6c6d31", "fitness": 0.07504376932735082, "name": "EnhancedHybridDE_SA", "description": "Introduce a dynamic crossover rate adjustment to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Dynamic non-linear scale factor adjustment\n                crossover_prob = 0.85 + 0.15 * np.sin(np.pi * evaluations / self.budget)  # Dynamic crossover rate adjustment\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07504 with standard deviation 0.04844.", "error": "", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {"aucs": [0.02043081744907127, 0.02759699087736245, 0.0189622709544095, 0.06955386083018322, 0.05109787487210593, 0.07230780099673229, 0.13274891578843606, 0.14018789079090366, 0.142507501386953]}}
{"id": "0ff6f864-a3b1-4c17-b324-a6d242743067", "fitness": 0.07361219426765252, "name": "EnhancedHybridDE_SA", "description": "Introduce a dynamic crossover rate adjustment to enhance diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Dynamic non-linear scale factor adjustment\n                crossover_prob = 0.8 + 0.2 * np.sin(np.pi * evaluations / self.budget)  # Dynamic crossover rate adjustment\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07361 with standard deviation 0.04965.", "error": "", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {"aucs": [0.022269256952753946, 0.024102415822199408, 0.015065099419923289, 0.05625724540181598, 0.054278942271279496, 0.07245186676056115, 0.13538952960248274, 0.14018789079090366, 0.142507501386953]}}
{"id": "3adb4c2a-ce24-45d0-8a7e-0345d35db097", "fitness": 0.07639929021322174, "name": "EnhancedHybridDE_SA_v2", "description": "Introduce a dynamic exploration-exploitation balance using adaptive crossover and mutation based on the fitness diversity of the population.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def fitness_diversity(self):\n        return np.std(self.fitness) / np.mean(self.fitness)\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            diversity = self.fitness_diversity()\n            adaptive_crossover_prob = 0.9 - 0.3 * diversity\n            adaptive_mutation_rate = 0.8 + 0.2 * diversity\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                mutant = self.mutate(i, adaptive_mutation_rate * scale_factor)\n                trial = self.crossover(self.population[i], mutant, adaptive_crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedHybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07640 with standard deviation 0.04941.", "error": "", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {"aucs": [0.01411267173495434, 0.02609602925336718, 0.019988368824321978, 0.06955386083018322, 0.0648258630442069, 0.07270435348449633, 0.1376170725696091, 0.14018789079090366, 0.142507501386953]}}
{"id": "d8063989-e2bc-4541-ac1d-81ac62c4f99f", "fitness": 0.07617438360136279, "name": "EnhancedHybridDE_SA", "description": "Enhance exploration and exploitation by adjusting mutation strategy using a cosine function.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Dynamic non-linear scale factor adjustment\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, np.cos(np.pi * evaluations / self.budget))  # Adjusted mutation strategy\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07617 with standard deviation 0.05266.", "error": "", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {"aucs": [0.014322842160570448, 0.016452527627744518, 0.014029887471236124, 0.07602526455138614, 0.06439649404418735, 0.0716416475422943, 0.13327175471931163, 0.152658411703108, 0.14277062259242657]}}
{"id": "8fd2834d-998e-4d37-9e03-1c400a4e8a22", "fitness": 0.07428560564910643, "name": "EnhancedHybridDE_SA", "description": "Improve convergence by incorporating differential weight and crossover rate adaptation based on population diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def diversity(self):\n        return np.std(self.population)\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                diversity = self.diversity() / self.dim\n                scale_factor = (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)) * (1 + diversity)\n                crossover_prob = np.random.uniform(0.8, 1.0) * (1 - diversity)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07429 with standard deviation 0.05232.", "error": "", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {"aucs": [0.01385607196089178, 0.014732422558393354, 0.01479033929835305, 0.07187461968948472, 0.06624574906186886, 0.06242980572088619, 0.13460029657557215, 0.14018789079090366, 0.1498532551856041]}}
{"id": "5b983d32-8bd0-4cbe-af79-af538704c9e5", "fitness": -Infinity, "name": "EnhancedHybridDE_SA", "description": "Integrate a dynamically adaptive mutation strategy with enhanced environmental selection pressure to improve convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.initial_pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.initial_pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        dynamic_pop_size = self.initial_pop_size\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += dynamic_pop_size\n\n            for i in range(dynamic_pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            dynamic_pop_size = max(5, int(self.initial_pop_size * (1 - evaluations / self.budget) ** 0.5))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 52, "feedback": "An exception occurred: TypeError(\"can't convert complex to int\").", "error": "TypeError(\"can't convert complex to int\")", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {}}
{"id": "70b3a050-3f9c-4724-af60-b2ff10b9474e", "fitness": 0.14424272844522013, "name": "EnhancedHybridDE_SA", "description": "Integrate a self-adaptive mutation strategy and enhanced local search to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14424 with standard deviation 0.17953.", "error": "", "parent_ids": ["49069e26-0dfc-42ea-ad46-5bc1d772f409"], "operator": null, "metadata": {"aucs": [0.634066892175484, 0.01692179760356949, 0.016001584951606862, 0.0687080112006011, 0.061002601730342776, 0.07456172214494972, 0.14422655402257056, 0.14018789079090366, 0.142507501386953]}}
{"id": "d56aaff1-e2dc-47b9-abb6-01c9b628df38", "fitness": -Infinity, "name": "EnhancedHybridDE_SA", "description": "Integrate adaptive learning rates and improve local search efficiency in the EnhancedHybridDE_SA algorithm.  ", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            learning_rate = 0.1 * np.exp(-(self.budget - evaluations) / self.budget) + 0.05\n            candidate = current_best + np.random.normal(0, learning_rate * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 54, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {}}
{"id": "624f0c25-0750-4e68-8f5f-a6f423f115bd", "fitness": 0.09460415846958266, "name": "EnhancedHybridDE_SA", "description": "Enhance mutation strategy dynamically based on diversity metrics and integrate a multi-phase local search with adaptive cooling schedules.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def calculate_diversity(self):\n        centroid = np.mean(self.population, axis=0)\n        return np.mean(np.linalg.norm(self.population - centroid, axis=1))\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor, diversity):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        diversity_factor = 1.0 + 0.5 * (1 - diversity)\n        mutant = self.population[a] + diversity_factor * scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def multi_phase_local_search(self, current_best, current_best_fitness):\n        phase_temperature = self.temperature\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.05 * phase_temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / phase_temperature) >= np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n            phase_temperature *= 0.95  # Gradual cooling within local search phases\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            diversity = self.calculate_diversity()\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor, diversity)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.multi_phase_local_search(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 55, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09460 with standard deviation 0.06358.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.21074737198510818, 0.014533734286067967, 0.016101515209314132, 0.06132090663320533, 0.057586036756712145, 0.06407474087560927, 0.13689964433051327, 0.14193643992790317, 0.1482370362218105]}}
{"id": "d79d507b-00d1-47bc-aeb9-fd415757b116", "fitness": -Infinity, "name": "DynamicChaoticDE", "description": "Incorporate dynamic population resizing and chaotic variable introduction to enhance diversity and convergence speed.", "code": "import numpy as np\n\nclass DynamicChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.pop_size = self.initial_pop_size\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def chaotic_perturbation(self, solution):\n        chaotic_sequence = self.logistic_map(np.random.rand(), self.pop_size)\n        perturbation = chaotic_sequence[:self.dim] * 0.05 * (self.ub - self.lb)\n        return np.clip(solution + perturbation, self.lb, self.ub)\n\n    def logistic_map(self, x0, length):\n        r = 3.8\n        x = np.zeros(length)\n        x[0] = x0\n        for i in range(1, length):\n            x[i] = r * x[i - 1] * (1 - x[i - 1])\n        return x\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution = self.chaotic_perturbation(best_solution)\n\n            self.temperature *= 0.9 + 0.1 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(self.initial_pop_size * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 56, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (17,) (20,) ').", "error": "ValueError('operands could not be broadcast together with shapes (17,) (20,) ')", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {}}
{"id": "8e1d0bdf-65b9-45a5-a03f-a342f04f939f", "fitness": 0.13556099765300078, "name": "EnhancedHybridDE_SA_V2", "description": "Implement a dynamic population size and use elitism to preserve the best solutions along with adaptive mutation and crossover strategies for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(len(self.population)))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += len(self.population)\n\n            for i in range(len(self.population)):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n\n            # Dynamic population size and elitism\n            new_pop_size = max(5, int(self.initial_pop_size * (1 - evaluations / self.budget)))\n            elite_idx = np.argsort(self.fitness)[:new_pop_size]\n            self.population = self.population[elite_idx]\n            self.fitness = self.fitness[elite_idx]\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedHybridDE_SA_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13556 with standard deviation 0.16118.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.5729196036719643, 0.022728468911900612, 0.022365753382010967, 0.060943405433210085, 0.06503072423201339, 0.05593012718353252, 0.13609685195853327, 0.14018789079090366, 0.14384615331293826]}}
{"id": "0b8aea1c-8ce3-46b2-bdd3-647ee78d75df", "fitness": 0.0736399232887193, "name": "EnhancedHybridDE_SA", "description": "Enhanced balance between exploration and exploitation by adaptive crossover rate and temperature adjustment.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = 0.8 + 0.2 * (best_fitness / (best_fitness + 1))  # Adaptive crossover rate\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95 + 0.05 * np.tanh(0.1 * evaluations / self.budget)  # Adjust temperature decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07364 with standard deviation 0.05033.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.016852137507745724, 0.016153348012412527, 0.02417859333056893, 0.05687086111333495, 0.05516623683576016, 0.07373398347874816, 0.13684469219327666, 0.14018789079090366, 0.14277156633572285]}}
{"id": "04d87244-b7d8-49ba-afdc-e41caf60708d", "fitness": 0.07717002371790876, "name": "EnhancedHybridDE_SA", "description": "Slightly adjust the mutation scale factor formula to improve convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.3 * np.cos(np.pi * evaluations / self.budget)  # Changed line\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07717 with standard deviation 0.05245.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.01682195283502186, 0.017978505969857173, 0.015823992961592315, 0.07532316556983265, 0.061002601730342776, 0.07456172214494972, 0.14107773568235304, 0.14943303518027629, 0.142507501386953]}}
{"id": "fb3eecb2-c6bd-4752-b8bf-48fe862aadac", "fitness": 0.07515958313122932, "name": "EnhancedHybridDE_SA_Improved", "description": "Introduce a dynamic learning rate and adaptive crossover to enhance the balance between exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        adaptive_prob = np.random.uniform(0.7, 1.0) if np.random.rand() < 0.5 else crossover_prob\n        cross_points = np.random.rand(self.dim) < adaptive_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        learning_rate = 0.1 * (1 - self.temperature)\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, learning_rate, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedHybridDE_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07516 with standard deviation 0.04979.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.01972054409548174, 0.01747148329962822, 0.03374805225900457, 0.06829830402945714, 0.05590173239476237, 0.05601306916268367, 0.13527732351515964, 0.140728819219747, 0.1492769202051395]}}
{"id": "a0d35af8-c3d6-4fca-accd-e4aa90b1cae2", "fitness": 0.07566338473206045, "name": "EnhancedHybridDE_SA_v2", "description": "Introduce a multi-scale mutation strategy and a dynamic crossover mechanism to enhance adaptability and convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.base_mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutation_scale = np.random.choice([scale_factor, scale_factor * 0.5, scale_factor * 1.5])\n        mutant = self.population[a] + mutation_scale * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, evaluations):\n        adapt_crossover_prob = self.crossover_rate * (1 - evaluations / self.budget)\n        cross_points = np.random.rand(self.dim) < adapt_crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedHybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07566 with standard deviation 0.05227.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.01570351927318636, 0.024367174744751363, 0.019160709404999032, 0.06132713275561252, 0.05987475719161306, 0.06534436215627526, 0.13588469555630622, 0.14569638980309874, 0.15361172170270154]}}
{"id": "bd18ac40-554f-468b-a10c-8b10a631ffb0", "fitness": 0.0751846090593759, "name": "EnhancedHybridDE_SA", "description": "Slightly adjust the simulated annealing temperature decay factor to improve convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.93 + 0.07 * np.tanh(0.1 * evaluations / self.budget)  # Adjusted decay factor\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07518 with standard deviation 0.05181.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.015826351730302557, 0.01676819790840256, 0.016325701412967186, 0.06600391179232068, 0.06347074231297523, 0.07134463017698767, 0.14422655402257056, 0.14018789079090366, 0.142507501386953]}}
{"id": "f74650db-0734-493b-87a2-b53cc3f197e0", "fitness": 0.07405864348889261, "name": "EnhancedHybridDE_SA", "description": "Refine adaptive factors and cooling schedule to enhance convergence speed and precision.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i])) + 0.05  # Updated adaptive factor\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95 + 0.05 * np.tanh(0.1 * evaluations / self.budget)  # Refined cooling schedule\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07406 with standard deviation 0.05059.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.015481462644929223, 0.01731162512290585, 0.027776845311128007, 0.06053895449024482, 0.06381685054949615, 0.05700189577593051, 0.1415159305965933, 0.14057672552185263, 0.142507501386953]}}
{"id": "b660e8d8-cdcf-4351-93c8-d394deda661e", "fitness": 0.07705312529758587, "name": "EnhancedHybridDE_SA_Refined", "description": "Enhance mutation by incorporating best individual influence and refine simulated annealing acceptance criteria.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor, best_individual):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        mutant += adaptive_factor * (self.population[a] - self.population[target_idx]) + 0.1 * (best_individual - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(min(delta_fitness / self.temperature, 50)) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                current_best_idx = np.argmin(self.fitness)\n                current_best_individual = self.population[current_best_idx]\n                mutant = self.mutate(i, scale_factor, adaptive_factor, current_best_individual)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedHybridDE_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07705 with standard deviation 0.05231.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.02301534709643127, 0.017485478600443694, 0.016179571012206684, 0.07602526455138614, 0.06233662678627827, 0.0625780734130783, 0.1392941310188115, 0.14674656939154285, 0.14981706580809417]}}
{"id": "25ae8621-27da-4521-9009-c7e7c77207cf", "fitness": 0.07762236409704693, "name": "EnhancedHybridDE_SA", "description": "Enhance mutation strategy and adaptive cooling schedule for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) * (1 + adaptive_factor)  # Adjusted mutation\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95 + 0.05 * np.tanh(0.1 * evaluations / self.budget)  # Adjusted cooling schedule\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07762 with standard deviation 0.05393.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.016865841121824987, 0.01862960472427244, 0.0157175360234858, 0.07451133640923135, 0.056034021043884, 0.07530274024507455, 0.13793862076454122, 0.14704369354491376, 0.15655788299619422]}}
{"id": "690bd9b9-9f85-47f7-938a-adc5cc568af8", "fitness": 0.0766391651724644, "name": "EnhancedHybridDE_SA_Improved", "description": "Introduce adaptive population size and dynamic crossover rate adjustments to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n        \n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = 0.9 - 0.4 * (evaluations / self.budget)  # Dynamic crossover adjustment\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Adaptive population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedHybridDE_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07664 with standard deviation 0.05321.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.014698386354264015, 0.020261042655961292, 0.022391798057374568, 0.05962346774959204, 0.05634827176724022, 0.0756724405847381, 0.14542407046480388, 0.14691467578709783, 0.14841833313110764]}}
{"id": "49d65830-53a8-4e31-9612-689749003b58", "fitness": 0.07297311896365118, "name": "EnhancedHybridDE_SA_v2", "description": "Integrate a multi-population strategy and dynamic parameter tuning for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_subpopulations = 3\n        self.subpop_size = 5 * self.dim\n        self.total_pop_size = self.num_subpopulations * self.subpop_size\n        self.mutation_base = 0.5\n        self.crossover_base = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.populations = [np.random.uniform(lb, ub, (self.subpop_size, self.dim)) for _ in range(self.num_subpopulations)]\n        self.fitness = [np.full(self.subpop_size, np.inf) for _ in range(self.num_subpopulations)]\n\n    def evaluate_population(self, func):\n        for sp in range(self.num_subpopulations):\n            for i in range(self.subpop_size):\n                if np.isinf(self.fitness[sp][i]):\n                    self.fitness[sp][i] = func(self.populations[sp][i])\n\n    def mutate(self, sp, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.subpop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = (self.populations[sp][a] + scale_factor * (self.populations[sp][b] - self.populations[sp][c]) \n                  + adaptive_factor * (self.populations[sp][a] - self.populations[sp][target_idx]))\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def select(self, sp, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[sp][target_idx]:\n            self.populations[sp][target_idx] = trial\n            self.fitness[sp][target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.total_pop_size\n\n            for sp in range(self.num_subpopulations):\n                for i in range(self.subpop_size):\n                    scale_factor = self.mutation_base + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                    adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[sp][i]))  \n                    crossover_prob = self.crossover_base + np.random.uniform(-0.1, 0.1)\n                    mutant = self.mutate(sp, i, scale_factor, adaptive_factor)\n                    trial = self.crossover(self.populations[sp][i], mutant, crossover_prob)\n                    trial_fitness = func(trial)\n                    evaluations += 1\n                    self.select(sp, i, trial, trial_fitness)\n\n            current_best_idx, current_best_fitness = None, np.inf\n            for sp in range(self.num_subpopulations):\n                sp_best_idx = np.argmin(self.fitness[sp])\n                sp_best, sp_best_fitness = self.populations[sp][sp_best_idx], self.fitness[sp][sp_best_idx]\n                if sp_best_fitness < current_best_fitness:\n                    current_best_idx, current_best_fitness = sp_best_idx, sp_best_fitness\n                    current_best = sp_best\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            dynamic_size_factor = 1 - evaluations / self.budget\n            self.subpop_size = max(5, int(5 * self.dim * dynamic_size_factor))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedHybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07297 with standard deviation 0.05261.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.014201375166668417, 0.02098259511139322, 0.018328939331792804, 0.05444201663935633, 0.05506590444646331, 0.06288362705836359, 0.14719043884871463, 0.14018789079090366, 0.14347528327920467]}}
{"id": "79475310-f4de-4c36-a659-12e94912b45c", "fitness": 0.07676467417637008, "name": "EnhancedHybridDE_SA_Refined", "description": "Integrate self-adaptive differential evolution with adaptive simulated annealing and dynamic population resizing for improved exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.9  # Less aggressive cooling\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedHybridDE_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07676 with standard deviation 0.05216.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.015633450426639883, 0.016294198911540714, 0.015720639312299722, 0.06969716264939085, 0.06251623065165268, 0.08273884797574582, 0.14422655402257056, 0.14018789079090366, 0.14386709284658683]}}
{"id": "ddf75b95-845e-4493-a8d6-adf6c57c70de", "fitness": 0.0777880465874002, "name": "EnhancedHybridDE_SA_v2", "description": "Introduce a dynamic population size and adaptive crossover strategy to further enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        self.pop_size = self.initial_pop_size\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = 0.8 + 0.2 * np.cos(np.pi * evaluations / self.budget)  # Adaptive crossover strategy\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(self.initial_pop_size * (1 - evaluations / self.budget)))  # Dynamically adjust population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedHybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07779 with standard deviation 0.04862.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.018736676806618058, 0.016322504001306082, 0.03944295505195583, 0.06006830225172344, 0.06918677831191455, 0.07230780099673229, 0.1413320096884949, 0.14018789079090366, 0.142507501386953]}}
{"id": "777e23d2-efa5-4c22-a755-fa5b3cdf6dff", "fitness": -Infinity, "name": "EnhancedHybridDE_ACO", "description": "Utilize an adaptive hybrid of Differential Evolution and Continuous Ant Colony Optimization for improved exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_ACO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.pheromone = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.pheromone = np.ones(self.dim)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def ant_colony_update(self, current_best):\n        pheromone_factor = np.exp(-self.fitness / np.min(self.fitness))\n        self.pheromone = 0.9 * self.pheromone + 0.1 * pheromone_factor\n\n        for i in range(self.pop_size):\n            if np.random.rand() < self.pheromone[i % self.dim]:\n                candidate = current_best + np.random.normal(0, 0.1 * self.pheromone[i % self.dim], self.dim)\n                candidate = np.clip(candidate, self.lb, self.ub)\n                candidate_fitness = self.func(candidate)\n                if candidate_fitness < self.fitness[i]:\n                    self.population[i] = candidate\n                    self.fitness[i] = candidate_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            self.ant_colony_update(best_solution)\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 70, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (20,) (200,) ').", "error": "ValueError('operands could not be broadcast together with shapes (20,) (200,) ')", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {}}
{"id": "485513f5-882e-44bf-b7fd-0dd853f4c507", "fitness": 0.09699821154280565, "name": "EnhancedHybridDE_SA", "description": "Slightly adjust the simulated annealing cooling schedule to improve convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.93 + 0.07 * np.tanh(0.1 * evaluations / self.budget)  # Adjusted cooling schedule\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09700 with standard deviation 0.06246.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.21214877408117028, 0.01676819790840256, 0.016325701412967186, 0.06600391179232068, 0.06347074231297523, 0.07134463017698767, 0.14422655402257056, 0.14018789079090366, 0.142507501386953]}}
{"id": "47f849a8-a251-4215-8998-2ac147e41fe9", "fitness": 0.07293137109627612, "name": "EnhancedHybridDE_SA", "description": "Improved dynamic parameter adaptation and exploration strategy for better convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.6 + 0.4 * np.sin(np.pi * evaluations / self.budget)  # Changed cos to sin\n                adaptive_factor = np.tanh(0.15 * (best_fitness - self.fitness[i]))  # Adjusted factor multiplier\n                crossover_prob = np.random.uniform(0.7, 1.0)  # Slightly lowered lower bound\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95 + 0.05 * np.tanh(0.1 * evaluations / self.budget)  # Adjusted decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07293 with standard deviation 0.05328.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.013491378341695226, 0.015011105909689348, 0.013422357426076115, 0.06759605320752793, 0.053590677809532195, 0.0648420525104032, 0.14266327874596396, 0.14292556140365786, 0.14283987451193925]}}
{"id": "81f25b50-c52d-4851-902e-ff4af9c13123", "fitness": 0.0749150984772643, "name": "EnhancedHybridDE_SA_Dynamic", "description": "Introduce dynamic population resizing and adaptive perturbation to improve the convergence speed and solution quality of EnhancedHybridDE_SA.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Dynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.initial_pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.initial_pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            perturbation_scale = 0.1 * self.temperature * np.random.uniform(0.8, 1.2)\n            candidate = current_best + np.random.normal(0, perturbation_scale, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.initial_pop_size\n\n            for i in range(self.initial_pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.initial_pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedHybridDE_SA_Dynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07492 with standard deviation 0.05126.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.0164526845021592, 0.01656169160719223, 0.018761611195343697, 0.06755701719257579, 0.058493446111680614, 0.07170150251542984, 0.1385989574638945, 0.14318709986100175, 0.14292187584610105]}}
{"id": "54e837e7-9be0-4540-a10d-1c05435be536", "fitness": -Infinity, "name": "EnhancedDynamicHybridDE_SA", "description": "Introduce dynamic population sizing and adaptive learning rates based on performance feedback to enhance convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedDynamicHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(len(self.population)))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += len(self.population)\n\n            for i in range(len(self.population)):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i])) \n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n\n            # Dynamically adjust the population size\n            success_rate = np.sum(self.fitness < best_fitness) / len(self.fitness)\n            self.population = self.population[np.argsort(self.fitness)[:int((1 + success_rate) * self.initial_pop_size * (1 - evaluations / self.budget))]]\n            self.fitness = self.fitness[np.argsort(self.fitness)[:len(self.population)]]\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 74, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {}}
{"id": "3f77acac-3256-4314-ac57-6d646714c274", "fitness": 0.14706740999855616, "name": "EnhancedHybridDE_SA", "description": "Introduced a nonlinear temperature decay and adjusted crossover probability for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14707 with standard deviation 0.18536.", "error": "", "parent_ids": ["70b3a050-3f9c-4724-af60-b2ff10b9474e"], "operator": null, "metadata": {"aucs": [0.6523989658077456, 0.016107878677020904, 0.014667555562814183, 0.07773940581033822, 0.06125796446403842, 0.06339869130201115, 0.14355504739406888, 0.14550049054237513, 0.1489806904265929]}}
{"id": "cba04330-156c-44e0-9064-4382c295e861", "fitness": 0.07976581242036064, "name": "EnhancedHybridDE_SA", "description": "Enhanced stability by introducing a dynamic mutation rate that decreases over generations.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor * (1 - evaluations / self.budget))  # Dynamic mutation rate\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07977 with standard deviation 0.05030.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.015568124078063628, 0.03072824258889595, 0.026517709617703944, 0.07773940581033822, 0.07260851442023775, 0.05922402318819919, 0.13706645900511227, 0.14943287212830192, 0.14900696094639287]}}
{"id": "cb0a8449-9d21-4f38-b49c-5911fc57d4f5", "fitness": 0.07497693681252823, "name": "EnhancedHybridDE_SA", "description": "Introduced dynamic crossover probability using cosine function for improved exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = 0.7 + 0.25 * (1 + np.cos(2 * np.pi * evaluations / self.budget))  # Dynamic crossover probability using cosine function\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07498 with standard deviation 0.05632.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.014981461689741904, 0.01551777044519509, 0.013901458044503268, 0.06634839476221055, 0.05327785324779499, 0.06059756103667158, 0.1515231700407218, 0.14606808728053833, 0.15257667476537662]}}
{"id": "2ec7b456-a36d-479a-9f08-3762d9533db9", "fitness": 0.07466881560968759, "name": "EnhancedHybridDE_SA", "description": "Enhanced mutation strategy with cosine perturbation and dynamic crossover adaptation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        perturbation = np.cos(2 * np.pi * np.random.rand(self.dim)) * (self.ub - self.lb) * 0.1  # Added cosine perturbation\n        return np.clip(mutant + perturbation, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.8, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07467 with standard deviation 0.05456.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.017872013038907952, 0.01621839646996237, 0.015179034938884617, 0.05901368381216632, 0.05953270050632864, 0.06169163383556775, 0.14740929602129293, 0.1422969567470116, 0.1528056251170662]}}
{"id": "bdc3fa57-9e1f-4df6-84c0-ea1d3dee2f6b", "fitness": 0.07677793946754617, "name": "EnhancedHybridDE_SA", "description": "Enhanced temperature decay and adaptive population size adjustment for optimized exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95 * (1 - evaluations / self.budget) + 0.05 * np.tanh(0.05 * evaluations / self.budget)  # Adjusted nonlinear decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget * 0.95)))  # Adjusted adaptive population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07678 with standard deviation 0.05468.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.016137255804604234, 0.016943573012118573, 0.01684677577379734, 0.07631836579605822, 0.058353989029778175, 0.06161399174678084, 0.14445832569773032, 0.1419771110924507, 0.15835206725459716]}}
{"id": "1b75616a-3afc-4826-9287-934c1e4b443e", "fitness": 0.0769562006811623, "name": "EnhancedHybridDE_SA", "description": "Enhanced adaptive factor and nonlinear decay for improved convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.15 * (best_fitness - self.fitness[i]))  # More responsive adaptive adjustment\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.90 * (1 - evaluations / self.budget) + 0.10 * np.tanh(0.1 * evaluations / self.budget)  # Slightly adjusted nonlinear decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07696 with standard deviation 0.05459.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.014899111338469773, 0.015490321681196795, 0.015873049466553102, 0.07816310256070169, 0.0628209044723026, 0.06214245768005766, 0.14737923893087257, 0.1461802848510424, 0.14965733514926405]}}
{"id": "da31679e-ed18-431f-8f39-7e452db99f66", "fitness": 0.07470373135308764, "name": "EnhancedHybridDE_SA_V2", "description": "Enhanced adaptive mechanisms in DE and SA, leveraging dynamic exploration-exploitation and thermal control.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.05 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.7, 0.95)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.9 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedHybridDE_SA_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07470 with standard deviation 0.05281.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.015784359984704732, 0.015726063323010298, 0.015716768721698138, 0.06843131940600633, 0.0634066087045162, 0.06179262564360799, 0.14245120870796824, 0.14295293515863572, 0.14607169252764107]}}
{"id": "2b935be7-91f8-49fc-8068-6f2181d23261", "fitness": 0.07738883154294957, "name": "EnhancedHybridDE_SA", "description": "Introduced a dynamic adjustment to the mutation rate based on the improvement of the best fitness to enhance exploration.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor * (1 + 0.1 * (best_fitness < self.fitness[i])))  # Adjust mutation rate\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07739 with standard deviation 0.05580.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.013755227415345184, 0.015148619869318924, 0.015583292860230635, 0.07773940581033822, 0.06125796446403842, 0.06339869130201115, 0.1434084491670301, 0.15445136406326632, 0.1517564689349672]}}
{"id": "80e138fc-286a-4605-ac99-362d4c575756", "fitness": 0.07550344483269172, "name": "ImprovedHybridDE_SA", "description": "Improved balance between exploration and exploitation using adaptive control of mutation and crossover rates based on population diversity.", "code": "import numpy as np\n\nclass ImprovedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def adapt_control_parameters(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        self.crossover_rate = 0.7 + 0.3 * (1 - diversity / (self.ub - self.lb))\n        self.mutation_rate = 0.5 + 0.5 * diversity / (self.ub - self.lb)\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            self.adapt_control_parameters()\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, self.crossover_rate)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 83, "feedback": "The algorithm ImprovedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07550 with standard deviation 0.05438.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.015489506394257835, 0.01516473151669806, 0.020754004784698687, 0.059206371898653076, 0.06469866636311583, 0.06059756103667158, 0.1431713174825251, 0.146993327372681, 0.1534555166449243]}}
{"id": "7e0485ee-488d-4bf3-9fa5-4f8a6b4c84ec", "fitness": 0.07338834928144018, "name": "EnhancedHybridDE_SA", "description": "Introduced dynamic population scaling and enhanced mutation adaptation based on fitness diversity to improve convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  \n                diversity_factor = np.std(self.fitness) / max(self.fitness)  # Enhance mutation adaptation\n                mutant = self.mutate(i, scale_factor * diversity_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, self.crossover_rate)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07339 with standard deviation 0.05576.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.014930767890846797, 0.01516473151669806, 0.01440332537197242, 0.05733697681373928, 0.05327785324779499, 0.06059756103667158, 0.14355160414706025, 0.147281623093385, 0.1539507004147933]}}
{"id": "27a354c1-f75c-492e-a43b-a10cd292b72f", "fitness": 0.07359834528808337, "name": "EnhancedHybridDE_SA", "description": "Enhanced exploration by integrating a stochastic mutation factor and improving the temperature update mechanism.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        stochastic_factor = np.random.uniform(0.9, 1.1)  # Added stochastic mutation factor\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) * stochastic_factor + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)  # Improved nonlinear decay\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07360 with standard deviation 0.05177.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.013780347859760456, 0.016657074812459816, 0.021939484677904963, 0.05512548325642086, 0.05890294064030921, 0.07039199682415387, 0.13614590047692443, 0.14070175599407075, 0.14874012305074602]}}
{"id": "6e3cb782-229c-4e20-9393-2963f62aef14", "fitness": -Infinity, "name": "RefinedHybridDE_SA", "description": "Introduced dynamic population resizing and adaptive crossover probability to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass RefinedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(len(self.population)))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        pop_size_decay = np.linspace(self.initial_pop_size, 5, self.budget)\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += len(self.population)\n\n            for i in range(len(self.population)):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = 0.7 + 0.25 * (1 - evaluations / self.budget)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            current_pop_size = int(pop_size_decay[evaluations])\n            if len(self.population) > current_pop_size:\n                to_reduce = len(self.population) - current_pop_size\n                worst_indices = np.argsort(self.fitness)[-to_reduce:]\n                self.population = np.delete(self.population, worst_indices, axis=0)\n                self.fitness = np.delete(self.fitness, worst_indices)\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 86, "feedback": "An exception occurred: IndexError('index 2004 is out of bounds for axis 0 with size 2000').", "error": "IndexError('index 2004 is out of bounds for axis 0 with size 2000')", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {}}
{"id": "ae7c32de-e6ad-42f3-bc12-329bb294a6bc", "fitness": 0.14766825804531256, "name": "EnhancedHybridDE_SA", "description": "Adjusted temperature decay factor in simulated annealing for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay adjustment\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14767 with standard deviation 0.18894.", "error": "", "parent_ids": ["3f77acac-3256-4314-ac57-6d646714c274"], "operator": null, "metadata": {"aucs": [0.6636231352958752, 0.016108316745475304, 0.014568407000326244, 0.07880149241615497, 0.061351822533051714, 0.05926788598778687, 0.1422031890434976, 0.14401298390903794, 0.14907708947660714]}}
{"id": "de13f934-0fb7-47a1-8fe4-ee9e2906b531", "fitness": -Infinity, "name": "EnhancedHybridDE_SA", "description": "Introduced adaptive population scaling and nonlinear cooling schedule to enhance exploration-exploitation trade-off for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.initial_pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.initial_pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.initial_pop_size\n\n            for i in range(self.initial_pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.7, 0.95)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.9 * (1 - evaluations / self.budget) + 0.15 * np.tanh(0.1 * evaluations / self.budget)\n            self.initial_pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget) ** 0.5))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 88, "feedback": "An exception occurred: TypeError(\"can't convert complex to int\").", "error": "TypeError(\"can't convert complex to int\")", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {}}
{"id": "bfb5b317-5158-4813-a1ab-08bc24fb7912", "fitness": -Infinity, "name": "EnhancedHybridDE_SA", "description": "Introduced adaptive crossover range for improved diversity and convergence.", "code": "# Adjusted line\ncrossover_prob = np.random.uniform(0.8, 0.95 - 0.05 * (evaluations / self.budget))  # Adaptively shrinking range\n\n# Original function definition and additional context unchanged\nimport numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.8, 0.95 - 0.05 * (evaluations / self.budget))  # Adaptively shrinking range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay adjustment\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 89, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {}}
{"id": "34624e4f-6c85-4a5a-b61e-03837d0082e9", "fitness": 0.14473998234568516, "name": "EnhancedHybridDE_SA", "description": "Refined adaptive factor and temperature decay to enhance convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.2 * (best_fitness - self.fitness[i]))  # Increased adaptive factor\n\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.94 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)  # Adjusted decay rate\n\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14474 with standard deviation 0.17954.", "error": "", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {"aucs": [0.6330592893511945, 0.014332089259282976, 0.016817971290434497, 0.07834375845033548, 0.06309354543447443, 0.05990189071908736, 0.1439248788305184, 0.1434612289159788, 0.14972518885986008]}}
{"id": "644f3ea1-1403-4b28-a6f9-9a7c36da9c85", "fitness": -Infinity, "name": "EnhancedHybridDE_SA_Improved", "description": "Introduced adaptive population resizing and chaos-based mutation to enhance exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        chaos_factor = np.sin(evaluations * np.pi / self.budget)  # New chaos factor for mutation\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx]) + chaos_factor * np.random.normal(size=self.dim)\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.7, 0.95)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)\n\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget) * (1 + 0.2 * np.sin(np.pi * evaluations / self.budget))))  # Adaptive resizing\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 91, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {}}
{"id": "4ca39688-6207-4088-b34c-81a45c5cb854", "fitness": 0.09129529472398776, "name": "EnhancedHybridDE_SA_Improved", "description": "Implement a dual-temperature simulated annealing with nonlinear decay and dynamic population scaling to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def dual_temperature_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature_high, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature_high) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n\n            # Secondary lower temperature to explore finer changes\n            candidate = current_best + np.random.normal(0, 0.05 * self.temperature_low, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature_low) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature_high = 1.0\n        self.temperature_low = 0.1\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.7, 0.95)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.dual_temperature_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature_high *= 0.92 * (1 - evaluations / self.budget) + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.temperature_low *= 0.95 * (1 - evaluations / self.budget) + 0.05 * np.tanh(0.05 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedHybridDE_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09130 with standard deviation 0.05456.", "error": "", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {"aucs": [0.11375742880904205, 0.014654012723478216, 0.019595041383260625, 0.07651643512701256, 0.06734549064334827, 0.05666037569570237, 0.15245672129761134, 0.15922193153756192, 0.1614502152988725]}}
{"id": "37cb4084-92f6-481a-aa57-c085093b6aac", "fitness": 0.07379040370055176, "name": "Enhanced_HybridDE_SA_Adaptive", "description": "Enhanced_HybridDE_SA_Adaptive: Introduce dynamic population size adjustment and enriched adaptive mutation based on fitness diversity.", "code": "import numpy as np\n\nclass Enhanced_HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.current_pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, diversity_factor):\n        candidates = list(range(self.current_pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = (self.population[a] + scale_factor * (self.population[b] - self.population[c]) +\n                  diversity_factor * (self.population[a] - self.population[target_idx]))\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.current_pop_size = self.initial_pop_size\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.current_pop_size\n\n            mean_fitness = np.mean(self.fitness)\n            stddev_fitness = np.std(self.fitness)\n            diversity_factor = np.tanh(stddev_fitness / mean_fitness)\n\n            for i in range(self.current_pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.7, 0.95)\n                mutant = self.mutate(i, scale_factor, adaptive_factor * diversity_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)\n            self.current_pop_size = max(5, int(self.initial_pop_size * (1 - 0.5 * evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 93, "feedback": "The algorithm Enhanced_HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07379 with standard deviation 0.05481.", "error": "", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {"aucs": [0.01382075062373922, 0.017390658482450472, 0.014615923389385888, 0.056883459163767025, 0.05969530698934755, 0.060647338620859026, 0.14426848147144733, 0.14824193420372056, 0.1485497803602488]}}
{"id": "607f7418-4947-4432-9a96-220e7fe8390d", "fitness": 0.07949670569916518, "name": "EnhancedHybridDE_SA", "description": "Enhance diversity by introducing random immigration to maintain exploration in EnhancedHybridDE_SA.  ", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay adjustment\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n                \n            # Introduce random immigration to maintain diversity\n            immigration_rate = 0.05\n            num_immigrants = int(self.pop_size * immigration_rate)\n            if num_immigrants > 0:\n                immigrants = np.random.uniform(self.lb, self.ub, (num_immigrants, self.dim))\n                self.population[-num_immigrants:] = immigrants\n                self.fitness[-num_immigrants:] = np.inf\n\n        return best_solution, best_fitness", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07950 with standard deviation 0.05793.", "error": "", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {"aucs": [0.014357675917434753, 0.01585193197340773, 0.01512476599571988, 0.0749508739011342, 0.06778361372721087, 0.06132198600494276, 0.15576703881010212, 0.15337393030254876, 0.15693853465998564]}}
{"id": "2fe94605-0f28-47e7-80f8-dd7f665ff8e7", "fitness": 0.07491595036831494, "name": "EnhancedDE_AdaptiveAnnealing", "description": "Enhanced Differential Evolution with Adaptive Annealing and Diversity Preservation to balance exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedDE_AdaptiveAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, diversity_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + diversity_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                diversity_factor = np.tanh(0.1 * (best_fitness - self.fitness[i])) * (np.std(self.population, axis=0).mean())\n                mutant = self.mutate(i, scale_factor, diversity_factor)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.9 * (1 - evaluations / self.budget) + 0.05 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedDE_AdaptiveAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07492 with standard deviation 0.05656.", "error": "", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {"aucs": [0.012415831864361015, 0.01514495427591922, 0.01200009354224607, 0.06626604702023242, 0.057803462656107585, 0.06140590417110181, 0.14715836737503418, 0.1526040933099353, 0.14944479909989694]}}
{"id": "eeb4c1ea-1443-4270-a6cd-4e843cfff94a", "fitness": 0.07576562620943178, "name": "EnhancedHybridDE_SA_v2", "description": "EnhancedHybridDE_SA_v2: Integrate adaptive population size control and nonlinear temperature decay in DE-SA hybrid for robust optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.max_pop_size = 10 * self.dim\n        self.min_pop_size = 4\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.max_pop_size, self.dim))\n        self.fitness = np.full(self.max_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.max_pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.max_pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def update_population_size(self, evaluations):\n        factor = 1 - evaluations / self.budget\n        self.max_pop_size = max(self.min_pop_size, int(10 * self.dim * factor))\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.max_pop_size\n\n            for i in range(self.max_pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.7, 0.95)\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)\n            self.update_population_size(evaluations)\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedHybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07577 with standard deviation 0.05349.", "error": "", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {"aucs": [0.01649944877294862, 0.016108316745475526, 0.014568407000326022, 0.07880149241615564, 0.061351822533051825, 0.05926788598778443, 0.1422031890435007, 0.1440129839090355, 0.1490770894766078]}}
{"id": "d0c13237-8bd9-444e-9f0f-c5dd5fe6a405", "fitness": -Infinity, "name": "EnhancedHybridDE_SA", "description": "Introduced a dynamic population size adjustment based on the fitness diversity to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay adjustment\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget) * np.var(self.fitness)))  # Dynamic population size adjustment\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 97, "feedback": "An exception occurred: IndexError('index 200 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 200 is out of bounds for axis 0 with size 200')", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {}}
{"id": "8eb91e88-8821-410e-ac21-d76765ae766f", "fitness": 0.09804970772904542, "name": "EnhancedHybridDE_SA", "description": "Introducing adaptive mutation and crossover rates for enhanced exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))\n                crossover_prob = np.random.uniform(0.7, 0.95)\n                adaptive_factor += 0.01 * (1 - evaluations / self.budget)  # Adaptive mutation rate\n                crossover_prob = 0.7 + 0.3 * np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptive crossover rate\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09805 with standard deviation 0.06454.", "error": "", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {"aucs": [0.21542682135249858, 0.015686514371164306, 0.017493374284333396, 0.07880149241615497, 0.05830157541138603, 0.05926788598778687, 0.13647341058749674, 0.1511352956275933, 0.1498609995229946]}}
{"id": "3f15b579-6d76-4a8e-bb7d-52bbebe90ed3", "fitness": 0.07576562620943181, "name": "EnhancedHybridDE_SA", "description": "Enhanced convergence by adapting the mutation rate based on current fitness diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor, adaptive_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c]) + adaptive_factor * (self.population[a] - self.population[target_idx])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                adaptive_factor = np.tanh(0.1 * (best_fitness - self.fitness[i]))  # Adaptively adjust mutation\n                crossover_prob = np.random.uniform(0.7, 0.95)  # Adjusted crossover probability range\n                self.mutation_rate = np.std(self.fitness) / np.mean(self.fitness)  # Adaptive mutation rate\n                mutant = self.mutate(i, scale_factor, adaptive_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 * (1 - evaluations / self.budget) + 0.1 * np.tanh(0.1 * evaluations / self.budget)  # Nonlinear decay adjustment\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07577 with standard deviation 0.05349.", "error": "", "parent_ids": ["ae7c32de-e6ad-42f3-bc12-329bb294a6bc"], "operator": null, "metadata": {"aucs": [0.01649944877294851, 0.016108316745475304, 0.014568407000326244, 0.07880149241615497, 0.061351822533051714, 0.05926788598778687, 0.1422031890434976, 0.14401298390903794, 0.14907708947660714]}}
