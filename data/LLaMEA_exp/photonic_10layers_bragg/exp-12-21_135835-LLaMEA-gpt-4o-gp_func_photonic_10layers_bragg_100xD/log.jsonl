{"id": "7b977c4c-978c-4d62-938c-999f9401aff9", "fitness": 0.059128197626396095, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation based on the convergence rate of the swarm.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05913 with standard deviation 0.00375.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.05219665688677344, 0.05868051909489669, 0.05897821935744896, 0.05527489593022228, 0.0621702977258316, 0.06251367722109824, 0.05599757045099196, 0.06299343981489447, 0.06334850215540722]}}
{"id": "68947eaf-2f1d-4194-bdb2-5ffe89c1472f", "fitness": 0.05492851314349229, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Fuzzy Logic Control to dynamically adjust inertia, cognitive, and social parameters for improved convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def _fuzzy_control(self, evaluations, max_evaluations):\n        # Adjust parameters based on progress\n        progress = evaluations / max_evaluations\n        if progress < 0.3:\n            inertia = 0.9\n            cognitive = 2.0\n            social = 1.5\n        elif progress < 0.7:\n            inertia = 0.8\n            cognitive = 1.5\n            social = 1.7\n        else:\n            inertia = 0.6\n            cognitive = 1.2\n            social = 1.5\n        return inertia, cognitive, social\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Apply fuzzy control to adjust parameters\n            self.inertia_weight, self.cognitive_param, self.social_param = self._fuzzy_control(evaluations, self.budget)\n            \n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05493 with standard deviation 0.00352.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.04844237671335372, 0.054996280920710405, 0.05441864449982592, 0.05128505990395049, 0.05824983918523641, 0.05762283859539541, 0.0519502915128518, 0.05901528564932723, 0.058376001310779246]}}
{"id": "ef9427db-5e11-444b-81dc-4e15545cec76", "fitness": 0.056756627919370466, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that uses adaptive inertia weight to enhance exploration and exploitation dynamics.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adjust inertia weight dynamically\n            self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05676 with standard deviation 0.00261.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05349944525550465, 0.052629626880086766, 0.05696970597979156, 0.0566462557427565, 0.055725296197939644, 0.06035240042460299, 0.057385422294991995, 0.0564520525001343, 0.06114944599852579]}}
{"id": "b90081b9-7607-435d-953d-7c01df68791a", "fitness": 0.05368743377115965, "name": "HybridPSO_DE", "description": "An enhanced hybrid PSO-DE that includes adaptive inertia weight adjustment to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                # Change: Adaptive inertia weight adjustment\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05369 with standard deviation 0.00176.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05085085817811441, 0.05235366953709064, 0.051112025880742484, 0.05383466787200275, 0.055427143703888904, 0.05411136740546485, 0.054534145388914546, 0.05614840290202405, 0.0548146230721942]}}
{"id": "10624bff-b1a8-4e30-94e5-f0518df181ff", "fitness": 0.05368743377115965, "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight to improve convergence by refining velocity updates in PSO.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive inertia weight\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05369 with standard deviation 0.00176.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05085085817811441, 0.05235366953709064, 0.051112025880742484, 0.05383466787200275, 0.055427143703888904, 0.05411136740546485, 0.054534145388914546, 0.05614840290202405, 0.0548146230721942]}}
{"id": "28409767-d497-4c2d-a33c-6d98cfd0297d", "fitness": 0.056756627919370466, "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight in HybridPSO_DE to enhance dynamic balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed inertia weight initialization\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05676 with standard deviation 0.00261.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05349944525550465, 0.052629626880086766, 0.05696970597979156, 0.0566462557427565, 0.055725296197939644, 0.06035240042460299, 0.057385422294991995, 0.0564520525001343, 0.06114944599852579]}}
{"id": "c75e8fcb-20f1-437e-ac01-77467d141bf5", "fitness": 0.057417783022933405, "name": "EnhancedHybridPSO_DE", "description": "An enhanced Hybrid PSO-DE algorithm introducing adaptive inertia weight and dynamic mutation control to balance exploration and exploitation more effectively, improving convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.initial_mutation_factor = 0.9\n        self.final_mutation_factor = 0.4\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Linearly decrease inertia weight and mutation factor\n            inertia_weight = (self.final_inertia_weight + \n                              (self.initial_inertia_weight - self.final_inertia_weight) * \n                              ((self.budget - evaluations) / self.budget))\n            \n            mutation_factor = (self.final_mutation_factor + \n                               (self.initial_mutation_factor - self.final_mutation_factor) * \n                               ((self.budget - evaluations) / self.budget))\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05742 with standard deviation 0.00335.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05348641081798344, 0.05268984468434834, 0.058792960403559635, 0.05663249987152452, 0.05578628184329215, 0.062326389585135145, 0.05737149204586156, 0.056513172881138996, 0.06316099507355688]}}
{"id": "6ea7efdc-4461-4eda-a662-336cc318e093", "fitness": 0.05368743377115965, "name": "HybridPSO_DE", "description": "A hybrid PSO-DE with adaptive inertia weight to enhance convergence by balancing exploration and exploitation.  ", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                # Changed line: Adding adaptive inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05369 with standard deviation 0.00176.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05085085817811441, 0.05235366953709064, 0.051112025880742484, 0.05383466787200275, 0.055427143703888904, 0.05411136740546485, 0.054534145388914546, 0.05614840290202405, 0.0548146230721942]}}
{"id": "7b326948-31c6-42ff-9cf7-7f058c88fd0c", "fitness": 0.05608447350356701, "name": "HybridPSO_DE", "description": "Introducing velocity clamping to improve convergence stability in the HybridPSO_DE algorithm.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                # Velocity clamping\n                velocities[i] = np.clip(velocities[i], -0.1, 0.1)\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05608 with standard deviation 0.00279.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.0514626827797281, 0.05653914687323369, 0.05316577661423638, 0.054483658360718445, 0.059902239252903944, 0.05629278582251229, 0.05519217814613908, 0.06069464820023318, 0.057027145482397956]}}
{"id": "0a877298-cf51-4b9f-9fed-acd2d6b20883", "fitness": 0.059128197626396095, "name": "HybridPSO_DE", "description": "Enhanced global best update by considering diversity to maintain exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best with diversity consideration\n            global_best_index = np.argmin(personal_best_scores)\n            if (np.std(personal_best_positions, axis=0) > 0.1).any():  # Conditional update \n                global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05913 with standard deviation 0.00375.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05219665688677344, 0.05868051909489669, 0.05897821935744896, 0.05527489593022228, 0.0621702977258316, 0.06251367722109824, 0.05599757045099196, 0.06299343981489447, 0.06334850215540722]}}
{"id": "0eb32be4-ac60-4816-90a0-ff07001263f3", "fitness": 0.05812431972988574, "name": "HybridPSO_DE", "description": "Introduced an adaptive mutation factor in DE to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = self.mutation_factor * (1.5 - evaluations / self.budget)  # Changed line\n                mutant = a + adaptive_mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05812 with standard deviation 0.00298.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.0551971145101684, 0.05868051909489669, 0.05313202847266307, 0.05845670139985926, 0.0621702977258316, 0.056264703307392305, 0.05922348108225428, 0.06299343981489447, 0.05700059216101161]}}
{"id": "270a2cc2-910f-44e5-9f98-a918651a28ff", "fitness": 0.056756627919370466, "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive inertia weight for improved convergence by modifying the inertia weight line to dynamically decrease.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            current_inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (current_inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 11, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05676 with standard deviation 0.00261.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05349944525550465, 0.052629626880086766, 0.05696970597979156, 0.0566462557427565, 0.055725296197939644, 0.06035240042460299, 0.057385422294991995, 0.0564520525001343, 0.06114944599852579]}}
{"id": "ffda361a-561e-4725-95c9-9311b47a55d7", "fitness": 0.05714413298224868, "name": "HybridPSO_DE", "description": "Enhancing velocity update by incorporating an additional feedback mechanism based on swarm diversity to maintain balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            swarm_diversity = np.mean(np.linalg.norm(particles - global_best_position, axis=1))  # Added line\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]) +\n                                 0.1 * swarm_diversity)  # Modified line\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 12, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05714 with standard deviation 0.00176.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.0543365692601836, 0.05474080179980645, 0.05513689801990851, 0.05755119329994496, 0.05796361834009822, 0.05838756850465954, 0.058307172747477654, 0.05872128452746861, 0.05915209034069058]}}
{"id": "b7f4fbb7-8bee-49f1-ba3e-eb0c493ca98e", "fitness": 0.056756627919370466, "name": "HybridPSO_DE", "description": "Introducing adaptive inertia weight in the hybrid PSO-DE algorithm to enhance balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adapt inertia weight\n            self.inertia_weight = 0.9 - (0.9 - 0.4) * (evaluations / self.budget)  # Single-line change\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 13, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05676 with standard deviation 0.00261.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05349944525550465, 0.052629626880086766, 0.05696970597979156, 0.0566462557427565, 0.055725296197939644, 0.06035240042460299, 0.057385422294991995, 0.0564520525001343, 0.06114944599852579]}}
{"id": "eb210d59-4968-4c9d-9b85-0afea09d762f", "fitness": 0.055090093990862524, "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid Particle Swarm Optimization and Differential Evolution algorithm that employs adaptive parameters and multi-swarm cooperation to improve convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n        self.num_swarms = 2\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.num_swarms, self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_swarms, self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([[func(p) for p in swarm] for swarm in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles.reshape(-1, self.dim)[global_best_index]\n        evaluations = self.num_swarms * self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * (evaluations / self.budget))\n            for swarm_idx in range(self.num_swarms):\n                for i in range(self.population_size):\n                    r1, r2 = np.random.rand(2)\n                    velocities[swarm_idx, i] = (inertia_weight * velocities[swarm_idx, i] +\n                                                self.cognitive_param * r1 * (personal_best_positions[swarm_idx, i] - particles[swarm_idx, i]) +\n                                                self.social_param * r2 * (global_best_position - particles[swarm_idx, i]))\n                    particles[swarm_idx, i] = particles[swarm_idx, i] + velocities[swarm_idx, i]\n                    particles[swarm_idx, i] = np.clip(particles[swarm_idx, i], lb, ub)\n                    \n                    score = func(particles[swarm_idx, i])\n                    evaluations += 1\n\n                    if score < personal_best_scores[swarm_idx, i]:\n                        personal_best_scores[swarm_idx, i] = score\n                        personal_best_positions[swarm_idx, i] = particles[swarm_idx, i]\n\n                swarm_best_index = np.argmin(personal_best_scores[swarm_idx])\n                swarm_best_position = personal_best_positions[swarm_idx, swarm_best_index]\n                \n                if personal_best_scores[swarm_idx, swarm_best_index] < np.min(personal_best_scores):\n                    global_best_position = swarm_best_position\n            \n            for swarm_idx in range(self.num_swarms):\n                for i in range(self.population_size):\n                    if evaluations >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[swarm_idx, np.random.choice(idxs, 3, replace=False)]\n                    mutant = a + self.mutation_factor * (b - c)\n                    mutant = np.clip(mutant, lb, ub)\n\n                    crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                    trial = np.where(crossover_mask, mutant, particles[swarm_idx, i])\n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[swarm_idx, i]:\n                        particles[swarm_idx, i] = trial\n                        personal_best_scores[swarm_idx, i] = trial_score\n                        personal_best_positions[swarm_idx, i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05509 with standard deviation 0.00190.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05162762672665677, 0.05374630159945881, 0.05296600413966068, 0.054659062751349685, 0.056905369449052334, 0.05607898221209251, 0.0553701316764611, 0.057647467960860954, 0.05680989940216985]}}
{"id": "fa28d076-e7ae-4f33-b6c7-f420fcf68366", "fitness": 0.05710606675843996, "name": "EnhancedHybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) enhanced by an adaptive inertia weight and self-adaptive parameters for balancing exploration and exploitation more dynamically.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor_min = 0.4\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = (self.inertia_weight_max - self.inertia_weight_min) * \\\n                             (1 - evaluations / self.budget) + self.inertia_weight_min\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Self-adaptive DE mutation factor\n            mutation_factor = (self.mutation_factor_max - self.mutation_factor_min) * \\\n                              (evaluations / self.budget) + self.mutation_factor_min\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n\n        return global_best_position", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05711 with standard deviation 0.00270.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05348641081798344, 0.057483596837274886, 0.05313324939325359, 0.05663249987152452, 0.060894771150978966, 0.05625981137172542, 0.05737149204586156, 0.06169868102520204, 0.056994088312155244]}}
{"id": "611c26b5-ad41-4065-96ee-2704a61a4d44", "fitness": 0.05811888737091637, "name": "HybridPSO_DE", "description": "Enhanced global best update strategy to improve convergence by considering both best and second-best scores.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best using both best and second-best scores\n            global_best_index = np.argmin(personal_best_scores)\n            second_best_index = np.argsort(personal_best_scores)[1]\n            global_best_position = (personal_best_positions[global_best_index] + personal_best_positions[second_best_index]) / 2\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 16, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05812 with standard deviation 0.00471.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05005861681072177, 0.060009447100668245, 0.056897983349128434, 0.0530005539213686, 0.06360526286823476, 0.06027842370158765, 0.053689948766403206, 0.06445478805102745, 0.061074961769107206]}}
{"id": "23596c04-137c-4a6f-b6dd-f125630f4de9", "fitness": 0.055538336100772634, "name": "HybridPSO_DE", "description": "Enhance the mutation factor update to adapt based on the iteration, thereby improving the balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                self.mutation_factor = 0.5 + 0.5 * (self.iteration / (self.budget / self.population_size))  # Adjusted line\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 17, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05554 with standard deviation 0.00440.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05065405155331992, 0.05868051909489669, 0.05026279181589699, 0.05363608413852916, 0.0621702977258316, 0.05321087258748014, 0.05433530873236092, 0.06299343981489447, 0.05390165944374381]}}
{"id": "efe91cbd-44cc-4d51-b788-0ed27b0b65cf", "fitness": 0.05854473159426749, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) with dynamically adjusted crossover probability to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                self.crossover_prob = 0.5 + 0.3 * np.sin(0.05 * evaluations) # Dynamic adjustment\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 18, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05854 with standard deviation 0.00433.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.050756809436320216, 0.05907085046522387, 0.05835586641589896, 0.05374203156549329, 0.0625883621768647, 0.061851614171176794, 0.05444197879353774, 0.06341833192278423, 0.06267673940110763]}}
{"id": "2b714baf-c813-47a0-802b-333ac20fa69b", "fitness": 0.05368743377115965, "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight in the PSO component to enhance convergence speed and accuracy.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                self.inertia_weight = (0.9 - 0.4) * (self.budget - evaluations) / self.budget + 0.4  # Adaptive inertia weight\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 19, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05369 with standard deviation 0.00176.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05085085817811441, 0.05235366953709064, 0.051112025880742484, 0.05383466787200275, 0.055427143703888904, 0.05411136740546485, 0.054534145388914546, 0.05614840290202405, 0.0548146230721942]}}
{"id": "da35b9b5-abac-44cd-8528-2510146f2e87", "fitness": 0.05614963134701191, "name": "AdaptiveHybridPSO_DE", "description": "Adaptive Hybrid PSO-DE with Time-Varying Parameters that balances exploration and exploitation by dynamically adjusting PSO and DE parameters based on convergence behavior.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.min_inertia = 0.4\n        self.max_inertia = 0.9\n        self.min_cognitive = 1.0\n        self.max_cognitive = 2.5\n        self.min_social = 1.0\n        self.max_social = 2.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n        self.max_iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = ((self.max_inertia - self.min_inertia) *\n                              (self.max_iterations - self.iteration) / self.max_iterations +\n                              self.min_inertia)\n            cognitive_param = ((self.max_cognitive - self.min_cognitive) *\n                               (self.iteration / self.max_iterations) +\n                               self.min_cognitive)\n            social_param = ((self.max_social - self.min_social) *\n                            (self.iteration / self.max_iterations) +\n                            self.min_social)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to enhance diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = personal_best_positions[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n\n        return global_best_position", "configspace": "", "generation": 20, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05615 with standard deviation 0.00182.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05298084739563158, 0.05388600553708234, 0.05449615440117095, 0.05609627328171163, 0.057072608178745154, 0.05770540858520745, 0.056827808320360274, 0.057821772437604, 0.058459803985593806]}}
{"id": "e872081b-f16a-403c-b5cb-33f688388611", "fitness": 0.057300036810721905, "name": "HybridPSO_DE", "description": "A hybrid PSO-DE algorithm with an adaptive inertia weight that decreases over time to improve convergence speed.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                # Change: Adaptive inertia weight\n                self.inertia_weight *= 0.99\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 21, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05730 with standard deviation 0.00281.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05767163416564269, 0.05261136426823243, 0.054362773963380184, 0.06111057374883233, 0.055708278593615934, 0.057563235866036955, 0.061921591443228174, 0.05643539616432425, 0.05831548308320422]}}
{"id": "f10c5f99-4509-4e1f-9e57-461c0201ad51", "fitness": 0.056645523076106236, "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid PSO-DE algorithm with adaptive parameter control and stochastic ranking to balance exploration and exploitation dynamically for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_param = 2.0\n        self.social_param = 2.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive parameter update\n                self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                self.cognitive_param = 1.5 + (0.5 * (evaluations / self.budget))\n                self.social_param = 1.5 + (0.5 * (evaluations / self.budget))\n                \n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover with stochastic ranking\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Stochastic ranking for selection\n                if np.random.rand() < 0.5:\n                    if trial_score < personal_best_scores[i]:\n                        particles[i] = trial\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial\n                else:\n                    if np.linalg.norm(trial - global_best_position) < np.linalg.norm(particles[i] - global_best_position):\n                        particles[i] = trial\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05665 with standard deviation 0.00266.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05434837015188054, 0.05184516745074352, 0.05659781465528335, 0.05755292274250323, 0.05488612216128719, 0.059942998523156876, 0.058306248063856314, 0.055599442659565845, 0.060730621276679275]}}
{"id": "c586202d-9b4f-4333-a1e2-4e8d0e378d60", "fitness": 0.05811318886001672, "name": "HybridPSO_DE", "description": "Enhanced hybrid PSO-DE with adaptive mutation factor for improved convergence and diversity.  ", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = self.mutation_factor * (1 - (evaluations / self.budget))  # Adaptive mutation factor\n                mutant = a + adaptive_mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 23, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05811 with standard deviation 0.00463.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.057478509153487956, 0.05949090078726427, 0.04999865988651131, 0.06088781279782973, 0.06303877000318303, 0.05293437560144121, 0.06169123004043131, 0.06387622411386829, 0.05362221735613337]}}
{"id": "b0b6299a-83ef-4dee-b362-21360eaf8a84", "fitness": 0.05472108104352616, "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid PSO-DE algorithm that incorporates adaptive parameter control and opposition-based learning to improve convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n        self.evaluations = 0\n\n    def adaptive_params(self):\n        # Dynamically adjust the inertia weight and cognitive/social parameters\n        self.inertia_weight = 0.9 - (0.5 * (self.evaluations / self.budget))\n        self.cognitive_param = 1.5 + (0.5 * (self.evaluations / self.budget))\n        self.social_param = 1.5 + (0.5 * (self.evaluations / self.budget))\n\n    def opposition_based_learning(self, particles, lb, ub):\n        # Apply opposition-based learning to improve exploration\n        opposite_particles = lb + ub - particles\n        opposite_particles = np.clip(opposite_particles, lb, ub)\n        return opposite_particles\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        self.evaluations = self.population_size\n\n        while self.evaluations < self.budget:\n            self.adaptive_params()\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            # Apply opposition-based learning\n            opposite_particles = self.opposition_based_learning(particles, lb, ub)\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(opposite_particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    particles[i] = opposite_particles[i]\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = opposite_particles[i]\n\n            self.iteration += 1\n\n        return global_best_position", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05472 with standard deviation 0.00229.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05062472477826985, 0.05430774916730052, 0.0523356533571232, 0.05359544298118979, 0.057519105364060574, 0.05540978763203808, 0.05429174461863551, 0.058274276809134884, 0.056131244683983006]}}
{"id": "bd711d61-285a-40fe-aa98-f0bb9f2d894b", "fitness": 0.05675662791937049, "name": "HybridPSO_DE", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Dynamic Inertia (eHPSO_ADI), refining convergence by adjusting the inertia weight based on iteration progress.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_init = 0.9  # Changed line to use dynamic inertia weight initialization\n        self.inertia_weight_final = 0.4  # New line to define final inertia weight\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = ((self.inertia_weight_init - self.inertia_weight_final) *  # Changed line to compute current inertia weight\n                              (1 - evaluations / self.budget) + self.inertia_weight_final)  # New line to apply dynamic inertia adjustment\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 25, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05676 with standard deviation 0.00261.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05349944525550465, 0.052629626880086766, 0.05696970597979156, 0.0566462557427565, 0.055725296197939644, 0.060352400424603214, 0.057385422294991995, 0.0564520525001343, 0.06114944599852579]}}
{"id": "f8ce4d93-a920-49dc-92c5-cc2ae0e7067b", "fitness": 0.05672136047535344, "name": "HybridPSO_DE", "description": "Enhance the exploration capability by slightly increasing the inertia weight for improved convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.72  # Adjusted inertia weight\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 26, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05672 with standard deviation 0.00190.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.054260941714662336, 0.05533466153301181, 0.053402308635167706, 0.057461441329411334, 0.05859643394994263, 0.05655861954468144, 0.058213812505166995, 0.05936363011608092, 0.05730039495005579]}}
{"id": "a4e372c0-6ccf-43da-a8be-3b63c4e4ff15", "fitness": 0.055712511813470506, "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE by dynamically adjusting the inertia weight to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9 for enhanced exploration to exploitation balance\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 27, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05571 with standard deviation 0.00250.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.051633563335888644, 0.05578609802289691, 0.052673830568576996, 0.054690207320379214, 0.05909224918010825, 0.055766149549262845, 0.05540792875809197, 0.0598705890143203, 0.056491990571709394]}}
{"id": "c34512d9-2bed-43da-a9bc-54ec2bec18c1", "fitness": 0.05368743377115965, "name": "ImprovedHybridPSO_DE", "description": "Improved HybridPSO_DE with adaptive learning rates and diversity maintenance to enhance convergence and exploration balance. ", "code": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Adaptive inertia weight to balance exploration and exploitation\n                inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n                \n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 28, "feedback": "The algorithm ImprovedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05369 with standard deviation 0.00176.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05085085817811441, 0.05235366953709064, 0.051112025880742484, 0.05383466787200275, 0.055427143703888904, 0.05411136740546485, 0.054534145388914546, 0.05614840290202405, 0.0548146230721942]}}
{"id": "b0a864ac-d559-417f-8a32-6c78c266271d", "fitness": 0.05876719170752276, "name": "HybridPSO_DE", "description": "Enhanced velocity update mechanism with dynamic inertia weight adjustment for improved convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position with dynamic inertia weight\n                r1, r2 = np.random.rand(2)\n                w = self.inertia_weight - 0.4 * (self.iteration / (self.budget / self.population_size))  # Adjust inertia weight dynamically\n                velocities[i] = (w * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 29, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05877 with standard deviation 0.00319.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05736211989711948, 0.05868051909489669, 0.05279775056710523, 0.06077041435294617, 0.0621702977258316, 0.055912469853227065, 0.06157370674271201, 0.06299343981489447, 0.05664400731897212]}}
{"id": "42b036b0-b6c3-4f5b-806c-22ef4372d5cf", "fitness": 0.058875330847471125, "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid Particle Swarm Optimization (PSO) and Differential Evolution (DE) algorithm that incorporates adaptive parameter control and diversity preservation through periodic random reinitialization of particles to improve exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n        self.adaptive_frequency = 10  # Frequency of adaptive changes\n        self.reinit_threshold = 0.2   # Threshold for diversity re-initialization\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            # Adaptive parameter control and diversity enhancement\n            if self.iteration % self.adaptive_frequency == 0:\n                self.cognitive_param = np.random.uniform(1.2, 2.0)\n                self.social_param = np.random.uniform(1.2, 2.0)\n                diversity = np.mean(np.std(particles, axis=0))\n                if diversity < self.reinit_threshold:\n                    random_indices = np.random.choice(self.population_size, size=self.population_size // 3, replace=False)\n                    particles[random_indices] = np.random.uniform(lb, ub, (len(random_indices), self.dim))\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05888 with standard deviation 0.00277.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05378884690608776, 0.05868051909489669, 0.05665492206923217, 0.056971424037674634, 0.0621702977258316, 0.0600491638597771, 0.05771963889887044, 0.06299343981489447, 0.060849725219975226]}}
{"id": "d5978dd8-019c-4470-b2b0-0094a0850323", "fitness": 0.055988288104492, "name": "HybridPSO_DE", "description": "An adaptive inertia weight strategy is integrated into the HybridPSO_DE to balance exploration and exploitation more effectively over iterations.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_max = 0.9  # Changed from 0.7 to adaptive (line 9)\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = (self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * self.iteration / (self.budget / self.population_size)))\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 31, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05599 with standard deviation 0.00320.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05635424373874254, 0.05015858822915986, 0.0543669053274044, 0.05972026812241993, 0.053098451052870255, 0.05757102228088751, 0.06051368073896912, 0.05378720426471606, 0.05832422918525837]}}
{"id": "fdbb4390-1d44-439c-8d1f-a19ca11e6538", "fitness": 0.05398735790446826, "name": "EnhancedHybridPSO_DE", "description": "An enhanced Hybrid PSO-DE with adaptive parameter adjustment and local search intensification to exploit promising regions and dynamically balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = ((self.final_inertia_weight - self.initial_inertia_weight) * \n                              (evaluations / self.budget) + self.initial_inertia_weight)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            # Local search intensification in promising areas\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                local_search = particles[i] + np.random.normal(0, 0.1, self.dim)\n                local_search = np.clip(local_search, lb, ub)\n                local_search_score = func(local_search)\n                evaluations += 1\n\n                if local_search_score < personal_best_scores[i]:\n                    personal_best_scores[i] = local_search_score\n                    personal_best_positions[i] = local_search\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05399 with standard deviation 0.00223.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.04993862706506169, 0.05173063764943586, 0.05350291466675683, 0.05286976313599667, 0.05476879867449447, 0.05664922648410908, 0.05355647363531013, 0.05548151307046301, 0.05738826675858655]}}
{"id": "50339cff-eafb-4dc1-8d4d-cd3e34a709cf", "fitness": 0.05571643428857878, "name": "AdaptiveHybridPSO_DE", "description": "Adaptive Hybrid PSO-DE with Dynamic Parameter Adjustment and Fitness-based Particle Re-initialization improves balance between exploration and exploitation by tuning parameters and re-initializing stagnant particles based on fitness diversity.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_param = 2.0\n        self.social_param = 2.0\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.evaluations = 0\n        self.iteration = 0\n        self.diversity_threshold = 0.01\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n        self.evaluations = self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position with dynamic parameters\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            diversity = np.std(personal_best_scores)\n            if diversity < self.diversity_threshold:\n                # Re-initialize some particles to maintain diversity\n                num_reinit = self.population_size // 10\n                for _ in range(num_reinit):\n                    idx = np.random.randint(0, self.population_size)\n                    particles[idx] = np.random.uniform(lb, ub, self.dim)\n                    velocities[idx] = np.random.uniform(-1, 1, self.dim)\n                    personal_best_positions[idx] = np.copy(particles[idx])\n                    personal_best_scores[idx] = func(particles[idx])\n                    self.evaluations += 1\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 33, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05572 with standard deviation 0.00279.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.055483415874490905, 0.05416411529846277, 0.050474437615232626, 0.05876517291968786, 0.05735693403596687, 0.05343286289939864, 0.05953744467603972, 0.05810739768214923, 0.05412612759578039]}}
{"id": "7a4b219e-ed08-4a13-abf0-a4dfd3c0bb52", "fitness": 0.057112142888473105, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation based on the convergence rate of the swarm, with enhanced mutation factor for improved search capability.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 34, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05711 with standard deviation 0.00372.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05272476432785145, 0.05913802716407235, 0.05224375870903053, 0.055834502435872846, 0.06266039710233051, 0.055315286496570804, 0.056564829242031656, 0.06349156465155681, 0.056036155866940995]}}
{"id": "e7f8f4ca-f8fa-4e0c-9c2f-c678e721e6ee", "fitness": 0.05371922930412151, "name": "EnhancedHybridPSO_DE_SA", "description": "Introduce adaptive inertia weight and a local search phase with simulated annealing to enhance exploitation and exploration balance in the hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n        self.T_initial = 1.0\n        self.T_final = 0.01\n        self.alpha = 0.9\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n        current_temperature = self.T_initial\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                score = func(particles[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            # Simulated Annealing local search\n            if evaluations < self.budget:\n                perturbed = global_best_position + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, lb, ub)\n                perturbed_score = func(perturbed)\n                evaluations += 1\n\n                if perturbed_score < personal_best_scores[global_best_index] or \\\n                   np.exp((personal_best_scores[global_best_index] - perturbed_score) / current_temperature) > np.random.rand():\n                    global_best_position = perturbed\n                    personal_best_scores[global_best_index] = perturbed_score\n                    personal_best_positions[global_best_index] = perturbed\n\n            current_temperature = self.alpha * current_temperature\n            current_temperature = max(current_temperature, self.T_final)\n            \n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedHybridPSO_DE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05372 with standard deviation 0.00178.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.05093738826929761, 0.05246054251566501, 0.051006341094456675, 0.05393060422102791, 0.05554279816762364, 0.05399770710948115, 0.05463245261964578, 0.056266234506463175, 0.05469899523343269]}}
{"id": "cb5d068c-63ad-4448-abc2-b962d34200e0", "fitness": 0.05452570872253366, "name": "HybridPSO_DE", "description": "A refined hybrid Particle Swarm Optimization (PSO) with Differential Evolution (DE) that includes adaptive inertia weight and mutation factor to enhance convergence and diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Adjusted\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.8  # Adjusted\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            self.mutation_factor = 0.5 + 0.3 * (1 - evaluations / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 36, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05453 with standard deviation 0.00199.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.050727524753192754, 0.052944792536918195, 0.053029220177518877, 0.05370376530119825, 0.05606076020533601, 0.05616703151936375, 0.054401399146118745, 0.05679247530504761, 0.056904409558108715]}}
{"id": "2de06409-2121-46bb-8b2c-0c5d79dfd71c", "fitness": 0.055712511813470506, "name": "HybridPSO_DE", "description": "A refined hybrid PSO-DE algorithm with adaptive inertia weight to improve convergence speed and precision.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 37, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05571 with standard deviation 0.00250.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.051633563335888644, 0.05578609802289691, 0.052673830568576996, 0.054690207320379214, 0.05909224918010825, 0.055766149549262845, 0.05540792875809197, 0.0598705890143203, 0.056491990571709394]}}
{"id": "c06b257d-f005-4294-8aa7-60f4ab4501e2", "fitness": 0.0638479338594612, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation based on the convergence rate of the swarm with increased crossover probability to enhance diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 38, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06385 with standard deviation 0.00267.", "error": "", "parent_ids": ["7b977c4c-978c-4d62-938c-999f9401aff9"], "operator": null, "metadata": {"aucs": [0.06015995897592541, 0.059654672175305956, 0.06344495767384051, 0.06381316271639592, 0.0632180528840599, 0.06733959986820282, 0.06467772572271557, 0.06405941257365244, 0.06826386214505231]}}
{"id": "9b90b72a-2a43-408b-97ae-aaca52c1e8fe", "fitness": 0.05443799953249415, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Parameter Tuning uses real-time feedback from function evaluations to dynamically adjust PSO and DE parameters for improved convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive parameter adjustment\n            if evaluations > 0 and evaluations % (self.population_size * 2) == 0:\n                improvement_rate = (np.min(personal_best_scores) - np.min(personal_best_scores)) / np.min(personal_best_scores)\n                if improvement_rate < 0.01:  # If stagnation is detected, adjust parameters\n                    self.cognitive_param *= 1.1\n                    self.social_param *= 0.9\n                    self.inertia_weight *= 1.05\n                    self.mutation_factor += 0.1\n                else:\n                    self.cognitive_param *= 0.9\n                    self.social_param *= 1.1\n                    self.inertia_weight *= 0.95\n                    self.mutation_factor -= 0.1\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05444 with standard deviation 0.00215.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.050492615801939755, 0.05223760167511826, 0.05373757122491685, 0.053454799007463194, 0.05530381441399812, 0.05690012090275898, 0.05414901658925586, 0.056023303448977546, 0.05764315272801879]}}
{"id": "2cf9ebcd-77ca-4730-b2e9-335165b7c390", "fitness": 0.055816020258821215, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive inertia and blend mutation enhancing balance between exploration and exploitation by varying inertia weight based on the iteration progress and introducing blend crossover for more diverse candidate solutions.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.iteration += 1\n            inertia_weight = self.calculate_adaptive_inertia()\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Blend Crossover\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, (particles[i] + mutant) / 2, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n        return global_best_position\n\n    def calculate_adaptive_inertia(self):\n        t = self.iteration / (self.budget // self.population_size)\n        return self.final_inertia_weight + \\\n               (self.initial_inertia_weight - self.final_inertia_weight) * (1 - t)", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05582 with standard deviation 0.00286.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.056518483780168105, 0.05138433567341005, 0.052510660774018, 0.059861383104037214, 0.054400270237077164, 0.05559458837038522, 0.060648489404592665, 0.05510755734860473, 0.056318413637097775]}}
{"id": "1758cb79-5fa4-4542-99be-4b5edf3353bc", "fitness": 0.054990043963973285, "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight to enhance convergence speed and solution quality by dynamically adjusting exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.9 - (0.5 * evaluations / self.budget)  # Adapted line\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 41, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05499 with standard deviation 0.00259.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05517855616138456, 0.05228501790122919, 0.050575002208605446, 0.05844111501943905, 0.055363018741970915, 0.05353936526120995, 0.05920871057979593, 0.05608553872878019, 0.054234071073344325]}}
{"id": "2c0e89be-82aa-42a4-a1f1-1559eb16894d", "fitness": -Infinity, "name": "HybridPSO_DE_Adaptive", "description": "Enhanced Hybrid PSO-DE with Adaptive Parameters based on Diversity Maintenance to balance exploration and exploitation dynamically, focusing on retaining diversity for better convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9  # Slightly increased crossover probability\n        self.iteration = 0\n        self.max_velocity = 0.2 * (func.bounds.ub - func.bounds.lb)  # Limiting max velocity\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim)) * self.max_velocity\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Calculate diversity\n            diversity = np.mean(np.std(particles, axis=0))\n\n            # Adapt parameters based on diversity\n            self.inertia_weight = 0.4 + 0.3 * (1 - diversity)\n            self.cognitive_param = 1.0 + 1.0 * diversity\n            self.social_param = 1.0 + 1.0 * (1 - diversity)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 42, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {}}
{"id": "050d9a01-50d5-4624-8751-9799fb4c2718", "fitness": 0.05578500806179733, "name": "AdaptiveDiffGuidedPSO", "description": "Adaptive Differentially Guided PSO with Dynamic Parameters: Enhances exploration and exploitation balance using a differentially guided PSO approach with dynamically tuned parameters based on current performance metrics.", "code": "import numpy as np\n\nclass AdaptiveDiffGuidedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_param = 1.4\n        self.social_param = 1.6\n        self.mutation_factor = 0.6\n        self.crossover_prob = 0.9\n        self.iteration = 0\n        self.performance_window = 5\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n        evaluations = self.population_size\n        past_global_best_scores = [personal_best_scores[global_best_index]]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            current_global_best_index = np.argmin(personal_best_scores)\n            if personal_best_scores[current_global_best_index] < personal_best_scores[global_best_index]:\n                global_best_index = current_global_best_index\n                global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive parameter adjustment based on performance\n            past_global_best_scores.append(personal_best_scores[global_best_index])\n            if len(past_global_best_scores) > self.performance_window:\n                past_global_best_scores.pop(0)\n                improvement = past_global_best_scores[-1] - past_global_best_scores[0]\n                if improvement < 0:\n                    self.inertia_weight *= 0.99\n                    self.cognitive_param *= 1.01\n                    self.social_param *= 0.99\n                else:\n                    self.inertia_weight *= 1.01\n                    self.cognitive_param *= 0.99\n                    self.social_param *= 1.01\n\n            # Apply DE mutation and crossover to enhance diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 43, "feedback": "The algorithm AdaptiveDiffGuidedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05579 with standard deviation 0.00191.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.053861144682948114, 0.05421468568654675, 0.052239137492549936, 0.057033883725663204, 0.057412416742110506, 0.05531863549603522, 0.05777943619921366, 0.05816411241580499, 0.05604162011530356]}}
{"id": "14dc85a8-3ac1-40b5-b83b-2e88d0770e53", "fitness": 0.05688844869780342, "name": "ImprovedHybridPSO_DE", "description": "Improved HybridPSO_DE with dynamic parameter tuning and local search phase to enhance convergence speed and solution accuracy in black-box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.initial_crossover_prob = 0.8\n        self.final_crossover_prob = 0.3\n        self.local_search_prob = 0.1\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = (self.final_inertia_weight - self.initial_inertia_weight) * (evaluations / self.budget) + self.initial_inertia_weight\n            crossover_prob = (self.final_crossover_prob - self.initial_crossover_prob) * (evaluations / self.budget) + self.initial_crossover_prob\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n                # Local search phase for fine-tuning\n                if np.random.rand() < self.local_search_prob:\n                    local_trial = particles[i] + np.random.normal(0, 0.1, self.dim)\n                    local_trial = np.clip(local_trial, lb, ub)\n                    local_trial_score = func(local_trial)\n                    evaluations += 1\n\n                    if local_trial_score < personal_best_scores[i]:\n                        particles[i] = local_trial\n                        personal_best_scores[i] = local_trial_score\n                        personal_best_positions[i] = local_trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 44, "feedback": "The algorithm ImprovedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05689 with standard deviation 0.00403.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.049865610425913975, 0.05825170033404303, 0.05535244519415505, 0.05279119463818538, 0.061714380551376125, 0.058622011502695415, 0.0534765349581694, 0.06253091743241579, 0.059391243243276604]}}
{"id": "f1ef3df9-ee48-4206-a011-29266a0c96fa", "fitness": 0.057188366983694845, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with dynamic parameter tuning and progressive population reduction for improved convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Increased for better initial exploration\n        self.cognitive_param = 1.7  # Fine-tuned for enhanced self-learning\n        self.social_param = 1.3  # Adjusted for balance between personal and global influence\n        self.mutation_factor = 0.6  # Increased to enhance exploration in DE\n        self.crossover_prob = 0.9  # Increased for higher diversity\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight *= 0.99  # Dynamic weight reduction to focus on exploitation\n            self.social_param += 0.01  # Gradually increase social influence\n            if self.iteration % 10 == 0 and self.population_size > 5:  # Reduce population size progressively\n                self.population_size -= 1\n                particles = particles[:self.population_size]\n                velocities = velocities[:self.population_size]\n                personal_best_positions = personal_best_positions[:self.population_size]\n                personal_best_scores = personal_best_scores[:self.population_size]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                score = func(particles[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n\n        return global_best_position", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05719 with standard deviation 0.00576.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05298721836071574, 0.061874505948598335, 0.04944599866060362, 0.056100410937670486, 0.06559973092321303, 0.0523477479743617, 0.056831356114986686, 0.0664810171094139, 0.05302731682369011]}}
{"id": "bc613bb7-4e9c-4fe0-8395-c8c2700c5322", "fitness": 0.05198609577531313, "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid PSO-DE algorithm that adapts inertia weight and mutation factor based on diversity metrics to better balance exploration and exploitation, thereby improving convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.initial_mutation_factor = 0.5\n        self.initial_crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            diversity = np.mean(np.var(particles, axis=0))\n            self.inertia_weight = 0.5 + 0.4 * (diversity / self.dim)\n            mutation_factor = self.initial_mutation_factor + 0.1 * (1 - diversity / self.dim)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                score = func(particles[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.initial_crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n\n        return global_best_position", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05199 with standard deviation 0.00324.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.047010047280664935, 0.04892788903955858, 0.05348773772802018, 0.049770842233598844, 0.05179639189245577, 0.05662994498196383, 0.05041623692461761, 0.05246784309170116, 0.05736792880523722]}}
{"id": "d423fb99-728d-446f-a608-cfc433099b32", "fitness": 0.05530608167912096, "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid Particle Swarm Optimization (PSO) with Differential Evolution (DE) that adapts inertia based on convergence rate to balance exploration and exploitation, leveraging adaptive mutation to dynamically enhance diversity and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with higher inertia\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.6  # Slightly higher mutation factor\n        self.initial_crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adapt inertia weight based on iteration\n            self.inertia_weight = 0.4 + 0.5 * np.cos((self.iteration / (self.budget / self.population_size)) * np.pi)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover with adaptive mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                \n                crossover_prob = self.initial_crossover_prob * (1 - evaluations / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05531 with standard deviation 0.00290.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05133094421758655, 0.05143010828046002, 0.056179873739575115, 0.054353620908273226, 0.05444780741442934, 0.05950557858791705, 0.05506272105849541, 0.05515550467411279, 0.06028857623123918]}}
{"id": "efb4a39b-8a08-484b-947f-077c17e078b0", "fitness": 0.05930162025486618, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation based on the convergence rate of the swarm with increased mutation factor to enhance diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.6  # Changed from 0.5 to 0.6\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 48, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05930 with standard deviation 0.00315.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.053317352962554576, 0.05868051909489669, 0.05835586641589896, 0.056464619009181094, 0.0621702977258316, 0.061851614171176794, 0.057204133698253834, 0.06299343981489447, 0.06267673940110763]}}
{"id": "b54cabe5-9f72-44b2-a64e-83c80fdcd470", "fitness": 0.054990043963971634, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE with Adaptive Dynamic Inertia Weight and Dynamic Population Size to Improve Convergence and Diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.min_population_size = 10\n        self.population_size = self.initial_population_size\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adjust inertia weight dynamically\n            inertia_weight = (self.inertia_weight_max - self.inertia_weight_min) * \\\n                             (1 - evaluations / self.budget) + self.inertia_weight_min\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            # Dynamic population size adjustment\n            if evaluations % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size -= 1\n                particles = particles[:self.population_size]\n                velocities = velocities[:self.population_size]\n                personal_best_positions = personal_best_positions[:self.population_size]\n                personal_best_scores = personal_best_scores[:self.population_size]\n\n            self.iteration += 1\n\n        return global_best_position", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05499 with standard deviation 0.00259.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05517855616138456, 0.05228501790122919, 0.05057500220859057, 0.05844111501943905, 0.055363018741970915, 0.05353936526120995, 0.05920871057979593, 0.05608553872878019, 0.054234071073344325]}}
{"id": "ef1fab3f-9b5b-45ff-9ce4-bbe8dafb2548", "fitness": 0.054146046587080804, "name": "EnhancedHybridPSO_DE", "description": "This enhanced HybridPSO_DE uses a dynamic inertia weight that decreases over iterations and adaptive mutation based on diversity to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9  # Increased to enhance diversity\n        self.iteration = 0\n        self.max_iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = (self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * \n                              (self.iteration / self.max_iterations))\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply adaptive DE mutation and crossover to adapt diversity\n            diversity = np.std(particles, axis=0).mean()\n            adjusted_mutation_factor = self.mutation_factor + diversity * 0.5\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + adjusted_mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05415 with standard deviation 0.00256.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.053170457674239446, 0.05322300678068137, 0.049219493595400565, 0.05630402708181681, 0.05636601761578108, 0.05210554022311176, 0.05704009618742523, 0.05710451853175447, 0.05278126159351648]}}
{"id": "35d4e28f-6fd4-496c-9a2f-f0384151c208", "fitness": 0.05645780416526842, "name": "ImprovedHybridPSO_DE", "description": "An improved hybrid PSO integrated with DE incorporating a dynamic inertia weight and adaptive mutation strategy to better balance exploration and exploitation for enhanced convergence.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9  # Increased from 0.8 to 0.9\n        self.iteration = 0\n        self.max_iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Dynamically adjust inertia weight\n            self.inertia_weight = 0.9 - 0.5 * (self.iteration / self.max_iterations)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply adaptive DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_adaptive = 0.5 + (np.random.rand() * 0.5)  # Adaptive mutation factor\n                mutant = a + mutation_factor_adaptive * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 51, "feedback": "The algorithm ImprovedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05646 with standard deviation 0.00255.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05662087306004515, 0.05256424432487272, 0.05306215685442772, 0.05997446858439237, 0.055651307754596924, 0.056186610712232965, 0.06076426440910998, 0.056375886286943566, 0.05692042550079435]}}
{"id": "0a90b13d-2cda-422c-a296-6b8804d2cf7c", "fitness": 0.0547478924753263, "name": "HybridPSO_DE", "description": "An enhanced Hybrid PSO-DE algorithm with adaptive inertia weight and dynamic mutation factor to improve convergence speed and diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n        self.min_inertia = 0.4  # Minimum inertia weight\n        self.max_inertia = 0.9  # Maximum inertia weight\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update inertia weight dynamically\n            self.inertia_weight = self.max_inertia - ((self.max_inertia - self.min_inertia) * evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                score = func(particles[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Improve diversity by adapting mutation factor based on iterations\n            self.mutation_factor = 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 52, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05475 with standard deviation 0.00183.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05348641081798344, 0.0521635989648922, 0.05170829348487993, 0.05663249987152452, 0.055228181576915114, 0.05474095940394608, 0.05737149204586156, 0.055947325460064756, 0.055452270651869084]}}
{"id": "649e7ad3-154e-46ef-871e-b84e421406fb", "fitness": 0.056581779883385835, "name": "HybridPSO_DE", "description": "Enhanced balance between exploration and exploitation by slightly increasing the inertia weight.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.72  # Changed from 0.7 to 0.72\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 53, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05658 with standard deviation 0.00265.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.055518593998909016, 0.05561881642985067, 0.051467772285921254, 0.058796871840909315, 0.05889954344809101, 0.054492660509951385, 0.05956818403785824, 0.059671382560385844, 0.055202193838595814]}}
{"id": "16bb1335-661b-4341-8126-6da3162c6bd6", "fitness": 0.05670730760750066, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation with a refined strategy for particle velocity updates to improve convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]) +\n                                 0.01 * (ub - lb) * np.random.uniform(-1, 1, self.dim))  # Modified line\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 54, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05671 with standard deviation 0.00400.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05781977041085218, 0.049632854517903224, 0.05549788765936814, 0.0612563928112132, 0.05254536916929109, 0.058774251516115594, 0.062066599158844715, 0.05322755122364198, 0.0595450920002758]}}
{"id": "b8f556cd-8e5f-468f-b318-8579cc594f64", "fitness": 0.05797519802643923, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive parameters that adjust inertia, cognitive, and social components based on iteration progress to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n        self.max_iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb = np.array(func.bounds.lb)\n        ub = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adapt inertia, cognitive and social parameters\n            w = self.inertia_weight * (1 - self.iteration / self.max_iterations)\n            c1 = self.cognitive_param * (1 - self.iteration / self.max_iterations)\n            c2 = self.social_param * self.iteration / self.max_iterations\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 55, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05798 with standard deviation 0.00363.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.051298006406896746, 0.057055751502715024, 0.05821275708249829, 0.0543092282095734, 0.06044136362170738, 0.06169212395343593, 0.055015377070513294, 0.061239060029130155, 0.06251311436148288]}}
{"id": "8ff80d01-421e-4c88-86cc-0abcbade6cc1", "fitness": 0.05930162025486618, "name": "HybridPSO_DE", "description": "Slightly adjusted the mutation factor to enhance exploration capabilities, aiming for better diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.6  # Changed from 0.5 to 0.6\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 56, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05930 with standard deviation 0.00315.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.053317352962554576, 0.05868051909489669, 0.05835586641589896, 0.056464619009181094, 0.0621702977258316, 0.061851614171176794, 0.057204133698253834, 0.06299343981489447, 0.06267673940110763]}}
{"id": "6cb9cc97-4522-4305-8da5-0d96ed23f05a", "fitness": 0.05479814229088556, "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid Particle Swarm Optimization integrated with Differential Evolution that adaptively tunes exploration-exploitation balance by dynamically adjusting inertia weight and mutation factor based on iteration progress, improving convergence speed and diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.initial_mutation_factor = 0.9\n        self.final_mutation_factor = 0.3\n        self.crossover_prob = 0.9\n        self.iteration = 0\n        self.max_iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.initial_inertia_weight - (\n                (self.initial_inertia_weight - self.final_inertia_weight) * (self.iteration / self.max_iterations)\n            )\n            mutation_factor = self.initial_mutation_factor - (\n                (self.initial_mutation_factor - self.final_mutation_factor) * (self.iteration / self.max_iterations)\n            )\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                score = func(particles[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n\n        return global_best_position", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05480 with standard deviation 0.00310.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.055208170443559856, 0.05309544906493269, 0.04918060800762003, 0.05847530921227728, 0.05622100343709946, 0.05206424429741441, 0.059244056130298595, 0.05695506144798712, 0.05273937857678057]}}
{"id": "817f2570-aeaf-4581-b7fe-d8c6cc78ccf8", "fitness": 0.05444162583551531, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation based on the convergence rate of the swarm with increased population size to enhance diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Changed from 30 to 35\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 58, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05444 with standard deviation 0.00212.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.050892620848766335, 0.05391554214656136, 0.051672214123854254, 0.05388109341996927, 0.0570850280264974, 0.05470294254393526, 0.05458174241163549, 0.05782966312552695, 0.055413785872891475]}}
{"id": "7218738a-fca7-4994-8204-091ead24e18a", "fitness": 0.05624661452774901, "name": "HybridPSO_DE", "description": "Enhanced the HybridPSO_DE algorithm by adjusting the inertia weight for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.6  # Changed from 0.7 to 0.6\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 59, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05625 with standard deviation 0.00246.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05300096180498859, 0.05624728157550063, 0.05239355722947425, 0.05613143007220178, 0.05956942966648027, 0.05546848472249721, 0.05686689396684086, 0.06035140539455863, 0.056190086317198906]}}
{"id": "c942fb45-812e-458d-a64a-482f79489d9e", "fitness": 0.056444512823854195, "name": "HybridPSO_DE", "description": "Improved inertia weight decay in the Hybrid PSO-DE for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Decay inertia weight linearly over iterations\n            self.inertia_weight = 0.9 - (0.5 * self.iteration / (self.budget / self.population_size))\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 60, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05644 with standard deviation 0.00233.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05250713739034185, 0.05611234525442477, 0.053589255829583515, 0.055597513199530546, 0.05943548171959889, 0.056739061646664646, 0.05632301955385488, 0.06021788120294458, 0.057478919617744095]}}
{"id": "0d4763cc-842c-4b01-83db-012cb35c1daf", "fitness": 0.05443799953249415, "name": "HybridPSO_DE", "description": "Introduced an adaptive inertia weight strategy in the PSO to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9, introducing adaptive inertia weight\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 61, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05444 with standard deviation 0.00215.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.050492615801939755, 0.05223760167511826, 0.05373757122491685, 0.053454799007463194, 0.05530381441399812, 0.05690012090275898, 0.05414901658925586, 0.056023303448977546, 0.05764315272801879]}}
{"id": "34dc17ba-edad-4e35-a6f9-e7949055721b", "fitness": 0.0532481757126931, "name": "HybridPSO_DE", "description": "A hybrid PSO-DE algorithm with improved inertia weight decay strategy to better balance exploration and exploitation over iterations.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Improved inertia weight decay strategy\n            self.inertia_weight = 0.9 - self.iteration * (0.5 / self.budget)  # Changed from constant to decay\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 62, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05325 with standard deviation 0.00215.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.050149976359814774, 0.04995397984027716, 0.05295066423750949, 0.053090551391300145, 0.052884976185384125, 0.0560610226687136, 0.053779499840818534, 0.05357163614588323, 0.056791274744536824]}}
{"id": "41264c76-6fe4-4ad9-9885-98f47c8df793", "fitness": 0.05624661452774901, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation, now with an adjusted inertia weight for enhanced convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.6  # Changed from 0.7 to 0.6\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 63, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05625 with standard deviation 0.00246.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05300096180498859, 0.05624728157550063, 0.05239355722947425, 0.05613143007220178, 0.05956942966648027, 0.05546848472249721, 0.05686689396684086, 0.06035140539455863, 0.056190086317198906]}}
{"id": "e9c5c435-16cb-4de6-bb53-53e012256130", "fitness": 0.04748601261691194, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Inertia and Fuzzy Logic to Balance Exploration and Exploitation based on Dynamic Fitness Improvement.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_param = 2.0\n        self.social_param = 2.0\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n        self.prev_best_score = float('inf')\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Fuzzy logic for adaptive inertia weight\n            fitness_improvement = (self.prev_best_score - global_best_score) / self.prev_best_score if self.prev_best_score != 0 else 1\n            self.inertia_weight = 0.9 - 0.5 * (1 - fitness_improvement)\n            self.prev_best_score = global_best_score\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n            global_best_score = personal_best_scores[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04749 with standard deviation 0.00285.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.04605630758321899, 0.047976016643743624, 0.042320121916224696, 0.04881987604190008, 0.05084739776555258, 0.044885359723914164, 0.049465919160458505, 0.051519522737364376, 0.04548359197983043]}}
{"id": "3e329869-d191-40ca-9bd9-302034648d36", "fitness": 0.05857896599643167, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation based on the convergence rate of the swarm with a slight increase in social influence to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.6  # Changed from 1.5 to 1.6\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 65, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05858 with standard deviation 0.00265.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05660413665245989, 0.05809545443660602, 0.05361164769337223, 0.05996059510947682, 0.06154763580505618, 0.056768398955744925, 0.06075118009674474, 0.06236159176091727, 0.05751005345750693]}}
{"id": "91b10df4-eee6-4037-9b21-43c693a46d62", "fitness": 0.05474727525311281, "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid PSO-DE algorithm which adaptively adjusts inertia weight and integrates a fitness diversity mechanism to prevent premature convergence and maintain exploration balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n        self.inertia_weight_min = 0.4\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight based on iteration\n            self.inertia_weight = self.inertia_weight_min + (0.9 - self.inertia_weight_min) * (\n                    (self.budget - evaluations) / self.budget)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Adaptive selection strategy based on diversity\n                if trial_score < personal_best_scores[i] or (trial_score - personal_best_scores[i]) < 0.01:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05475 with standard deviation 0.00185.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05348641081798344, 0.05228501790122919, 0.05157883794614371, 0.05663249987152452, 0.055363018741970915, 0.054606285808089794, 0.05737149204586156, 0.05608553872878019, 0.05531637541643197]}}
{"id": "7ba9f2e0-9668-492d-8a67-188b657eac71", "fitness": 0.054172220040988414, "name": "EnhancedHybridPSO_DE_EMF", "description": "Enhanced Dynamic Hybrid PSO-DE with Adaptive Mutation Factor (EMF) which dynamically adjusts the mutation factor and velocity based on the population diversity to balance exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE_EMF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5  # Initialization\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            diversity = np.mean(np.std(particles, axis=0))\n            self.mutation_factor = 0.5 + 0.3 * (diversity / (ub-lb).ptp())\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedHybridPSO_DE_EMF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05417 with standard deviation 0.00541.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.04719016066672488, 0.05868051909489669, 0.049702554315614655, 0.05001909546244543, 0.0621702977258316, 0.05270429453751191, 0.0506809818534546, 0.06299343981489447, 0.05340863689752151]}}
{"id": "2e5a3f2f-1f49-4aca-8a8c-837f0da6a1ca", "fitness": 0.05811895743767708, "name": "HybridPSO_DE", "description": "Modified hybrid PSO-DE with increased cognitive parameter to enhance local search capabilities while maintaining diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.7  # Changed from 1.5 to 1.7\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8 \n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 68, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05812 with standard deviation 0.00290.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.053534497087633914, 0.05868051909489669, 0.054784248997580276, 0.05668657108349162, 0.0621702977258316, 0.05801688724319143, 0.057427077322630304, 0.06299343981489447, 0.05877707856894343]}}
{"id": "367c5290-90b9-467c-96f5-92617bd7ca13", "fitness": 0.06082922141145683, "name": "HybridPSO_DE", "description": "Introduced an adaptive mutation factor that linearly decreases over time to enhance early exploration and late exploitation in the HybridPSO_DE algorithm.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = self.mutation_factor * (1 - evaluations / self.budget)  # Adaptive mutation factor\n                mutant = a + adaptive_mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 69, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06083 with standard deviation 0.00500.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.052775417087391197, 0.06353939725974167, 0.05836934730546617, 0.055879442598117834, 0.06740848511671738, 0.06186578898860684, 0.05660822496420603, 0.06832580819854728, 0.0626910811843171]}}
{"id": "59c58901-149e-498c-be29-971b67074e96", "fitness": 0.05545485706234378, "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight reduction to enhance convergence speed by decreasing the inertia weight over iterations.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                self.inertia_weight = 0.7 * (1 - self.iteration / self.budget)  # Adaptive inertia weight reduction\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 70, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05545 with standard deviation 0.00451.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.04951393191146247, 0.05868051909489669, 0.051162638191376564, 0.052416740452800425, 0.0621702977258316, 0.05417634753728484, 0.05309651752369471, 0.06299343981489447, 0.05488328130885223]}}
{"id": "69aee4dd-3b3b-48c8-9b78-a2ce4716414c", "fitness": 0.05820837749448964, "name": "HybridPSO_ADE", "description": "A hybrid Particle Swarm Optimization (PSO) enhanced with Adaptive Differential Evolution (ADE) that dynamically adjusts mutation and crossover parameters based on diversity metrics to improve convergence and maintain diversity.", "code": "import numpy as np\n\nclass HybridPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.initial_mutation_factor = 0.5\n        self.initial_crossover_prob = 0.8\n        self.iteration = 0\n\n    def adapt_parameters(self, diversity):\n        # Adjust mutation factor and crossover probability based on diversity\n        self.mutation_factor = self.initial_mutation_factor * (1.0 + diversity)\n        self.crossover_prob = self.initial_crossover_prob * (1.0 - diversity)\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Calculate diversity metric\n            diversity = np.mean(np.std(particles, axis=0))\n\n            # Adapt mutation and crossover parameters\n            self.adapt_parameters(diversity)\n\n            # Apply ADE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 71, "feedback": "The algorithm HybridPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05821 with standard deviation 0.00449.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.050183628846266704, 0.05868051909489669, 0.05835586641589896, 0.05313569420485975, 0.0621702977258316, 0.061851614171176794, 0.05382759777547419, 0.06299343981489447, 0.06267673940110763]}}
{"id": "e068b8a8-ab56-4cd3-9943-3251e0f8fb28", "fitness": 0.05726395084483008, "name": "HybridPSO_DE", "description": "Introduce adaptive mutation factor in DE based on iteration to balance exploration and exploitation phases, improving convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = 0.5 + 0.5 * (1.0 - self.iteration / (self.budget // self.population_size))\n                mutant = a + adaptive_mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 72, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05726 with standard deviation 0.00333.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05288057055310613, 0.05868051909489669, 0.0529949663639554, 0.05598618112241582, 0.0621702977258316, 0.05611128321705028, 0.05671526182713316, 0.06299343981489447, 0.05684303788418721]}}
{"id": "e87323bf-5344-4406-a7c4-db510f1a5c19", "fitness": 0.054248823276444105, "name": "RefinedHybridPSO_DE", "description": "A refined hybrid PSO-DE algorithm with adaptive inertia weight adjustment, improved social-cognitive balance, and an enhanced DE mutation strategy to better explore and exploit the search space.", "code": "import numpy as np\n\nclass RefinedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.inertia_damp = 0.99\n        self.cognitive_param = 1.7\n        self.social_param = 1.7\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.9\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                score = func(particles[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            self.inertia_weight *= self.inertia_damp\n\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = personal_best_positions[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 73, "feedback": "The algorithm RefinedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05425 with standard deviation 0.00275.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.049055232433371176, 0.053996340864765235, 0.05286839872682403, 0.05193294246117419, 0.05717280538240688, 0.05597876167874882, 0.05260665830605726, 0.057919175559131286, 0.05670909407551805]}}
{"id": "78069aab-6737-480a-ab13-f4958ebc9da2", "fitness": 0.056444512823854195, "name": "HybridPSO_DE", "description": "Introduce a dynamic inertia weight adjustment mechanism based on the iteration progress to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - (self.iteration / (self.budget / self.population_size)) * 0.5\n                \n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 74, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05644 with standard deviation 0.00233.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05250713739034185, 0.05611234525442477, 0.053589255829583515, 0.055597513199530546, 0.05943548171959889, 0.056739061646664646, 0.05632301955385488, 0.06021788120294458, 0.057478919617744095]}}
{"id": "8f710bc1-526f-41c3-b33d-a94f400fd9e3", "fitness": 0.05437840931840096, "name": "EPSO_ADE", "description": "Enhanced Particle Swarm Optimization with Adaptive Differential Evolution (EPSO-ADE) that leverages adaptive inertia weight and mutation factor to balance exploration and exploitation dynamically, improving convergence and diversity.", "code": "import numpy as np\n\nclass EPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with a high inertia weight\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n        self.decay_rate = 0.99  # Decay factor for inertia weight and mutation factor\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply adaptive DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            # Decay inertia weight and mutation factor adaptively\n            self.inertia_weight *= self.decay_rate\n            self.mutation_factor *= self.decay_rate\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 75, "feedback": "The algorithm EPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05438 with standard deviation 0.00182.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05165755839014263, 0.05147181152900715, 0.05317016476226366, 0.054689347242079855, 0.054493736012980576, 0.05629336589305356, 0.055400477405265436, 0.055202491054364144, 0.05702673157645166]}}
{"id": "c8389a19-f680-4a5e-a024-fb0a95c6a0a9", "fitness": 0.05811895743767708, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation based on the convergence rate of the swarm with increased cognitive parameter to enhance personal learning.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.7  # Changed from 1.5 to 1.7\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 76, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05812 with standard deviation 0.00290.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.053534497087633914, 0.05868051909489669, 0.054784248997580276, 0.05668657108349162, 0.0621702977258316, 0.05801688724319143, 0.057427077322630304, 0.06299343981489447, 0.05877707856894343]}}
{"id": "1951daf6-6629-431e-9643-8bd33a7435d2", "fitness": 0.05830166228492993, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with adaptive inertia weight and dynamic mutation factor to balance exploration-exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor_max = 0.9\n        self.mutation_factor_min = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            mutation_factor = self.mutation_factor_max - ((self.mutation_factor_max - self.mutation_factor_min) * evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05830 with standard deviation 0.00255.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.053524292040343036, 0.05626824394048735, 0.05770097686134379, 0.05667256270025056, 0.059627468405791584, 0.061139613941095905, 0.057412083585252405, 0.0604192347646898, 0.06195048432511496]}}
{"id": "bf41d410-eb9e-4808-9587-d5601ff084c2", "fitness": 0.05301908675603052, "name": "EnhancedHybridPSO_DE", "description": "An Enhanced Hybrid PSO-DE algorithm that adapts inertia dynamically based on convergence rate and incorporates adaptive mutation factor for improved exploration-exploitation balance and diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.inertia_decay = 0.99\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.base_mutation_factor = 0.5\n        self.crossover_prob = 0.9  # Increased to encourage exploration\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor = self.base_mutation_factor * (1 - self.iteration / self.budget)  # Adaptive mutation factor\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            # Update inertia weight\n            self.inertia_weight *= self.inertia_decay\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05302 with standard deviation 0.00204.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.051020722599510404, 0.05217350787718522, 0.04920341704818243, 0.05401342131807174, 0.0552377141140612, 0.052087936288532366, 0.0547150357780668, 0.0559567482527592, 0.05276327752790533]}}
{"id": "08d44400-bcc0-4864-a9e7-a04635c5d112", "fitness": 0.05443799953249415, "name": "HybridPSO_DE", "description": "Enhanced inertia weight adaptation in HybridPSO_DE for improved convergence control.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 79, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05444 with standard deviation 0.00215.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.050492615801939755, 0.05223760167511826, 0.05373757122491685, 0.053454799007463194, 0.05530381441399812, 0.05690012090275898, 0.05414901658925586, 0.056023303448977546, 0.05764315272801879]}}
{"id": "29d192e7-d716-4e90-87ee-2cfa96a51f42", "fitness": 0.05132036968563916, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE utilizing adaptive parameters for mutation factor and inertia weight based on population diversity to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.base_mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Calculate diversity\n            diversity = np.mean(np.std(particles, axis=0))\n\n            # Adaptive parameters\n            mutation_factor = self.base_mutation_factor + 0.2 * (1 - diversity)\n            inertia_weight = self.inertia_weight + 0.1 * diversity\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05132 with standard deviation 0.00576.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.048060551421183484, 0.056145642512203, 0.04327778427566342, 0.05087981452670176, 0.059460703628369416, 0.04584045609568943, 0.05153934673397553, 0.060240938036259295, 0.046438089940707084]}}
{"id": "e3812c71-c173-42b8-9663-858bd9e25000", "fitness": 0.05549550391856344, "name": "HybridPSO_DE", "description": "A hybrid PSO-DE algorithm using a dynamic inertia weight strategy to improve convergence by gradually decreasing it over iterations.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                # Change: Dynamic inertia weight\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 81, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05550 with standard deviation 0.00294.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05486601463443275, 0.0547216083407287, 0.049898447734770035, 0.05811259708422056, 0.057947411947271266, 0.05282308037041983, 0.05887634774688544, 0.05870588290350043, 0.05350814450484198]}}
{"id": "d81bc987-0472-4c18-a3f2-cd97d5d0bc99", "fitness": 0.05605148798178631, "name": "EnhancedHybridPSO_DE", "description": "A hybrid PSO-DE algorithm with adaptive inertia weight and self-adaptive mutation factor to enhance convergence speed and solution diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor_min = 0.4\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.8\n        self.iteration = 0\n        self.max_iterations = (budget // self.population_size)\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adapt inertia weight\n            self.inertia_weight = self.inertia_weight_min + (self.inertia_weight - self.inertia_weight_min) * (self.max_iterations - self.iteration) / self.max_iterations\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                \n                # Self-adaptive mutation factor\n                mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * np.random.rand()\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05605 with standard deviation 0.00305.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05185991341422047, 0.0570996469227657, 0.052107503802583555, 0.054910674168656914, 0.060500797134595885, 0.055168712906840556, 0.05562654207214068, 0.061302561222739804, 0.05588704019153323]}}
{"id": "116470b6-4917-4d27-afe4-2826ef419372", "fitness": 0.05473168143045356, "name": "EnhancedHybridPSO_DE", "description": "An enhanced hybrid PSO-DE algorithm with adaptive inertia weight and self-adaptive mutation factor to fine-tune exploration and exploitation dynamically based on convergence metrics.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor_min = 0.4\n        self.mutation_factor_max = 0.9\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Dynamically adjust inertia weight and mutation factor\n            w = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (evaluations / self.budget)\n            f = self.mutation_factor_max - (self.mutation_factor_max - self.mutation_factor_min) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                score = func(particles[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + f * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n\n        return global_best_position", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05473 with standard deviation 0.00200.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05369667546765544, 0.0510405512469051, 0.052572605781912696, 0.056855465813932526, 0.05403856393238626, 0.055658901843540276, 0.05759754658950744, 0.05474154413534982, 0.05638327806289245]}}
{"id": "635b412c-1461-47e0-8ecb-2f7d58184326", "fitness": 0.05645062803013604, "name": "HybridPSO_DE", "description": "A hybrid PSO-DE algorithm with an increased crossover probability to enhance diversity and maintain exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9  # Changed from 0.8 to 0.9\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 84, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05645 with standard deviation 0.00404.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05330129833893915, 0.05868051909489669, 0.05023751516783814, 0.056433973778054036, 0.0621702977258316, 0.05318866698335023, 0.05716966505138876, 0.06299343981489447, 0.05388027631603132]}}
{"id": "d82d9881-568b-4917-8b81-5bd705d61abe", "fitness": 0.056581779883385835, "name": "HybridPSO_DE", "description": "Improved convergence by slightly adjusting the inertia weight for better balance in exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.72  # Changed from 0.7 to 0.72\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 85, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05658 with standard deviation 0.00265.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.055518593998909016, 0.05561881642985067, 0.051467772285921254, 0.058796871840909315, 0.05889954344809101, 0.054492660509951385, 0.05956818403785824, 0.059671382560385844, 0.055202193838595814]}}
{"id": "760cfc57-9c78-4c9e-a9b6-971cf0c044d8", "fitness": 0.05930162025486618, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation based on the convergence rate of the swarm with increased mutation factor to enhance diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.6  # Changed from 0.5 to 0.6\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 86, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05930 with standard deviation 0.00315.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.053317352962554576, 0.05868051909489669, 0.05835586641589896, 0.056464619009181094, 0.0621702977258316, 0.061851614171176794, 0.057204133698253834, 0.06299343981489447, 0.06267673940110763]}}
{"id": "a895bc3d-20e8-42da-a8a2-41c643c19c75", "fitness": 0.05784178527019469, "name": "HybridPSO_DE", "description": "A hybrid PSO integrated with DE, modifying inertia weight dynamically based on iterations to enhance convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                self.inertia_weight = 0.4 + (0.7 - 0.4) * (self.budget - evaluations) / self.budget  # Changed line\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 87, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05784 with standard deviation 0.00437.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05285674355765191, 0.060773930147905886, 0.05255651634996428, 0.05597447136661504, 0.06441524819434585, 0.05564573866994704, 0.05670676895970406, 0.06527575671490438, 0.05637089347071378]}}
{"id": "959e6245-f89b-4192-bcbf-7ad3a2ea6962", "fitness": 0.054843083966521676, "name": "AdaptiveHybridPSO_DE", "description": "A Self-Adaptive Hybrid PSO-DE algorithm that dynamically adjusts inertia weight and mutation factors based on search progress to enhance convergence and diversity.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n        self.max_iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adjust inertia weight and mutation factor adaptively\n            inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n            mutation_factor = 0.4 + 0.6 * (1 - evaluations / self.budget)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 88, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05484 with standard deviation 0.00180.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.053498692369724155, 0.05197666338560769, 0.05214969758831389, 0.0566455746694523, 0.05502731144419504, 0.05522061170624881, 0.05738476066840992, 0.05574301900369194, 0.055941424863051314]}}
{"id": "33781f06-db0d-43c1-b66f-64c79442956c", "fitness": 0.05479389270969367, "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE by modifying the inertia weight for improved adaptability and convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = ((0.5 + 0.5 * np.random.rand()) * velocities[i] +  # Modified inertia weight\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 89, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05479 with standard deviation 0.00203.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05089948143808665, 0.05332390731248737, 0.0532555552266023, 0.053885191589171044, 0.05646117918417759, 0.05639897955458428, 0.05458511326130522, 0.05719804518095639, 0.05713758163987215]}}
{"id": "d292f975-94a1-4180-a0b4-510a729a4831", "fitness": 0.05509487026961952, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Parameters and Memory-Based Mutation for Better Convergence and Diversity Maintenance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n        self.max_iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n        memory = np.copy(particles)  # Memory to store historical best solutions\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            inertia_weight = self.initial_inertia_weight - ((self.initial_inertia_weight - self.final_inertia_weight) * (self.iteration / self.max_iterations))\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover with memory for diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = memory[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection with memory update\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                if trial_score < func(memory[i]):\n                    memory[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05509 with standard deviation 0.00253.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05286941097377551, 0.05050066131676623, 0.05496668503020463, 0.05597983119488037, 0.05346709095615365, 0.05821652775588049, 0.05671017918301968, 0.05416242207214195, 0.05898102394375315]}}
{"id": "c0fed2af-97bc-4793-ad2f-312fd36b5df9", "fitness": 0.05728875303125079, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Inertia and Self-Adaptive Mutation for improved convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Start with higher inertia\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.initial_mutation_factor = 0.5\n        self.crossover_prob = 0.9  # Increased for more diversity\n        self.iteration = 0\n        self.evaluations = 0\n\n    def _adaptive_inertia(self):\n        return max(self.inertia_weight_min, self.inertia_weight - (self.inertia_weight - self.inertia_weight_min) * (self.evaluations / self.budget))\n\n    def _self_adaptive_mutation(self, current_mutation_factor):\n        return current_mutation_factor * (1.2 - 0.4 * (self.evaluations / self.budget))\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        self.evaluations = self.population_size\n\n        while self.evaluations < self.budget:\n            inertia_weight = self._adaptive_inertia()\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            mutation_factor = self._self_adaptive_mutation(self.initial_mutation_factor)\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05729 with standard deviation 0.00397.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05225953031971564, 0.059677154389082054, 0.05267058792375634, 0.05534057457157959, 0.06324169407982094, 0.05576747342378152, 0.056063940086949815, 0.06408331635835984, 0.056494506128211386]}}
{"id": "44cbd5d0-f52d-4140-b7b0-81c661ad212f", "fitness": 0.057727500055188626, "name": "RefinedHybridPSO_DE", "description": "Introducing adaptive inertia weight and dynamic population size to balance exploration and exploitation more effectively in the hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass RefinedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.final_population_size = 10\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        def adaptive_inertia_weight():\n            return self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (evaluations / self.budget)\n\n        def dynamic_population_size():\n            return int(self.initial_population_size - (self.initial_population_size - self.final_population_size) * (evaluations / self.budget))\n        \n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.initial_population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.initial_population_size\n\n        while evaluations < self.budget:\n            population_size = dynamic_population_size()\n            inertia_weight = adaptive_inertia_weight()\n\n            for i in range(population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 92, "feedback": "The algorithm RefinedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05773 with standard deviation 0.00275.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.0581558725460567, 0.05393198086205708, 0.053787696218770886, 0.061611233405201804, 0.05710986175913901, 0.05696118522732885, 0.062425952267673446, 0.05785669196271659, 0.05770702624775326]}}
{"id": "3505d086-47d3-40cd-849c-b2a1ceb18e74", "fitness": 0.05604081156755574, "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive inertia weight and dynamic mutation factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Adjusted from 0.7 to 0.9\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.8  # Adjusted from 0.5 to 0.8\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 93, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05604 with standard deviation 0.00206.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05486418914311186, 0.054003174610520954, 0.05219123470089959, 0.058100647298777064, 0.05718568279090108, 0.05525415725890992, 0.058861746929965375, 0.05793362683003189, 0.05597284454488394]}}
{"id": "98b0e89d-271e-46b5-804c-e1fb1e23bf2a", "fitness": 0.05853595538671143, "name": "HybridPSO_ADE", "description": "An enhanced hybrid Particle Swarm Optimization (PSO) with Adaptive Differential Evolution (ADE) that dynamically adjusts mutation and crossover rates based on population diversity to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        def diversity_measure(population):\n            mean_pos = np.mean(population, axis=0)\n            return np.mean(np.linalg.norm(population - mean_pos, axis=1))\n\n        while evaluations < self.budget:\n            current_diversity = diversity_measure(particles)\n\n            # Adaptive mutation and crossover\n            self.mutation_factor = 0.5 + 0.3 * (1 - current_diversity / self.dim)\n            self.crossover_prob = 0.7 + 0.3 * (current_diversity / self.dim)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply ADE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 94, "feedback": "The algorithm HybridPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05854 with standard deviation 0.00271.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05400092339593798, 0.05868051909489669, 0.05550730619515509, 0.05718383235991986, 0.0621702977258316, 0.0587912897163928, 0.05793188154520845, 0.06299343981489447, 0.05956410863216588]}}
{"id": "5b5592ec-b274-4130-93fa-ee2c711aeba5", "fitness": 0.05395043111572964, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Inertia and Dynamic Crossover for improved convergence by adjusting inertia based on iterations and using dynamic crossover probabilities to maintain diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.initial_crossover_prob = 0.8\n        self.final_crossover_prob = 0.9\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            inertia_weight = self.initial_inertia_weight - (\n                (self.initial_inertia_weight - self.final_inertia_weight) * (evaluations / self.budget)\n            )\n            # Dynamic crossover probability\n            crossover_prob = self.initial_crossover_prob + (\n                (self.final_crossover_prob - self.initial_crossover_prob) * (evaluations / self.budget)\n            )\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05395 with standard deviation 0.00212.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05348641081798344, 0.050412335128549035, 0.051170360104497936, 0.05663249987152452, 0.05336891164798108, 0.05417302753190756, 0.05737149204586156, 0.05406175170939498, 0.05487709118386663]}}
{"id": "bb25d344-f6a2-49b1-8098-ffc81666c704", "fitness": 0.054990043963973285, "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight to balance exploration and exploitation dynamically throughout iterations.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8  # Changed from 0.7 to 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.9 - (0.5 * evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 96, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05499 with standard deviation 0.00259.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05517855616138456, 0.05228501790122919, 0.050575002208605446, 0.05844111501943905, 0.055363018741970915, 0.05353936526120995, 0.05920871057979593, 0.05608553872878019, 0.054234071073344325]}}
{"id": "b9ed4397-81fa-4611-8df9-278466c97c25", "fitness": 0.055601947085381465, "name": "HybridPSO_DE", "description": "Improved exploitation by increasing the cognitive_param to 1.6 to enhance the convergence of individual particles towards their personal bests.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.6  # Changed from 1.5 to 1.6\n        self.social_param = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 97, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05560 with standard deviation 0.00466.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.051499229505692634, 0.05898147487779226, 0.04929972825120821, 0.054527543537271184, 0.06249296453612019, 0.05219019726867258, 0.05523794133410631, 0.0633214585390246, 0.05286698591854522]}}
{"id": "c3d1ad0c-e7c7-4923-8709-854f3c39e866", "fitness": 0.05737744935854786, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE with dynamic parameters adjustment and adaptive mutation strategy to balance exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.iteration = 0\n        self.max_iterations = budget // self.population_size\n        \n        # Dynamic parameters initialization\n        self.inertia_weight = 0.9\n        self.cognitive_param = 2.0\n        self.social_param = 2.0\n        self.mutation_factor_base = 0.8\n        self.mutation_factor = self.mutation_factor_base\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            iteration_ratio = self.iteration / self.max_iterations\n            # Adaptive inertia weight\n            self.inertia_weight = 0.9 - 0.5 * iteration_ratio\n            # Adaptive mutation factor\n            self.mutation_factor = self.mutation_factor_base * (1 - iteration_ratio)\n\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05738 with standard deviation 0.00391.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05160812499044487, 0.05375732091180552, 0.05951178568539783, 0.05463511040815716, 0.05691691649472863, 0.06306268493278833, 0.05534504265097262, 0.05765914066056843, 0.06390091749206739]}}
{"id": "4349ca01-8e34-46d3-820c-4262840f6e50", "fitness": 0.056283181589154636, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization (PSO) integrated with Differential Evolution (DE) that dynamically adapts exploration and exploitation with a dynamic mutation factor to enhance diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.mutation_factor = 0.5  # Adjust mutation factor dynamically\n        self.crossover_prob = 0.8\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize particles\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.array([func(p) for p in particles])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = particles[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Update velocity and position\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_param * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_param * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n                # Evaluate particles\n                score = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n\n            # Update global best\n            global_best_index = np.argmin(personal_best_scores)\n            global_best_position = personal_best_positions[global_best_index]\n\n            # Apply DE mutation and crossover to adapt diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Dynamic mutation factor\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                trial = np.where(crossover_mask, mutant, particles[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    particles[i] = trial\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n\n            self.iteration += 1\n        \n        return global_best_position", "configspace": "", "generation": 99, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05628 with standard deviation 0.00423.", "error": "", "parent_ids": ["c06b257d-f005-4294-8aa7-60f4ab4501e2"], "operator": null, "metadata": {"aucs": [0.05336681196985171, 0.05868051909489669, 0.049680978247326646, 0.056518656516391874, 0.0621702977258316, 0.052597702294503446, 0.05725929871232582, 0.06299343981489447, 0.05328092992636946]}}
