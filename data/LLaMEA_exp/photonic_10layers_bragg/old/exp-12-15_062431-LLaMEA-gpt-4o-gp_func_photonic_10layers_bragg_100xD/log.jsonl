{"id": "66f42ff0-497d-4946-a3a1-999e5bba2741", "fitness": 0.06452589571337282, "name": "AdaptiveDifferentialEvolution", "description": "A novel adaptive differential evolution algorithm with dynamic parameter tuning to efficiently explore and exploit the search space within the evaluation budget.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.eval_count = 0\n        \n    def __call__(self, func):\n        # Initialize population\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3), bounds[0], bounds[1])\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n            \n            # Adaptive parameter tuning\n            self.crossover_rate = 0.5 + 0.3 * np.sin(np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(np.pi * self.eval_count / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06453 with standard deviation 0.00389.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.0615472750029884, 0.07001677599416156, 0.06201363614296851]}}
{"id": "7da9829f-0696-470f-9f26-ef1c3a1bc0c3", "fitness": 0.06479964062912769, "name": "AdaptiveDifferentialEvolution", "description": "A refined adaptive differential evolution algorithm with improved parameter adaptation based on progress in the search space.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.eval_count = 0\n        \n    def __call__(self, func):\n        # Initialize population\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3), bounds[0], bounds[1])\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n            \n            # Adaptive parameter tuning\n            self.crossover_rate = 0.5 + 0.3 * np.sin(np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))  # Modified line\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06480 with standard deviation 0.00371.", "error": "", "parent_ids": ["66f42ff0-497d-4946-a3a1-999e5bba2741"], "operator": null, "metadata": {"aucs": [0.06170784438107957, 0.07001677599416156, 0.06267430151214193]}}
{"id": "81680a67-cafe-4ea9-9c82-ddb41b145ab3", "fitness": 0.06846862041216961, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic population size and self-adaptive mutation and crossover strategies.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.eval_count = 0\n        \n    def __call__(self, func):\n        # Initialize population\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3), bounds[0], bounds[1])\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n            \n            # Dynamic population size adjustment\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            # Self-adaptive parameter tuning\n            self.crossover_rate = 0.5 + 0.3 * np.sin(np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06847 with standard deviation 0.00423.", "error": "", "parent_ids": ["7da9829f-0696-470f-9f26-ef1c3a1bc0c3"], "operator": null, "metadata": {"aucs": [0.06563912960009899, 0.07445314323930607, 0.06531358839710377]}}
{"id": "7deceef3-a1de-4577-8a3d-3f1195954dd5", "fitness": 0.07984275067031359, "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with oscillating control parameters and dynamic elitism selection.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation with oscillating control parameters\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor, bounds[0], bounds[1])\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n            \n            # Dynamic population size adjustment\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            # Self-adaptive parameter tuning with oscillating control\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            # Dynamic elitism selection\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 3, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07984 with standard deviation 0.00183.", "error": "", "parent_ids": ["81680a67-cafe-4ea9-9c82-ddb41b145ab3"], "operator": null, "metadata": {"aucs": [0.07888664450221672, 0.07823496495686522, 0.08240664255185881]}}
{"id": "9639cefc-6d0d-46fd-a602-368cea5eacb9", "fitness": 0.08326336923137467, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with oscillating control parameters, dynamic elitism selection, and self-adaptive mutation strategies for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Additional parameter for self-adaptive mutation strategy\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08326 with standard deviation 0.00175.", "error": "", "parent_ids": ["7deceef3-a1de-4577-8a3d-3f1195954dd5"], "operator": null, "metadata": {"aucs": [0.0853975792100149, 0.0811082110302489, 0.08328431745386022]}}
{"id": "4e4ea107-aa5a-4ac3-b19f-b32cfb08a2d1", "fitness": 0.07079328253719956, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved Enhanced Adaptive Differential Evolution with dynamic population size adjustment, diversity preservation, and adaptive parameter control for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim  # Changed initial population size\n        self.min_population_size = 3 * dim  # Changed minimum population size\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.alpha = 0.15  # Changed self-adaptive mutation strategy parameter\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 8) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size * (1 + diversity)))  # Adjusted population reduction\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.4 + 0.2 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.6 + 0.25 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 8)  # Adjusted elite size\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07079 with standard deviation 0.00315.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.06899332669237124, 0.07521561507712637, 0.06817090584210106]}}
{"id": "efe5b97f-845d-416e-95c9-8ba7fee998c1", "fitness": 0.08216454043714305, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with refined elite preservation by doubling the elites added back to the population for better diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Additional parameter for self-adaptive mutation strategy\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10) * 2  # Double the elite size\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08216 with standard deviation 0.00069.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08310240462768537, 0.08193671541451775, 0.08145450126922604]}}
{"id": "849c81ce-01e8-49a6-96bd-0a6ba1147457", "fitness": 0.08326336923137467, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic population resizing, self-adaptive crossover and mutation rates, and oscillating control parameters for efficient convergence improvement.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.base_crossover_rate = 0.9\n        self.base_mutation_factor = 0.8\n        self.alpha = 0.1  # Self-adaptive mutation strategy parameter\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.base_mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.base_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            # Dynamic adjustment of crossover and mutation factors\n            self.base_crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.base_mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count / self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08326 with standard deviation 0.00175.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.0853975792100149, 0.0811082110302489, 0.08328431745386022]}}
{"id": "718f2d54-1cd7-4e41-9ff4-0885d6d541fc", "fitness": 0.08259039362859255, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with stochastic tunneling for escaping local optima, employing a dynamic adjustment of the mutation factor based on variance in fitness values to improve exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Additional parameter for self-adaptive mutation strategy\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            dynamic_mutation_factor = self.mutation_factor + 0.1 * (fitness_variance / (1 + fitness_variance))\n            \n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + dynamic_mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                \n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n                else:\n                    p_accept = np.exp(-np.abs(f_trial - fitness[i]) / (fitness_variance + 1e-12))\n                    if np.random.rand() < p_accept:\n                        population[i] = trial\n                        fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08259 with standard deviation 0.00145.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08439313215478672, 0.0808533258428693, 0.08252472288812163]}}
{"id": "384f6fd1-3011-47ca-b147-c2fdcd60fcb8", "fitness": 0.07980800670394687, "name": "AdvancedDynamicDifferentialEvolution", "description": "Advanced Dynamic Differential Evolution with adaptive population resizing and frequency-modulated control parameters for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Self-adaptive mutation strategy parameter\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)  # Frequency-modulated oscillation\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 5) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.4 * np.sin(4 * np.pi * self.eval_count / self.budget)  # Enhanced modulation\n            self.mutation_factor = 0.5 + 0.4 * np.cos(4 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 9, "feedback": "The algorithm AdvancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07981 with standard deviation 0.00083.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08086333540448176, 0.07882171118543047, 0.07973897352192838]}}
{"id": "294a07fd-860b-48c2-8335-bd2032f0843e", "fitness": 0.08073667732973766, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic mutation factor fine-tuning using fitness diversity to improve convergence stability.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Additional parameter for self-adaptive mutation strategy\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            # Changed line: Replace mutation factor calculation for improved stability\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.std() / fitness.mean()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08074 with standard deviation 0.00112.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08213675797897768, 0.07938699046376607, 0.08068628354646923]}}
{"id": "12c94a5e-2fd5-4093-9c8d-23c7ae4b6f2c", "fitness": 0.07872926195068024, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive population resizing, elite reinforcement, and chaotic perturbation strategy for robust global convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Self-adaptive mutation strategy\n        self.beta = 0.3  # Chaotic perturbation factor\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Chaotic perturbation\n                chaotic_perturbation = self.beta * (np.random.rand(self.dim) - 0.5)\n                trial = np.clip(trial + chaotic_perturbation, bounds[0], bounds[1])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07873 with standard deviation 0.00162.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08102106718187796, 0.07765385433979854, 0.0775128643303642]}}
{"id": "5ab17a3e-6c76-4294-88ca-9d7f077c8c03", "fitness": 0.07410991392140402, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved Enhanced Adaptive Differential Evolution with adaptive population resizing strategy and diversity preservation for robust exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim  # Changed initial population size\n        self.min_population_size = 3 * dim  # Modified min population size\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size / 1.5))  # Changed population resizing strategy\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(2, self.population_size // 8)  # Adjusted elite size\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07411 with standard deviation 0.00325.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.07412820329491343, 0.07808508988701646, 0.07011644858228216]}}
{"id": "ec8478c2-5f91-458f-80da-2ade22e05eb8", "fitness": 0.08326336923137467, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "A multi-strategy Enhanced Adaptive Differential Evolution with diversity preservation and adaptive parameter control for enhanced convergence and robustness.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # New parameter for diversity preservation\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            diversity = np.mean(np.std(population, axis=0))\n            \n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if diversity < self.diversity_threshold:\n                self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n            else:\n                self.mutation_factor = max(0.4, self.mutation_factor * 0.9)\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08326 with standard deviation 0.00175.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.0853975792100149, 0.0811082110302489, 0.08328431745386022]}}
{"id": "38abd54d-ea95-4cbd-8a42-f45c779adeac", "fitness": 0.07984436935255486, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved Enhanced Adaptive Differential Evolution with time-varying crossover and mutation, chaotic map initialization, and elite learning strategy for superior exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n\n    def chaotic_initialization(self, bounds):\n        logistic_map = np.random.rand(self.population_size)\n        for i in range(1, 100):\n            logistic_map = 4.0 * logistic_map * (1 - logistic_map)\n        return bounds[0] + (bounds[1] - bounds[0]) * logistic_map[:, np.newaxis] * np.random.rand(self.population_size, self.dim)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = self.chaotic_initialization(bounds)\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.cos(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.sin(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07984 with standard deviation 0.00255.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08284616506719877, 0.07661615872827299, 0.08007078426219283]}}
{"id": "f947ab52-a571-49f3-965f-db6dc8d2a0ad", "fitness": 0.08211102472211666, "name": "HybridAdaptiveDifferentialEvolution", "description": "Introduce a hybrid mutation strategy combining oscillating differential mutation with a novel noise amplification mechanism for dynamic exploration.", "code": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Self-adaptive mutation strategy parameter\n        self.noise_amplification_factor = 0.05  # New noise amplification parameter\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                noise_amplification = self.noise_amplification_factor * np.random.randn(self.dim)\n                mutant = np.clip(\n                    x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + noise_amplification,\n                    bounds[0], bounds[1]\n                )\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count / self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 15, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08211 with standard deviation 0.00305.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08642602282131939, 0.07983576836229522, 0.08007128298273536]}}
{"id": "aa266d16-1588-4275-a93a-1cf92325ee2b", "fitness": 0.08307290978316835, "name": "ImprovedEnhancedAdaptiveDifferentialEvolution", "description": "Improved Enhanced Adaptive Differential Evolution with dynamic scaling factors and diversity preservation to balance exploration and exploitation for superior convergence.", "code": "import numpy as np\n\nclass ImprovedEnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Additional parameter for self-adaptive mutation strategy\n        self.diversity_threshold = 0.1  # Threshold to maintain diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            diversity = np.mean(np.std(population, axis=0))\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                dynamic_scaling = np.clip(1.0 - (self.eval_count / self.budget), 0.1, 1.0)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor * dynamic_scaling + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n            if diversity < self.diversity_threshold:\n                additional_population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                additional_fitness = np.array([func(ind) for ind in additional_population])\n                self.eval_count += self.population_size\n                combined_population = np.vstack((population, additional_population))\n                combined_fitness = np.append(fitness, additional_fitness)\n                best_indices = np.argsort(combined_fitness)[:self.population_size]\n                population = combined_population[best_indices]\n                fitness = combined_fitness[best_indices]\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 16, "feedback": "The algorithm ImprovedEnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08307 with standard deviation 0.00191.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08571197423934018, 0.08126685323808658, 0.0822399018720783]}}
{"id": "66148c00-007b-4828-a334-84ea525a5ddc", "fitness": 0.08196042458209755, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Novel Differential Evolution with adaptive oscillating factors, elite retention, and dynamic population control for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = 0.5 * np.sin(4 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n\n                if f_trial < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(f_trial)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.6 + 0.3 * np.sin(3 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.6 + 0.3 * np.cos(3 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08196 with standard deviation 0.00275.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08393524670299857, 0.08388067079801975, 0.07806535624527433]}}
{"id": "613536be-da93-4c5f-b4a3-5d79c1bfda09", "fitness": 0.06982798981250256, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic oscillating control parameters, elitism based on fitness variance, and adaptive population resizing for better convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.min_population_size = 5 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Additional parameter for self-adaptive mutation strategy\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size * 0.75))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            fitness_variance = np.var(fitness)\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness_variance / (fitness.min() + 1e-5)))\n\n            elite_size = max(1, self.population_size // 8)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06983 with standard deviation 0.00250.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.06629082835216082, 0.07168204723891869, 0.07151109384642818]}}
{"id": "9ac683ad-2634-4393-b478-17dc78fba716", "fitness": 0.08262276173971365, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Adjusted the self-adaptive mutation strategy to enhance exploration capabilities and improve convergence speed.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Additional parameter for self-adaptive mutation strategy\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * np.exp(-self.eval_count/self.budget)  # Modified line\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08262 with standard deviation 0.00199.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08530932571634275, 0.08055257773743907, 0.08200638176535913]}}
{"id": "1c11030e-b39f-4278-b995-c6568448db0a", "fitness": 0.07665305952678654, "name": "EnhancedAdaptiveDiffEvoWithLocalSearch", "description": "Introduce adaptive population resizing with a mutation strategy that leverages local search intensification for improved convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDiffEvoWithLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.eval_count = 0\n        # Dynamic control parameters\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.initial_population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.initial_population_size\n        \n        while self.eval_count < self.budget:\n            for i in range(len(population)):\n                indices = np.random.choice([j for j in range(len(population)) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                local_search = np.random.normal(0, 0.1, self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self.alpha * local_search, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Update population size adaptively\n            if self.eval_count % (self.budget // 10) == 0 and len(population) > self.min_population_size:\n                self.population_size = max(self.min_population_size, len(population) // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            # Dynamic parameter adaptation\n            self.crossover_rate = 0.5 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.4 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            # Maintain elite population\n            elite_size = max(1, len(population) // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedAdaptiveDiffEvoWithLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07665 with standard deviation 0.00379.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08148204972295003, 0.0722103897874844, 0.0762667390699252]}}
{"id": "50849723-c805-4d4a-b0fc-57b46d7638f1", "fitness": 0.07704693278042622, "name": "ImprovedEnhancedAdaptiveDifferentialEvolution", "description": "Improved Enhanced Adaptive Differential Evolution with adaptive population resizing and stochastic ranking for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedEnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Adaptive population resizing\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size * 0.9))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            # Stochastic ranking for selection\n            if self.eval_count % (self.budget // 5) == 0:\n                perm = np.random.permutation(self.population_size)\n                for j in range(self.population_size):\n                    if fitness[perm[j]] < fitness[j]:\n                        population[j], population[perm[j]] = population[perm[j]], population[j]\n                        fitness[j], fitness[perm[j]] = fitness[perm[j]], fitness[j]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count / self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 21, "feedback": "The algorithm ImprovedEnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07705 with standard deviation 0.00327.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08124696202437875, 0.07327479713168195, 0.07661903918521795]}}
{"id": "8895d0ec-dd2b-48b0-a40f-4d72dcfe0e6e", "fitness": 0.07911402416597313, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic control parameters, adaptive population resizing, and hybrid crossover strategies for robust optimization across diverse landscapes.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1  # Additional parameter for self-adaptive mutation strategy\n        self.beta = 0.5   # For adaptive population resizing\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                # Implementing a hybrid crossover strategy (binomial and exponential)\n                if np.random.rand() < 0.5:\n                    cross_points = np.random.rand(self.dim) < self.crossover_rate\n                else:\n                    n = np.random.randint(0, self.dim)\n                    L = np.random.randint(1, self.dim+1)\n                    cross_points = np.zeros(self.dim, dtype=bool)\n                    cross_points[n:(n+L)%self.dim] = True\n\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size * self.beta))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget) * (fitness.std() / max(1e-8, fitness.mean()))\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / fitness.min()))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population = np.vstack((elite_population, population))\n            fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07911 with standard deviation 0.00124.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.07762837662335365, 0.08065575123755908, 0.07905794463700666]}}
{"id": "07020917-2843-4870-a948-60a36b0875d2", "fitness": 0.0834075460503102, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with novel adaptive parameter control and diversity preservation mechanisms for robust global optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # Additional parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08341 with standard deviation 0.00268.", "error": "", "parent_ids": ["9639cefc-6d0d-46fd-a602-368cea5eacb9"], "operator": null, "metadata": {"aucs": [0.08675510692590649, 0.08019121276584218, 0.08327631845918193]}}
{"id": "614e09b6-6d2c-4e84-96e4-39fe078354ff", "fitness": 0.0778885006715813, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with strategic step-size adaptation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # Additional parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.4 * np.cos(2 * np.pi * (self.eval_count/self.budget) * np.std(population, axis=0).mean())\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07789 with standard deviation 0.00431.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08396701531152517, 0.07443346993885391, 0.07526501676436481]}}
{"id": "90ecb316-a246-454e-814a-641606ae7b0e", "fitness": 0.0834075460503102, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with improved elitism strategy to bolster solution quality and convergence speed.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # Additional parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08341 with standard deviation 0.00268.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08675510692590649, 0.08019121276584218, 0.08327631845918193]}}
{"id": "dd4ffc18-a69c-4fde-a11a-40fc388a9c64", "fitness": 0.0834075460503102, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with improved self-adaptive mechanisms and dynamic population resizing for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                \n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n            \n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08341 with standard deviation 0.00268.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08675510692590649, 0.08019121276584218, 0.08327631845918193]}}
{"id": "d6f06c47-b891-4a78-b2cc-ca83cfca935b", "fitness": 0.0768247170364581, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Oscillation and Reinforced Exploration to enhance convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(4 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(4 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07682 with standard deviation 0.00088.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.07801710333176581, 0.07593959639448633, 0.07651745138312216]}}
{"id": "d82d5c41-3e72-46cd-8143-9185a51a6b57", "fitness": 0.07420702743938974, "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution incorporating dynamic subgrouping and local search enhancement for improved global optimization.", "code": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        def local_search(individual):\n            perturbation = np.random.randn(self.dim) * 0.01\n            candidate = np.clip(individual + perturbation, bounds[0], bounds[1])\n            candidate_fitness = func(candidate)\n            self.eval_count += 1\n            return candidate, candidate_fitness\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n            for j in range(self.population_size):\n                candidate, candidate_fitness = local_search(population[j])\n                if candidate_fitness < fitness[j]:\n                    population[j] = candidate\n                    fitness[j] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 28, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07421 with standard deviation 0.00246.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.07755248401192127, 0.07172661276712622, 0.07334198553912175]}}
{"id": "dc7659dc-4d8f-490b-bcd3-ce6b5acf3073", "fitness": 0.0826581687156885, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with improved adaptive mutation factor for better convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # Additional parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                # Improved adaptive mutation factor\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 + 0.5 * np.cos(self.eval_count / self.budget))\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08266 with standard deviation 0.00250.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08536167529483163, 0.0793329292292515, 0.08327990162298238]}}
{"id": "31c2fe23-8011-4b81-9a56-e73b954fdb7d", "fitness": 0.0730460065544762, "name": "SelfTuningAdaptiveDifferentialEvolution", "description": "Self-Tuning Adaptive Differential Evolution with dynamic parameter adjustment, elite retention, and periodic reinitialization for enhanced global optimization efficiency.", "code": "import numpy as np\n\nclass SelfTuningAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.15  # Adjusted for better diversity preservation\n        self.elite_preservation = 0.1  # Fraction of population to retain as elite\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = 0.5 + 0.5 * np.sin(2 * np.pi * self.eval_count / self.budget)  # Enhanced oscillation\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size * (1 - self.elite_preservation)))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.4 + 0.5 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, int(self.population_size * self.elite_preservation))\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 30, "feedback": "The algorithm SelfTuningAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07305 with standard deviation 0.00189.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.07423281135703808, 0.07452145173885627, 0.07038375656753426]}}
{"id": "edd94238-6f30-4b47-948a-660597e5af8d", "fitness": 0.08208608009146352, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic scaling of mutation and crossover based on success history and diversity to boost global search capability and convergence speed.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n        self.success_history = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n                    self.success_history.append(1)\n                else:\n                    self.success_history.append(0)\n\n            if len(self.success_history) > 100:\n                recent_success_rate = sum(self.success_history[-100:]) / 100\n                self.mutation_factor = 0.5 + 0.3 * recent_success_rate\n                self.crossover_rate = 0.3 + 0.6 * recent_success_rate\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08209 with standard deviation 0.00243.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08442574487225862, 0.07873798163328527, 0.08309451376884669]}}
{"id": "9ab1936c-96aa-410f-bd91-7f86d62fe6ac", "fitness": 0.08156816662892881, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with reinforcement learning-based parameter tuning to dynamically adjust mutation and crossover rates for improved convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n        self.rl_learning_rate = 0.05  # Reinforcement learning rate\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n                    reward = 1\n                else:\n                    reward = -1\n\n                # Reinforcement learning adjustment\n                self.crossover_rate += self.rl_learning_rate * reward * (np.random.rand() - 0.5)\n                self.crossover_rate = np.clip(self.crossover_rate, 0.1, 0.9)\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08157 with standard deviation 0.00188.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.0842190397518846, 0.08043944189297958, 0.08004601824192226]}}
{"id": "4a6fb35c-1142-4fdc-8dbe-34efab0f660c", "fitness": 0.0834075460503102, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic elite preservation and population diversity boosting for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n                self.diversity_threshold *= 0.95  # Dynamically adjust diversity threshold\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08341 with standard deviation 0.00268.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08675510692590649, 0.08019121276584218, 0.08327631845918193]}}
{"id": "7e7ee885-9445-450d-9cd7-86a7c1449df1", "fitness": 0.0834075460503102, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic population adjustment and adaptive parameter tuning for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # Additional parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08341 with standard deviation 0.00268.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08675510692590649, 0.08019121276584218, 0.08327631845918193]}}
{"id": "9ced9a74-1b36-415c-83c7-7bd75a4981d6", "fitness": 0.07752038683667502, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with refined population resizing strategy and dynamic adjustment of diversity threshold for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05  # Adjusted for better exploration\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 8) == 0 and self.population_size > self.min_population_size:  # Adjusted frequency of resizing\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07752 with standard deviation 0.00268.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.0810875174096336, 0.07464567842887349, 0.07682796467151798]}}
{"id": "d04167d2-c1c1-4aac-a650-0795553c33ea", "fitness": 0.08024635862832852, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic mutation factor based on budget and fitness variance for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # Additional parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            fitness_variance = np.var(fitness)  # Newly added\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness_variance / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08025 with standard deviation 0.00186.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08283115448355394, 0.07855929141690843, 0.07934862998452319]}}
{"id": "b36c497d-fb09-40c3-9a64-ee85c81867ef", "fitness": 0.08218268595650076, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with modified diversity threshold and adaptive mutation factor for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05  # Modified parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.6 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))  # Adjusted mutation factor\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08218 with standard deviation 0.00351.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08413459360098885, 0.07725582163591493, 0.08515764263259851]}}
{"id": "2c5efe79-392a-45f9-b53d-6167de1737f7", "fitness": 0.08208822936596616, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic crossover and mutation rates tuned by the fitness variance for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # Additional parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            fitness_variance = np.var(fitness)\n            self.crossover_rate = 0.3 + 0.4 * fitness_variance  # Change 1\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count / self.budget) * fitness_variance)  # Change 2\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08209 with standard deviation 0.00345.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08693721007107336, 0.0791634935224943, 0.08016398450433082]}}
{"id": "fd7d8837-b97f-45fe-9fbf-efd33faba6e8", "fitness": 0.07719441148553785, "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with enhanced mutation and dynamic population resizing for efficient convergence.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                adaptive_phase = np.cos(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * adaptive_phase * (x2 - x3) + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 5) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size * 0.75))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.cos(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.sin(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 39, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07719 with standard deviation 0.00043.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.0765914989608587, 0.07755237879976062, 0.07743935669599422]}}
{"id": "f7b947f4-1faa-4be6-aceb-12bfdefbffb9", "fitness": 0.08331600794272209, "name": "DynamicOscillationDifferentialEvolution", "description": "Dynamic Oscillation Differential Evolution (DODE): Incorporates dynamic oscillation factors for mutation and adaptive diversity-enhancement strategies to improve exploration and convergence.", "code": "import numpy as np\n\nclass DynamicOscillationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                dynamic_oscillation = np.sin(2 * np.pi * (self.eval_count / self.budget) ** 2)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * dynamic_oscillation\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * dynamic_oscillation + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            adaptive_mutation_scaling = np.mean(fitness) / (np.min(fitness) + 1e-8)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * adaptive_mutation_scaling)\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 40, "feedback": "The algorithm DynamicOscillationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08332 with standard deviation 0.00202.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.0847794321126416, 0.08471397858041751, 0.08045461313510716]}}
{"id": "cf31e39c-7c0a-4374-9bc2-6610dd15b3cd", "fitness": 0.080962914975104, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic oscillatory parameter adaptation and multi-phase population control for improved convergence and diversity management.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            # Dynamic oscillatory adaptation\n            oscillation_rate = np.sin(2 * np.pi * self.eval_count / self.budget)\n            self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillation_rate + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            # Phase-wise population control\n            if self.eval_count % (self.budget // 10) == 0:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            # Update adaptation rates\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            # Diversity management\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08096 with standard deviation 0.00263.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08370169471638766, 0.08177743235094537, 0.07740961785797895]}}
{"id": "803a9a46-d8c7-4112-b09f-d6f662ea0ae8", "fitness": 0.06729183726288324, "name": "AdvancedEvolutionaryStrategy", "description": "Advanced Evolutionary Strategy integrating dynamic environmental adaptation and enhanced diversity mechanisms for superior global optimization performance.", "code": "import numpy as np\n\nclass AdvancedEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.min_population_size = 6 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.15\n        self.diversity_threshold = 0.15\n        self.memory_size = 5\n        self.successful_mutations = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                adaptive_factor = np.var(fitness) / (np.mean(fitness) + 1e-8)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * adaptive_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n                    self.successful_mutations.append(self.mutation_factor)\n\n            if len(self.successful_mutations) > self.memory_size:\n                self.successful_mutations.pop(0)\n            self.mutation_factor = 0.5 + 0.3 * np.mean(self.successful_mutations) if self.successful_mutations else 0.5\n\n            if self.eval_count % (self.budget // 8) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((population, new_individuals))\n                fitness = np.append(fitness, [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 42, "feedback": "The algorithm AdvancedEvolutionaryStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06729 with standard deviation 0.00487.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.06418409797866587, 0.07417270320824121, 0.06351871060174263]}}
{"id": "b51ea23e-7330-439a-b9bd-dbb858d08ac8", "fitness": 0.07931359899910417, "name": "DynamicPopulationControlledDifferentialEvolution", "description": "Dynamic Population Controlled Differential Evolution with Chaos-Driven Exploration (DPCCDE) using chaos theory for enhanced exploration and dynamic population resizing for improved convergence.", "code": "import numpy as np\n\nclass DynamicPopulationControlledDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def _chaos_sequence(self, n):\n        x = 0.5  # Initial value for logistic map\n        sequence = np.zeros(n)\n        for i in range(n):\n            x = 4.0 * x * (1.0 - x)  # Logistic map\n            sequence[i] = x\n        return sequence\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        chaos_sequence = self._chaos_sequence(self.budget)\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                chaos_factor = chaos_sequence[self.eval_count % self.budget]\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * chaos_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 43, "feedback": "The algorithm DynamicPopulationControlledDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07931 with standard deviation 0.00131.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08093146438024923, 0.07772662914425499, 0.0792827034728083]}}
{"id": "e4d005a3-139e-4e93-a264-3a3607ac9dfa", "fitness": -Infinity, "name": "AdaptiveDualPopulationDifferentialEvolution", "description": "Adaptive Dual-Population Differential Evolution with Dynamic Parameters and Balanced Exploration-Exploitation Control for Enhanced Global Optimization Performance.", "code": "import numpy as np\n\nclass AdaptiveDualPopulationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.secondary_population_size = 6 * dim\n        self.min_population_size = 4 * dim\n        self.primary_population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        primary_population = np.random.rand(self.primary_population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        secondary_population = np.random.rand(self.secondary_population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        \n        primary_fitness = np.array([func(ind) for ind in primary_population])\n        secondary_fitness = np.array([func(ind) for ind in secondary_population])\n        self.eval_count += self.primary_population_size + self.secondary_population_size\n\n        while self.eval_count < self.budget:\n            for population, fitness, size in [(primary_population, primary_fitness, self.primary_population_size), \n                                              (secondary_population, secondary_fitness, self.secondary_population_size)]:\n                for i in range(size):\n                    indices = np.random.choice([j for j in range(size) if j != i], 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                    self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                    mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                    cross_points = np.random.rand(self.dim) < self.crossover_rate\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n                    trial = np.where(cross_points, mutant, population[i])\n\n                    f_trial = func(trial)\n                    self.eval_count += 1\n                    if f_trial < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = f_trial\n\n                if self.eval_count % (self.budget // 10) == 0 and size > self.min_population_size:\n                    size = max(self.min_population_size, size // 2)\n                    indices = np.argsort(fitness)[:size]\n                    population[:] = population[indices]\n                    fitness[:] = fitness[indices]\n\n                diversity = np.std(population, axis=0).mean()\n                if population is primary_population:\n                    self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n                    self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n                    if diversity < self.diversity_threshold:\n                        new_individuals = np.random.rand(self.initial_population_size - size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                        population = np.vstack((population, new_individuals))\n                        fitness = np.append(fitness, [func(ind) for ind in new_individuals])\n                        self.eval_count += len(new_individuals)\n\n        combined_population = np.vstack((primary_population, secondary_population))\n        combined_fitness = np.append(primary_fitness, secondary_fitness)\n        best_index = np.argmin(combined_fitness)\n        return combined_population[best_index], combined_fitness[best_index]", "configspace": "", "generation": 44, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (60,10) into shape (120,10)').", "error": "ValueError('could not broadcast input array from shape (60,10) into shape (120,10)')", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {}}
{"id": "62533fd3-0181-4167-8668-eb7ccd61014c", "fitness": 0.07698233727127934, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive learning strategies for parameter tuning and dynamic population management to improve convergence efficiency and robustness.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # Additional parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = 0.5 + 0.5 * np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.2 * np.cos(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.25 * np.sin(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07698 with standard deviation 0.00319.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08111914806924225, 0.0733668167063406, 0.07646104703825518]}}
{"id": "1b2aad8b-0e84-4fa1-8218-22090b8f835d", "fitness": 0.08303465990947134, "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution with dynamic fitness-based parameter tuning and strategic population resampling for improved convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                fitness_diff = (fitness[i] - fitness[indices]).clip(min=0.1)\n                adaptive_mutation_factor = self.mutation_factor * np.exp(-fitness_diff.std() / fitness_diff.mean())\n                mutant = np.clip(x1 + adaptive_mutation_factor * (x2 - x3) + self.alpha * np.random.randn(self.dim), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n            \n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count / self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n            \n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 46, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08303 with standard deviation 0.00180.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08151562127268253, 0.08555984451181098, 0.08202851394392052]}}
{"id": "206b16a3-5edf-4453-bb18-2cacb79392a4", "fitness": 0.07237151362657679, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved Enhanced Adaptive Differential Evolution by incorporating adaptive population resampling to tackle premature convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1  # Additional parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, np.random.rand(self.population_size - elite_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0])) # Resample non-elite\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in population[elite_size:]])\n                self.eval_count += self.population_size - elite_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07237 with standard deviation 0.00383.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.07596653576982537, 0.07408948717911157, 0.06705851793079343]}}
{"id": "885eaf7b-a31e-4bc3-a85b-7231fb9f85e7", "fitness": -Infinity, "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution with dynamic multi-strategy mutation and enhanced convergence tracking for improved global optimization performance.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.adaptive_factor = 0.1\n        self.diversity_threshold = 0.1\n        self.convergence_factor = 0.05  # New parameter for convergence tracking\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillation = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.adaptive_factor * np.random.randn(self.dim)\n                strategy_choice = np.random.rand()\n\n                if strategy_choice < 0.5:\n                    mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillation, bounds[0], bounds[1])\n                else:\n                    mutant = np.clip(x1 + self.mutation_factor * (population[np.argmin(fitness)] - x3) + self_adaptive_factor * oscillation, bounds[0], bounds[1])\n\n                mutant += self_adaptive_factor * np.random.randn(self.dim)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold or fitness.std() < self.convergence_factor:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 48, "feedback": "An exception occurred: NameError(\"name 'self_adaptive_factor' is not defined\").", "error": "NameError(\"name 'self_adaptive_factor' is not defined\")", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {}}
{"id": "734b5f19-a1ab-4d61-b794-be7a5c12c43d", "fitness": 0.0810935853808975, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with enhanced elite preservation and adaptive mutation for optimized exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 8)  # Changed from 10 to 8\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08109 with standard deviation 0.00241.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08423455227261023, 0.07836776148354385, 0.08067844238653843]}}
{"id": "e2fb07a2-0c52-47ce-805f-7498c6fbf016", "fitness": 0.08143308528871211, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with refined diversity control and adaptive oscillating factor for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.15  # Adjusted parameter to preserve diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)  # Adjusted oscillating factor\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08143 with standard deviation 0.00139.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08045513782581792, 0.08045175529321391, 0.08339236274710449]}}
{"id": "95271335-fd11-4ef8-97a6-dcf392b27431", "fitness": 0.07937722549694133, "name": "EnhancedAdaptiveDifferentialEvolutionV2", "description": "Enhanced Adaptive Differential Evolution with dynamic learning strategies integrating a history-based adaptation for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n        self.history = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        self.history.append(np.min(fitness))\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                adaptive_learning = np.mean(self.history[-5:]) if len(self.history) > 5 else self.history[-1]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget + adaptive_learning)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n                    self.history.append(f_trial)\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count / self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07938 with standard deviation 0.00207.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08207821140975491, 0.07705091757461957, 0.07900254750644953]}}
{"id": "2c9bc605-18b6-4594-b453-7894c8bffc9b", "fitness": 0.05749554604216156, "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution incorporating quantum superposition principles for enhanced exploration and exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n        \n    def quantum_superposition(self, bounds):\n        amplitudes = np.random.rand(self.population_size, self.dim)\n        phases = np.random.rand(self.population_size, self.dim) * 2 * np.pi\n        quantum_positions = (amplitudes * np.cos(phases)) * (bounds[1] - bounds[0]) + bounds[0]\n        return quantum_positions\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = self.quantum_superposition(bounds)\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = self.quantum_superposition(bounds)[self.population_size:]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 52, "feedback": "The algorithm QuantumInspiredAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05750 with standard deviation 0.00142.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.05816486130678433, 0.05880019404481451, 0.055521582774885836]}}
{"id": "93ee0bf0-31e5-4f62-a865-1a728c139634", "fitness": 0.08026436640281949, "name": "AdvancedOscillatingDifferentialEvolution", "description": "Advanced Oscillating Differential Evolution with dynamic population resizing and adaptive parameter modification for improved convergence and robustness.", "code": "import numpy as np\n\nclass AdvancedOscillatingDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.cos(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.6 + 0.3 * np.sin(2 * np.pi * (self.eval_count/self.budget) * (fitness.std() / (fitness.mean() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.concatenate((elite_population, population))\n                fitness = np.concatenate((fitness[elite_indices], fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 53, "feedback": "The algorithm AdvancedOscillatingDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08026 with standard deviation 0.00448.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08574037091107178, 0.08028158908113692, 0.07477113921624978]}}
{"id": "168c7d9a-04ac-4c01-9685-420ea419a531", "fitness": 0.08907160569359292, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic swarm intelligence elements for improved convergence and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2  # New parameter for p-best selection\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                # Introduced p-best selection strategy\n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08907 with standard deviation 0.00100.", "error": "", "parent_ids": ["07020917-2843-4870-a948-60a36b0875d2"], "operator": null, "metadata": {"aucs": [0.08847426502210287, 0.09047797970510352, 0.08826257235357238]}}
{"id": "cf693afb-8342-4777-92a4-5d6e98c7c834", "fitness": 0.08323690906333314, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with an adaptive learning rate inspired by annealing processes for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2  # New parameter for p-best selection\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                # Introduced p-best selection strategy\n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            # Adaptive learning rate based on an annealing schedule\n            annealing_factor = 0.5 * (1 + np.cos(np.pi * self.eval_count / self.budget))\n            self.crossover_rate = 0.3 + 0.4 * annealing_factor\n            self.mutation_factor = 0.5 + 0.3 * annealing_factor\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 55, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08324 with standard deviation 0.00309.", "error": "", "parent_ids": ["168c7d9a-04ac-4c01-9685-420ea419a531"], "operator": null, "metadata": {"aucs": [0.07914412344972299, 0.0865996369159775, 0.08396696682429894]}}
{"id": "9c71e298-ed5b-460b-8d10-7a86500211b5", "fitness": 0.07773001955999541, "name": "QuantumEnhancedDifferentialEvolution", "description": "Quantum-Enhanced Adaptive Differential Evolution, incorporating quantum-inspired initialization and adaptive mutation oscillation for enhanced diversity and convergence.", "code": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        \n        # Quantum-inspired initialization\n        population = np.random.randn(self.population_size, self.dim)\n        population = np.clip(population, -1, 1) * (bounds[1] - bounds[0]) / 2 + (bounds[1] + bounds[0]) / 2\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.randn(self.initial_population_size - self.population_size, self.dim)\n                new_individuals = np.clip(new_individuals, -1, 1) * (bounds[1] - bounds[0]) / 2 + (bounds[1] + bounds[0]) / 2\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 56, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07773 with standard deviation 0.00763.", "error": "", "parent_ids": ["168c7d9a-04ac-4c01-9685-420ea419a531"], "operator": null, "metadata": {"aucs": [0.07293742208616627, 0.08850060548962158, 0.07175203110419837]}}
{"id": "3552f3f2-26ef-4ea9-af92-a236cf95d13c", "fitness": 0.08815588292246923, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with improved oscillating factor for better convergence dynamics.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2  # New parameter for p-best selection\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)  # Adjusted oscillating factor\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                # Introduced p-best selection strategy\n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08816 with standard deviation 0.00339.", "error": "", "parent_ids": ["168c7d9a-04ac-4c01-9685-420ea419a531"], "operator": null, "metadata": {"aucs": [0.08912085415016113, 0.0836047731052123, 0.09174202151203426]}}
{"id": "4a9ecd32-bd2a-4e6b-8e76-9d6fb96587a9", "fitness": 0.0852790655528125, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with self-adaptive rate mechanisms and periodic reinitialization for dynamic exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n        self.reinit_rate = 0.05  # New parameter for periodic reinitialization\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            # Self-adaptive rates\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n            # Periodic reinitialization for diversity\n            if self.eval_count % int(self.budget * self.reinit_rate) == 0:\n                num_to_reinit = max(1, int(self.reinit_rate * self.population_size))\n                reinit_indices = np.random.choice(self.population_size, num_to_reinit, replace=False)\n                population[reinit_indices] = np.random.rand(num_to_reinit, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                fitness[reinit_indices] = [func(ind) for ind in population[reinit_indices]]\n                self.eval_count += num_to_reinit\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08528 with standard deviation 0.00474.", "error": "", "parent_ids": ["168c7d9a-04ac-4c01-9685-420ea419a531"], "operator": null, "metadata": {"aucs": [0.07869078623699122, 0.08964719597762538, 0.08749921444382092]}}
{"id": "c716c48c-06ec-4cec-bcf5-e1820637aab2", "fitness": 0.08374855701936627, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduced dynamic learning rates and adaptive population resizing in Enhanced Adaptive Differential Evolution for better exploration-exploitation balance and convergence rate.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 5) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size * 0.7))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            learning_rate = np.clip(0.3 + 0.7 * (fitness.min() / (fitness.mean() + 1e-8)), 0.1, 0.8)\n            self.crossover_rate = 0.3 + learning_rate * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + learning_rate * np.cos(2 * np.pi * (self.eval_count/self.budget))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08375 with standard deviation 0.00290.", "error": "", "parent_ids": ["168c7d9a-04ac-4c01-9685-420ea419a531"], "operator": null, "metadata": {"aucs": [0.07964413944917725, 0.08582911112484415, 0.0857724204840774]}}
{"id": "36e98eef-7806-485b-bb31-387c9e744f7e", "fitness": 0.07400147363770804, "name": "AdaptiveSinusoidalPerturbationDE", "description": "Adaptive Sinusoidal Perturbation Differential Evolution with multi-phase dynamic adaptation for enhanced global and local search balance.", "code": "import numpy as np\n\nclass AdaptiveSinusoidalPerturbationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.min_population_size = 5 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(3 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 15) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.2 + 0.5 * np.sin(3 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.6 + 0.2 * np.cos(3 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 12)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 60, "feedback": "The algorithm AdaptiveSinusoidalPerturbationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07400 with standard deviation 0.00148.", "error": "", "parent_ids": ["168c7d9a-04ac-4c01-9685-420ea419a531"], "operator": null, "metadata": {"aucs": [0.07202675329142538, 0.07437169252843878, 0.07560597509325995]}}
{"id": "3e67c275-ae6d-4f6f-a86c-32f69b144e9e", "fitness": 0.09071315572730954, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with incremental oscillating factor for better adaptability and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2  # New parameter for p-best selection\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(3 * np.pi * self.eval_count / self.budget)  # Changed from 2 to 3 for better adaptability\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                # Introduced p-best selection strategy\n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09071 with standard deviation 0.00123.", "error": "", "parent_ids": ["168c7d9a-04ac-4c01-9685-420ea419a531"], "operator": null, "metadata": {"aucs": [0.08897823196304622, 0.09149629198691145, 0.09166494323197094]}}
{"id": "65aba303-bd08-4133-882c-c2e4fab1257e", "fitness": 0.08254582785927748, "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution using dynamic population control and hybrid mutation strategies for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.15\n        self.dynamic_shrink_rate = 0.2  # New parameter for dynamic shrink rate\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)  # Increased frequency for finer adjustments\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n\n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size * (1 - self.dynamic_shrink_rate)))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.2 + 0.5 * np.sin(1.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.4 + 0.4 * np.cos(3 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 15)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 62, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08255 with standard deviation 0.00765.", "error": "", "parent_ids": ["3e67c275-ae6d-4f6f-a86c-32f69b144e9e"], "operator": null, "metadata": {"aucs": [0.08595485905654443, 0.07195132258997128, 0.08973130193131673]}}
{"id": "a9eb68bb-5354-497e-8db5-d49a4f9bc55f", "fitness": 0.08750816875827327, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with elite preservation and dynamic boundary expansion for improved convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = 0.5 + 0.3 * np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                expansion_factor = 0.1\n                expanded_bounds = np.array([\n                    bounds[0] - expansion_factor * (bounds[1] - bounds[0]),\n                    bounds[1] + expansion_factor * (bounds[1] - bounds[0])\n                ])\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (expanded_bounds[1] - expanded_bounds[0]) + expanded_bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08751 with standard deviation 0.00364.", "error": "", "parent_ids": ["3e67c275-ae6d-4f6f-a86c-32f69b144e9e"], "operator": null, "metadata": {"aucs": [0.08236137018618572, 0.08983821950641735, 0.09032491658221675]}}
{"id": "e3ee1bc9-c144-465d-9ca9-4dcab702a6f8", "fitness": 0.0861206276868226, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with refined crossover mechanism for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2  # New parameter for p-best selection\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(3 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n                \n                # Updated crossover strategy\n                cross_points = np.random.rand(self.dim) < (self.crossover_rate / (1 + np.exp(-self.eval_count/self.budget)))\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08612 with standard deviation 0.00312.", "error": "", "parent_ids": ["3e67c275-ae6d-4f6f-a86c-32f69b144e9e"], "operator": null, "metadata": {"aucs": [0.08956371751757031, 0.08201184195201572, 0.08678632359088179]}}
{"id": "dccc1e8e-ffa5-46b8-b609-eb461ffb8229", "fitness": 0.09028741956091879, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with improved self-adaptive strategies for better convergence dynamics and robustness.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.25  # Adjusted parameter for p-best selection\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)  # Changed from 3 to 4 for improved adaptability\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.4 + 0.5 * np.sin(3 * np.pi * self.eval_count / self.budget)  # Modified crossover rate adaptation\n            self.mutation_factor = 0.4 + 0.4 * np.cos(3 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09029 with standard deviation 0.00218.", "error": "", "parent_ids": ["3e67c275-ae6d-4f6f-a86c-32f69b144e9e"], "operator": null, "metadata": {"aucs": [0.08893516011529168, 0.09335931645711215, 0.08856778211035254]}}
{"id": "4fd54494-b365-4f85-aefd-7c1e86ba4b5b", "fitness": -Infinity, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic parameter tuning and memory-based mutation strategy for improved exploitation and exploration balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n        self.memory = []  # Memory for storing successful strategies\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2  # New parameter for p-best selection\n        \n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(3 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                # Memory-based mutation strategy\n                if len(self.memory) > 0 and np.random.rand() < 0.5:\n                    mem_strategy = self.memory[np.random.randint(len(self.memory))]\n                    mutant = np.clip(mem_strategy + self_adaptive_mutation, bounds[0], bounds[1])\n                else:\n                    p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                    mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.5 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n                    self.memory.append((x1, x2, x3))  # Update memory with successful strategies\n\n            # Dynamic parameter tuning\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 66, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_ids": ["3e67c275-ae6d-4f6f-a86c-32f69b144e9e"], "operator": null, "metadata": {}}
{"id": "8fdda8e2-838a-49f1-a9ea-8945f47a4151", "fitness": 0.09115138018294504, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic oscillating strategies and elitism to enhance global search and convergence speed.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)  # Further tuned oscillation\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2.5 * np.pi * self.eval_count / self.budget)  # Adjusted periodicity\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09115 with standard deviation 0.00102.", "error": "", "parent_ids": ["3e67c275-ae6d-4f6f-a86c-32f69b144e9e"], "operator": null, "metadata": {"aucs": [0.08981843896264818, 0.09230731670506775, 0.09132838488111916]}}
{"id": "3f63848f-53b6-4733-a259-79807df39fe1", "fitness": 0.09115138018294504, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Differential Evolution with strategic adaptive mutation and reinforcement of diversity to accelerate convergence and improve exploration.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n            population_diversity = np.std(population, axis=0).mean()\n\n            if population_diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                diversity_scaling_factor = np.random.rand(self.dim) * 0.1  # New line\n                new_individuals += diversity_scaling_factor  # Modified line\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09115 with standard deviation 0.00102.", "error": "", "parent_ids": ["8fdda8e2-838a-49f1-a9ea-8945f47a4151"], "operator": null, "metadata": {"aucs": [0.08981843896264818, 0.09230731670506775, 0.09132838488111916]}}
{"id": "d040b98f-243a-46f1-b092-265786772d21", "fitness": 0.09129690171609073, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Improved Enhanced Adaptive Differential Evolution with adaptive population scaling based on diversity and fitness variance for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = max(self.min_population_size, int(self.population_size * 1.1))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09130 with standard deviation 0.00118.", "error": "", "parent_ids": ["8fdda8e2-838a-49f1-a9ea-8945f47a4151"], "operator": null, "metadata": {"aucs": [0.08989648441788045, 0.0927743052698714, 0.09121991546052033]}}
{"id": "8e37338d-fe4c-4217-80d0-f2285ac976f5", "fitness": 0.09143861636091903, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Refined Enhanced Adaptive Differential Evolution with noise handling in mutation to improve robustness and convergence rate.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(4 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise = np.random.randn(self.dim) * 0.05  # Added line for noise handling\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = max(self.min_population_size, int(self.population_size * 1.1))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09144 with standard deviation 0.00099.", "error": "", "parent_ids": ["d040b98f-243a-46f1-b092-265786772d21"], "operator": null, "metadata": {"aucs": [0.09275976601960745, 0.09117882714373293, 0.0903772559194167]}}
{"id": "c8d4b2ab-0c9d-4e38-8cf0-f54c4ac4008d", "fitness": 0.09152641011124352, "name": "ImprovedEnhancedAdaptiveDifferentialEvolution", "description": "Improved Enhanced Adaptive Differential Evolution with dynamic oscillating parameters and adaptive noise scaling for enhanced search efficiency and exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedEnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(6 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)  # Dynamic noise scaling\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = max(self.min_population_size, int(self.population_size * 1.2))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 71, "feedback": "The algorithm ImprovedEnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09153 with standard deviation 0.00411.", "error": "", "parent_ids": ["8e37338d-fe4c-4217-80d0-f2285ac976f5"], "operator": null, "metadata": {"aucs": [0.08575863519929416, 0.09379459713275717, 0.09502599800167921]}}
{"id": "5bd98b12-b303-46f3-ae55-1ae0b5a9a723", "fitness": 0.09164409721317916, "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution with dynamic population resizing and self-adaptive crossover and mutation rates for improved convergence and robustness.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(6 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 72, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09164 with standard deviation 0.00382.", "error": "", "parent_ids": ["c8d4b2ab-0c9d-4e38-8cf0-f54c4ac4008d"], "operator": null, "metadata": {"aucs": [0.08630852937240607, 0.09360239770687084, 0.09502136456026056]}}
{"id": "d86d1524-d529-4ff7-857f-8a94777ead51", "fitness": 0.08561827386431053, "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Enhanced mutation and crossover dynamics to improve convergence speed while maintaining solution diversity.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(6 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + 0.85 * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < (self.crossover_rate * 0.8)\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 73, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08562 with standard deviation 0.00224.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.08615595301572954, 0.08264000158306284, 0.08805886699413923]}}
{"id": "68f1535b-5760-4f12-8298-428890662f5a", "fitness": 0.0884386548601636, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive elitism and diversity-driven population adjustment for robust and efficient convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(6 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, int(self.population_size * 0.75))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08844 with standard deviation 0.00751.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.07781933748315562, 0.09342395177599849, 0.09407267532133667]}}
{"id": "36050433-6abe-491d-8f10-b91a0bae15aa", "fitness": 0.08648563932404489, "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with time-varying adaptive strategies, leveraging population elitism and diversity control for improved convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n        self.elitism_rate = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                time_factor = np.cos(np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * time_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, int(self.elitism_rate * self.population_size))\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08649 with standard deviation 0.00223.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.08931051361466869, 0.0838558186814724, 0.08629058567599357]}}
{"id": "8e1b8cd1-346b-4117-a0cf-7ce62c28b620", "fitness": -Infinity, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic environmental adaptation and chaotic sequence-driven mutation for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n        self.chaos_sequence = self._generate_chaos_sequence(budget)\n\n    def _generate_chaos_sequence(self, budget):\n        # Utilizing logistic map for chaos-driven mutation\n        x = 0.5\n        seq = []\n        for _ in range(budget):\n            x = 4.0 * x * (1 - x)\n            seq.append(x)\n        return np.array(seq)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(6 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n\n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                chaos_influence = self.chaos_sequence[self.eval_count] * self.mutation_factor\n                mutant = np.clip(x1 + chaos_influence * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 76, "feedback": "An exception occurred: IndexError('index 72 is out of bounds for axis 0 with size 67').", "error": "IndexError('index 72 is out of bounds for axis 0 with size 67')", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {}}
{"id": "737cc15c-8daa-435e-b6ff-4b4576280b21", "fitness": 0.09164409721317916, "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Refined Adaptive Differential Evolution with enhanced mutation dynamics and oscillating crossover adaptation for improved exploration and convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(6 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 77, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09164 with standard deviation 0.00382.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.08630852937240607, 0.09360239770687084, 0.09502136456026056]}}
{"id": "7eec2741-6f7b-4458-a45e-0aa85eb65a89", "fitness": 0.09164409721317916, "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive oscillating strategies and improved diversity management for superior convergence performance.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(6 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09164 with standard deviation 0.00382.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.08630852937240607, 0.09360239770687084, 0.09502136456026056]}}
{"id": "53d87221-9bc5-47f1-a8ac-28de7f5a6794", "fitness": 0.0912224086051937, "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Improved Advanced Adaptive Differential Evolution with enhanced elite preservation and dynamic oscillating factor scaling for better convergence and exploration balance.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(8 * np.pi * self.eval_count / self.budget)  # Changed factor scaling\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 8)  # Changed elite size preservation\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 79, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09122 with standard deviation 0.00211.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.0883187078042511, 0.0920572948910624, 0.09329122312026761]}}
{"id": "cc3460f7-915f-4efb-a36a-c55a49fb62e9", "fitness": 0.09006626046073496, "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with finer self-adaptive oscillation for mutation factor adjustment.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(6 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            # Change 1: Adjusted mutation factor scaling for better adaptation\n            self.mutation_factor = 0.5 + 0.35 * np.cos(3.6 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                # Change 2: Changed the fraction of new individuals added to the population\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 80, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09007 with standard deviation 0.00618.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.08134599274598209, 0.09394466027500692, 0.09490812836121587]}}
{"id": "baac9683-b816-4ded-a5dc-4577d1696bef", "fitness": 0.08913473183505734, "name": "AdvancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with improved diversity management and adaptive oscillation factor for better convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(8 * np.pi * self.eval_count / self.budget)  # Increased oscillation frequency\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < 1.5 * self.diversity_threshold or fitness_variance < 0.01:  # Increased diversity threshold\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 81, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08913 with standard deviation 0.00287.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.08654640575024886, 0.08772536480860016, 0.09313242494632301]}}
{"id": "0e6191c6-7706-4ee4-9a22-65083c95d833", "fitness": 0.09164409721317916, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with improved oscillation-based parameter tuning and dynamic elitism for boosted convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(6 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(3.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(3.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09164 with standard deviation 0.00382.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.08630852937240607, 0.09360239770687084, 0.09502136456026056]}}
{"id": "b79a6c30-2b75-4b37-aee5-efd26d813c22", "fitness": -Infinity, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic diversity control, oscillating mutation strategies, and elitism for improved exploration and convergence balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.min_population_size = 3 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.15\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = 0.5 + 0.5 * np.sin(2 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.08 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.4 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * np.sin(2.5 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.cos(2.5 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 8)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 83, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'diversity' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'diversity' referenced before assignment\")", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {}}
{"id": "80f05b8a-e01e-4e02-a035-e159818281d1", "fitness": 0.09341987959998381, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic oscillation and elite strategy to improve exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * np.sin(4 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.4 * np.cos(4 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09342 with standard deviation 0.00237.", "error": "", "parent_ids": ["5bd98b12-b303-46f3-ae55-1ae0b5a9a723"], "operator": null, "metadata": {"aucs": [0.09569496761794227, 0.0944215778952, 0.09014309328680914]}}
{"id": "28338423-9b9c-48f9-897b-b7b7c27a89fb", "fitness": 0.09211523195307585, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporate adaptive scaling of mutation factor using a sinusoidal function to enhance balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * np.sin(4 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.45 * np.cos(8 * np.pi * (self.eval_count/self.budget))  # Changed line\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09212 with standard deviation 0.00435.", "error": "", "parent_ids": ["80f05b8a-e01e-4e02-a035-e159818281d1"], "operator": null, "metadata": {"aucs": [0.09574263458676979, 0.09460777293126443, 0.0859952883411933]}}
{"id": "5eb525d4-b456-4abc-bec0-2fb39707820d", "fitness": 0.07816062876672518, "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive mutation guided by fitness ranking and historical memory for diversified exploration and faster convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.p_best_rate = 0.2\n        self.memory = []\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count = self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                historical_factor = self.memory[-1] if self.memory else 0\n                self_adaptive_mutation = np.random.randn(self.dim) * historical_factor\n                p_best = population[np.argsort(fitness)[:max(1, int(self.p_best_rate * self.population_size))]][0]\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) + self_adaptive_mutation + 0.6 * (p_best - x1), bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            best_idx = np.argmin(fitness)\n            if len(self.memory) >= 5:\n                self.memory.pop(0)\n            self.memory.append(fitness[best_idx])\n\n            ranked_indices = np.argsort(fitness)\n            self.crossover_rate = 0.3 + 0.5 * np.sin(4 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.4 * np.cos(4 * np.pi * (self.eval_count/self.budget) * (fitness[ranked_indices[:5]].mean() / (fitness.min() + 1e-8)))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07816 with standard deviation 0.00038.", "error": "", "parent_ids": ["80f05b8a-e01e-4e02-a035-e159818281d1"], "operator": null, "metadata": {"aucs": [0.07859466377441049, 0.07767644266981344, 0.0782107798559516]}}
{"id": "4d3506bf-5a69-4323-8865-a184ade2ab37", "fitness": 0.08396148792927671, "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Adaptive Population Control and Adaptive Strategy Mixing to enhance exploration, exploitation, and diversity management.", "code": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.strategy_mix_rate = 0.5\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        \n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                \n                if np.random.rand() < self.strategy_mix_rate:\n                    mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) + self_adaptive_mutation + noise, bounds[0], bounds[1])\n                else:\n                    mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < 0.05 or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, int(self.population_size * 0.7))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * np.sin(4 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.4 * np.cos(4 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < 0.05:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 87, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08396 with standard deviation 0.00476.", "error": "", "parent_ids": ["80f05b8a-e01e-4e02-a035-e159818281d1"], "operator": null, "metadata": {"aucs": [0.0837619250033852, 0.07822835656346872, 0.08989418222097623]}}
{"id": "35da4088-1fe7-45db-bb63-7735030c987f", "fitness": 0.09245401868990329, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with modified mutation factor oscillation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * np.sin(4 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.4 * np.sin(4 * np.pi * (self.eval_count/self.budget))  # Modified oscillation function\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09245 with standard deviation 0.00373.", "error": "", "parent_ids": ["80f05b8a-e01e-4e02-a035-e159818281d1"], "operator": null, "metadata": {"aucs": [0.09544322187464527, 0.09471769089170257, 0.08720114330336204]}}
{"id": "fe7cb96a-919d-4922-803f-81e5f46fbe3a", "fitness": -Infinity, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic oscillation, elite strategy, and adaptive population size adjustment to improve exploration, convergence, and handling of diverse landscapes.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n        dynamic_adjustment_factor = 0.1\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * (1.5 + dynamic_adjustment_factor)))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // (2 + dynamic_adjustment_factor))\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * np.sin(4 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.4 * np.cos(4 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 89, "feedback": "An exception occurred: TypeError('slice indices must be integers or None or have an __index__ method').", "error": "TypeError('slice indices must be integers or None or have an __index__ method')", "parent_ids": ["80f05b8a-e01e-4e02-a035-e159818281d1"], "operator": null, "metadata": {}}
{"id": "484c13dc-95ae-4d1a-9939-38793e584bfd", "fitness": 0.09367999627270433, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introducing adaptive scaling for self-adaptive mutation to enhance population diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                # Changed self_adaptive_mutation to include dynamic scaling based on budget usage\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count/self.budget)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor + self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                fitness_variance = np.var(fitness)\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * np.sin(4 * np.pi * self.eval_count / self.budget)\n            self.mutation_factor = 0.5 + 0.4 * np.cos(4 * np.pi * (self.eval_count/self.budget) * (fitness.mean() / (fitness.min() + 1e-8)))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09368 with standard deviation 0.00208.", "error": "", "parent_ids": ["80f05b8a-e01e-4e02-a035-e159818281d1"], "operator": null, "metadata": {"aucs": [0.09578666498368171, 0.09439725212936279, 0.09085607170506849]}}
{"id": "cf6d42d2-0ecd-4de1-9183-ab34faf6f701", "fitness": 0.0950763924782307, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introducing dynamic scaling of crossover and mutation rates based on fitness variance and diversity to enhance convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                \n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count / self.budget)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor +\n                                 self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * (1 - fitness_variance / (fitness_variance + 1))\n            self.mutation_factor = 0.5 + 0.4 * (1 - diversity / (diversity + 1))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09508 with standard deviation 0.00227.", "error": "", "parent_ids": ["484c13dc-95ae-4d1a-9939-38793e584bfd"], "operator": null, "metadata": {"aucs": [0.09733874318432834, 0.09591023914329244, 0.09198019510707134]}}
{"id": "e1a1dd69-f282-4ed7-81bb-7f9d55e29af0", "fitness": 0.0889107499323523, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Refined oscillating factor to use a cosine function, enhancing exploration and exploitation balance for better convergence. ", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.cos(10 * np.pi * self.eval_count / self.budget)\n                \n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count / self.budget)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor +\n                                 self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * (1 - fitness_variance / (fitness_variance + 1))\n            self.mutation_factor = 0.5 + 0.4 * (1 - diversity / (diversity + 1))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08891 with standard deviation 0.00217.", "error": "", "parent_ids": ["cf6d42d2-0ecd-4de1-9183-ab34faf6f701"], "operator": null, "metadata": {"aucs": [0.09158947672277828, 0.08627498633751096, 0.08886778673676765]}}
{"id": "ae285f5b-b704-4800-983e-d1febc408ab6", "fitness": 0.08755123459139665, "name": "EnhancedAdaptiveDifferentialEvolutionV2", "description": "Introduce multi-phase adaptive mutation strategies and elite re-introduction to balance exploration and exploitation, improving convergence robustness and speed.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n        self.phase_switch_threshold = 0.3\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n        global_best = population[np.argmin(fitness)]\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                if self.eval_count / self.budget < self.phase_switch_threshold:\n                    adaptive_mutation = self.alpha * np.random.randn(self.dim)\n                else:\n                    adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count / self.budget)\n\n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n\n                if self.eval_count / self.budget < self.phase_switch_threshold:\n                    mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) +\n                                     adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                else:\n                    mutant = np.clip(global_best + self.mutation_factor * (x2 - x3) +\n                                     adaptive_mutation + noise, bounds[0], bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * (1 - fitness_variance / (fitness_variance + 1))\n            self.mutation_factor = 0.5 + 0.4 * (1 - diversity / (diversity + 1))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n            global_best = population[np.argmin(fitness)]\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08755 with standard deviation 0.00023.", "error": "", "parent_ids": ["cf6d42d2-0ecd-4de1-9183-ab34faf6f701"], "operator": null, "metadata": {"aucs": [0.08787677261171212, 0.08738449953152261, 0.08739243163095523]}}
{"id": "bc94359d-1566-44c6-9991-c81c1ec3c188", "fitness": 0.0955897272121438, "name": "AdaptiveOscillationDifferentialEvolution", "description": "Introducing adaptive oscillation-driven mutation and crossover with elitism support for enhanced exploration and convergence stability.", "code": "import numpy as np\n\nclass AdaptiveOscillationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                \n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count / self.budget)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor +\n                                 self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * (1 - fitness_variance / (fitness_variance + 1))\n            self.mutation_factor = 0.5 + 0.4 * (1 - diversity / (diversity + 1))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                elite_population = np.vstack((elite_population, elite_population + np.random.randn(elite_size, self.dim) * 0.1))\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 94, "feedback": "The algorithm AdaptiveOscillationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09559 with standard deviation 0.00137.", "error": "", "parent_ids": ["cf6d42d2-0ecd-4de1-9183-ab34faf6f701"], "operator": null, "metadata": {"aucs": [0.09639592647603301, 0.09670803364013791, 0.09366522152026047]}}
{"id": "60ee0501-9cb2-4f47-823d-f2d7b6daa5b2", "fitness": 0.09461995355932869, "name": "EnhancedOscillationDifferentialEvolution", "description": "Enhanced Oscillation Differential Evolution with dynamic adaptive mutation, oscillation-driven crossover, and elitism for robust exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedOscillationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                \n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count / self.budget)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.1 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor +\n                                 self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.5 + 0.4 * (1 - fitness_variance / (fitness_variance + 1))\n            self.mutation_factor = 0.6 + 0.3 * (1 - diversity / (diversity + 1))\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                elite_population = np.vstack((elite_population, elite_population + np.random.randn(elite_size, self.dim) * 0.1))\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedOscillationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09462 with standard deviation 0.00176.", "error": "", "parent_ids": ["bc94359d-1566-44c6-9991-c81c1ec3c188"], "operator": null, "metadata": {"aucs": [0.0966403489477532, 0.09486738522887428, 0.0923521265013586]}}
{"id": "84051354-25ab-4251-9712-2a016731c99b", "fitness": 0.08997200302419746, "name": "AdaptiveOscillationDifferentialEvolution", "description": "Enhancing diversity and adaptation by dynamically adjusting oscillation parameters and introducing a novel scaling for diversity influence.", "code": "import numpy as np\n\nclass AdaptiveOscillationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(12 * np.pi * self.eval_count / self.budget)  # Changed line\n\n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count / self.budget)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor +\n                                 self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.4 + 0.4 * (1 - fitness_variance / (fitness_variance + 1))  # Changed line\n            self.mutation_factor = 0.6 + 0.3 * (1 - diversity / (diversity + 1))  # Changed line\n\n            elite_size = max(1, self.population_size // 10)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                elite_population = np.vstack((elite_population, elite_population + np.random.randn(elite_size, self.dim) * 0.1))\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 96, "feedback": "The algorithm AdaptiveOscillationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08997 with standard deviation 0.00413.", "error": "", "parent_ids": ["bc94359d-1566-44c6-9991-c81c1ec3c188"], "operator": null, "metadata": {"aucs": [0.0841688940574552, 0.09348899844045389, 0.0922581165746833]}}
{"id": "0a2ed27d-2987-46b8-8e70-900aa7f0dfd2", "fitness": 0.09559442634380681, "name": "AdaptiveOscillationDifferentialEvolution", "description": "Enhanced mutation factor control and adaptive elite selection to improve convergence and exploration balance.", "code": "import numpy as np\n\nclass AdaptiveOscillationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                \n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count / self.budget)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor +\n                                 self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.4))  # Reduced growth multiplier\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.5 * (1 - fitness_variance / (fitness_variance + 1))\n            self.mutation_factor = 0.4 + 0.6 * (1 - diversity / (diversity + 1))  # Adjusted mutation scaling\n\n            elite_size = max(1, self.population_size // 8)  # Changed elite size\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                elite_population = np.vstack((elite_population, elite_population + np.random.randn(elite_size, self.dim) * 0.1))\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 97, "feedback": "The algorithm AdaptiveOscillationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09559 with standard deviation 0.00152.", "error": "", "parent_ids": ["bc94359d-1566-44c6-9991-c81c1ec3c188"], "operator": null, "metadata": {"aucs": [0.09619635926455117, 0.09707637454199847, 0.09351054522487079]}}
{"id": "2168d193-835d-48c9-a5aa-7f6332253d31", "fitness": 0.09500596644536334, "name": "AdaptiveOscillationDifferentialEvolution", "description": "Introduce dynamic population adaptation and stochastic crossover to enhance exploration and exploitation in adaptive differential evolution.", "code": "import numpy as np\n\nclass AdaptiveOscillationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(10 * np.pi * self.eval_count / self.budget)\n                \n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count / self.budget)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor +\n                                 self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.7 * np.random.rand()  # Stochastic crossover adjustment\n            self.mutation_factor = 0.5 + 0.5 * (1 - diversity / (diversity + 1))\n\n            elite_size = max(1, self.population_size // 8)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                elite_population = np.vstack((elite_population, elite_population + np.random.randn(elite_size, self.dim) * 0.1))\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 98, "feedback": "The algorithm AdaptiveOscillationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09501 with standard deviation 0.00092.", "error": "", "parent_ids": ["0a2ed27d-2987-46b8-8e70-900aa7f0dfd2"], "operator": null, "metadata": {"aucs": [0.09599149970029475, 0.09524980611608524, 0.09377659351971002]}}
{"id": "0105667b-7a03-4d04-9b97-1dc700e61dde", "fitness": 0.0930530714438258, "name": "AdaptiveOscillationDifferentialEvolution", "description": "Improved diversity management and oscillation control for enhanced convergence and stability in optimization.", "code": "import numpy as np\n\nclass AdaptiveOscillationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.population_size = self.initial_population_size\n        self.eval_count = 0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.alpha = 0.1\n        self.diversity_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        population = np.random.rand(self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        p_best_rate = 0.2\n\n        while self.eval_count < self.budget:\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                indices = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                oscillating_factor = np.sin(5 * np.pi * self.eval_count / self.budget)  # Reduced oscillation frequency\n                \n                self_adaptive_mutation = self.alpha * np.random.randn(self.dim) * (1 - self.eval_count / self.budget)\n                \n                p_best = population[np.argsort(fitness)[:max(1, int(p_best_rate * self.population_size))]][0]\n                noise_scale = 0.05 * (1.0 - self.eval_count / self.budget)\n                noise = np.random.randn(self.dim) * noise_scale\n                mutant = np.clip(x1 + self.mutation_factor * (x2 - x3) * oscillating_factor +\n                                 self_adaptive_mutation + 0.6 * (p_best - x1) + noise, bounds[0], bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n\n            if self.eval_count % (self.budget // 10) == 0:\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold or fitness_variance < 0.01:\n                    self.population_size = min(self.initial_population_size, int(self.population_size * 1.3))  # Further reduced growth multiplier\n                else:\n                    self.population_size = max(self.min_population_size, self.population_size // 2)\n                indices = np.argsort(fitness)[:self.population_size]\n                population = population[indices]\n                fitness = fitness[indices]\n\n            self.crossover_rate = 0.3 + 0.4 * (1 - fitness_variance / (fitness_variance + 1))  # Adjusted crossover scaling\n            self.mutation_factor = 0.3 + 0.7 * (1 - diversity / (diversity + 1))  # Modified mutation scaling\n\n            elite_size = max(1, self.population_size // 8)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elite_population = population[elite_indices]\n\n            if diversity < self.diversity_threshold:\n                new_individuals = np.random.rand(self.initial_population_size - self.population_size, self.dim) * (bounds[1] - bounds[0]) + bounds[0]\n                population = np.vstack((elite_population, new_individuals))\n                fitness = np.append(fitness[elite_indices], [func(ind) for ind in new_individuals])\n                self.eval_count += len(new_individuals)\n            else:\n                elite_population = np.vstack((elite_population, elite_population + np.random.randn(elite_size, self.dim) * 0.05))  # Reduced noise scale\n                population = np.vstack((elite_population, population))\n                fitness = np.append(fitness[elite_indices], fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 99, "feedback": "The algorithm AdaptiveOscillationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09305 with standard deviation 0.00077.", "error": "", "parent_ids": ["0a2ed27d-2987-46b8-8e70-900aa7f0dfd2"], "operator": null, "metadata": {"aucs": [0.09289371038938987, 0.09220417167051709, 0.09406133227157043]}}
