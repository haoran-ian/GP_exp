{"id": "d53a87b6-eaf2-4084-9a14-7b12ef8be4da", "fitness": 0.06576610395203493, "name": "AdaptiveSwarmOptimizer", "description": "A dynamic swarm-based optimizer that balances exploration and exploitation using adaptive velocity and position updates.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.5\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = self.inertia_weight * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06577 with standard deviation 0.00398.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.07011828100926809, 0.06049767969961861, 0.0666823511472181]}}
{"id": "a821c89b-23d5-4d04-afa2-30fa646e2d8d", "fitness": 0.06125897383096468, "name": "EnhancedSwarmOptimizer", "description": "An enhanced swarm optimizer that incorporates adaptive inertia weight and random local reinitialization to improve convergence and prevent premature stagnation.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.reinit_prob = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for iteration in range(self.budget):\n            inertia_weight = self.inertia_weight_max - (\n                (self.inertia_weight_max - self.inertia_weight_min) * (iteration / self.budget)\n            )\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.reinit_prob:\n                    swarm_position[i] = np.random.uniform(lb, ub, self.dim)\n                    swarm_velocity[i] = np.random.uniform(-1, 1, self.dim)\n                else:\n                    inertia = inertia_weight * swarm_velocity[i]\n                    cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                    social_component = self.social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                    swarm_velocity[i] = inertia + cognitive_component + social_component\n                    swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06126 with standard deviation 0.00407.", "error": "", "parent_ids": ["d53a87b6-eaf2-4084-9a14-7b12ef8be4da"], "operator": null, "metadata": {"aucs": [0.06679492967109923, 0.057127323951399855, 0.05985466787039495]}}
{"id": "12b1dba4-bb36-433c-9315-c89b66d6ccdc", "fitness": 0.06607016736038063, "name": "EnhancedSwarmOptimizer", "description": "An enhanced dynamic swarm optimizer using adaptive inertia weight and a local convergence factor for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.inertia_damping = 0.995  # Damping factor for inertia weight\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5  # New local convergence weight\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = self.inertia_weight * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                # Adding a local convergence factor\n                local_convergence = self.local_convergence_weight * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n            # Update the inertia weight\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06607 with standard deviation 0.00414.", "error": "", "parent_ids": ["d53a87b6-eaf2-4084-9a14-7b12ef8be4da"], "operator": null, "metadata": {"aucs": [0.06568620909130629, 0.07132040442661236, 0.06120388856322323]}}
{"id": "5ca40eae-7a96-46f2-a468-d5e4fd46addb", "fitness": 0.0664338449734545, "name": "EnhancedSwarmOptimizer", "description": "A refined enhanced swarm optimizer using a non-linear inertia weight decay and adaptive local convergence weight for better balance.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.inertia_damping = 0.995  # Damping factor for inertia weight\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5  # New local convergence weight\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):  # Change 1: Use t instead of _\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]  # Change 2: Non-linear inertia decay\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight + t / self.budget) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])  # Change 3: Adaptive local convergence weight\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n            # Update the inertia weight\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06643 with standard deviation 0.00429.", "error": "", "parent_ids": ["12b1dba4-bb36-433c-9315-c89b66d6ccdc"], "operator": null, "metadata": {"aucs": [0.06711390908228732, 0.07132040442661236, 0.060867221411463834]}}
{"id": "5bec7933-783e-4ebc-86d2-0c5731ac6b33", "fitness": 0.06661359089597141, "name": "EnhancedSwarmOptimizer", "description": "Introducing a diversity maintenance mechanism by adding a mutation step to avoid premature convergence and enhance exploration.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.inertia_damping = 0.995  # Damping factor for inertia weight\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5  # New local convergence weight\n        self.mutation_rate = 0.1  # Mutation rate for diversity\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):  # Change 1: Use t instead of _\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]  # Change 2: Non-linear inertia decay\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight + t / self.budget) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])  # Change 3: Adaptive local convergence weight\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                swarm_position[i] += self.mutation_rate * np.random.uniform(-1, 1, self.dim)  # Change 4: Introduce mutation\n\n            # Update the inertia weight\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06661 with standard deviation 0.00781.", "error": "", "parent_ids": ["5ca40eae-7a96-46f2-a468-d5e4fd46addb"], "operator": null, "metadata": {"aucs": [0.06401328516462779, 0.07721141614731453, 0.05861607137597191]}}
{"id": "981ddaac-4d2c-4983-9ccb-b9cbd8ab7c38", "fitness": 0.06736337415603492, "name": "EnhancedSwarmOptimizer", "description": "Adjusted inertia damping factor to enhance balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.inertia_damping = 0.99  # Adjusted damping factor for inertia weight\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5  # New local convergence weight\n        self.mutation_rate = 0.1  # Mutation rate for diversity\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):  # Change 1: Use t instead of _\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]  # Change 2: Non-linear inertia decay\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight + t / self.budget) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])  # Change 3: Adaptive local convergence weight\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                swarm_position[i] += self.mutation_rate * np.random.uniform(-1, 1, self.dim)  # Change 4: Introduce mutation\n\n            # Update the inertia weight\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06736 with standard deviation 0.00894.", "error": "", "parent_ids": ["5bec7933-783e-4ebc-86d2-0c5731ac6b33"], "operator": null, "metadata": {"aucs": [0.06401328516462779, 0.07960208514962186, 0.058474752153855114]}}
{"id": "80b56efe-ecfd-4653-a105-7158541210bb", "fitness": 0.06733369937288276, "name": "EnhancedSwarmOptimizer", "description": "Introducing a hybrid adaptive mutation and learning-based velocity update to enhance PSO convergence.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.adaptive_mutation_rate = 0.1\n        self.learning_rate = 0.1  # New learning rate for velocity update\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight + t / self.budget) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                adaptive_mutation = self.adaptive_mutation_rate * (1 - np.tanh(t / self.budget)) * np.random.uniform(-1, 1, self.dim)  # Adaptive mutation\n                learning_component = self.learning_rate * (global_best_position - swarm_position[i])  # Learning-based velocity update\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence + learning_component\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i] + adaptive_mutation, lb, ub)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06733 with standard deviation 0.00404.", "error": "", "parent_ids": ["981ddaac-4d2c-4983-9ccb-b9cbd8ab7c38"], "operator": null, "metadata": {"aucs": [0.06268573862526206, 0.07253567676640915, 0.0667796827269771]}}
{"id": "76b2349a-ea60-4caf-91f6-c0a7836a5792", "fitness": 0.08059203331186, "name": "AdaptiveLearningSwarmOptimizer", "description": "Introduce adaptive learning rates for cognitive and social components to dynamically adjust exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveLearningSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                # Adaptive cognitive and social weights\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)\n                social_weight = self.social_weight * (t / self.budget)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight + t / self.budget) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                swarm_position[i] += self.mutation_rate * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveLearningSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08059 with standard deviation 0.00199.", "error": "", "parent_ids": ["981ddaac-4d2c-4983-9ccb-b9cbd8ab7c38"], "operator": null, "metadata": {"aucs": [0.08015799075235275, 0.08321156834874288, 0.0784065408344844]}}
{"id": "acb31c46-3d93-4e1e-9140-58db61906dbe", "fitness": 0.0805922477583576, "name": "AdaptiveLearningSwarmOptimizer", "description": "Adjust the mutation rate dynamically based on the remaining budget to enhance explorative capabilities.", "code": "import numpy as np\n\nclass AdaptiveLearningSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                # Adaptive cognitive and social weights\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)\n                social_weight = self.social_weight * (t / self.budget)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight + t / self.budget) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                # Adjust the mutation rate dynamically\n                swarm_position[i] += (self.mutation_rate * (1 - t / self.budget)) * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveLearningSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08059 with standard deviation 0.00198.", "error": "", "parent_ids": ["76b2349a-ea60-4caf-91f6-c0a7836a5792"], "operator": null, "metadata": {"aucs": [0.08015812840308767, 0.08321111181804308, 0.07840750305394206]}}
{"id": "a17b9f87-813b-4f4b-b1a4-90d6896a8091", "fitness": 0.08064689546291963, "name": "AdaptiveLearningSwarmOptimizer", "description": "Introduce a self-adaptive strategy for local convergence weight adjustment based on iteration progress to enhance solution refinement. ", "code": "import numpy as np\n\nclass AdaptiveLearningSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                # Adaptive cognitive and social weights\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)\n                social_weight = self.social_weight * (t / self.budget)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                # Adjust the mutation rate dynamically\n                swarm_position[i] += (self.mutation_rate * (1 - t / self.budget)) * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 9, "feedback": "The algorithm AdaptiveLearningSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08065 with standard deviation 0.00209.", "error": "", "parent_ids": ["acb31c46-3d93-4e1e-9140-58db61906dbe"], "operator": null, "metadata": {"aucs": [0.07996107074205139, 0.08348176669650231, 0.07849784895020517]}}
{"id": "2c52d200-b1fa-4859-ab50-f559458c4703", "fitness": 0.07027159335645317, "name": "EnhancedAdaptiveLearningSwarmOptimizer", "description": "Incorporate diversity preservation and dynamic leader selection in adaptive learning swarm optimization to enhance exploration and convergence balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveLearningSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.mutation_rate = 0.1\n        self.diversity_weight = 0.1\n        self.leaders_fraction = 0.2\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            # Dynamic leader selection based on the top fraction\n            leader_indices = np.argsort(personal_best_value)[:int(self.leaders_fraction * self.population_size)]\n            dynamic_leader_position = np.mean(personal_best_position[leader_indices], axis=0)\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)\n                social_weight = self.social_weight * (t / self.budget)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (dynamic_leader_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                diversity_component = self.diversity_weight * np.random.rand(self.dim) * (np.std(swarm_position, axis=0))\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence + diversity_component\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                swarm_position[i] += (self.mutation_rate * (1 - t / self.budget)) * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedAdaptiveLearningSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07027 with standard deviation 0.00530.", "error": "", "parent_ids": ["a17b9f87-813b-4f4b-b1a4-90d6896a8091"], "operator": null, "metadata": {"aucs": [0.06564537863026687, 0.06748040348174311, 0.07768899795734951]}}
{"id": "c064ff67-4401-4d80-81ed-937a139f9c5b", "fitness": 0.08064689428100798, "name": "AdaptiveLearningSwarmOptimizer", "description": "Enhance mutation strategy by incorporating exponential decay to improve exploration over iterations.", "code": "import numpy as np\n\nclass AdaptiveLearningSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                # Adaptive cognitive and social weights\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)\n                social_weight = self.social_weight * (t / self.budget)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                # Adjust the mutation rate dynamically with exponential decay\n                swarm_position[i] += (self.mutation_rate * np.exp(-t / self.budget)) * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 11, "feedback": "The algorithm AdaptiveLearningSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08065 with standard deviation 0.00209.", "error": "", "parent_ids": ["a17b9f87-813b-4f4b-b1a4-90d6896a8091"], "operator": null, "metadata": {"aucs": [0.07996105860457614, 0.0834817793288758, 0.07849784490957201]}}
{"id": "c4313592-dd04-467d-9fb3-8066623beecc", "fitness": 0.07879453406720793, "name": "AdaptiveLearningSwarmOptimizer", "description": "Integrate a time-varying local convergence strategy for enhanced exploration and exploitation balance. ", "code": "import numpy as np\n\nclass AdaptiveLearningSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                # Adaptive cognitive and social weights\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)\n                social_weight = self.social_weight * (t / self.budget)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 - abs(0.5 - t / self.budget))) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                # Adjust the mutation rate dynamically\n                swarm_position[i] += (self.mutation_rate * (1 - t / self.budget)) * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 12, "feedback": "The algorithm AdaptiveLearningSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07879 with standard deviation 0.00191.", "error": "", "parent_ids": ["a17b9f87-813b-4f4b-b1a4-90d6896a8091"], "operator": null, "metadata": {"aucs": [0.07610930122232917, 0.07987319253665359, 0.08040110844264103]}}
{"id": "9bca0f5a-b140-4227-9ebf-4d4350f54a8e", "fitness": 0.07173497126195279, "name": "AdaptiveLearningSwarmOptimizer", "description": "Introduce a dynamic local convergence weight scaling based on swarm diversity to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveLearningSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                # Adaptive cognitive and social weights\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)\n                social_weight = self.social_weight * (t / self.budget)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                diversity_factor = np.std(swarm_position) / 10  # New line for dynamic scaling based on diversity\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget) * diversity_factor) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                # Adjust the mutation rate dynamically\n                swarm_position[i] += (self.mutation_rate * (1 - t / self.budget)) * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 13, "feedback": "The algorithm AdaptiveLearningSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07173 with standard deviation 0.00943.", "error": "", "parent_ids": ["a17b9f87-813b-4f4b-b1a4-90d6896a8091"], "operator": null, "metadata": {"aucs": [0.08449496125652534, 0.06872224437252483, 0.06198770815680821]}}
{"id": "ed328552-a78c-4903-a4f5-d7b25272574f", "fitness": 0.07072197284447494, "name": "AdvancedMomentumSwarmOptimizer", "description": "Implement a dynamically adaptive velocity control mechanism using historical momentum and fitness trends to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedMomentumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.momentum_factor = 0.5\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        velocity_memory = np.zeros((self.population_size, self.dim))\n        \n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = self.inertia_weight * velocity_memory[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                \n                # Adaptive momentum based velocity update\n                new_velocity = inertia + cognitive_component + social_component\n                new_velocity = self.momentum_factor * velocity_memory[i] + self.learning_rate * new_velocity\n                \n                swarm_velocity[i] = new_velocity\n                velocity_memory[i] = new_velocity\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 14, "feedback": "The algorithm AdvancedMomentumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07072 with standard deviation 0.00572.", "error": "", "parent_ids": ["a17b9f87-813b-4f4b-b1a4-90d6896a8091"], "operator": null, "metadata": {"aucs": [0.07785452977941676, 0.06383846040299646, 0.0704729283510116]}}
{"id": "90df2851-e033-4a56-9df6-00b6e67288a9", "fitness": 0.08081924186988676, "name": "EnhancedAdaptiveSwarmOptimizer", "description": "Enhance solution diversity and convergence by integrating adaptive mutation control and progressive swarm entropy adjustment.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)\n                social_weight = self.social_weight * (t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08082 with standard deviation 0.00212.", "error": "", "parent_ids": ["a17b9f87-813b-4f4b-b1a4-90d6896a8091"], "operator": null, "metadata": {"aucs": [0.08021976622680993, 0.08366868069753675, 0.0785692786853136]}}
{"id": "b031d2fa-42d8-44cb-9309-b54be2b284bc", "fitness": 0.07978348545129099, "name": "PredatorPreySwarmOptimizer", "description": "Improve convergence by incorporating predator-prey dynamics and dynamic subpopulation migration in enhanced swarm behavior.", "code": "import numpy as np\n\nclass PredatorPreySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.predator_influence = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n        \n        predator_position = np.random.uniform(lb, ub, self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)\n                social_weight = self.social_weight * (t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                \n                # Predator effect\n                predator_effect = self.predator_influence * np.random.rand(self.dim) * (predator_position - swarm_position[i])\n                \n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence - predator_effect\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n            \n            # Update predator position\n            predator_position = np.mean(swarm_position, axis=0) + np.random.uniform(-0.5, 0.5, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 16, "feedback": "The algorithm PredatorPreySwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07978 with standard deviation 0.00531.", "error": "", "parent_ids": ["90df2851-e033-4a56-9df6-00b6e67288a9"], "operator": null, "metadata": {"aucs": [0.07550100409735283, 0.08726742933518306, 0.07658202292133709]}}
{"id": "4eee6c03-6699-4b2a-906a-422da37bd65a", "fitness": 0.08094099635095493, "name": "EnhancedAdaptiveSwarmOptimizer", "description": "Enhance balance between exploration and exploitation by dynamically adjusting weights based on function evaluations.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08094 with standard deviation 0.00202.", "error": "", "parent_ids": ["90df2851-e033-4a56-9df6-00b6e67288a9"], "operator": null, "metadata": {"aucs": [0.08201723660867644, 0.08269964852531753, 0.07810610391887085]}}
{"id": "26c1a64c-5401-4edc-b6a2-97262d0e7828", "fitness": 0.08036619705673176, "name": "EnhancedAdaptiveSwarmOptimizer", "description": "Introduce an adaptive cognitive component to enhance convergence by fine-tuning individual learning influence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - fitness_value/global_best_value)**2  # Changed line\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08037 with standard deviation 0.00073.", "error": "", "parent_ids": ["4eee6c03-6699-4b2a-906a-422da37bd65a"], "operator": null, "metadata": {"aucs": [0.08093060098766347, 0.07933388303394762, 0.08083410714858419]}}
{"id": "e110f813-b7cb-47f9-89d2-efa1f82a64fb", "fitness": 0.08164658421808442, "name": "EnhancedAdaptiveSwarmOptimizer", "description": "Enhance convergence by introducing dynamic personal best adjustment based on proximity to global best.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])  # New line added\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08165 with standard deviation 0.00270.", "error": "", "parent_ids": ["4eee6c03-6699-4b2a-906a-422da37bd65a"], "operator": null, "metadata": {"aucs": [0.0811522746123664, 0.08517554003751271, 0.07861193800437416]}}
{"id": "f69c7db3-346a-4144-9a32-3a9a2f5a1b6d", "fitness": -Infinity, "name": "DualPhaseAdaptiveSwarmOptimizer", "description": "Introduce a dual-phase adaptive control mechanism dynamically adjusting swarm parameters to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass DualPhaseAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.exploration_weight = 0.7\n        self.exploitation_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            phase_control = (1 - t / self.budget)\n            exploration_phase = phase_control > 0.5\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                if exploration_phase:\n                    weighted_cognitive = self.cognitive_weight * self.exploration_weight * np.random.rand(self.dim)\n                    weighted_social = self.social_weight * self.exploration_weight * np.random.rand(self.dim)\n                else:\n                    weighted_cognitive = self.cognitive_weight * self.exploitation_weight * np.random.rand(self.dim)\n                    weighted_social = self.social_weight * self.exploitation_weight * np.random.rand(self.dim)\n\n                cognitive_component = weighted_cognitive * (personal_best_position[i] - swarm_position[i])\n                social_component = weighted_social * (global_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                \n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i]) \n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 20, "feedback": "An exception occurred: AttributeError(\"'DualPhaseAdaptiveSwarmOptimizer' object has no attribute 'local_convergence_weight'\").", "error": "AttributeError(\"'DualPhaseAdaptiveSwarmOptimizer' object has no attribute 'local_convergence_weight'\")", "parent_ids": ["e110f813-b7cb-47f9-89d2-efa1f82a64fb"], "operator": null, "metadata": {}}
{"id": "bdcc6bca-8e40-4a3a-8bec-b4981e392e6b", "fitness": 0.08347892354821555, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Introduce dynamic neighborhood topology in the swarm to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])  # Added line for refining convergence\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 21, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08348 with standard deviation 0.00250.", "error": "", "parent_ids": ["e110f813-b7cb-47f9-89d2-efa1f82a64fb"], "operator": null, "metadata": {"aucs": [0.08087477662498022, 0.08685506271547039, 0.08270693130419604]}}
{"id": "e420162e-7a17-4f8b-ad7e-94bda30b8c01", "fitness": 0.08338535116729173, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance exploitation by dynamically adjusting cognitive and social weights based on swarm diversity.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                diversity_factor = 1 / (1 + entropy)  # New line\n                cognitive_weight = self.cognitive_weight * diversity_factor  # Modified line\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 22, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08339 with standard deviation 0.00389.", "error": "", "parent_ids": ["bdcc6bca-8e40-4a3a-8bec-b4981e392e6b"], "operator": null, "metadata": {"aucs": [0.0789394131606237, 0.08841403863631725, 0.08280260170493425]}}
{"id": "feda5d80-a9b6-477e-8871-161b6aed4dbc", "fitness": 0.07776995003627507, "name": "ChaoticNeighborhoodSwarmOptimizer", "description": "Integrate chaos theory-based randomization into the dynamic neighborhood swarm for enhanced exploration and exploitation dynamics.", "code": "import numpy as np\n\nclass ChaoticNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.chaos_param = np.random.rand()\n\n    def chaotic_rand(self):\n        # Logistic map for chaotic random number generation\n        self.chaos_param = 4.0 * self.chaos_param * (1 - self.chaos_param)\n        return self.chaos_param\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * self.chaotic_rand() * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * self.chaotic_rand() * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * self.chaotic_rand() * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n                personal_best_position[i] += 0.01 * self.chaotic_rand() * (global_best_position - personal_best_position[i])  # Added line for refining convergence\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 23, "feedback": "The algorithm ChaoticNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07777 with standard deviation 0.00521.", "error": "", "parent_ids": ["bdcc6bca-8e40-4a3a-8bec-b4981e392e6b"], "operator": null, "metadata": {"aucs": [0.08000080101044493, 0.07056864710393951, 0.08274040199444077]}}
{"id": "9171dd29-90c8-400b-b600-310cc749c992", "fitness": 0.08338562921545911, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Refine the velocity update mechanism by adjusting the cognitive component's influence with entropy modulation.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - (1 - fitness_value/global_best_value) * t / self.budget) * (1 + entropy)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])  # Added line for refining convergence\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 24, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08339 with standard deviation 0.00150.", "error": "", "parent_ids": ["bdcc6bca-8e40-4a3a-8bec-b4981e392e6b"], "operator": null, "metadata": {"aucs": [0.08188409978408595, 0.08543353425497413, 0.08283925360731725]}}
{"id": "11d5db15-0c19-4762-8b82-35efabf321dd", "fitness": 0.08227798132963822, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance convergence by refining social component and dynamically adjusting inertia for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.5 + (self.inertia_weight - 0.5) * (1 - t / self.budget)) * swarm_velocity[i]  # Modified line\n                cognitive_weight = self.cognitive_weight * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])  # Modified line\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 25, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08228 with standard deviation 0.00290.", "error": "", "parent_ids": ["bdcc6bca-8e40-4a3a-8bec-b4981e392e6b"], "operator": null, "metadata": {"aucs": [0.07834854552995563, 0.08526504224929954, 0.08322035620965951]}}
{"id": "ea7f294d-b25c-4a10-9a4d-b98e995c2ac1", "fitness": 0.08145710981256889, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Introduce adaptive cognitive and social weights based on convergence progress to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - (1 - fitness_value/global_best_value) * (1 - t / self.budget))  # Modified line for adaptive cognitive weight\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy) * (1 - t / self.budget)  # Modified line for adaptive social weight\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])  # Added line for refining convergence\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 26, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08146 with standard deviation 0.00240.", "error": "", "parent_ids": ["bdcc6bca-8e40-4a3a-8bec-b4981e392e6b"], "operator": null, "metadata": {"aucs": [0.07814355473284618, 0.0837504428951551, 0.0824773318097054]}}
{"id": "0070df49-8183-45bb-ae08-5cf8ec4a8393", "fitness": 0.06300772068555087, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance global exploration and adaptive mutation by refining weight balancing and mutation application in swarm dynamics.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * (1 + (fitness_value/global_best_value) * (1 - t / self.budget)) * (1 + entropy)  # Adjusted weight calculation\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                if i == np.argmin(personal_best_value):  # Apply mutation more on global best to enhance exploration\n                    swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)  # Moved mutation inside the condition\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i]) \n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 27, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06301 with standard deviation 0.00543.", "error": "", "parent_ids": ["bdcc6bca-8e40-4a3a-8bec-b4981e392e6b"], "operator": null, "metadata": {"aucs": [0.06352344019935796, 0.06938108968289602, 0.05611863217439861]}}
{"id": "b2cece2f-b36e-4f2b-a9ab-f990952b2b31", "fitness": 0.08236028265783775, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance local search and adaptivity in dynamic neighborhood swarm to improve convergence and exploration balance.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.98\n        self.cognitive_weight = 1.6\n        self.social_weight = 1.6\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.12\n        self.final_mutation_rate = 0.02\n        self.leader_selection_pressure = 2.0\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.3 + (self.inertia_weight - 0.3) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * np.random.rand() * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.uniform(-1, 1, self.dim)\n                personal_best_position[i] += 0.015 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 28, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08236 with standard deviation 0.00444.", "error": "", "parent_ids": ["bdcc6bca-8e40-4a3a-8bec-b4981e392e6b"], "operator": null, "metadata": {"aucs": [0.07615386298765248, 0.08632368615304609, 0.0846032988328147]}}
{"id": "81078def-4d81-48ae-b332-33e1f79c35a4", "fitness": 0.08549883195395007, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance convergence by adjusting mutation influence and introducing randomness in cognitive component scaling.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)  # Changed line\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)  # Changed line\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 29, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08550 with standard deviation 0.00132.", "error": "", "parent_ids": ["bdcc6bca-8e40-4a3a-8bec-b4981e392e6b"], "operator": null, "metadata": {"aucs": [0.08425009253766103, 0.08491596202892848, 0.08733044129526069]}}
{"id": "7211d71e-7f5e-4460-a7ea-c1ef2a398c0a", "fitness": 0.07748612709487583, "name": "HierarchicalSwarmOptimizer", "description": "Introduce hierarchical learning in swarm optimization by leveraging both global and local historical success rates to dynamically adjust exploration-exploitation balance.", "code": "import numpy as np\n\nclass HierarchicalSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.mutation_rate_start = 0.1\n        self.mutation_rate_end = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n        \n        global_success_rate = 0.5  # Initial global success rate\n        local_success_rates = np.ones(self.population_size) * 0.5  # Initial local success rates\n\n        for t in range(self.budget):\n            inertia_weight = self.inertia_weight_end + (self.inertia_weight_start - self.inertia_weight_end) * \\\n                             (1 - t / self.budget)\n            mutation_rate = self.mutation_rate_end + (self.mutation_rate_start - self.mutation_rate_end) * \\\n                            (1 - t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                    local_success_rates[i] = 0.9 * local_success_rates[i] + 0.1\n                else:\n                    local_success_rates[i] *= 0.9\n\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n                    global_success_rate = 0.9 * global_success_rate + 0.1\n                else:\n                    global_success_rate *= 0.9\n\n            for i in range(self.population_size):\n                inertia = inertia_weight * swarm_velocity[i]\n                cognitive_component = (self.cognitive_weight * local_success_rates[i]) * np.random.rand(self.dim) * \\\n                                      (personal_best_position[i] - swarm_position[i])\n                social_component = (self.social_weight * global_success_rate) * np.random.rand(self.dim) * \\\n                                   (global_best_position - swarm_position[i])\n                local_convergence = self.local_convergence_weight * np.random.rand(self.dim) * \\\n                                    (np.mean(swarm_position, axis=0) - swarm_position[i])\n                \n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                swarm_position[i] += mutation_rate * np.random.normal(0, 1, self.dim)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 30, "feedback": "The algorithm HierarchicalSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07749 with standard deviation 0.00976.", "error": "", "parent_ids": ["81078def-4d81-48ae-b332-33e1f79c35a4"], "operator": null, "metadata": {"aucs": [0.0841854251161146, 0.08459284945381063, 0.06368010671470226]}}
{"id": "a7488c53-05ca-444f-ab01-994520ef1ff1", "fitness": 0.07695179667662051, "name": "AdaptiveSubswarmOptimizer", "description": "Enhance swarm adaptability by dynamically adjusting mutation rates and leveraging local sub-swarm leaders for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveSubswarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.98\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(3, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.3 + (self.inertia_weight - 0.3) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveSubswarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07695 with standard deviation 0.00300.", "error": "", "parent_ids": ["81078def-4d81-48ae-b332-33e1f79c35a4"], "operator": null, "metadata": {"aucs": [0.07925971550509348, 0.07888437620225897, 0.07271129832250911]}}
{"id": "4bf826b7-afa0-4f04-a00f-a58e5839012c", "fitness": 0.08483953818925716, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Boost optimization by refining velocity update with adaptive entropy-based social weight.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget) \n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value) * entropy) * t / self.budget) * (1 + entropy)  # Changed line\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)  \n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 32, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08484 with standard deviation 0.00175.", "error": "", "parent_ids": ["81078def-4d81-48ae-b332-33e1f79c35a4"], "operator": null, "metadata": {"aucs": [0.08399915857329121, 0.08324477733055435, 0.08727467866392591]}}
{"id": "5e130228-8990-4fb3-b13f-91d9b4c66ca0", "fitness": 0.07012270174602424, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Refine velocity update by incorporating a nonlinear scaling factor based on iteration progress.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n\n                scaling_factor = 1 - np.exp(-5 * t / self.budget)  # Changed line\n                swarm_position[i] = np.clip(swarm_position[i] + scaling_factor * swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 33, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07012 with standard deviation 0.00051.", "error": "", "parent_ids": ["81078def-4d81-48ae-b332-33e1f79c35a4"], "operator": null, "metadata": {"aucs": [0.06958851315995818, 0.06997515812224508, 0.07080443395586944]}}
{"id": "e0b88dd5-09cb-4cf5-9daa-c3800f7eb777", "fitness": 0.08650765138780347, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Improve swarm convergence by enhancing the role of local convergence in velocity updates.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6  # Changed line\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 34, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08651 with standard deviation 0.00230.", "error": "", "parent_ids": ["81078def-4d81-48ae-b332-33e1f79c35a4"], "operator": null, "metadata": {"aucs": [0.08335550014735371, 0.0887760010262032, 0.08739145298985351]}}
{"id": "d6e4bf86-4942-416a-9701-2f9820f73ac7", "fitness": 0.08430577645290223, "name": "AdaptiveLearningSwarmOptimizer", "description": "Enhance swarm convergence by introducing self-adaptive learning factors and entropy-based mutation rates for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveLearningSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.initial_cognitive_weight = 1.5\n        self.initial_social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n            \n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = self.inertia_weight * swarm_velocity[i]\n                cognitive_weight = self.initial_cognitive_weight * np.random.rand() * (1 - t / self.budget)\n                social_weight = self.initial_social_weight * np.random.rand() * (1 + entropy) * t / self.budget\n                cognitive_component = cognitive_weight * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * (local_best_position - swarm_position[i])\n                local_convergence = self.local_convergence_weight * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n            \n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 35, "feedback": "The algorithm AdaptiveLearningSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08431 with standard deviation 0.00463.", "error": "", "parent_ids": ["e0b88dd5-09cb-4cf5-9daa-c3800f7eb777"], "operator": null, "metadata": {"aucs": [0.07786255707710166, 0.08651580771264922, 0.08853896456895582]}}
{"id": "ec137d7c-4956-4c2f-aa60-24b6da5dce12", "fitness": 0.0738020639244098, "name": "EnhancedDynamicSwarmOptimizer", "description": "Enhance swarm adaptability by dynamically adjusting weights based on fitness landscape features and iteration progress.", "code": "import numpy as np\n\nclass EnhancedDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n            \n            inertia_weight = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget))\n            adaptive_cognitive_weight = self.cognitive_weight * (1 - entropy) * (1 + t / self.budget)\n            adaptive_social_weight = self.social_weight * (1 + entropy) * (1 - t / self.budget)\n            \n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = inertia_weight * swarm_velocity[i]\n                cognitive_component = adaptive_cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = adaptive_social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedDynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07380 with standard deviation 0.00972.", "error": "", "parent_ids": ["e0b88dd5-09cb-4cf5-9daa-c3800f7eb777"], "operator": null, "metadata": {"aucs": [0.06176665941978943, 0.08557183333018348, 0.0740676990232565]}}
{"id": "7a2378de-05ee-476e-80f3-444ce494db69", "fitness": 0.081219035254314, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance swarm convergence by reducing cognitive weight as the search progresses, improving global exploration.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6  # Changed line\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)  # Changed line\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 37, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08122 with standard deviation 0.00610.", "error": "", "parent_ids": ["e0b88dd5-09cb-4cf5-9daa-c3800f7eb777"], "operator": null, "metadata": {"aucs": [0.0726337648152926, 0.08472637016150808, 0.08629697078614129]}}
{"id": "454133bc-2b4a-400c-b0ae-c59fd007e6e0", "fitness": 0.08563786483084183, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance swarm convergence through adaptive local convergence weight based on exploration-exploitation balance.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6  # Changed line\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                adaptive_local_convergence_weight = self.local_convergence_weight * (1 - entropy)  # Changed line\n                local_convergence = adaptive_local_convergence_weight * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 38, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08564 with standard deviation 0.00071.", "error": "", "parent_ids": ["e0b88dd5-09cb-4cf5-9daa-c3800f7eb777"], "operator": null, "metadata": {"aucs": [0.08488125793544743, 0.08544608630751005, 0.08658625024956801]}}
{"id": "e5dc372f-568b-4656-8c50-680293e48d8a", "fitness": 0.08650764569361402, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance local convergence by modifying mutation rate based on swarm diversity.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6  # Changed line\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) * (1 + entropy)  # Modified line\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 39, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08651 with standard deviation 0.00230.", "error": "", "parent_ids": ["e0b88dd5-09cb-4cf5-9daa-c3800f7eb777"], "operator": null, "metadata": {"aucs": [0.08335549818658439, 0.08877598326295133, 0.08739145563130635]}}
{"id": "8a2fec2a-c3bc-408c-86be-034da166780a", "fitness": 0.07537851920513354, "name": "EnhancedSwarmOptimizer", "description": "Enhance swarm dynamics by integrating a self-adaptive mutation mechanism and an entropy-based convergence control.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.98\n        self.cognitive_weight = 1.7\n        self.social_weight = 1.7\n        self.local_convergence_weight = 0.7\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n        \n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (0.5 + 0.5 * (1 - t / self.budget))))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07538 with standard deviation 0.00649.", "error": "", "parent_ids": ["e0b88dd5-09cb-4cf5-9daa-c3800f7eb777"], "operator": null, "metadata": {"aucs": [0.06909008887251633, 0.08431112992784007, 0.07273433881504421]}}
{"id": "e85c7afe-f6b7-4da6-81f2-a3b1d05c7d33", "fitness": 0.08650768566780387, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Improve swarm convergence by slightly enhancing the adaptive mutation rate over time.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2  # Modified line\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 41, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08651 with standard deviation 0.00230.", "error": "", "parent_ids": ["e0b88dd5-09cb-4cf5-9daa-c3800f7eb777"], "operator": null, "metadata": {"aucs": [0.08335551199130609, 0.08877610329706598, 0.08739144171503954]}}
{"id": "2381d184-e06e-4471-a652-71162a9c5cf6", "fitness": 0.0864637359645346, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance swarm convergence by dynamically adjusting local convergence influence over time.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 - t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])  # Modified line\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 42, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08646 with standard deviation 0.00225.", "error": "", "parent_ids": ["e85c7afe-f6b7-4da6-81f2-a3b1d05c7d33"], "operator": null, "metadata": {"aucs": [0.08339821010900383, 0.08871477443495424, 0.08727822334964574]}}
{"id": "12f78917-443f-443a-bee8-12078517fd9e", "fitness": 0.08183495798869682, "name": "DynamicVelocitySwarmOptimizer", "description": "Enhance swarm exploration by incorporating a dynamic velocity scaling mechanism based on fitness feedback.", "code": "import numpy as np\n\nclass DynamicVelocitySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.velocity_scaling_factor = 0.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                velocity_scaling = (1 + fitness_value / (global_best_value + 1e-9)) * self.velocity_scaling_factor\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_velocity[i] *= velocity_scaling\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 43, "feedback": "The algorithm DynamicVelocitySwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08183 with standard deviation 0.00220.", "error": "", "parent_ids": ["e85c7afe-f6b7-4da6-81f2-a3b1d05c7d33"], "operator": null, "metadata": {"aucs": [0.08275946000187784, 0.07879512543667455, 0.08395028852753805]}}
{"id": "b5b931d2-75eb-46e1-89d5-7145f0a128b3", "fitness": 0.05955213675610612, "name": "EnhancedNeighborhoodSwarmOptimizer", "description": "Enhance swarm dynamics by introducing time-varying neighborhood influence and adaptive velocity scaling.", "code": "import numpy as np\n\nclass EnhancedNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * np.random.rand() * (1 + (fitness_value/global_best_value) * (1 + entropy))\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_velocity[i] = np.clip(swarm_velocity[i], -2, 2) # Adaptive velocity scaling\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05955 with standard deviation 0.00124.", "error": "", "parent_ids": ["e85c7afe-f6b7-4da6-81f2-a3b1d05c7d33"], "operator": null, "metadata": {"aucs": [0.06060373357529292, 0.05780994385675031, 0.060242732836275126]}}
{"id": "fb1e4ed9-8ad4-4104-9569-f64d827c654d", "fitness": 0.04480820520814518, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance swarm convergence by adapting inertia and mutation rates based on fitness improvement.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            fitness_improvement = np.mean([f for f in personal_best_value if f < global_best_value])\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - fitness_improvement / global_best_value)  # Modified line\n            adaptive_inertia = max(0.4, self.inertia_weight * (1 - fitness_improvement / global_best_value))  # Modified line\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = adaptive_inertia * swarm_velocity[i]  # Modified line\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 45, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04481 with standard deviation 0.00178.", "error": "", "parent_ids": ["e85c7afe-f6b7-4da6-81f2-a3b1d05c7d33"], "operator": null, "metadata": {"aucs": [0.04565905788618552, 0.04233577183476955, 0.04642978590348046]}}
{"id": "4cdbd07f-1169-4ace-832d-4bddba57a1cf", "fitness": 0.07634610104391171, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Introduce dynamic neighborhood size and entropy-driven mutation to enhance swarm exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (0.5 + 0.5 * np.sin(np.pi * t / self.budget))))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, entropy, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 46, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07635 with standard deviation 0.00519.", "error": "", "parent_ids": ["e85c7afe-f6b7-4da6-81f2-a3b1d05c7d33"], "operator": null, "metadata": {"aucs": [0.07383190643110804, 0.07163155754744321, 0.08357483915318387]}}
{"id": "1f1efa20-110a-4855-a64a-5ff6f93a3e4a", "fitness": 0.07346981179680127, "name": "EnhancedDynamicSwarmOptimizer", "description": "Enhance swarm optimization by dynamically adjusting swarm size and introducing a global learning factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.global_learning_factor = 0.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)   \n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                global_learning = self.global_learning_factor * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + global_learning\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n            self.population_size = max(5, int(self.population_size * (1 - t / self.budget * 0.1)))  # Reduce population size over time\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedDynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07347 with standard deviation 0.00737.", "error": "", "parent_ids": ["e85c7afe-f6b7-4da6-81f2-a3b1d05c7d33"], "operator": null, "metadata": {"aucs": [0.08132384232539847, 0.063606842748413, 0.07547875031659235]}}
{"id": "fa5ed412-fec4-4cbe-9798-364b5d968380", "fitness": 0.08386015293736389, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance swarm convergence by adjusting the local convergence weight based on entropy.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget) * (1 + entropy)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])  # Modified line\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 48, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08386 with standard deviation 0.00330.", "error": "", "parent_ids": ["e85c7afe-f6b7-4da6-81f2-a3b1d05c7d33"], "operator": null, "metadata": {"aucs": [0.0851554870011505, 0.0793273665178259, 0.08709760529311528]}}
{"id": "0725ad03-5413-4042-9a52-8bd7fe7beb84", "fitness": 0.08666614043114677, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Improve swarm convergence by fine-tuning the inertia weight decay for better adaptability.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995  # Modified line\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 49, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08667 with standard deviation 0.00217.", "error": "", "parent_ids": ["e85c7afe-f6b7-4da6-81f2-a3b1d05c7d33"], "operator": null, "metadata": {"aucs": [0.08373784369934345, 0.08892706215635826, 0.0873335154377386]}}
{"id": "1501f2a3-dae3-426b-bded-ec25a543d672", "fitness": 0.0864706305494728, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance swarm convergence by introducing a slight adjustment to the cognitive weight for better exploration.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.55  # Modified line\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 50, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08647 with standard deviation 0.00225.", "error": "", "parent_ids": ["0725ad03-5413-4042-9a52-8bd7fe7beb84"], "operator": null, "metadata": {"aucs": [0.0833824543408348, 0.08869557061094002, 0.08733386669664356]}}
{"id": "2407eb53-792c-4566-859c-176461380125", "fitness": 0.06577286442491286, "name": "EnhancedSwarmOptimizer", "description": "Enhance swarm adaptability by introducing dynamic leader selection and hybrid velocity update strategies.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            dynamic_leader_index = np.argmin(personal_best_value)\n            dynamic_leader_position = personal_best_position[dynamic_leader_index]\n\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                leader_component = self.social_weight * np.random.rand(self.dim) * (dynamic_leader_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + leader_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06577 with standard deviation 0.00728.", "error": "", "parent_ids": ["0725ad03-5413-4042-9a52-8bd7fe7beb84"], "operator": null, "metadata": {"aucs": [0.06505955658502127, 0.07502506064443382, 0.05723397604528346]}}
{"id": "3cbc1570-e7e9-4041-bc11-9aa5c8bedafb", "fitness": 0.08650116291567851, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance swarm convergence by refining the local convergence weight decay for increased adaptability.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 - t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])  # Modified line\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 52, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08650 with standard deviation 0.00232.", "error": "", "parent_ids": ["0725ad03-5413-4042-9a52-8bd7fe7beb84"], "operator": null, "metadata": {"aucs": [0.08337284030118342, 0.08891821234454755, 0.08721243610130458]}}
{"id": "d16e314a-50fb-4ae8-8453-2fd978c8de93", "fitness": 0.08728120867945958, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Enhance optimization by adjusting personal best attraction dynamically based on convergence trend.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 53, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08728 with standard deviation 0.00328.", "error": "", "parent_ids": ["0725ad03-5413-4042-9a52-8bd7fe7beb84"], "operator": null, "metadata": {"aucs": [0.0832324334377198, 0.09127210609806058, 0.08733908650259836]}}
{"id": "6a9d8cc6-2366-454a-abd7-359e27ff0866", "fitness": 0.08637951095794567, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Slightly adjust cognitive component for improved convergence.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = (cognitive_weight + 0.6 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 54, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08638 with standard deviation 0.00332.", "error": "", "parent_ids": ["d16e314a-50fb-4ae8-8453-2fd978c8de93"], "operator": null, "metadata": {"aucs": [0.08192514857094424, 0.08987318609783868, 0.08734019820505412]}}
{"id": "d42868cf-0b25-4b5e-a266-4147262219cf", "fitness": 0.062092927334963, "name": "AdaptiveInertiaSwarmOptimizer", "description": "Introduce adaptive inertia and diversity preservation mechanisms to enhance convergence and exploration balance.", "code": "import numpy as np\n\nclass AdaptiveInertiaSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.diversity_preservation_weight = 0.1\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (t / self.budget)\n\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, 2, replace=False)\n                local_best_position = personal_best_position[neighbors[np.argmin(personal_best_value[neighbors])]]\n\n                inertia = inertia_weight * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                diversity_component = self.diversity_preservation_weight * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n\n                swarm_velocity[i] = inertia + cognitive_component + social_component + diversity_component\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                # Minor random perturbation to maintain diversity\n                swarm_position[i] += 0.01 * np.random.normal(0, 1, self.dim)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 55, "feedback": "The algorithm AdaptiveInertiaSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06209 with standard deviation 0.01167.", "error": "", "parent_ids": ["d16e314a-50fb-4ae8-8453-2fd978c8de93"], "operator": null, "metadata": {"aucs": [0.07842664485016426, 0.05190894642184629, 0.055943190732878456]}}
{"id": "b0630f14-8cb3-462f-ad50-6b16a47739da", "fitness": 0.06264410448099471, "name": "AdaptiveFeedbackSwarmOptimizer", "description": "Utilize swarm intelligence with adaptive learning rates based on performance feedback to enhance convergence efficiency.", "code": "import numpy as np\n\nclass AdaptiveFeedbackSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.7\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.feedback_weight = 0.5\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n\n                feedback_factor = 1 - np.exp(-self.feedback_weight * (global_best_value - personal_best_value[i]))\n                learning_rate = 1 + feedback_factor * (1 - fitness_value / global_best_value)\n                swarm_velocity[i] = inertia + learning_rate * (cognitive_component + social_component)\n\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 56, "feedback": "The algorithm AdaptiveFeedbackSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06264 with standard deviation 0.00295.", "error": "", "parent_ids": ["d16e314a-50fb-4ae8-8453-2fd978c8de93"], "operator": null, "metadata": {"aucs": [0.06679209641713069, 0.06022086969707763, 0.0609193473287758]}}
{"id": "810e8332-10ca-4000-b437-2caf6746beaa", "fitness": 0.08644119911926913, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Integrate adaptive learning rates and enhanced exploitation strategies for improved convergence.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.8  # Reduced initial inertia for better exploration\n        self.inertia_damping = 0.99  # Slightly increased damping for gradual reduction\n        self.cognitive_weight = 1.7  # Enhanced cognitive coefficient\n        self.social_weight = 1.3  # Reduced social influence for diverse explorations\n        self.local_convergence_weight = 0.5  # Reduce local convergence to avoid premature convergence\n        self.initial_mutation_rate = 0.15  # Increase initial mutation for better diversity\n        self.final_mutation_rate = 0.02  # Slightly increase final mutation for sustained exploration\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 57, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08644 with standard deviation 0.00064.", "error": "", "parent_ids": ["d16e314a-50fb-4ae8-8453-2fd978c8de93"], "operator": null, "metadata": {"aucs": [0.08561332353095064, 0.08653753206119685, 0.08717274176565992]}}
{"id": "77cdae4a-a99e-473b-ac98-f48458e1d17c", "fitness": 0.08051971416701838, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Refine swarm dynamics by incorporating adaptive exploration-exploitation balance and entropy-influenced neighborhood interactions.  ", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.exploration_exploitation_balance = 0.5  # New parameter\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n            exploration_factor = 1 - np.exp(-5 * t / self.budget)  # New exploration factor\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                adaptive_component = exploration_factor * np.random.rand(self.dim) * (global_best_position - swarm_position[i])  # New adaptive component\n\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence + adaptive_component\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08052 with standard deviation 0.00105.", "error": "", "parent_ids": ["d16e314a-50fb-4ae8-8453-2fd978c8de93"], "operator": null, "metadata": {"aucs": [0.07947552672124014, 0.08013430666068966, 0.08194930911912535]}}
{"id": "e13508c2-fafa-44d6-81c6-2975c2b5cb0d", "fitness": 0.0690022583655124, "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce adaptive learning rate and multi-swarm interaction to enhance global exploration and local exploitation.", "code": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.learning_rate = 0.5\n        self.num_swarms = 3\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarms = []\n        for _ in range(self.num_swarms):\n            swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n            swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            personal_best_position = np.copy(swarm_position)\n            personal_best_value = np.array([float('inf')] * self.population_size)\n            global_best_value = float('inf')\n            global_best_position = np.zeros(self.dim)\n            swarms.append([swarm_position, swarm_velocity, personal_best_position, personal_best_value, global_best_value, global_best_position])\n        \n        global_best_value_global = float('inf')\n        global_best_position_global = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean([np.std(swarm[0], axis=0) / (ub - lb) for swarm in swarms])\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for swarm_index, swarm in enumerate(swarms):\n                swarm_position, swarm_velocity, personal_best_position, personal_best_value, global_best_value, global_best_position = swarm\n\n                for i in range(self.population_size):\n                    fitness_value = func(swarm_position[i])\n                    if fitness_value < personal_best_value[i]:\n                        personal_best_value[i] = fitness_value\n                        personal_best_position[i] = swarm_position[i]\n                    if fitness_value < global_best_value:\n                        global_best_value = fitness_value\n                        global_best_position = swarm_position[i]\n                    if fitness_value < global_best_value_global:\n                        global_best_value_global = fitness_value\n                        global_best_position_global = swarm_position[i]\n\n                neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n                for i in range(self.population_size):\n                    neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                    local_best_value = float('inf')\n                    local_best_position = np.zeros(self.dim)\n                    for neighbor in neighbors:\n                        if personal_best_value[neighbor] < local_best_value:\n                            local_best_value = personal_best_value[neighbor]\n                            local_best_position = personal_best_position[neighbor]\n\n                    inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget)) * swarm_velocity[i]\n                    cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                    social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                    cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                    social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                    local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                    swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                    swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                    swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                    personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position_global - personal_best_position[i])\n\n                self.inertia_weight *= self.inertia_damping\n                swarm[4], swarm[5] = global_best_value, global_best_position\n\n        return global_best_position_global, global_best_value_global", "configspace": "", "generation": 59, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06900 with standard deviation 0.00384.", "error": "", "parent_ids": ["d16e314a-50fb-4ae8-8453-2fd978c8de93"], "operator": null, "metadata": {"aucs": [0.07305275080025553, 0.06384321344758548, 0.07011081084869619]}}
{"id": "2127e2c6-4986-4ed2-8cbf-3a0f0a51aea7", "fitness": 0.08731098567982361, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Incorporate a non-linear decay factor to enhance convergence speed by adjusting inertia weight dynamically.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 60, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08731 with standard deviation 0.00315.", "error": "", "parent_ids": ["d16e314a-50fb-4ae8-8453-2fd978c8de93"], "operator": null, "metadata": {"aucs": [0.0834140235224976, 0.09111640079344374, 0.08740253272352949]}}
{"id": "dd700f6c-bbb4-42cd-a931-4e203926bdf4", "fitness": 0.0875566781055479, "name": "DynamicNeighborhoodSwarmOptimizer", "description": "Introduce a dynamic adjustment factor for the social_weight to enhance adaptability based on population diversity.", "code": "import numpy as np\n\nclass DynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            entropy = np.mean(np.std(swarm_position, axis=0) / (ub - lb))\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + entropy * 0.5)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 61, "feedback": "The algorithm DynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08756 with standard deviation 0.00318.", "error": "", "parent_ids": ["2127e2c6-4986-4ed2-8cbf-3a0f0a51aea7"], "operator": null, "metadata": {"aucs": [0.08344599338869696, 0.09120207202389552, 0.08802196890405123]}}
{"id": "72529f51-681a-4ec9-99b9-14c9dde423e4", "fitness": 0.08755942076911323, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce diversity-enhanced momentum and adaptive neighborhood convergence to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08756 with standard deviation 0.00319.", "error": "", "parent_ids": ["dd700f6c-bbb4-42cd-a931-4e203926bdf4"], "operator": null, "metadata": {"aucs": [0.08344266373994624, 0.09122402645431127, 0.08801157211308219]}}
{"id": "60d190c3-e074-4815-a0f0-522bf3e4f80d", "fitness": 0.08532586305385814, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Enhance exploration by introducing a dynamic inertia weight that increases at mid-iterations to avoid premature convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                # Adjusted inertia calculation to enhance exploration.\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - abs((0.5 - t / self.budget)) * 2)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08533 with standard deviation 0.00121.", "error": "", "parent_ids": ["72529f51-681a-4ec9-99b9-14c9dde423e4"], "operator": null, "metadata": {"aucs": [0.08627871248705177, 0.08362402979984107, 0.08607484687468159]}}
{"id": "741fd816-b02d-4137-8efc-29b03a9113d6", "fitness": 0.0840973203327104, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Integrate non-linear adaptive inertia to enhance swarm adaptability over time.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = self.inertia_weight * (0.5 + 0.5 * np.tanh((t / self.budget) - 0.5)) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08410 with standard deviation 0.00277.", "error": "", "parent_ids": ["72529f51-681a-4ec9-99b9-14c9dde423e4"], "operator": null, "metadata": {"aucs": [0.08520398414612051, 0.08029580935472969, 0.08679216749728103]}}
{"id": "56c1eee5-9514-4cd9-8625-421592bc30d9", "fitness": 0.08714815080870757, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce velocity clamping to prevent excessive exploration and improve convergence stability.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                # Velocity clamping\n                max_velocity = (ub - lb) * 0.1\n                swarm_velocity[i] = np.clip(swarm_velocity[i], -max_velocity, max_velocity)\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08715 with standard deviation 0.00120.", "error": "", "parent_ids": ["72529f51-681a-4ec9-99b9-14c9dde423e4"], "operator": null, "metadata": {"aucs": [0.08688786839988627, 0.08873507273732684, 0.08582151128890958]}}
{"id": "d29c029c-6e53-476d-944b-8bfe4094d966", "fitness": 0.08215180166272318, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Enhance exploitation by introducing an adaptive social weight scaling with random perturbation based on current fitness.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight) * (1 + np.random.rand() * 0.1)  # Modified line\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08215 with standard deviation 0.00364.", "error": "", "parent_ids": ["72529f51-681a-4ec9-99b9-14c9dde423e4"], "operator": null, "metadata": {"aucs": [0.07794027974894069, 0.08169017014108515, 0.0868249550981437]}}
{"id": "0e635e7d-67ff-4e60-bea3-dd6906a449f7", "fitness": 0.06681188514964165, "name": "HybridLevyDynamicSwarmOptimizer", "description": "Implement a hybrid strategy combining a modified Lvy flight pattern with adaptive inertia and mutation to enhance exploration and convergence.", "code": "import numpy as np\n\nclass HybridLevyDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.99\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        def levy_flight(Lambda):\n            sigma1 = np.power((np.math.gamma(1 + Lambda) * np.sin(np.pi * Lambda / 2)) /\n                              (np.math.gamma((1 + Lambda) / 2) * Lambda * np.power(2, (Lambda - 1) / 2)), 1 / Lambda)\n            sigma2 = 1\n            u = np.random.normal(0, sigma1, size=self.dim)\n            v = np.random.normal(0, sigma2, size=self.dim)\n            step = u / np.power(np.abs(v), 1 / Lambda)\n            return step\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = self.inertia_weight * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                levy_step = levy_flight(1.5) * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n                \n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence + levy_step\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub) \n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 67, "feedback": "The algorithm HybridLevyDynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06681 with standard deviation 0.00551.", "error": "", "parent_ids": ["72529f51-681a-4ec9-99b9-14c9dde423e4"], "operator": null, "metadata": {"aucs": [0.06507071586115065, 0.06110502779330784, 0.07425991179446645]}}
{"id": "5514ed90-5356-4958-8965-6d5d01f87202", "fitness": 0.08667472590776219, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Enhance adaptive strategies and introduce local search intensification to improve convergence speed and accuracy.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.992  # Changed from 0.995\n        self.cognitive_weight = 1.7  # Changed from 1.5\n        self.social_weight = 1.7  # Changed from 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.4  # Changed from 0.3\n        self.initial_mutation_rate = 0.15  # Changed from 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.3  # Changed from 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.015 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])  # Changed from 0.01\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08667 with standard deviation 0.00161.", "error": "", "parent_ids": ["72529f51-681a-4ec9-99b9-14c9dde423e4"], "operator": null, "metadata": {"aucs": [0.0844378668875625, 0.08813602919858288, 0.08745028163714119]}}
{"id": "d1b237ef-d877-4c0e-83c3-dbd07f4fe7c4", "fitness": 0.08755942076911323, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a dynamic cognitive weight adjustment based on iteration progress to enhance local search adaptability.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08756 with standard deviation 0.00319.", "error": "", "parent_ids": ["72529f51-681a-4ec9-99b9-14c9dde423e4"], "operator": null, "metadata": {"aucs": [0.08344266373994624, 0.09122402645431127, 0.08801157211308219]}}
{"id": "49c961f4-fbde-48bb-85b1-914e589ea68f", "fitness": 0.08782979205133778, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce adaptive inertia damping to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)  # Changed line to introduce adaptive inertia damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08783 with standard deviation 0.00292.", "error": "", "parent_ids": ["72529f51-681a-4ec9-99b9-14c9dde423e4"], "operator": null, "metadata": {"aucs": [0.08401324112425035, 0.09111852996401093, 0.08835760506575208]}}
{"id": "73b0456c-c663-4e18-a166-c69cefef269a", "fitness": 0.08300593957290248, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a time-varying cognitive weight for improved exploration adaptability.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - t / self.budget)  # Updated line\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08301 with standard deviation 0.00167.", "error": "", "parent_ids": ["49c961f4-fbde-48bb-85b1-914e589ea68f"], "operator": null, "metadata": {"aucs": [0.08065838397066838, 0.08442366479228225, 0.0839357699557568]}}
{"id": "c2a340fa-9718-43fb-a8b7-4c355158391d", "fitness": 0.08728623928840729, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a dynamic cognitive weight adjustment based on fitness improvement rate for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                cognitive_weight += 0.1 * (global_best_value / (fitness_value + 1e-9))  # Changed line to introduce dynamic cognitive weight adjustment\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget) \n\n        return global_best_position, global_best_value", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08729 with standard deviation 0.00218.", "error": "", "parent_ids": ["49c961f4-fbde-48bb-85b1-914e589ea68f"], "operator": null, "metadata": {"aucs": [0.08435105885748972, 0.08957967944951972, 0.08792797955821241]}}
{"id": "d2f7d12e-53ca-4175-b4cb-11257be7a485", "fitness": -Infinity, "name": "MemoryEnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Incorporate a dynamic memory pool to enhance local search and adaptively adjust weights based on convergence speed.", "code": "import numpy as np\n\nclass MemoryEnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.memory_pool_size = 10\n        self.memory_pool = []\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            # Update memory pool with local bests\n            self.memory_pool.extend(personal_best_position)\n            self.memory_pool = sorted(self.memory_pool, key=lambda x: func(x))[:self.memory_pool_size]\n            \n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                \n                if self.memory_pool:\n                    memory_contribution = np.random.choice(self.memory_pool)\n                    memory_component = 0.1 * np.random.rand(self.dim) * (memory_contribution - swarm_position[i])\n                else:\n                    memory_component = 0\n                \n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence + memory_component\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n        \n        return global_best_position, global_best_value", "configspace": "", "generation": 73, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_ids": ["49c961f4-fbde-48bb-85b1-914e589ea68f"], "operator": null, "metadata": {}}
{"id": "45701049-898a-4e62-9d23-50fde297e7c6", "fitness": 0.07339714173948368, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a dynamic learning factor and enhanced neighborhood influence to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.learning_factor = 0.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.full(self.population_size, float('inf'))\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = self.inertia_weight * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value / global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value / global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = self.local_convergence_weight * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                dynamic_learning = self.learning_factor * (global_best_position - swarm_position[i])\n\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence + dynamic_learning\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07340 with standard deviation 0.00912.", "error": "", "parent_ids": ["49c961f4-fbde-48bb-85b1-914e589ea68f"], "operator": null, "metadata": {"aucs": [0.06196847308003972, 0.0842948122166075, 0.0739281399218038]}}
{"id": "051bc0e6-d7dd-4a65-9a4a-9a433b6c9c8f", "fitness": 0.08787829765248656, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Enhance adaptive mutation rate based on fitness diversity to improve exploration early on.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2  # Changed line\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08788 with standard deviation 0.00287.", "error": "", "parent_ids": ["49c961f4-fbde-48bb-85b1-914e589ea68f"], "operator": null, "metadata": {"aucs": [0.08413919064052588, 0.09113075375134938, 0.08836494856558441]}}
{"id": "ac63532b-ebc9-4248-80d8-a852e81c9699", "fitness": 0.08785363868016427, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Update inertia weight adaptation formula to balance exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.6 + (self.inertia_weight - 0.6) * (1 - t / self.budget) ** 2) * swarm_velocity[i]  # Changed line\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08785 with standard deviation 0.00301.", "error": "", "parent_ids": ["051bc0e6-d7dd-4a65-9a4a-9a433b6c9c8f"], "operator": null, "metadata": {"aucs": [0.08396030187068249, 0.09129524612328044, 0.08830536804652989]}}
{"id": "68dd7df9-7a4d-4a2d-8711-a8934523bbd8", "fitness": 0.0866144091212508, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a diversity-based adjustment factor to the social component to enhance exploration in diverse regions.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight) * (0.5 + 0.5 * diversity)  # Changed line\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08661 with standard deviation 0.00246.", "error": "", "parent_ids": ["051bc0e6-d7dd-4a65-9a4a-9a433b6c9c8f"], "operator": null, "metadata": {"aucs": [0.08317675330640273, 0.08882686155406272, 0.08783961250328698]}}
{"id": "ffac3c58-21d7-4da0-9871-b054334a7e57", "fitness": 0.04480820520814518, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce adaptive learning rates based on particle improvement speed to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        improvement_speed = np.zeros(self.population_size)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    improvement_speed[i] = (personal_best_value[i] - fitness_value) / (1 + np.abs(personal_best_value[i]))\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                adaptive_cognitive_weight = self.cognitive_weight * (1 + improvement_speed[i])\n                adaptive_social_weight = self.social_weight * (1 + improvement_speed[i] * diversity)\n\n                cognitive_component = adaptive_cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = adaptive_social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04481 with standard deviation 0.00178.", "error": "", "parent_ids": ["051bc0e6-d7dd-4a65-9a4a-9a433b6c9c8f"], "operator": null, "metadata": {"aucs": [0.04565905788618552, 0.04233577183476955, 0.04642978590348046]}}
{"id": "66146c74-a82e-4520-a978-dd277d4b2571", "fitness": 0.0855498637176599, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a dynamic inertia weight strategy based on the current diversity and budget to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n            \n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * diversity) * swarm_velocity[i]  # Changed line\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget) * diversity  # Changed line\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08555 with standard deviation 0.00134.", "error": "", "parent_ids": ["051bc0e6-d7dd-4a65-9a4a-9a433b6c9c8f"], "operator": null, "metadata": {"aucs": [0.08564227191473772, 0.08386180829762313, 0.08714551094061884]}}
{"id": "63212e20-1d92-4a08-a0a6-c5a3772b6c0f", "fitness": 0.08511155644799621, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce dynamic inertia damping based on diversity to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - t / self.budget + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2 * diversity) * swarm_velocity[i]  # Changed line\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08511 with standard deviation 0.00019.", "error": "", "parent_ids": ["051bc0e6-d7dd-4a65-9a4a-9a433b6c9c8f"], "operator": null, "metadata": {"aucs": [0.08522874270490677, 0.08483793587130406, 0.0852679907677778]}}
{"id": "0fb9dfa1-293c-4175-b5b6-0619d74b9d54", "fitness": 0.08787842369420285, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Refine the adaptive mutation rate formula with a non-linear scaling factor for precision.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2  # Changed line\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08788 with standard deviation 0.00288.", "error": "", "parent_ids": ["051bc0e6-d7dd-4a65-9a4a-9a433b6c9c8f"], "operator": null, "metadata": {"aucs": [0.08413912128497114, 0.09113113898702485, 0.08836501081061254]}}
{"id": "eddb86c7-9ab5-47f6-ae42-b16d72fed852", "fitness": 0.08412344698249867, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Improve the convergence by dynamically adjusting the local convergence weight based on diversity.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + diversity)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])  # Changed line\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08412 with standard deviation 0.00147.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08421679759902423, 0.08228171127998962, 0.08587183206848215]}}
{"id": "f60aa00c-3b90-41b7-95d6-c83dd4e28f5b", "fitness": 0.07636429134249512, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a dynamic adaptive inertia weight that leverages the population's fitness variance to enhance convergence and exploration balance.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            fitness_values = np.array([func(pos) for pos in swarm_position])\n            fitness_variance = np.var(fitness_values)\n            adaptive_inertia_weight = self.inertia_weight * (1 - fitness_variance) + 0.4 * fitness_variance\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                if fitness_values[i] < personal_best_value[i]:\n                    personal_best_value[i] = fitness_values[i]\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_values[i] < global_best_value:\n                    global_best_value = fitness_values[i]\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = adaptive_inertia_weight * swarm_velocity[i]\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = self.local_convergence_weight * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07636 with standard deviation 0.00662.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.06729735688656346, 0.08292957869103157, 0.07886593844989032]}}
{"id": "ca1e8924-3094-497a-8e25-b5d4fd544d60", "fitness": 0.07582818011004044, "name": "ImprovedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a dynamic inertia weight adaptation that balances exploration and exploitation based on convergence progress and swarm diversity.", "code": "import numpy as np\n\nclass ImprovedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.2 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.3\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia_weight = self.inertia_weight * (1 - t / self.budget) ** 0.5 * (1 + diversity)\n                cognitive_component = self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = self.social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = self.local_convergence_weight * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia_weight * swarm_velocity[i] + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 84, "feedback": "The algorithm ImprovedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07583 with standard deviation 0.00836.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.06501278781223041, 0.0853602139348223, 0.07711153858306863]}}
{"id": "dccd48d3-1b0c-44ae-aab8-1fc7ba8a789e", "fitness": 0.08787842369420285, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce an adaptive neighborhood size that dynamically contracts based on fitness improvement rate to enhance convergence precision.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n        fitness_improvement_rate = 0.0\n\n        for t in range(self.budget):\n            previous_best_value = global_best_value\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            fitness_improvement_rate = max(0.01, (previous_best_value - global_best_value) / (previous_best_value + 1e-10))\n            neighborhood_size = max(2, int(self.population_size * (1 - fitness_improvement_rate * t / self.budget)))\n\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08788 with standard deviation 0.00288.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08413912128497114, 0.09113113898702485, 0.08836501081061254]}}
{"id": "eb3817f9-e430-49f1-8e67-5ff28ed04ef2", "fitness": 0.07131369661254532, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Incorporate a dynamically adjusted leader strategy to enhance exploration during early iterations and exploit the best solutions during later stages.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            dynamic_leader_weight = 1 - t / (self.budget + 1)\n            \n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value / global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value / global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                dynamic_leader_component = dynamic_leader_weight * np.random.rand(self.dim) * (global_best_position - swarm_position[i])\n\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                \n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence + dynamic_leader_component\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07131 with standard deviation 0.00060.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.0711416583286657, 0.07067744100678441, 0.07212199050218582]}}
{"id": "b802ae7b-f0a2-4472-bf9c-094f88f7cca0", "fitness": 0.08786692171167061, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Adjusted inertia weight damping to enhance convergence stability.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.997  # Changed line\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08787 with standard deviation 0.00294.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.0840432348435759, 0.0912068568619856, 0.08835067342945035]}}
{"id": "09aa6368-2070-4960-a52e-2168ac42041c", "fitness": 0.08787836414060061, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Tweak the adaptive mutation rate formula with a refined non-linear scaling factor for improved precision.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.05 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.25  # Changed line\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08788 with standard deviation 0.00288.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08413915245626835, 0.09113095906672486, 0.08836498089880862]}}
{"id": "c53e879f-3ab0-40f5-a7d5-5a1322170d5b", "fitness": -Infinity, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Integrate a dynamic exploration-exploitation balance control by adjusting the inertia and social weights based on convergence rate estimates.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.convergence_history = []\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            mean_fitness = np.mean([func(pos) for pos in swarm_position])\n            self.convergence_history.append(mean_fitness)\n            if len(self.convergence_history) > 5:\n                recent_convergence_rate = np.mean(np.diff(self.convergence_history[-5:]))\n                inertia_adjustment = min(1.0, max(0.5, 1.0 - recent_convergence_rate))\n                social_adjustment = min(2.0, max(1.0, 1.0 + recent_convergence_rate))\n            else:\n                inertia_adjustment = 1.0\n                social_adjustment = 1.0\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = inertia_adjustment * (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = social_weight * social_adjustment * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 89, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'social_weight' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'social_weight' referenced before assignment\")", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {}}
{"id": "1a0e17b7-886f-40bc-98e9-4bc23d635c8f", "fitness": 0.08714133084072435, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Improve local convergence and adaptive mutation by refining the cognitive and diversity weights.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.7  # Changed line\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.4  # Changed line\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.2 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.3  # Changed line\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08714 with standard deviation 0.00167.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08480715228333169, 0.08865699845074348, 0.0879598417880979]}}
{"id": "d51a8905-669b-4088-8833-4730eaed0508", "fitness": 0.08774067909468641, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a time-dependent scaling factor in the velocity update formula for enhanced convergence control.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                time_dependent_scaling = (1 - t / self.budget)  # Changed line\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i] * time_dependent_scaling, lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08774 with standard deviation 0.00278.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08426474724798705, 0.09108204173472079, 0.0878752483013514]}}
{"id": "cea76e01-5a7f-4e7e-9620-f16093731310", "fitness": 0.08787797255673957, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a mutation decay function that gradually reduces the mutation rate over iterations to enhance convergence stability.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n            \n            # Changed line\n            adaptive_mutation_rate *= (1 - t / self.budget)  # Mutation decay function\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08788 with standard deviation 0.00287.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08413926686816109, 0.09112986434439674, 0.08836478645766088]}}
{"id": "7205edf5-7007-4ab6-87bd-02d7d2ea6a51", "fitness": 0.08702369396742819, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Integrate a dynamic feedback loop to adjust weights based on convergence rate for enhanced precision and adaptability.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.feedback_scaling = 0.5\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n        prev_global_best_value = float('inf')\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            converg_rate = (prev_global_best_value - global_best_value) / abs(prev_global_best_value)\n            feedback_factor = max(0, self.feedback_scaling * converg_rate)\n            adaptive_mutation_rate = (self.initial_mutation_rate * \n                                      (1 - (t / self.budget) ** 1.1 + diversity) + \n                                      self.final_mutation_rate * (t / self.budget) ** 1.2)\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    prev_global_best_value = global_best_value\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = (self.cognitive_weight + feedback_factor) * np.random.rand() * (1 - (1 - fitness_value / global_best_value) * t / self.budget)\n                social_weight = (self.social_weight + feedback_factor) * ((1 + (fitness_value / global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n            \n        return global_best_position, global_best_value", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08702 with standard deviation 0.00204.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08424341557104553, 0.08907944270966195, 0.08774822362157708]}}
{"id": "93e96bad-6d5e-4fd3-a625-b3f7b5c60ef0", "fitness": 0.08743740974963517, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a hybrid strategy by integrating adaptive learning rates and velocity clamping for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n        self.learning_rate_schedule = lambda t: 0.5 + 0.5 * np.cos(t / self.budget * np.pi)  # New line\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            learning_rate = self.learning_rate_schedule(t)  # New line\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n\n                # Velocity clamping to improve stability\n                max_velocity = (ub - lb) * 0.1\n                swarm_velocity[i] = np.clip(swarm_velocity[i], -max_velocity, max_velocity)  # New line\n\n                swarm_position[i] = np.clip(swarm_position[i] + learning_rate * swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08744 with standard deviation 0.00110.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08742440562897091, 0.0887950080384744, 0.0860928155814602]}}
{"id": "5c61040a-5590-439d-b504-43eedd8a2d95", "fitness": 0.07998113307046706, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a dynamic scaling factor to the local convergence to enhance balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget) * diversity) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])  # Changed line\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07998 with standard deviation 0.00088.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08122124502748951, 0.07944094954183811, 0.07928120464207356]}}
{"id": "aa24f248-b446-4644-b133-d281ee637e3e", "fitness": 0.07457160854071292, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Integrate a dynamic inertia weight adjustment to enhance convergence speed and stability, while leveraging a nonlinear velocity update for improved exploration.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = self.inertia_weight * swarm_velocity[i]\n                cognitive_component = (self.cognitive_weight * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i]))\n                social_component = (self.social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i]))\n                local_convergence = (self.local_convergence_weight * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i]))\n                nonlinear_factor = 1 + (fitness_value / global_best_value) * (t / self.budget)\n                swarm_velocity[i] = (inertia + cognitive_component + social_component + local_convergence) * nonlinear_factor\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - (t / self.budget) ** 2)  # Dynamic adjustment for inertia weight\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07457 with standard deviation 0.00652.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.0662375645105816, 0.08216511005379179, 0.07531215105776534]}}
{"id": "16433a89-0f56-4837-9567-25d9bd8778a5", "fitness": 0.08787842369420285, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce a refined weight scaling factor to further enhance convergence precision with minimal code alteration.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = (0.4 + (self.inertia_weight - 0.4) * (1 - t / self.budget) ** 2) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08788 with standard deviation 0.00288.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08413912128497114, 0.09113113898702485, 0.08836501081061254]}}
{"id": "44811494-50c4-4d46-b080-e4587603612f", "fitness": 0.08788494412097958, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Integrate a non-linear decaying inertia strategy with adaptive neighborhood influence to enhance convergence speed and precision.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = self.inertia_weight * np.exp(-t/self.budget) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * np.random.rand() * (1 - (1 - fitness_value/global_best_value) * t / self.budget)\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08788 with standard deviation 0.00290.", "error": "", "parent_ids": ["0fb9dfa1-293c-4175-b5b6-0619d74b9d54"], "operator": null, "metadata": {"aucs": [0.08411699068313627, 0.09117059352702273, 0.08836724815277974]}}
{"id": "2de1e0d7-6e7a-4149-95ac-33a78726ab59", "fitness": 0.08764367539622668, "name": "EnhancedDynamicNeighborhoodSwarmOptimizer", "description": "Introduce adaptive cognitive weight decay to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicNeighborhoodSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.9\n        self.inertia_damping = 0.995\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.local_convergence_weight = 0.6\n        self.diversity_weight = 0.3\n        self.initial_mutation_rate = 0.1\n        self.final_mutation_rate = 0.01\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_value = np.array([float('inf')] * self.population_size)\n        global_best_value = float('inf')\n        global_best_position = np.zeros(self.dim)\n\n        for t in range(self.budget):\n            diversity = np.linalg.norm(np.std(swarm_position, axis=0)) / np.linalg.norm(ub - lb)\n            adaptive_mutation_rate = self.initial_mutation_rate * (1 - (t / self.budget) ** 1.1 + diversity) + self.final_mutation_rate * (t / self.budget) ** 1.2\n\n            for i in range(self.population_size):\n                fitness_value = func(swarm_position[i])\n                if fitness_value < personal_best_value[i]:\n                    personal_best_value[i] = fitness_value\n                    personal_best_position[i] = swarm_position[i]\n                if fitness_value < global_best_value:\n                    global_best_value = fitness_value\n                    global_best_position = swarm_position[i]\n\n            neighborhood_size = max(2, int(self.population_size * (1 - t / self.budget)))\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_value = float('inf')\n                local_best_position = np.zeros(self.dim)\n                for neighbor in neighbors:\n                    if personal_best_value[neighbor] < local_best_value:\n                        local_best_value = personal_best_value[neighbor]\n                        local_best_position = personal_best_position[neighbor]\n\n                inertia = self.inertia_weight * np.exp(-t/self.budget) * swarm_velocity[i]\n                cognitive_weight = self.cognitive_weight * (1 - (t / self.budget)) * np.random.rand() # Changed line\n                social_weight = self.social_weight * ((1 + (fitness_value/global_best_value)) * t / self.budget) * (1 + diversity * self.diversity_weight)\n                cognitive_component = (cognitive_weight + 0.5 * (1 - fitness_value / global_best_value)) * np.random.rand(self.dim) * (personal_best_position[i] - swarm_position[i])\n                social_component = social_weight * np.random.rand(self.dim) * (local_best_position - swarm_position[i])\n                local_convergence = (self.local_convergence_weight * (1 + t / self.budget)) * np.random.rand(self.dim) * (np.mean(swarm_position, axis=0) - swarm_position[i])\n                swarm_velocity[i] = inertia + cognitive_component + social_component + local_convergence\n                swarm_position[i] = np.clip(swarm_position[i] + swarm_velocity[i], lb, ub)\n\n                swarm_position[i] += adaptive_mutation_rate * np.random.normal(0, 1, self.dim)\n                personal_best_position[i] += 0.01 * np.random.rand(self.dim) * (global_best_position - personal_best_position[i])\n\n            self.inertia_weight *= self.inertia_damping * (1 - t / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedDynamicNeighborhoodSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08764 with standard deviation 0.00334.", "error": "", "parent_ids": ["44811494-50c4-4d46-b080-e4587603612f"], "operator": null, "metadata": {"aucs": [0.0832874204601255, 0.09140149782256046, 0.08824210790599407]}}
