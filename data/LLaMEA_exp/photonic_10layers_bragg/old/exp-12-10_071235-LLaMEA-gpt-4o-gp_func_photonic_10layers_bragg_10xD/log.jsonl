{"id": "a817778d-aee7-4f5b-9363-0f277bd0f65c", "fitness": 0.05332496619269559, "name": "HybridPSOwithMutation", "description": "Hybrid Particle Swarm Optimization with Adaptive Mutation Enhancements for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOwithMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.mutation_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Ensure the population remains within bounds\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSOwithMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05332 with standard deviation 0.00449.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.05607620218654219, 0.0596615992380114, 0.05395386478781328, 0.05510813209885734, 0.05862077267795973, 0.0530278041232235, 0.0474215248505897, 0.05040891637700984, 0.04564587939425335]}}
{"id": "a8d5b048-0d81-404c-8b95-58aaff505eaf", "fitness": 0.05327743588859219, "name": "HybridPSOwithMutation", "description": "Enhanced turbulence scaling to improve exploration during optimization.", "code": "import numpy as np\n\nclass HybridPSOwithMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.mutation_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    turbulence_scale = np.random.rand()  # Change made here for enhanced exploration\n                    population[i] += mutation_vector * mutation_probability * turbulence_scale\n\n                # Ensure the population remains within bounds\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSOwithMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05328 with standard deviation 0.00450.", "error": "", "parent_ids": ["a817778d-aee7-4f5b-9363-0f277bd0f65c"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.0596615992380114, 0.05395386478781328, 0.054959381766184756, 0.05862077267795973, 0.0530278041232235, 0.04729420300234266, 0.05040891637700984, 0.04564587939425335]}}
{"id": "78c87840-ab06-4aeb-af2b-374ae7b1291d", "fitness": 0.05358152045068998, "name": "EnhancedHybridPSO", "description": "Enhanced Hybrid Particle Swarm Optimization (EHPSO) with Adaptive Mutation and Dynamic Parameter Adjustment for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.99)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.99)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)  # Gaussian mutation\n                    population[i] += mutation_vector * mutation_probability\n\n                # Ensure the population remains within bounds\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05358 with standard deviation 0.00418.", "error": "", "parent_ids": ["a817778d-aee7-4f5b-9363-0f277bd0f65c"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.05896322579020552, 0.05561660105500876, 0.054959381766184756, 0.05793713388932498, 0.05465921361883663, 0.04729420300234266, 0.04983082106319725, 0.04704860224057805]}}
{"id": "786d4883-db3c-4938-a027-1312e440ca84", "fitness": 0.05331725467604212, "name": "EnhancedHybridPSO", "description": "Enhanced Hybrid Particle Swarm Optimization (EHPSO) refined by introducing a slight adjustment to the inertia weight decay for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.995)  # Adjusted decay rate\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.99)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.99)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)  # Gaussian mutation\n                    population[i] += mutation_vector * mutation_probability\n\n                # Ensure the population remains within bounds\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05332 with standard deviation 0.00408.", "error": "", "parent_ids": ["78c87840-ab06-4aeb-af2b-374ae7b1291d"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.055451897327426614, 0.054959381766184756, 0.05727003653138041, 0.054497737092550014, 0.04729420300234266, 0.04926495037508172, 0.046910537110141926]}}
{"id": "a296fc94-97d9-4bd2-b491-81bc728b8751", "fitness": 0.05283589489343629, "name": "EnhancedHybridPSO", "description": "Enhance convergence by scaling the inertia weight with a sine function for dynamic exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = 0.5 + 0.4 * np.sin(0.1 * evaluations)  # small change here\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.99)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.99)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)  # Gaussian mutation\n                    population[i] += mutation_vector * mutation_probability\n\n                # Ensure the population remains within bounds\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05284 with standard deviation 0.00422.", "error": "", "parent_ids": ["78c87840-ab06-4aeb-af2b-374ae7b1291d"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05391868435832081, 0.054959381766184756, 0.05727003653138041, 0.05299325739784566, 0.04729420300234266, 0.04926495037508172, 0.04561599173049968]}}
{"id": "77b10300-4a29-4f15-81a9-d4a1127c1138", "fitness": 0.05283589489343629, "name": "QuantumEnhancedHybridPSO", "description": "Quantum-Inspired Enhanced Hybrid Particle Swarm Optimization (QEHPSO) leveraging Quantum Bit Encoding for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass QuantumEnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        # Initialize particles\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            # Quantum-inspired bit encoding\n            quantum_population = np.random.choice([0, 1], size=(self.population_size, self.dim))\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                # Quantum-inspired update\n                quantum_velocity = (self.inertia_weight * velocities[i]\n                                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                                    + self.social_coefficient * r2 * (global_best_position - population[i]))\n\n                probabilities = 1 / (1 + np.exp(-quantum_velocity))\n                quantum_population[i] = np.random.rand(self.dim) < probabilities\n\n                # Convert quantum bits to real values\n                new_position = self.lower_bound + (self.upper_bound - self.lower_bound) * quantum_population[i]\n                population[i] = new_position\n\n                # Ensure the population remains within bounds\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)  # Gaussian mutation\n                    population[i] += mutation_vector * mutation_probability\n\n        return global_best_position", "configspace": "", "generation": 5, "feedback": "The algorithm QuantumEnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05284 with standard deviation 0.00422.", "error": "", "parent_ids": ["78c87840-ab06-4aeb-af2b-374ae7b1291d"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05391868435832081, 0.054959381766184756, 0.05727003653138041, 0.05299325739784566, 0.04729420300234266, 0.04926495037508172, 0.04561599173049968]}}
{"id": "6e7d7035-7dc3-4b57-8f4f-6ff9a2330407", "fitness": -Infinity, "name": "AdvancedAdaptivePSO", "description": "Advanced Adaptive Particle Swarm Optimization (AAPSO) integrates Lévy flight for exploration and an entropy-based adaptive mutation to enhance convergence in diverse problem landscapes.", "code": "import numpy as np\n\nclass AdvancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.entropy_threshold = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=size)\n        v = np.random.normal(0, 1, size=size)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            # Calculate population entropy for adaptive mutation\n            mean_position = np.mean(population, axis=0)\n            entropy = -np.sum((population - mean_position)**2) / self.population_size\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adjust mutation probability based on entropy\n                if entropy < self.entropy_threshold:\n                    levy_step = self.levy_flight(self.dim)\n                    population[i] += levy_step\n\n                # Ensure the population remains within bounds\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 6, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["78c87840-ab06-4aeb-af2b-374ae7b1291d"], "operator": null, "metadata": {}}
{"id": "f2218f2a-de39-4267-b2ca-d2e087f5bef6", "fitness": 0.05307530035732509, "name": "AdvancedAdaptivePSO", "description": "Advanced Adaptive Particle Swarm Optimization (AAPSO) with Non-linear Inertia Weight Decay and Self-adaptive Lévy Flight Mutation for enhanced global and local search balance.", "code": "import numpy as np\n\nclass AdvancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Non-linear decay of inertia weight\n                self.inertia_weight = 0.4 + 0.5 * np.exp(-0.01 * evaluations)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Self-adaptive Lévy flight mutation\n                mutation_probability = self.mutation_coefficient * (np.linalg.norm(population[i] - global_best_position) / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    levy_flight = np.random.normal(0, 1, self.dim) / np.power(np.abs(np.random.normal(0, 1)), 1.0 / 1.5)\n                    population[i] += levy_flight * mutation_probability\n\n                # Ensure the population remains within bounds\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 7, "feedback": "The algorithm AdvancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05308 with standard deviation 0.00424.", "error": "", "parent_ids": ["78c87840-ab06-4aeb-af2b-374ae7b1291d"], "operator": null, "metadata": {"aucs": [0.056693961836006945, 0.058282047248739755, 0.05391868435832081, 0.05571196424989533, 0.05727003653138041, 0.05299325739784566, 0.04792680948815553, 0.04926495037508172, 0.04561599173049968]}}
{"id": "83cc605a-45c3-4e08-981d-cdfc33028dea", "fitness": 0.05311248163789901, "name": "QuantumInspiredEnhancedPSO", "description": "Quantum-Inspired Enhanced Hybrid PSO with Adaptive Mutation and Dynamic Parameter Adjustment for improved convergence.", "code": "import numpy as np\n\nclass QuantumInspiredEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n\n                # Dynamic parameter adjustment\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.97)\n                self.cognitive_coefficient = max(1.0, self.cognitive_coefficient * 0.97)\n                self.social_coefficient = max(1.0, self.social_coefficient * 0.97)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Quantum-inspired mutation\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.uniform(-1, 1, self.dim)  # Uniform mutation\n                    population[i] += mutation_vector * mutation_probability\n\n                # Ensure the population remains within bounds\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 8, "feedback": "The algorithm QuantumInspiredEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05311 with standard deviation 0.00414.", "error": "", "parent_ids": ["78c87840-ab06-4aeb-af2b-374ae7b1291d"], "operator": null, "metadata": {"aucs": [0.05614029289702838, 0.058282047248739755, 0.05458365844615132, 0.055170967063150056, 0.05727003653138041, 0.05364600382832607, 0.04747525007588038, 0.04926495037508172, 0.046179128275352976]}}
{"id": "9b7c89b2-359e-4d8e-9b35-70460f2958dd", "fitness": 0.0548782039440194, "name": "QuantumInspiredHybridPSO", "description": "Quantum-Inspired Hybrid PSO (QI-HPSO) with Quantum Tunneling and Adaptive Parameter Tuning for Enhanced Convergence and Exploration.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 9, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05488 with standard deviation 0.00479.", "error": "", "parent_ids": ["78c87840-ab06-4aeb-af2b-374ae7b1291d"], "operator": null, "metadata": {"aucs": [0.056238250996370365, 0.06210690630864757, 0.05632309630823695, 0.055266972526497704, 0.06101031754740671, 0.05535232703784687, 0.047557130306050244, 0.05240472105744631, 0.04764411340767183]}}
{"id": "50dbab37-86db-475f-a670-6e49434b9921", "fitness": 0.0548782039440194, "name": "QuantumInspiredHybridPSO", "description": "Enhanced QI-HPSO with Adaptive Quantum Coefficient for Dynamic Exploration.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient\n\n                # Update quantum coefficient dynamically\n                self.quantum_coefficient = np.clip(self.quantum_coefficient * (1 + 0.01 * (global_best_score / (1 + fitness))), 0.05, 0.2)\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 10, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05488 with standard deviation 0.00479.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.056238250996370365, 0.06210690630864757, 0.05632309630823695, 0.055266972526497704, 0.06101031754740671, 0.05535232703784687, 0.047557130306050244, 0.05240472105744631, 0.04764411340767183]}}
{"id": "feb0bd41-bd51-44b3-bef8-76b64a275bc2", "fitness": 0.0548782039440194, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Swarm Resizing and Improved Quantum Tunneling for Robust Optimization Performance.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        dynamic_population_size = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(dynamic_population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            # Reduce population size dynamically for faster convergence\n            if evaluations % (self.budget // 10) == 0:\n                dynamic_population_size = max(10, dynamic_population_size - 5)\n\n            for i in range(dynamic_population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Improved Quantum tunneling with directional bias towards global best\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient * (1 + 0.1 * np.sign(global_best_position - population[i]))\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05488 with standard deviation 0.00479.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.056238250996370365, 0.06210690630864757, 0.05632309630823695, 0.055266972526497704, 0.06101031754740671, 0.05535232703784687, 0.047557130306050244, 0.05240472105744631, 0.04764411340767183]}}
{"id": "6eea479a-fee3-45db-a33b-e8c3e1f7ffe1", "fitness": 0.05311053311281474, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Swarm Resizing and Self-Adaptive Quantum Tunneling for Improved Convergence and Exploration.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Self-adaptive quantum tunneling\n                quantum_adapt = self.quantum_coefficient / (1 + evaluations/self.budget)\n                if np.random.rand() < quantum_adapt:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * quantum_adapt\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Dynamic swarm resizing for improved exploration-exploitation balance\n            if evaluations % (self.budget // 10) == 0:\n                cur_best_index = np.argmin(personal_best_scores)\n                new_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                new_population[0] = personal_best_positions[cur_best_index]\n                population = new_population\n\n        return global_best_position", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05311 with standard deviation 0.00422.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.05663353803846516, 0.058282047248739755, 0.05408648365747448, 0.055654313397167865, 0.05727003653138041, 0.053158006644806854, 0.0478870736643735, 0.04926495037508172, 0.04575834845784288]}}
{"id": "5ed7ce89-b420-4df9-9f45-e9f836447c97", "fitness": 0.0548782039440194, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Population Resizing and Stochastic Reseeding for Improved Convergence and Diversity Maintenance.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Dynamic population resizing\n            if evaluations % (self.budget // 10) == 0:\n                diversity_score = np.mean(np.var(population, axis=0))\n                if diversity_score < 0.1:\n                    new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (10, self.dim))\n                    population = np.vstack((population, new_individuals))\n                    velocities = np.vstack((velocities, np.random.uniform(-1, 1, (10, self.dim))))\n                    personal_best_positions = np.vstack((personal_best_positions, new_individuals))\n                    personal_best_scores = np.concatenate((personal_best_scores, np.full(10, np.inf)))\n                    self.population_size += 10\n\n            # Stochastic reseeding to maintain diversity\n            if evaluations % (self.budget // 5) == 0:\n                worst_indices = np.argsort(personal_best_scores)[-5:]\n                for idx in worst_indices:\n                    population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    velocities[idx] = np.random.uniform(-1, 1, self.dim)\n                    personal_best_scores[idx] = np.inf\n\n        return global_best_position", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05488 with standard deviation 0.00479.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.056238250996370365, 0.06210690630864757, 0.05632309630823695, 0.055266972526497704, 0.06101031754740671, 0.05535232703784687, 0.047557130306050244, 0.05240472105744631, 0.04764411340767183]}}
{"id": "6f7e510d-f229-49df-a599-14accb3a09ef", "fitness": 0.05356805978467358, "name": "QuantumInspiredHybridPSO", "description": "Quantum-Inspired Hybrid PSO with Adaptive Swarm Reconfiguration and Dynamic Quantum Crossover for Enhanced Exploration-Exploitation Balance.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic parameter tuning\n                self.inertia_weight = 0.4 + (0.5 * (1 - evaluations / self.budget))\n                self.cognitive_coefficient = 1.5 + (0.5 * (1 - evaluations / self.budget))\n                self.social_coefficient = 1.5 + (0.5 * (1 - evaluations / self.budget))\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / np.linalg.norm(self.upper_bound - self.lower_bound))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Dynamic quantum crossover\n                if np.random.rand() < self.quantum_coefficient:\n                    other = personal_best_positions[np.random.randint(self.population_size)]\n                    crossover_factor = np.random.rand(self.dim)\n                    population[i] = crossover_factor * population[i] + (1 - crossover_factor) * other\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 14, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05357 with standard deviation 0.00404.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.056092888626262716, 0.058282047248739755, 0.05608839087221451, 0.05512443045411031, 0.05727003653138041, 0.055120373386784216, 0.047435081926659683, 0.04926495037508172, 0.04743433864082891]}}
{"id": "0f3e6492-2746-4994-a4ee-a249ac199a64", "fitness": 0.05283589489343629, "name": "QuantumInspiredHybridPSO", "description": "Enhanced QI-HPSO with Dynamic Quantum Tunneling Coefficient (D-QTC) for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Dynamic Quantum Tunneling Coefficient\n                self.quantum_coefficient = 0.1 + 0.9 * (evaluations / self.budget)\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 15, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05284 with standard deviation 0.00422.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05391868435832081, 0.054959381766184756, 0.05727003653138041, 0.05299325739784566, 0.04729420300234266, 0.04926495037508172, 0.04561599173049968]}}
{"id": "9ab4c0ce-f08b-429d-9c39-5d91dfd02b89", "fitness": 0.05283589489343629, "name": "QuantumInspiredHybridPSO", "description": "Enhanced QI-HPSO with adaptive learning rate decay and stochastic rank-based selection for improved convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                # Stochastic rank-based selection for social learning\n                ranked_indices = np.argsort(personal_best_scores)\n                selected_peer = population[ranked_indices[np.random.randint(0, 5)]]\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (selected_peer - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 16, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05284 with standard deviation 0.00422.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05391868435832081, 0.054959381766184756, 0.05727003653138041, 0.05299325739784566, 0.04729420300234266, 0.04926495037508172, 0.04561599173049968]}}
{"id": "82e6d760-3d7c-4daa-80ec-36aec2eac887", "fitness": -Infinity, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Learning Rate, Multi-Swarm Strategy, and Dynamic Quantum Tunneling for Improved Exploration and Convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.global_learning_rate = 0.1\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n        self.num_swarms = 3\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        swarms = [np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim)) for _ in range(self.num_swarms)]\n        velocities = [np.random.uniform(-1, 1, (self.population_size, self.dim)) for _ in range(self.num_swarms)]\n        personal_best_positions = [np.copy(swarm) for swarm in swarms]\n        personal_best_scores = [np.full(self.population_size, np.inf) for _ in range(self.num_swarms)]\n        global_best_positions = [None] * self.num_swarms\n        global_best_scores = [np.inf] * self.num_swarms\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for s in range(self.num_swarms):\n                for i in range(self.population_size):\n                    fitness = func(swarms[s][i])\n                    evaluations += 1\n\n                    if fitness < personal_best_scores[s][i]:\n                        personal_best_scores[s][i] = fitness\n                        personal_best_positions[s][i] = swarms[s][i]\n\n                    if fitness < global_best_scores[s]:\n                        global_best_scores[s] = fitness\n                        global_best_positions[s] = swarms[s][i]\n\n                for i in range(self.population_size):\n                    r1 = np.random.rand(self.dim)\n                    r2 = np.random.rand(self.dim)\n\n                    # Dynamic adjustment of parameters\n                    self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                    self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                    self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                    velocities[s][i] = (\n                        self.inertia_weight * velocities[s][i]\n                        + self.cognitive_coefficient * r1 * (personal_best_positions[s][i] - swarms[s][i])\n                        + self.social_coefficient * r2 * (global_best_positions[s] - swarms[s][i])\n                    )\n\n                    swarms[s][i] += velocities[s][i] * self.global_learning_rate\n\n                    # Adaptive mutation based on distance to global best\n                    distance_to_best = np.linalg.norm(swarms[s][i] - global_best_positions[s])\n                    mutation_probability = self.mutation_coefficient * (distance_to_best / np.linalg.norm(self.upper_bound - self.lower_bound))\n                    \n                    if np.random.rand() < mutation_probability:\n                        mutation_vector = np.random.normal(0, 1, self.dim)\n                        swarms[s][i] += mutation_vector * mutation_probability\n\n                    # Dynamic Quantum tunneling with swarm interaction\n                    if np.random.rand() < self.quantum_coefficient:\n                        other_swarm = (s + np.random.randint(1, self.num_swarms)) % self.num_swarms\n                        quantum_tunnel = np.random.normal(0, 1, self.dim)\n                        swarms[s][i] = global_best_positions[other_swarm] + quantum_tunnel * self.quantum_coefficient\n\n                    swarms[s][i] = np.clip(swarms[s][i], self.lower_bound, self.upper_bound)\n\n        best_swarm_idx = np.argmin(global_best_scores)\n        return global_best_positions[best_swarm_idx]", "configspace": "", "generation": 17, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {}}
{"id": "273bbbc1-b87b-4d02-bb16-b9a8345bfc05", "fitness": 0.05283589489343629, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO (EQI-HPSO) with Adaptive Quantum Tunneling and Non-linear Inertia Reduction for improved global exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Non-linear reduction of inertia weight\n                self.inertia_weight = max(0.4, 0.9 * (1 - (evaluations / self.budget) ** 2))\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive Quantum tunneling for enhanced exploration\n                quantum_tunnel_probability = (global_best_score - personal_best_scores[i]) / (np.abs(global_best_score) + 1e-10)\n                if np.random.rand() < self.quantum_coefficient * quantum_tunnel_probability:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05284 with standard deviation 0.00422.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05391868435832081, 0.054959381766184756, 0.05727003653138041, 0.05299325739784566, 0.04729420300234266, 0.04926495037508172, 0.04561599173049968]}}
{"id": "e87cba89-bcff-4095-b712-83a1af4f5a29", "fitness": 0.05308860992741303, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO (EQI-HPSO) with Adaptive Inertia, Self-Learning, and Dynamic Population for Improved Convergence and Exploration.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Adaptive inertia weight\n                self.inertia_weight = max(0.4, 0.4 + 0.5 * (global_best_score - personal_best_scores[i]) / global_best_score)\n                \n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Self-learning mutation based on experience\n                if np.random.rand() < self.mutation_coefficient:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * (personal_best_scores[i] - global_best_score)\n\n                # Enhanced quantum tunneling\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Dynamic population adjustment\n            if evaluations % (self.budget // 10) == 0:\n                new_population_size = max(10, int(self.initial_population_size * (global_best_score / np.mean(personal_best_scores))))\n                if new_population_size != self.population_size:\n                    population = np.resize(population, (new_population_size, self.dim))\n                    velocities = np.resize(velocities, (new_population_size, self.dim))\n                    personal_best_positions = np.resize(personal_best_positions, (new_population_size, self.dim))\n                    personal_best_scores = np.resize(personal_best_scores, new_population_size)\n                    self.population_size = new_population_size\n\n        return global_best_position", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05309 with standard deviation 0.00425.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.05673298802167792, 0.058282047248739755, 0.05391868435832081, 0.05575147419940707, 0.05727003653138041, 0.05299325739784566, 0.04796805948376426, 0.04926495037508172, 0.04561599173049968]}}
{"id": "46423c75-69f1-43b3-9ff9-759f61f87793", "fitness": 0.05284583556500887, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO (EQI-HPSO) with Adaptive Quantum Tunneling, Dynamic Neighborhood, and Nonlinear Inertia Weight for Improved Global Exploration and Local Exploitation.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Nonlinear inertia weight reduction over iterations\n                current_inertia_weight = self.initial_inertia_weight - (\n                    (self.initial_inertia_weight - self.final_inertia_weight) * (evaluations / self.budget)\n                )\n\n                velocities[i] = (\n                    current_inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on dynamic neighborhood\n                neighborhood_size = max(1, int(self.population_size * 0.1))\n                neighborhood_indices = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                neighborhood_best_position = min(neighborhood_indices, key=lambda idx: personal_best_scores[idx])\n\n                mutation_probability = self.mutation_coefficient * (\n                    np.linalg.norm(population[i] - personal_best_positions[neighborhood_best_position])\n                    / np.linalg.norm(self.upper_bound - self.lower_bound)\n                )\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                adaptive_quantum_coefficient = self.quantum_coefficient * (1 - evaluations / self.budget)\n                if np.random.rand() < adaptive_quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * adaptive_quantum_coefficient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05285 with standard deviation 0.00421.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.0539502849101986, 0.054959381766184756, 0.05727003653138041, 0.05302428724530872, 0.04729420300234266, 0.04926495037508172, 0.045642827375312]}}
{"id": "9dbacc77-092c-4dfb-a00b-d5b7be3b04c1", "fitness": 0.05503522336095371, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Quantum Coefficient Adjustment for Improved Exploration.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient * np.exp(-evaluations / self.budget)\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 21, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05504 with standard deviation 0.00474.", "error": "", "parent_ids": ["9b7c89b2-359e-4d8e-9b35-70460f2958dd"], "operator": null, "metadata": {"aucs": [0.05674083919351336, 0.06210690630864757, 0.05632309630823695, 0.05575928146969911, 0.06101031754740671, 0.05535232703784687, 0.04797540791811472, 0.05240472105744631, 0.04764411340767183]}}
{"id": "a884fe3a-bff4-4e39-bb0b-47d3813eb459", "fitness": 0.05479719166048812, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Quantum Coefficient and Dynamic Population Size for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n                self.quantum_coefficient = 0.1 * np.exp(-evaluations / (0.5 * self.budget))\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n\n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Dynamic population size adjustment\n            if evaluations < self.budget // 2:\n                population_size = self.initial_population_size\n            else:\n                population_size = max(10, int(self.initial_population_size * (self.budget - evaluations) / self.budget))\n\n            # Resize arrays if population size changes\n            if len(population) != population_size:\n                population = np.resize(population, (population_size, self.dim))\n                velocities = np.resize(velocities, (population_size, self.dim))\n                personal_best_positions = np.resize(personal_best_positions, (population_size, self.dim))\n                personal_best_scores = np.resize(personal_best_scores, population_size)\n\n        return global_best_position", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05480 with standard deviation 0.00481.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.05596077152819401, 0.06210690630864757, 0.05634187907721855, 0.05499494829521823, 0.06101031754740671, 0.055370732145655244, 0.04732465834962796, 0.05240472105744631, 0.047659790634978494]}}
{"id": "d5fb5cbf-2969-445f-b369-9c77fcb694da", "fitness": 0.05359051769053388, "name": "EnhancedQuantumPSOWithGradientDescent", "description": "Enhanced Quantum-inspired PSO with Adaptive Parameter Tuning and Gradient Descent-based Local Search for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumPSOWithGradientDescent:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.gradient_step_size = 0.01\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient * np.exp(-evaluations / self.budget)\n\n                # Gradient descent-based local search\n                gradient = self.compute_gradient(func, population[i])\n                population[i] -= self.gradient_step_size * gradient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position\n\n    def compute_gradient(self, func, position):\n        epsilon = 1e-8\n        gradient = np.zeros(self.dim)\n        for j in range(self.dim):\n            perturb = np.zeros(self.dim)\n            perturb[j] = epsilon\n            gradient[j] = (func(position + perturb) - func(position - perturb)) / (2 * epsilon)\n        return gradient", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedQuantumPSOWithGradientDescent got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05359 with standard deviation 0.00404.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05632309698502325, 0.054959381766184756, 0.05727003653138041, 0.05535232770126852, 0.04729420300234266, 0.04926495037508172, 0.04764411397425261]}}
{"id": "fa3bb799-b5c4-4228-a01f-ce52cf5e77e4", "fitness": 0.05360488234722024, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Quantum Coefficient for Improved Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling coefficient\n                self.quantum_coefficient = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                \n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient * np.exp(-evaluations / self.budget)\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 24, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05360 with standard deviation 0.00405.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05637661053450771, 0.054959381766184756, 0.05727003653138041, 0.05540210457193184, 0.04729420300234266, 0.04926495037508172, 0.047670105464282075]}}
{"id": "039aec1d-f4d0-4928-a4b6-d126acbed69e", "fitness": 0.05479131776003294, "name": "QuantumInspiredHybridPSO", "description": "Introduced adaptive quantum tunneling coefficient and enhanced mutation strategy for dynamic exploration.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability * 0.5  # Enhanced mutation strategy\n\n                # Adaptive quantum tunneling\n                adaptive_quantum_coeff = self.quantum_coefficient * (1 - evaluations / self.budget)\n                if np.random.rand() < adaptive_quantum_coeff:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * adaptive_quantum_coeff\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 25, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05479 with standard deviation 0.00482.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.05596077152819401, 0.06210690630864757, 0.05632309630823695, 0.05499494829521823, 0.06101031754740671, 0.05535232703784687, 0.04732465834962796, 0.05240472105744631, 0.04764411340767183]}}
{"id": "bf7c48b7-04ae-499e-b65b-918bbf4046b6", "fitness": 0.05503522336095371, "name": "ImprovedQuantumInspiredHybridPSO", "description": "Improved Quantum-Inspired Hybrid PSO with Adaptive Learning Rates and Diversity Preservation to Enhance Convergence and Robustness.", "code": "import numpy as np\n\nclass ImprovedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        learning_rate = 0.1\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on learning rate\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability * learning_rate\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient * np.exp(-evaluations / self.budget)\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Adjust learning rate based on diversity\n            diversity = np.std(population)\n            learning_rate = min(0.2, max(0.01, 0.1 * (1 - evaluations / self.budget) + 0.1 * diversity / np.std(self.upper_bound - self.lower_bound)))\n\n        return global_best_position", "configspace": "", "generation": 26, "feedback": "The algorithm ImprovedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05504 with standard deviation 0.00474.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.05674083919351336, 0.06210690630864757, 0.05632309630823695, 0.05575928146969911, 0.06101031754740671, 0.05535232703784687, 0.04797540791811472, 0.05240472105744631, 0.04764411340767183]}}
{"id": "4d6958d3-13ee-4f41-b18b-9aa3facc04c0", "fitness": 0.053848134471799064, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Improved Velocity Update for Better Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                # Use a decay factor for the velocity update based on evaluations\n                decay_factor = 0.99 ** (evaluations / self.budget)\n                velocities[i] *= decay_factor\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient * np.exp(-evaluations / self.budget)\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 27, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05385 with standard deviation 0.00403.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.05684047029245687, 0.058282047248739755, 0.05623200558758401, 0.05585666352114782, 0.05727003653138041, 0.055262947791531736, 0.04805685534961257, 0.04926495037508172, 0.04756723354865666]}}
{"id": "e9fbf4bf-e19a-40a2-bd18-e0bd36ec4fc6", "fitness": 0.05479131776003294, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Quantum Tunneling for Further Exploration.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                # Change: Make quantum tunneling strength adaptive based on the number of evaluations\n                adaptive_quantum_coefficient = self.quantum_coefficient * (1 - evaluations / self.budget)\n                if np.random.rand() < adaptive_quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * adaptive_quantum_coefficient * np.exp(-evaluations / self.budget)\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 28, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05479 with standard deviation 0.00482.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.05596077152819401, 0.06210690630864757, 0.05632309630823695, 0.05499494829521823, 0.06101031754740671, 0.05535232703784687, 0.04732465834962796, 0.05240472105744631, 0.04764411340767183]}}
{"id": "0e39b0a0-00ea-4536-a9b3-59f3315dcba9", "fitness": 0.05288774355569556, "name": "QuantumInspiredHybridPSO", "description": "Introduced an adaptive velocity scaling based on fitness variance to enhance convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            fitness_variance = np.var(personal_best_scores)  # New line added\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                ) * (1 + fitness_variance)  # Adjusting velocity scaling\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient * np.exp(-evaluations / self.budget)\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 29, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05289 with standard deviation 0.00420.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.054083938882464766, 0.054959381766184756, 0.05727003653138041, 0.053155377409014104, 0.04729420300234266, 0.04926495037508172, 0.0457552551555207]}}
{"id": "a38c5575-fb8f-4f73-8424-822f56284fee", "fitness": 0.05477995200736832, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Exploration Techniques for Improved Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on distance to global best\n                distance_to_best = np.linalg.norm(population[i] - global_best_position)\n                mutation_probability = self.mutation_coefficient * (distance_to_best / (np.linalg.norm(self.upper_bound - self.lower_bound)))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Modified quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim) * np.random.rand()\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient * np.exp(-evaluations / self.budget)\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 30, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05478 with standard deviation 0.00482.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.06210690630864757, 0.05632309630823695, 0.054959381766184756, 0.06101031754740671, 0.05535232703784687, 0.04729420300234266, 0.05240472105744631, 0.04764411340767183]}}
{"id": "60d13e0d-4370-4a38-9a2a-45656c791818", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Quantum Coefficient Scaling and Mutation for Improved Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 31, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["9dbacc77-092c-4dfb-a00b-d5b7be3b04c1"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "aa0f1560-ef6e-44f3-a244-6a931462cffa", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Improved Mutation Strategy for Enhanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 0.5, self.dim)  # Adjusted standard deviation\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 32, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "e4341a4e-e6cc-4b33-9d57-5a9028651710", "fitness": 0.054199155270971335, "name": "QuantumInspiredHybridPSO", "description": "Adaptive Quantum-Based Dynamic PSO with Momentum-Driven Mutation and Stochastic Quantum Drift for Balanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.95)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.95)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.95)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Momentum-Driven Mutation\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability * (1 + np.linalg.norm(velocities[i]))\n\n                # Stochastic Quantum Drift for exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (1.5 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 33, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05420 with standard deviation 0.00450.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05843139995849511, 0.05962946643483835, 0.05443148342582693, 0.057413286663918206, 0.05858957228867678, 0.05349631199069993, 0.04936878891088814, 0.050384075781204185, 0.04604801198419439]}}
{"id": "27aff27f-7c8a-4ef0-8c3f-523ef2c95d31", "fitness": 0.0548916683172356, "name": "QuantumInspiredHybridPSO", "description": "Improved Quantum-Inspired Hybrid PSO with Dynamic Quantum Coefficient Adjustment and Enhanced Mutation Strategy for Better Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Enhanced mutation strategy with dynamic coefficient adjustment\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_strength = np.random.uniform(0.5, 1.5)\n                    mutation_vector = np.random.normal(0, mutation_strength, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Dynamic quantum coefficient adjustment for exploration\n                self.quantum_coefficient = max(0.05, self.quantum_coefficient * (1 - evaluations / self.budget))\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 34, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05489 with standard deviation 0.00478.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05616372481441001, 0.06210690630864757, 0.056442273650150976, 0.05519340205839418, 0.06101031754740671, 0.05546908274943352, 0.04749117761273769, 0.05240472105744631, 0.047743409056493435]}}
{"id": "ba21704f-e6d2-4b5c-843a-2c192abd7a14", "fitness": 0.053142309541331256, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Quantum Tunneling and Momentum for Robust Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n        self.momentum = 0.2  # New momentum term for velocity adjustment\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                    + self.momentum * (global_best_position - personal_best_positions[i])  # Added momentum term\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Enhanced adaptive quantum tunneling for robust exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    directional_vector = global_best_position - population[i]\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor * directional_vector\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 35, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05314 with standard deviation 0.00418.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05611973910475787, 0.05846892919607172, 0.05451356862871548, 0.055150808141984364, 0.05745315403380513, 0.05357705106292121, 0.0474579650536755, 0.04942088491842778, 0.046118685731622255]}}
{"id": "252dd139-8ab1-4824-a4a6-b2cd3fcfcb35", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Learning Rate for Improved Convergence Speed.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 36, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "c0deea3d-4224-4971-8e9b-d6f33ab20f28", "fitness": 0.05384137178424272, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Adaptive Quantum-Inspired Hybrid PSO with Dynamic Topology Adjustment and Enhanced Mutation Strategies for Superior Convergence Performance.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n    \n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n\n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability * np.exp(-evaluations / self.budget)\n\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                topology_adjustment = np.random.choice(range(self.population_size), size=self.dim, replace=False)\n                population[i] = np.mean([population[index] for index in topology_adjustment], axis=0)\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05384 with standard deviation 0.00417.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05784481839136091, 0.05838697414722693, 0.05510713127206501, 0.05684048439772382, 0.05737285047646279, 0.05415892218195295, 0.04889283556436541, 0.04935250596207996, 0.046615823664946654]}}
{"id": "d919d69d-819a-4ddf-bfa6-61496f51655d", "fitness": 0.05310107396470898, "name": "ImprovedQuantumInspiredHybridPSO", "description": "Improved Quantum-Inspired Hybrid PSO with Adaptive Learning Rate and Enhanced Local Search for Better Convergence and Diversity.", "code": "import numpy as np\n\nclass ImprovedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = None\n        self.upper_bound = None\n        self.init_parameters()\n\n    def init_parameters(self):\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.learning_rate = 0.1\n\n    def adapt_parameters(self, evaluations):\n        decay_rate = 0.98\n        self.inertia_weight = max(0.4, self.inertia_weight * decay_rate)\n        self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * decay_rate)\n        self.social_coefficient = max(1.5, self.social_coefficient * decay_rate)\n        self.learning_rate = 0.1 + 0.9 * (evaluations / self.budget)\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                self.adapt_parameters(evaluations)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += self.learning_rate * velocities[i]\n\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 38, "feedback": "The algorithm ImprovedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05310 with standard deviation 0.00439.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.05913458481066003, 0.05391868435832081, 0.054959381766184756, 0.05810379266297727, 0.05299325739784566, 0.04729420300234266, 0.04996526832301873, 0.04561599173049968]}}
{"id": "3f73d7e3-3495-4872-acdf-491ded46d62d", "fitness": 0.05283589489343629, "name": "EnhancedQuantumDEPSO", "description": "Optimized Quantum-Inspired Hybrid PSO incorporating Differential Evolution for enhanced convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedQuantumDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.de_crossover_probability = 0.9\n        self.de_scaling_factor = 0.5\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Differential Evolution step\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant_vector = x0 + self.de_scaling_factor * (x1 - x2)\n                trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_probability, mutant_vector, population[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                if func(trial_vector) < fitness:\n                    population[i] = trial_vector\n\n                # Adaptive mutation\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedQuantumDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05284 with standard deviation 0.00422.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05391868435832081, 0.054959381766184756, 0.05727003653138041, 0.05299325739784566, 0.04729420300234266, 0.04926495037508172, 0.04561599173049968]}}
{"id": "3113638c-9011-4615-89de-9e73ed67489d", "fitness": 0.05395005258397803, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Quantum Coefficient Scaling, Mutation, and Multi-Layered Quantum Tunneling for Improved Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Multi-layered adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n                \n                if np.random.rand() < self.quantum_coefficient / 2:\n                    deeper_quantum_tunnel = np.random.normal(0, 0.5, self.dim)\n                    deeper_scaling_factor = scaling_factor / 2\n                    population[i] += deeper_quantum_tunnel * self.quantum_coefficient * deeper_scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 40, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05395 with standard deviation 0.00409.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05632534192339822, 0.058282047248739755, 0.05719204576178649, 0.055352288874937705, 0.05727003653138041, 0.05620334767532653, 0.04729420300234266, 0.04926495037508172, 0.04836621186280876]}}
{"id": "e364adf8-3334-4386-a5f3-457fb92d5011", "fitness": 0.053182871358510485, "name": "QuantumInspiredHybridPSO", "description": "Improved Quantum-Inspired Hybrid PSO by fine-tuning the mutation coefficient and initial inertia weight for better convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.85  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.15  # Adjusted mutation coefficient\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 41, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05318 with standard deviation 0.00416.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0564252024340135, 0.058282047248739755, 0.054525535974160655, 0.05545014676481841, 0.05727003653138041, 0.05358846003689177, 0.04771304292549361, 0.04926495037508172, 0.04612641993601452]}}
{"id": "8b37d892-9ee6-4015-ae53-dce3913eeec6", "fitness": 0.0536758099065715, "name": "QuantumInspiredHybridPSO", "description": "Incorporate adaptive velocity scaling based on the fitness improvement rate to enhance convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                # Adaptive velocity scaling based on fitness improvement\n                improvement_rate = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                velocity_scaling = 1 + 0.5 * improvement_rate\n                velocities[i] *= velocity_scaling\n\n                population[i] += velocities[i]\n\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 42, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05368 with standard deviation 0.00448.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05650172488050642, 0.058282047248739755, 0.05703196726792381, 0.056182997187566475, 0.05727003653138041, 0.05505866632386658, 0.04729420300234266, 0.04968707736193578, 0.04577356935488164]}}
{"id": "aaa70d13-f10f-4590-a8ee-2b3b478afe7b", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Fine-tuned Quantum-Inspired Hybrid PSO with Enhanced Adaptive Mutation for Improved Result Quality.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Enhanced Adaptive mutation with Gaussian perturbation and time-dependent decay\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * (mutation_probability ** 0.5)\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 43, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "6646d350-3962-428e-9ef1-b56adf07df89", "fitness": 0.052878238516690726, "name": "QuantumInspiredHybridPSO", "description": "Improved Quantum-Inspired Hybrid PSO with Adaptive Lêvy Flight and Dynamic Memory Sharing for Enhanced Global Search and Robust Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        memory = np.full((self.population_size, self.dim), np.inf)\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                # Lêvy Flight for enhanced exploration\n                if np.random.rand() < 0.2:  # probability for Lêvy flight\n                    levy_flight_step = np.random.standard_cauchy(self.dim)\n                    population[i] += levy_flight_step * mutation_probability\n\n                # Dynamic Memory Sharing\n                memory[i] = self.cognitive_coefficient * r1 * personal_best_positions[i] + self.social_coefficient * r2 * global_best_position\n                population[i] = 0.5 * (population[i] + memory[i])\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 44, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05288 with standard deviation 0.00420.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.0540602738236311, 0.054959381766184756, 0.05727003653138041, 0.05313334680274007, 0.04729420300234266, 0.04926495037508172, 0.04571540546958486]}}
{"id": "5918ba8a-14e7-4147-91a4-19c1819aa6f4", "fitness": 0.05351060871594967, "name": "QuantumInspiredHybridPSO", "description": "Improved Quantum-Inspired Hybrid PSO with dynamic mutation scaling and enhanced cognitive/social weighting for superior convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = np.clip(self.cognitive_coefficient * 0.98 + 0.02 * r1, 1.5, 3.0)\n                self.social_coefficient = np.clip(self.social_coefficient * 0.98 + 0.02 * r2, 1.5, 3.0)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * np.sqrt(relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 45, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05351 with standard deviation 0.00417.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.05846601647509386, 0.054804881576725806, 0.05602502270032572, 0.0574502963659852, 0.05386192133927892, 0.04819863159469162, 0.04941842921860984, 0.04635771881099626]}}
{"id": "f0246b7e-02bf-42e7-9f60-5ebce8b105c1", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Minor adjustment to the mutation probability calculation to enhance convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + (1 - evaluations / self.budget))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 46, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "3e5bd621-5640-4e8b-ba9f-ed6024e275a8", "fitness": 0.052895505822873945, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Quantum-Inspired Hybrid PSO with Adaptive Swarm Intelligence and Dynamic Exploration-Exploitation Balance for Enhanced Convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters with improved balance\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.99)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.99)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on dynamic exploration-exploitation balance\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n\n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration with dynamic scaling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-5 * (evaluations / self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05290 with standard deviation 0.00419.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.0541083458494821, 0.054959381766184756, 0.05727003653138041, 0.05317943717275786, 0.04729420300234266, 0.04926495037508172, 0.04577664882936505]}}
{"id": "b9572a36-0001-493d-8a43-8ef0e220a5f3", "fitness": 0.05283589489343629, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Differential Evolution and Dynamic Parameter Tuning for Improved Convergence and Robustness.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.differential_weight = 0.8\n        self.crossover_rate = 0.9\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                # Differential Evolution strategy for enhanced diversity\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = population[a] + self.differential_weight * (population[b] - population[c])\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, population[i])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial_vector)\n                evaluations += 1\n                if trial_fitness < fitness:\n                    population[i] = trial_vector\n                    personal_best_positions[i] = trial_vector\n                    personal_best_scores[i] = trial_fitness\n                    if trial_fitness < global_best_score:\n                        global_best_score = trial_fitness\n                        global_best_position = trial_vector\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05284 with standard deviation 0.00422.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05391868435832081, 0.054959381766184756, 0.05727003653138041, 0.05299325739784566, 0.04729420300234266, 0.04926495037508172, 0.04561599173049968]}}
{"id": "d66755a1-5dd3-47ad-ad33-cf6ade9ba530", "fitness": 0.05495720500331674, "name": "QuantumInspiredHybridPSO", "description": "Introduce a decay factor to the mutation probability, enhancing convergence by dynamically reducing exploration intensity over time.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget) * (1 - evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 49, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05496 with standard deviation 0.00476.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05649091358889469, 0.06210690630864757, 0.05632309630823695, 0.055514539564453624, 0.06101031754740671, 0.05535232703784687, 0.04776791020924609, 0.05240472105744631, 0.04764411340767183]}}
{"id": "4ae7dbdf-9daa-4ee5-a2ac-58cbf80be6f4", "fitness": 0.05417050832529266, "name": "QuantumInspiredHybridPSO", "description": "Introduce a nonlinear time-varying inertia weight to enhance convergence speed and avoid local optima.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = 0.4 + (0.5 * (1 - (evaluations/self.budget)**2))  # Nonlinear time-varying inertia\n\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 50, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05417 with standard deviation 0.00405.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05656157647549831, 0.058594901836254154, 0.05722899382640845, 0.055583741799951736, 0.05757656262363553, 0.05623952948500388, 0.04782661106914443, 0.0495258111627499, 0.04839684664898758]}}
{"id": "26fa8b1f-253d-424a-8216-561981bff0ba", "fitness": 0.05283589489343629, "name": "QuantumInspiredHybridPSO", "description": "Quantum-Inspired Hybrid PSO with Self-Adaptive Parameter Control and Dynamic Neighborhood for Enhanced Optimization Performance.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = None\n        self.upper_bound = None\n        # Introduce self-adaptive parameters\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Adaptive inertia weight based on evaluations\n                self.inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (evaluations / self.budget)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                # Dynamic neighborhood - average of local best neighbors\n                neighbors = np.random.choice(self.population_size, size=5, replace=False)\n                local_best = min([personal_best_scores[n] for n in neighbors])\n                local_best_index = np.argmin([personal_best_scores[n] for n in neighbors])\n                local_best_position = personal_best_positions[neighbors[local_best_index]]\n\n                velocities[i] += r1 * (local_best_position - population[i])\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 51, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05284 with standard deviation 0.00422.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05391868435832081, 0.054959381766184756, 0.05727003653138041, 0.05299325739784566, 0.04729420300234266, 0.04926495037508172, 0.04561599173049968]}}
{"id": "3edbd099-6800-4256-87d9-6bbbd62aa5a8", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Introduced adaptive dynamic scaling in mutation for more responsive adaptation to changes in the fitness landscape.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability * np.exp(-evaluations / (3 * self.budget))\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 52, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "bf002298-667a-47f1-90ba-b19ad421cf61", "fitness": 0.054686154140181076, "name": "EnhancedQuantumInspiredHybridPSO", "description": "The Enhanced Quantum-Inspired Hybrid PSO with Dynamic Population Resizing, Adaptive Learning Rates, and Quantum Tunneling for Superior Optimization Performance.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.initial_population_size = self.population_size\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters and population size\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n                self.population_size = max(10, int(self.initial_population_size * (1 - evaluations / self.budget)))\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Handle dynamic population resizing effect\n            if len(population) != self.population_size:\n                idx = np.argsort(personal_best_scores)[:self.population_size]\n                population = population[idx]\n                velocities = velocities[idx]\n                personal_best_positions = personal_best_positions[idx]\n                personal_best_scores = personal_best_scores[idx]\n\n        return global_best_position", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05469 with standard deviation 0.00437.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.0603647428024745, 0.057758872304742526, 0.054959381766184756, 0.05930729648083821, 0.05675746781072333, 0.04729420300234266, 0.050978779051140455, 0.048830142412652044]}}
{"id": "ef2ada56-7a64-44ba-bf22-24abdd9421a1", "fitness": 0.05524708154415692, "name": "QuantumInspiredHybridPSO", "description": "Refined Quantum-Inspired Hybrid PSO with Enhanced Adaptive Quantum Coefficient and Mutation Strategy for Faster Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Enhanced Adaptive mutation strategy\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (2 * relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Enhanced Adaptive quantum tunneling strategy\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (1.5 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 54, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05525 with standard deviation 0.00468.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05697547241550116, 0.06210690630864757, 0.05676766684196355, 0.055988841886458696, 0.06101031754740671, 0.05578769247397408, 0.048168787022632054, 0.05240472105744631, 0.04801332834338212]}}
{"id": "a3c1a40a-c856-41e9-9506-1318945edbed", "fitness": 0.054014515721320704, "name": "QuantumInspiredHybridPSO", "description": "Hybrid Quantum-Inspired PSO with Dynamic Inertia and Adaptive Mutation based on Fitness Diversity for Enhanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            fitness_scores = np.zeros(self.population_size)\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n                fitness_scores[i] = fitness\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            fitness_diversity = np.std(fitness_scores)\n            self.inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * (evaluations / self.budget))\n            \n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Enhanced adaptive mutation with fitness diversity factor\n                relative_improvement = (personal_best_scores[i] - fitness_scores[i]) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + fitness_diversity)\n\n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling with adaptive scaling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 55, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05401 with standard deviation 0.00449.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05941867676539203, 0.058282047248739755, 0.05420039713632363, 0.05838021874011223, 0.05727003653138041, 0.053269863640908244, 0.05018936049274547, 0.04926495037508172, 0.04585509056120285]}}
{"id": "f3dbbf53-d88c-47ee-9431-88e00a25f4e0", "fitness": 0.05241738910475202, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Population Size for Improved Resource Allocation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, min(100, int(budget / 50)))  # Dynamic population size based on budget\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 56, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05242 with standard deviation 0.00424.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05436477285939756, 0.058282047248739755, 0.054151761837280654, 0.05342658739112249, 0.05727003653138041, 0.0532220506522465, 0.04596090809487474, 0.04926495037508172, 0.045813386952644364]}}
{"id": "215a3bad-403f-4099-9dbb-b0c62b8234f7", "fitness": 0.05517401790601639, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Quantum Tunneling Scaling and Enhanced Initialization for Improved Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 0.5, self.dim)  # Change 1: Adjust mutation vector scaling\n                    population[i] += mutation_vector * mutation_probability\n\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / self.budget)  # Change 2: Modify scaling factor computation\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 57, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05517 with standard deviation 0.00470.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05674083919351336, 0.06210690630864757, 0.05676766684196355, 0.05575928146969911, 0.06101031754740671, 0.05578769247397408, 0.04797540791811472, 0.05240472105744631, 0.04801332834338212]}}
{"id": "84b817bd-c6e4-495f-9b45-9eda20667768", "fitness": 0.05509599954837942, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Quantum Coefficient Scaling, Mutation, and Periodic Reinitialization for Improved Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.reinit_period = budget // 4\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            if evaluations % self.reinit_period == 0:\n                stagnation_factor = 0.1 * (1 - global_best_score / np.max(personal_best_scores))\n                num_to_reinit = int(self.population_size * stagnation_factor)\n                reinit_indices = np.random.choice(self.population_size, num_to_reinit, replace=False)\n                for idx in reinit_indices:\n                    population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    velocities[idx] = np.random.uniform(-1, 1, self.dim)\n                    personal_best_scores[idx] = np.inf\n\n        return global_best_position", "configspace": "", "generation": 58, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05510 with standard deviation 0.00472.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05649091358889469, 0.06210690630864757, 0.05676766684196355, 0.055514539564453624, 0.06101031754740671, 0.05578769247397408, 0.04776791020924609, 0.05240472105744631, 0.04801332834338212]}}
{"id": "b9018ea2-d577-420b-90d7-346a93f26547", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Introduced Adaptive Velocity Damping to Quantum-Inspired Hybrid PSO for Enhanced Stability and Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i] * (0.5 + 0.5 * np.sin(evaluations / self.budget * np.pi))  # Adaptive Velocity Damping\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 59, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "2595d5e8-a895-42b1-a1ea-32e70c0818a5", "fitness": 0.05311975161681121, "name": "EnhancedQuantumHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Parameter Scaling, Global and Local Mutation Strategies, and Quantum Wave Collapse for Robust Exploration and Exploitation.", "code": "import numpy as np\n\nclass EnhancedQuantumHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters with lower bounds\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.97)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.97)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.97)\n\n                # Update velocities with adaptive inertia weight\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Global mutation improves exploration\n                if np.random.rand() < self.mutation_coefficient:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * self.mutation_coefficient\n\n                # Local mutation based on relative improvement\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                local_mutation_prob = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < local_mutation_prob:\n                    local_mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += local_mutation_vector * local_mutation_prob\n\n                # Quantum wave collapse strategy for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedQuantumHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05312 with standard deviation 0.00412.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.054822283694490714, 0.054959381766184756, 0.05727003653138041, 0.053880107808383815, 0.04729420300234266, 0.04926495037508172, 0.046380252494165886]}}
{"id": "6f430cea-5a8f-48ef-8bcb-c7afe59d565d", "fitness": 0.05363630807803056, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Slightly Increased Quantum Tunneling Coefficient for Better Exploration.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.15  # Changed from 0.1 to 0.15\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 61, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05364 with standard deviation 0.00404.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.056070714058918725, 0.058282047248739755, 0.05632309630823695, 0.05510272816457862, 0.05727003653138041, 0.05535232703784687, 0.047416759569820166, 0.04926495037508172, 0.04764411340767183]}}
{"id": "0af2f65f-d40e-48ff-958e-68475a036cbb", "fitness": 0.05367871163440401, "name": "EnhancedQuantumPSO", "description": "Quantum-Inspired PSO with Dynamic Interference and Adaptive Parameter Control for Enhanced Search Efficiency.", "code": "import numpy as np\n\nclass EnhancedQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.interference_coefficient = 0.05\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                # Interference mechanism to increase diversity and avoid premature convergence\n                if np.random.rand() < self.interference_coefficient:\n                    interference_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += interference_vector * self.interference_coefficient\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05368 with standard deviation 0.00409.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05632534192339822, 0.058282047248739755, 0.05632309630823695, 0.055352288874937705, 0.05727003653138041, 0.05535232703784687, 0.04729420300234266, 0.04926495037508172, 0.04764411340767183]}}
{"id": "1c49f7d4-5e62-4313-a4dd-7918db4aeaa4", "fitness": 0.05415256365762681, "name": "QuantumInspiredHybridPSO", "description": "Enhanced exploration by adjusting population size and adaptive mutation strategy. ", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 55  # Increased population size for better exploration\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation with exponential decay\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + np.exp(-evaluations / self.budget))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 63, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05415 with standard deviation 0.00478.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.061396873906268135, 0.05502265669162665, 0.054959381766184756, 0.06031793774659189, 0.05407626442710278, 0.04729420300234266, 0.05183509236086692, 0.046546161387126306]}}
{"id": "e780dd6d-c5d4-46d9-b427-dadaf7c359dc", "fitness": 0.054389374244719554, "name": "QuantumInspiredHybridPSO", "description": "Quantum-Inspired Hybrid PSO with Dynamic Communication Topology and Enhanced Mutation for Better Exploration and Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Enhanced mutation with adaptive scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, np.std(population, axis=0), self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Dynamic communication topology for enhanced exploration\n                local_best_position = personal_best_positions[np.random.choice(self.population_size)]\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = local_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 64, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05439 with standard deviation 0.00437.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05639724596551443, 0.06037144967689112, 0.05632309630823695, 0.05542261504579915, 0.05931470580773546, 0.05535232703784687, 0.047688747563237266, 0.050990067389542926, 0.04764411340767183]}}
{"id": "02e70a48-29d2-4699-927d-44fb00894aa6", "fitness": 0.05345935239425922, "name": "EnhancedQIHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Learning Rates and Adaptive Population Resizing for Balanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass EnhancedQIHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n        self.learning_rate_decay = 0.995  # New parameter for dynamic learning rate\n        self.population_resize_interval = int(budget / 5)  # Resize population at intervals\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters with decay\n                self.inertia_weight *= self.learning_rate_decay\n                self.cognitive_coefficient *= self.learning_rate_decay\n                self.social_coefficient *= self.learning_rate_decay\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Adaptive population resizing\n            if evaluations % self.population_resize_interval == 0 and self.population_size > 10:\n                self.population_size -= 5\n                population = population[:self.population_size]\n                velocities = velocities[:self.population_size]\n                personal_best_positions = personal_best_positions[:self.population_size]\n                personal_best_scores = personal_best_scores[:self.population_size]\n\n        return global_best_position", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedQIHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05346 with standard deviation 0.00405.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05590597472066594, 0.054959381766184756, 0.05727003653138041, 0.05494279146061787, 0.04729420300234266, 0.04926495037508172, 0.04729028481278863]}}
{"id": "17a718ad-126f-483b-9c09-a3e0a7d474b0", "fitness": 0.0539573250609858, "name": "QuantumInspiredHybridPSO", "description": "Introduce time-decayed influence weights for global best update to enhance convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i]) * (1 - evaluations / self.budget)  # Modified line\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 66, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05396 with standard deviation 0.00403.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.056930712701186104, 0.05837122887182278, 0.056403692385101234, 0.055944781632418006, 0.05735735035103118, 0.05543087781569833, 0.04813004186328973, 0.04933886804574916, 0.047708371882575706]}}
{"id": "ae20c821-c6eb-4429-9e77-1887a333a934", "fitness": 0.054779368148981024, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Optimized Parameter Decay for Better Balance Between Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.97)  # Changed from 0.98 to 0.97\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 67, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05478 with standard deviation 0.00418.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05814337311030615, 0.059582066234666664, 0.05661933081227599, 0.057130403378201744, 0.058543048886079974, 0.05564187047285574, 0.049123969691566405, 0.05034398655668337, 0.047886264198193196]}}
{"id": "30f2fd97-aa84-47ef-8a25-ada21e199db2", "fitness": 0.05524708154415692, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Improved Adaptive Quantum Coefficient Scaling for Enhanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (1.5 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 68, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05525 with standard deviation 0.00468.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05697547241550116, 0.06210690630864757, 0.05676766684196355, 0.055988841886458696, 0.06101031754740671, 0.05578769247397408, 0.048168787022632054, 0.05240472105744631, 0.04801332834338212]}}
{"id": "164604a3-f6dd-4247-9abe-2c64a8c270fe", "fitness": 0.05522511288389472, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Time-Varying Quantum Coefficient and Adaptive Multi-Stage Mutation for Enhanced Convergence and Diversity.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Multi-stage adaptive mutation\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                if np.random.rand() < mutation_probability:\n                    mutation_stage = np.random.choice([0.5, 1.0, 1.5])  # Different mutation intensities\n                    mutation_vector = np.random.normal(0, mutation_stage, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Time-varying quantum tunneling\n                if np.random.rand() < self.quantum_coefficient * (1 - evaluations / self.budget):\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 69, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05523 with standard deviation 0.00471.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05623210734961559, 0.06210690630864757, 0.05743945259486738, 0.0552608044345384, 0.06101031754740671, 0.05644606318096601, 0.04755096477842524, 0.05240472105744631, 0.04857467870313925]}}
{"id": "9438768d-d188-45fe-a464-6ab7cecd9488", "fitness": 0.05498274688183759, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Particle Swarm Optimization with Dynamic Adaptive Mechanisms for Improved Exploration, Exploitation, and Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Improved mutation strategy with adaptive scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + np.log1p(evaluations) / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.random.uniform(0.5, 1.5)  # Introduced variability in scaling \n                    population[i] += mutation_vector * mutation_probability * scaling_factor\n\n                # Enhanced quantum tunneling with dynamic scaling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (1.5 * self.budget))  # Adjusted scaling factor\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 70, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05498 with standard deviation 0.00475.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05652183824810608, 0.06210690630864757, 0.0563741495195893, 0.05554472444707281, 0.06101031754740671, 0.0554023649094475, 0.047792896099769555, 0.05240472105744631, 0.047686803799052435]}}
{"id": "79d06ce5-178c-4393-a93c-8b63a6f398df", "fitness": 0.05283589489343629, "name": "AdvancedQuantumInspiredHybridPSO", "description": "Advanced Quantum-Inspired Hybrid PSO with Adaptive Learning Rate, Stochastic Gradient Influence, and Nonlinear Inertia Weight Reduction for Enhanced Convergence.", "code": "import numpy as np\n\nclass AdvancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Nonlinear inertia weight reduction based on current evaluations\n                self.inertia_weight = max(0.1, 0.9 * (1 - (evaluations / self.budget)**2))\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.99)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.99)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                # Stochastic gradient influence for improved local search\n                if np.random.rand() < 0.2:\n                    grad_influence = np.random.normal(0, 0.1, self.dim)\n                    population[i] += grad_influence\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration with exponential scaling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (3 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 71, "feedback": "The algorithm AdvancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05284 with standard deviation 0.00422.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05391868435832081, 0.054959381766184756, 0.05727003653138041, 0.05299325739784566, 0.04729420300234266, 0.04926495037508172, 0.04561599173049968]}}
{"id": "c79bdfdd-1bf6-4192-8a65-403dc38ea3b3", "fitness": 0.05345935239425922, "name": "QuantumInspiredHybridPSO", "description": "Quantum-Inspired Hybrid PSO with Enhanced Dynamic Parameter Adjustment for Optimized Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Enhanced dynamic adjustment of parameters\n                self.inertia_weight = max(0.3, self.inertia_weight * 0.995)\n                self.cognitive_coefficient = max(1.4, self.cognitive_coefficient * 0.995)\n                self.social_coefficient = max(1.4, self.social_coefficient * 0.995)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 72, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05346 with standard deviation 0.00405.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05590597472066594, 0.054959381766184756, 0.05727003653138041, 0.05494279146061787, 0.04729420300234266, 0.04926495037508172, 0.04729028481278863]}}
{"id": "406d8057-886f-4c31-9622-db226070ffb5", "fitness": 0.053017022651623336, "name": "AdaptiveQuantumInspiredPSO", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization with Dynamic Mutation and Quantum Tunneling for Enhanced Convergence and Diversity.", "code": "import numpy as np\n\nclass AdaptiveQuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, 0.9 - 0.5 * (evaluations / self.budget))\n                self.cognitive_coefficient = max(1.5, 2.0 - 0.5 * (evaluations / self.budget))\n                self.social_coefficient = max(1.5, 2.0 - 0.5 * (evaluations / self.budget))\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on diversity and time-dependent scaling\n                diversity = np.std(population, axis=0).mean()\n                mutation_probability = self.mutation_coefficient * (diversity + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 73, "feedback": "The algorithm AdaptiveQuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05302 with standard deviation 0.00415.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05449564319733857, 0.054959381766184756, 0.05727003653138041, 0.05355939113677077, 0.04729420300234266, 0.04926495037508172, 0.04610304897624018]}}
{"id": "78358734-4e8e-4140-96e9-11171e1b7cbe", "fitness": 0.053704704762333036, "name": "OptimizedQuantumHybridPSO", "description": "Optimized Quantum-Inspired Hybrid PSO with Dynamic Learning Rate Adjustment and Improved Quantum Tunneling for Enhanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass OptimizedQuantumHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, 0.9 * (1 - evaluations / self.budget))\n                self.cognitive_coefficient = max(1.5, 2.0 * (1 - evaluations / self.budget))\n                self.social_coefficient = max(1.5, 2.0 * (1 - evaluations / self.budget))\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Dynamic mutation based on relative improvement and adaptive scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + (self.budget - evaluations) / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Improved quantum tunneling with dynamic coefficient\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.sqrt((self.budget - evaluations) / self.budget)\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 74, "feedback": "The algorithm OptimizedQuantumHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05370 with standard deviation 0.00426.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.058076750455658965, 0.058282047248739755, 0.054549391411313874, 0.05706544447713113, 0.05727003653138041, 0.05361244904362128, 0.0490705755986931, 0.04926495037508172, 0.046150697719377076]}}
{"id": "d631b10c-f1b3-44e0-88f6-0e4cec4bda10", "fitness": 0.05486407317057889, "name": "AdvancedQuantumInspiredPSO", "description": "Advanced Quantum-Inspired Hybrid PSO with Dynamic Quantum Coefficient, Adaptive Mutation Thresholding, and Enhanced Multi-Exploration Strategies.", "code": "import numpy as np\n\nclass AdvancedQuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.initial_quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        quantum_coefficient = self.initial_quantum_coefficient\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget) ** 0.5\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                dynamic_quantum_coefficient = quantum_coefficient * (1 - evaluations / self.budget)\n                if np.random.rand() < dynamic_quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * dynamic_quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 75, "feedback": "The algorithm AdvancedQuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05486 with standard deviation 0.00479.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05619481370510859, 0.06210690630864757, 0.05632309630823695, 0.05522381000367926, 0.06101031754740671, 0.05535232703784687, 0.04751655315916592, 0.05240472105744631, 0.04764411340767183]}}
{"id": "06946644-a45d-4570-8455-f3cb43c06026", "fitness": 0.0544263405559198, "name": "AdaptiveQuantumInspiredPSO", "description": "Adaptive Quantum-Inspired Hybrid PSO with Dynamic Parameter Adjustment and Elite Strategy for Balanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass AdaptiveQuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.elite_fraction = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            elite_count = int(self.population_size * self.elite_fraction)\n            elite_indices = np.argsort(personal_best_scores)[:elite_count]\n            elite_positions = personal_best_positions[elite_indices]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters based on progress\n                phase_ratio = evaluations / self.budget\n                self.inertia_weight = 0.9 - 0.5 * phase_ratio\n                self.cognitive_coefficient = 2.5 - 1.5 * phase_ratio\n                self.social_coefficient = 1.5 + 1.5 * phase_ratio\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n\n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                # Integrate elite strategy\n                if len(elite_positions) > 0 and np.random.rand() < 0.2:\n                    elite_target = elite_positions[np.random.randint(len(elite_positions))]\n                    population[i] = (population[i] + elite_target) / 2\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 76, "feedback": "The algorithm AdaptiveQuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05443 with standard deviation 0.00418.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05900539674321115, 0.054959381766184756, 0.05727003653138041, 0.05797728410513381, 0.04729420300234266, 0.04926495037508172, 0.04985926360067272]}}
{"id": "a4ebb158-e5a1-4326-aa0c-4f7858120432", "fitness": -Infinity, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Improved Dynamic Parameter Adjustment and Adaptive Memory for Better Performance.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n        self.adaptive_memory = []\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n                    self.adaptive_memory.append(global_best_position)\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.2, self.inertia_weight * 0.99)\n                self.cognitive_coefficient = max(1.0, self.cognitive_coefficient * 0.99)\n                self.social_coefficient = max(1.0, self.social_coefficient * 0.99)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (3 * self.budget))  # Changed from 2 to 3\n                    memory_factor = np.random.choice(self.adaptive_memory)  # Added adaptive memory influence\n                    population[i] = memory_factor + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 77, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {}}
{"id": "f8312db4-bc52-410c-ae39-aa0410c6551b", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Mutation Coefficient Adjustment for Better Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1  # Adjusted dynamically\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = (self.mutation_coefficient + 0.05) * (relative_improvement + evaluations / self.budget)  # Adjusted mutation coefficient\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 78, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "46757307-4bf7-4baf-96f6-70238e4714f6", "fitness": 0.055258538581075274, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Population Resizing and Adaptive Learning Parameters for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 20\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation and quantum tunneling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Dynamic population resizing\n            if evaluations % (self.budget // 10) == 0:\n                self.population_size = int((self.min_population_size + \n                                            (self.max_population_size - self.min_population_size) * \n                                            (1 - evaluations / self.budget)))\n                population = np.resize(population, (self.population_size, self.dim))\n                velocities = np.resize(velocities, (self.population_size, self.dim))\n                personal_best_positions = np.resize(personal_best_positions, (self.population_size, self.dim))\n                personal_best_scores = np.resize(personal_best_scores, self.population_size)\n\n        return global_best_position", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "0add8f12-6052-436d-9689-0c13b7a57577", "fitness": 0.05510828699909424, "name": "QuantumInspiredHybridPSO", "description": "Improved Quantum-Inspired Hybrid PSO with Enhanced Adaptive Quantum Coefficient and Modified Mutation Strategy.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Refined mutation strategy using exponential decay\n                mutation_probability = self.mutation_coefficient * np.exp(-evaluations / self.budget)\n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Enhanced adaptive quantum tunneling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-(evaluations / (1.5 * self.budget)))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 80, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05511 with standard deviation 0.00472.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05697547241550116, 0.06210690630864757, 0.05632309630823695, 0.055988841886458696, 0.06101031754740671, 0.05535232703784687, 0.048168787022632054, 0.05240472105744631, 0.04764411340767183]}}
{"id": "0c961666-b166-4932-b587-018905e806d1", "fitness": -Infinity, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Quantum Coefficient Scaling, Mutation, and Dynamic Population Size for Improved Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Adjust population size dynamically\n            if evaluations % (self.budget // 10) == 0:\n                self.population_size = int(self.population_size * 1.02)  # Increase population size slightly\n\n        return global_best_position", "configspace": "", "generation": 81, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {}}
{"id": "d09d0fb3-e3ab-4bca-a1c7-6da1f1510038", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Budget-Adjusted Quantum Coefficient for Better Exploration.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 82, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "d2f12529-e0fb-4382-8605-e641f4c6efe0", "fitness": 0.05326005393977695, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Diversity Control and Differential Evolution for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                # Differential evolution component for enhanced diversity\n                if np.random.rand() < 0.5:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices[0]], population[indices[1]], population[indices[2]]\n                    trial_vector = x1 + 0.8 * (x2 - x3)\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_fitness < fitness:\n                        population[i] = trial_vector\n                        personal_best_scores[i] = trial_fitness\n                        personal_best_positions[i] = trial_vector\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05326 with standard deviation 0.00409.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.0552700952493963, 0.054959381766184756, 0.05727003653138041, 0.05431920539767443, 0.04729420300234266, 0.04926495037508172, 0.046756064256661345]}}
{"id": "150d1479-6ed2-44f8-872c-01a63d82dbca", "fitness": 0.05359439716077449, "name": "QuantumTunedAdaptiveHybridPSO", "description": "Quantum-Tuned Adaptive Hybrid PSO with Self-Adjusting Parameters and Enhanced Diversity for Balanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumTunedAdaptiveHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Updated dynamic adjustment of parameters for enhanced exploration-exploitation balance\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.99)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.99)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                # Boost diversity with an enhanced mutation mechanism\n                diversity_factor = np.std(population, axis=0)\n                mutation_probability = self.mutation_coefficient * (1 + np.sum(diversity_factor) / self.dim)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                population[i] += velocities[i]\n\n                # Improved quantum tunneling with self-adapting quantum coefficient\n                if np.random.rand() < self.quantum_coefficient:\n                    quantum_jump = np.random.normal(0, 1, self.dim)\n                    population[i] = global_best_position + quantum_jump * self.quantum_coefficient * np.exp(-evaluations / (2 * self.budget))\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 84, "feedback": "The algorithm QuantumTunedAdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05359 with standard deviation 0.00413.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.05878698341243804, 0.05583584702954725, 0.054959381766184756, 0.057764563792843227, 0.05487328638098676, 0.04729420300234266, 0.049684613660848864, 0.047226193771247704]}}
{"id": "7eb01a86-27ea-4385-b35f-0442fbedb935", "fitness": 0.055258538581075274, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Coefficient Adjustment and Dynamic Population Size for Improved Convergence and Exploration.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        current_population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (current_population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (current_population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(current_population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(current_population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(current_population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Dynamic population adjustment\n            if evaluations / self.budget > 0.5 and current_population_size > 10:\n                current_population_size = int(current_population_size * 0.9)\n                population = population[:current_population_size]\n                velocities = velocities[:current_population_size]\n                personal_best_positions = personal_best_positions[:current_population_size]\n                personal_best_scores = personal_best_scores[:current_population_size]\n\n        return global_best_position", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "7806d65b-6834-43ef-861d-1c0d0f7c2089", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Optimized Quantum-Inspired Hybrid PSO with Enhanced Dynamic Mutation Scaling for Improved Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Enhanced adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * np.log(1 + relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 86, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "3246a8d5-f261-42de-85d4-12243dce877e", "fitness": 0.05456081614767373, "name": "ImprovedQuantumInspiredHybridPSO", "description": "Improved Quantum-Inspired Hybrid PSO with Adaptive Dynamic Decay Parameters and Diversified Tunneling for Boosted Exploration and Convergence.", "code": "import numpy as np\n\nclass ImprovedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic decay of parameters\n                self.inertia_weight = max(0.3, self.inertia_weight * (0.99 - 0.5 * evaluations / self.budget))\n                self.cognitive_coefficient = max(1.0, self.cognitive_coefficient * (0.99 - 0.5 * evaluations / self.budget))\n                self.social_coefficient = max(1.0, self.social_coefficient * (0.99 - 0.5 * evaluations / self.budget))\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Diversified quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    tunnel_variation = np.random.uniform(-1, 1, self.dim) * self.quantum_coefficient * scaling_factor\n                    population[i] = global_best_position + adaptive_quantum_tunnel * tunnel_variation\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 87, "feedback": "The algorithm ImprovedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05456 with standard deviation 0.00475.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.060977131375173466, 0.058282047248739755, 0.0544023607812848, 0.05990216056936093, 0.05727003653138041, 0.05346806025076101, 0.05145485510747183, 0.04926495037508172, 0.04602574308980967]}}
{"id": "c0db9987-3134-4c4f-b8a9-0a25736487c1", "fitness": 0.05525224063587228, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Strategy, Mutation, and Dynamic Quantum Coefficient Scaling for Optimized Searching Performance.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n                    self.quantum_coefficient = max(0.05, self.quantum_coefficient * 0.99)  # Change made here\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 88, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05525 with standard deviation 0.00468.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.056992157881688765, 0.06210690630864757, 0.05676766684196355, 0.0560051246265999, 0.06101031754740671, 0.05578769247397408, 0.04818225064174153, 0.05240472105744631, 0.04801332834338212]}}
{"id": "262395f6-1293-47c9-929e-1d4931d39cd0", "fitness": 0.05336865077912466, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Velocity Damping, Adaptive Inertia Adjustment, and Global Best Perturbation for Balanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n        self.velocity_damping = 0.99  # New parameter for dynamic velocity damping\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                # Apply velocity damping\n                velocities[i] *= self.velocity_damping\n\n                velocities[i] += (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                # Perturbation to avoid premature convergence\n                if evaluations > self.budget * 0.75:  # Trigger near the end of budget\n                    perturbation_strength = 0.1 * (1 - evaluations / self.budget)\n                    perturbation = np.random.uniform(-perturbation_strength, perturbation_strength, self.dim)\n                    population[i] += perturbation\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05337 with standard deviation 0.00408.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05624836786038201, 0.058282047248739755, 0.05529207849529283, 0.055276917327655606, 0.05727003653138041, 0.054341054880875705, 0.047565795409625244, 0.04926495037508172, 0.046776608883088655]}}
{"id": "fc2b3d21-9296-4ba9-817a-495893981c16", "fitness": 0.053259592567795805, "name": "QuantumEnhancedPSO", "description": "Quantum-Enhanced PSO with Dynamic Neighborhood and Adaptive Velocity Clamping for Superior Convergence and Stability.", "code": "import numpy as np\n\nclass QuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            # Determine dynamic neighborhood\n            neighborhood_size = max(1, int(self.population_size / 10))\n            local_best_positions = np.zeros_like(population)\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                best_neighbor = min(neighbors, key=lambda x: personal_best_scores[x])\n                local_best_positions[i] = personal_best_positions[best_neighbor]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                r3 = np.random.rand(self.dim)\n\n                # Dynamic parameter adjustment\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                # Update velocities with local best influence\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (local_best_positions[i] - population[i])\n                    + self.social_coefficient * r3 * (global_best_position - population[i])\n                )\n\n                # Velocity clamping\n                velocity_clamp = (self.upper_bound - self.lower_bound) / 2\n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Adaptive mutation\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                # Boundary check\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 90, "feedback": "The algorithm QuantumEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05326 with standard deviation 0.00437.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05654249138761425, 0.059020551725250336, 0.05391868435832081, 0.05556522854988122, 0.057992819232857484, 0.05299325739784566, 0.04781200148285236, 0.04987530724504041, 0.04561599173049968]}}
{"id": "cc13b6ef-2ada-450e-8fac-3b74a5db09c6", "fitness": 0.05449314014669023, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Parameter Tuning and Multi-Phase Exploration for Balanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Multi-phase exploration switch\n            exploration_phase = evaluations < self.budget * 0.5\n\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic inertia weight update\n                inertia_adjustment = ((self.final_inertia_weight - self.initial_inertia_weight) * \n                                      (evaluations / self.budget))\n                self.inertia_weight = self.initial_inertia_weight - inertia_adjustment\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on exploration phase\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = (self.mutation_coefficient * \n                                        (relative_improvement + evaluations / self.budget))\n                if exploration_phase:\n                    mutation_probability *= 1.5  # Enhance mutation in exploration phase\n\n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Quantum tunneling with phase-dependent scaling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget)) if exploration_phase else 0.5\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05449 with standard deviation 0.00421.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.05922122590745671, 0.054959381766184756, 0.05727003653138041, 0.05818797153078936, 0.04729420300234266, 0.04926495037508172, 0.0500339433277055]}}
{"id": "87ec5f14-1deb-49d3-8029-f16daf1103d3", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Minor enhancement of the mutation process by increasing mutation probability slightly for better exploration.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Slightly increased mutation coefficient for better exploration\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = (self.mutation_coefficient + 0.05) * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 92, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "59609b22-6773-482a-9b47-0c8f1b6cc9b7", "fitness": 0.05517401790601639, "name": "QuantumInspiredHybridPSO", "description": "Improved Adaptive Quantum Tunneling by refining the scaling factor for enhanced exploration.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / self.budget) # Refined scaling factor for exploration\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 93, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05517 with standard deviation 0.00470.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05674083919351336, 0.06210690630864757, 0.05676766684196355, 0.05575928146969911, 0.06101031754740671, 0.05578769247397408, 0.04797540791811472, 0.05240472105744631, 0.04801332834338212]}}
{"id": "867cf0cc-8eea-4817-9920-28e43dfb3e22", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with dynamic quantum coefficient scaling for improved exploration and exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            self.quantum_coefficient = max(0.05, self.quantum_coefficient * 0.99)  # Added line\n\n        return global_best_position", "configspace": "", "generation": 94, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "caf96ee9-94ef-40f8-a0d2-91e27bd1382b", "fitness": 0.05314983525991304, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Neighborhood Topology and Nonlinear Parameter Decay for Improved Balance between Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        # Initialize neighborhood topology\n        neighborhood_size = max(3, self.population_size // 5)\n        neighborhood_indices = [np.random.choice(self.population_size, neighborhood_size, replace=False)\n                                for _ in range(self.population_size)]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                # Use neighborhood best instead of global best\n                neighborhood_best_score = np.inf\n                neighborhood_best_position = np.copy(global_best_position)\n                \n                for idx in neighborhood_indices[i]:\n                    if personal_best_scores[idx] < neighborhood_best_score:\n                        neighborhood_best_score = personal_best_scores[idx]\n                        neighborhood_best_position = personal_best_positions[idx]\n\n                # Nonlinear decay of parameters\n                inertia_decay = 0.99\n                self.inertia_weight = max(0.4, self.inertia_weight * inertia_decay)\n                cognitive_decay = 0.99\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * cognitive_decay)\n                social_decay = 0.99\n                self.social_coefficient = max(1.5, self.social_coefficient * social_decay)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (neighborhood_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation and quantum tunneling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = neighborhood_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 95, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05315 with standard deviation 0.00411.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.0559245016305312, 0.058282047248739755, 0.054917567243897736, 0.054959381766184756, 0.05727003653138041, 0.05397379200541874, 0.04729420300234266, 0.04926495037508172, 0.04646203753564038]}}
{"id": "4d538c54-120c-4667-bb85-3f86d406b6aa", "fitness": 0.054961852124451864, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Quantum Coefficient Scaling, Momentum-Based Mutation, and Strategic Restart Mechanism for Robust Exploration and Exploitation.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n        self.evaluations_since_best = 0\n        self.best_reset_threshold = 50\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n                    self.evaluations_since_best = 0\n                else:\n                    self.evaluations_since_best += 1\n\n            # Strategic restart mechanism\n            if self.evaluations_since_best > self.best_reset_threshold:\n                idx = np.argmax(personal_best_scores)\n                population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                velocities[idx] = np.random.uniform(-1, 1, self.dim)\n                personal_best_scores[idx] = np.inf\n                self.evaluations_since_best = 0\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Momentum-based adaptive mutation\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                momentum_factor = 1 + np.tanh(relative_improvement)\n                mutation_probability = self.mutation_coefficient * (momentum_factor + evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05496 with standard deviation 0.00476.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05650577609433727, 0.06210690630864757, 0.05632309630823695, 0.05552910233139219, 0.06101031754740671, 0.05535232703784687, 0.04778030902708108, 0.05240472105744631, 0.04764411340767183]}}
{"id": "7751c2a0-24ca-4339-b33e-4413eff7cc31", "fitness": 0.053424093203704684, "name": "EnhancedQuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Adaptive Dynamic Population Resizing and Non-linear Parameter Adjustments for Optimal Balance Between Exploration and Exploitation in Black Box Optimization.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Non-linear dynamic adjustment of parameters\n                self.inertia_weight = 0.4 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                self.cognitive_coefficient = 1.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n                self.social_coefficient = 1.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation with non-linear scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + np.sqrt(evaluations / self.budget))\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-np.sqrt(evaluations) / self.budget)\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            # Dynamically adjust population size\n            if evaluations % (self.budget // 10) == 0:\n                self.population_size = max(10, self.initial_population_size - (self.initial_population_size * evaluations // self.budget))\n                population = population[:self.population_size]\n                velocities = velocities[:self.population_size]\n                personal_best_positions = personal_best_positions[:self.population_size]\n                personal_best_scores = personal_best_scores[:self.population_size]\n\n        return global_best_position", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedQuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05342 with standard deviation 0.00431.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.057741698004739606, 0.058282047248739755, 0.05398421043564228, 0.05673924055634205, 0.05727003653138041, 0.0530576014506724, 0.04880540689509616, 0.04926495037508172, 0.04567164733564777]}}
{"id": "2a490b5b-183e-4c99-986b-3a091fdc6c9e", "fitness": 0.055258538581075274, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO with Dynamic Mutation Coefficient Adjustment for Improved Exploration and Exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n                \n                # Dynamically adjust mutation coefficient for increased exploration\n                self.mutation_coefficient = 0.1 + 0.1 * (evaluations / self.budget)\n                \n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 98, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05526 with standard deviation 0.00467.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.05701256036183977, 0.06210690630864757, 0.05676766684196355, 0.05602502270032572, 0.06101031754740671, 0.05578769247397408, 0.04819863159469162, 0.05240472105744631, 0.04801332834338212]}}
{"id": "ce197553-0982-4799-8f53-544d302a1bdb", "fitness": 0.053796759551157654, "name": "QuantumInspiredHybridPSO", "description": "Enhanced Quantum-Inspired Hybrid PSO now includes dynamic mutation coefficient scaling based on iteration progress.", "code": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 2.0\n        self.mutation_coefficient = 0.1\n        self.quantum_coefficient = 0.1\n        self.lower_bound = None\n        self.upper_bound = None\n\n    def __call__(self, func):\n        self.lower_bound = np.array(func.bounds.lb)\n        self.upper_bound = np.array(func.bounds.ub)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(population[i])\n                evaluations += 1\n\n                if fitness < personal_best_scores[i]:\n                    personal_best_scores[i] = fitness\n                    personal_best_positions[i] = population[i]\n\n                if fitness < global_best_score:\n                    global_best_score = fitness\n                    global_best_position = population[i]\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Dynamic adjustment of parameters\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.98)\n                self.cognitive_coefficient = max(1.5, self.cognitive_coefficient * 0.98)\n                self.social_coefficient = max(1.5, self.social_coefficient * 0.98)\n\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                    + self.social_coefficient * r2 * (global_best_position - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                # Adaptive mutation based on relative improvement and time-dependent scaling\n                relative_improvement = (personal_best_scores[i] - fitness) / max(1e-6, personal_best_scores[i])\n                mutation_probability = self.mutation_coefficient * (relative_improvement + evaluations / self.budget)\n\n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    population[i] += mutation_vector * mutation_probability\n\n                # Dynamic mutation coefficient scaling based on iteration progress\n                self.mutation_coefficient = 0.1 + 0.9 * (evaluations / self.budget)\n                \n                # Adaptive quantum tunneling for enhanced exploration\n                if np.random.rand() < self.quantum_coefficient:\n                    adaptive_quantum_tunnel = np.random.normal(0, 1, self.dim)\n                    scaling_factor = np.exp(-evaluations / (2 * self.budget))\n                    population[i] = global_best_position + adaptive_quantum_tunnel * self.quantum_coefficient * scaling_factor\n\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position", "configspace": "", "generation": 99, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05380 with standard deviation 0.00416.", "error": "", "parent_ids": ["60d13e0d-4370-4a38-9a2a-45656c791818"], "operator": null, "metadata": {"aucs": [0.056943517916434705, 0.058282047248739755, 0.05632309630823695, 0.05579654413268398, 0.05727003653138041, 0.05535232703784687, 0.04729420300234266, 0.04926495037508172, 0.04764411340767183]}}
