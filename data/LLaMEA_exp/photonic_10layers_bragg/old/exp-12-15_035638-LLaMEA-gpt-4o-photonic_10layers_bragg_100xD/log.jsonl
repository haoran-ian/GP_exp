{"id": "9e255fa5-ce97-49d4-80f1-4bd0b42aba79", "fitness": -Infinity, "name": "AdaptiveExploratorySwarm", "description": "An adaptive swarm-based exploratory algorithm with feedback-driven parameter tuning for efficient search in black box optimization.", "code": "import numpy as np\n\nclass AdaptiveExploratorySwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(40, self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.5    # inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Update velocity\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n\n        # Update position\n        self.positions[i] = self.positions[i] + self.velocities[i]\n\n        # Apply bounds\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        # Evaluate fitness\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        # Update personal best\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        # Update global best\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        # Adapt parameters based on the progress\n        if self.func_evals > self.budget / 2:\n            self.c1 *= 0.99\n            self.c2 *= 1.01\n        self.w = max(0.1, self.w * 0.99)", "configspace": "", "generation": 0, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 133, in evaluate_gp_func\n    algorithm(problem)\n  File \"<string>\", line 33, in __call__\n  File \"<string>\", line 44, in update_particle\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n.", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 133, in evaluate_gp_func\n    algorithm(problem)\n  File \"<string>\", line 33, in __call__\n  File \"<string>\", line 44, in update_particle\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "459ef51a-6d05-48e9-acc8-d982fe40c0fc", "fitness": -Infinity, "name": "AdaptiveExploratorySwarm", "description": "A refined adaptive swarm-based algorithm with enhanced velocity initialization to ensure diverse exploration in black box optimization tasks.", "code": "import numpy as np\n\nclass AdaptiveExploratorySwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(40, self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.5    # inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        # Enhanced velocity initialization for diverse exploration\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim)) * (ub - lb)\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Update velocity\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n\n        # Update position\n        self.positions[i] = self.positions[i] + self.velocities[i]\n\n        # Apply bounds\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        # Evaluate fitness\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        # Update personal best\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        # Update global best\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        # Adapt parameters based on the progress\n        if self.func_evals > self.budget / 2:\n            self.c1 *= 0.99\n            self.c2 *= 1.01\n        self.w = max(0.1, self.w * 0.99)", "configspace": "", "generation": 1, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_ids": ["9e255fa5-ce97-49d4-80f1-4bd0b42aba79"], "operator": null, "metadata": {}}
{"id": "06b386dc-aeb9-408e-a79f-9da6b1ce246a", "fitness": 0.06487223560629418, "name": "AdaptiveExploratorySwarm", "description": "An adaptive swarm-based exploratory algorithm with feedback-driven parameter tuning for efficient search in black box optimization, refined to ensure bounds are fully initialized.", "code": "import numpy as np\n\nclass AdaptiveExploratorySwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(40, self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.5    # inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)  # Initialized to mid-point of bounds\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Update velocity\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n\n        # Update position\n        self.positions[i] = self.positions[i] + self.velocities[i]\n\n        # Apply bounds\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        # Evaluate fitness\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        # Update personal best\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        # Update global best\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        # Adapt parameters based on the progress\n        if self.func_evals > self.budget / 2:\n            self.c1 *= 0.99\n            self.c2 *= 1.01\n        self.w = max(0.1, self.w * 0.99)", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveExploratorySwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06487 with standard deviation 0.00664.", "error": "", "parent_ids": ["9e255fa5-ce97-49d4-80f1-4bd0b42aba79"], "operator": null, "metadata": {"aucs": [0.07399711586316715, 0.05840923292276434, 0.06221035803295105]}}
{"id": "cbc3c4be-bdd1-4ad7-a558-b15c83a53cb3", "fitness": 0.037570959399235236, "name": "AdaptiveExploratorySwarm", "description": "Enhancing Adaptive Exploratory Swarm with Dynamic Population Scaling and Early Stopping Criteria for improved exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveExploratorySwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(40, self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.5    # inertia weight\n        self.bounds = None\n        self.func_evals = 0\n        self.dynamic_population_scaling = True  # Flag for dynamic scaling\n        self.convergence_threshold = 1e-6  # Early stopping threshold\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            # Early stopping based on convergence threshold\n            if abs(self.global_best_score - min(self.best_scores)) < self.convergence_threshold:\n                break\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        if self.func_evals > self.budget / 2:\n            self.c1 *= 0.99\n            self.c2 *= 1.01\n        self.w = max(0.1, self.w * 0.99)\n\n        # Dynamic population scaling\n        if self.dynamic_population_scaling and self.func_evals < self.budget / 3:\n            self.population_size = min(self.population_size + 1, self.budget // 5)", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveExploratorySwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03757 with standard deviation 0.00479.", "error": "", "parent_ids": ["06b386dc-aeb9-408e-a79f-9da6b1ce246a"], "operator": null, "metadata": {"aucs": [0.03136292579020117, 0.038339528390194166, 0.04301042401731037]}}
{"id": "5d882ae9-8dfb-4f0c-ba47-e6ddf181d0ee", "fitness": 0.0909400217702236, "name": "AdaptiveExploratorySwarm", "description": "Enhanced adaptive swarm-based optimization by adjusting velocity and parameter adaptation for improved convergence.  ", "code": "import numpy as np\n\nclass AdaptiveExploratorySwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(40, self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.5    # inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)  # Initialized to mid-point of bounds\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Update velocity\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        # Update position\n        self.positions[i] = self.positions[i] + self.velocities[i]\n\n        # Apply bounds\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        # Evaluate fitness\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        # Update personal best\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        # Update global best\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        # Adapt parameters based on the progress\n        if self.func_evals > self.budget / 2:\n            self.c1 *= 0.98  # Reduced decay rate\n            self.c2 *= 1.02  # Increased growth rate\n        self.w = max(0.1, self.w * 0.99)", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveExploratorySwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09094 with standard deviation 0.00186.", "error": "", "parent_ids": ["06b386dc-aeb9-408e-a79f-9da6b1ce246a"], "operator": null, "metadata": {"aucs": [0.09198599259822049, 0.09251169165431816, 0.08832238105813217]}}
{"id": "2db85b76-7e82-4098-beb2-324893822952", "fitness": -Infinity, "name": "MultiPhaseAdaptiveSwarm", "description": "Leverage multi-phase adaptive swarm optimization with velocity adjustment and hybrid mutation to balance exploration and exploitation for enhanced convergence.", "code": "import numpy as np\n\nclass MultiPhaseAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(40, self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1_start = 2.0\n        self.c2_start = 2.0\n        self.c1_end = 1.5\n        self.c2_end = 2.5\n        self.w_start = 0.9\n        self.w_end = 0.4\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            phase = self.func_evals / self.budget\n            for i in range(self.population_size):\n                self.update_particle(i, func, phase)\n\n            self.update_parameters(phase)\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func, phase):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        cognitive_component = self.c1(phase) * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2(phase) * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w(phase) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self, phase):\n        self.c1 = lambda p: (1-p)*self.c1_start + p*self.c1_end\n        self.c2 = lambda p: (1-p)*self.c2_start + p*self.c2_end\n        self.w = lambda p: (1-p)*self.w_start + p*self.w_end", "configspace": "", "generation": 5, "feedback": "An exception occurred: AttributeError(\"'MultiPhaseAdaptiveSwarm' object has no attribute 'c1'\").", "error": "AttributeError(\"'MultiPhaseAdaptiveSwarm' object has no attribute 'c1'\")", "parent_ids": ["5d882ae9-8dfb-4f0c-ba47-e6ddf181d0ee"], "operator": null, "metadata": {}}
{"id": "42af9bb9-d2d2-4e62-9422-081ea0b82cbd", "fitness": -Infinity, "name": "AdaptiveExploratorySwarm", "description": "Enhanced adaptive swarm-based optimization by adjusting velocity and parameter adaptation for improved convergence.  ", "code": "import numpy as np\n\nclass AdaptiveExploratorySwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(40, self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.5    # inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)  # Initialized to mid-point of bounds\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Update velocity\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        # Update position\n        self.positions[i] = self.positions[i] + self.velocities[i]\n\n        # Apply bounds\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        # Evaluate fitness\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        # Update personal best\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        # Update global best\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        # Adapt parameters based on the progress\n        if self.func_evals > self.budget / 2:\n            self.c1 *= 0.98  # Reduced decay rate\n            self.c2 *= 1.02  # Increased growth rate\n        self.w = max(0.1, self.w * 0.99)", "configspace": "", "generation": 5, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_ids": ["5d882ae9-8dfb-4f0c-ba47-e6ddf181d0ee"], "operator": "\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.4% of the code, which means if the code has 100 lines, you can only change 1.3513513513513513 lines, and the rest of the lines should remain unchanged. This input code has 74 lines, so you can only change 1 lines, the rest 73 lines should remain unchanged. This changing rate 1.4% is the mandatory requirement, you cannot change more or less than this rate.\n    ", "metadata": {"aucs": [0.09198599259822049, 0.09251169165431816, 0.08832238105813217]}}
{"id": "2e92f7a5-a452-45a8-a32e-82d1203eae3b", "fitness": 0.09148217794472879, "name": "DynamicAdaptiveSwarm", "description": "Dynamic Adaptive Swarm Optimization with time-varying inertia and adaptive learning to enhance global convergence.", "code": "import numpy as np\n\nclass DynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress\n        self.w = 0.9 - 0.5 * progress", "configspace": "", "generation": 7, "feedback": "The algorithm DynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09148 with standard deviation 0.00066.", "error": "", "parent_ids": ["5d882ae9-8dfb-4f0c-ba47-e6ddf181d0ee"], "operator": null, "metadata": {"aucs": [0.09099911257609627, 0.09103352194053693, 0.09241389931755317]}}
{"id": "857b3659-b951-4a49-beaf-0360d85b480a", "fitness": 0.09080130149469261, "name": "DynamicAdaptiveSwarm", "description": "Enhanced Dynamic Adaptive Swarm Optimization with a refined inertia weight update for improved convergence.", "code": "import numpy as np\n\nclass DynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress\n        self.w = 0.7 + 0.2 * np.sin(np.pi * progress)  # Updated inertia weight calculation", "configspace": "", "generation": 8, "feedback": "The algorithm DynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09080 with standard deviation 0.00118.", "error": "", "parent_ids": ["2e92f7a5-a452-45a8-a32e-82d1203eae3b"], "operator": null, "metadata": {"aucs": [0.0906295944520924, 0.08944846625768355, 0.09232584377430186]}}
{"id": "baa80b95-1774-4b39-85b9-5c3f5dcb284a", "fitness": 0.056810925972053804, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced Dynamic Adaptive Swarm Optimization with a diversity preservation mechanism and adaptive inertia to improve global exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n        \n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress\n        self.w = 0.9 - 0.5 * progress\n\n        diversity = np.mean(np.std(self.positions, axis=0))\n        self.w = self.w + 0.3 * diversity * (1 - progress)", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05681 with standard deviation 0.00891.", "error": "", "parent_ids": ["2e92f7a5-a452-45a8-a32e-82d1203eae3b"], "operator": null, "metadata": {"aucs": [0.0552207959515314, 0.04678487070416337, 0.06842711126046663]}}
{"id": "740ba05a-f5db-43c8-be9e-784ac24c4eae", "fitness": 0.09044822666499674, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced Dynamic Adaptive Swarm Optimization with nonlinear dynamic parameters and stochastic velocity clustering for intensified exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # initial cognitive component\n        self.c2 = 2.05  # initial social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        \n        # Implementing stochastic velocity clustering\n        velocity_threshold = 0.05 * (self.bounds.ub - self.bounds.lb)\n        cluster_indices = np.where(np.abs(self.velocities[i]) < velocity_threshold, 0, 1)\n        self.velocities[i][cluster_indices == 0] = np.random.normal(size=np.count_nonzero(cluster_indices == 0)) * velocity_threshold[cluster_indices == 0]\n        \n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * np.sqrt(progress)\n        self.c2 = 1.5 + 1.5 * np.sqrt(progress)\n        self.w = 0.9 - 0.5 * np.sin(progress * np.pi / 2)", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09045 with standard deviation 0.00129.", "error": "", "parent_ids": ["2e92f7a5-a452-45a8-a32e-82d1203eae3b"], "operator": null, "metadata": {"aucs": [0.08946922105604682, 0.08960700944844802, 0.0922684494904954]}}
{"id": "845cb49f-a575-452a-bb1d-b009417c89ef", "fitness": 0.09224165009862957, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced Dynamic Adaptive Swarm Optimization with a novel non-linear inertia weight decay and elite-guided exploration to improve convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Elite-guided exploration\n        elite_factor = np.random.normal(0, 0.1, self.dim) * (self.global_best_position - self.positions[i])\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component + elite_factor\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Non-linear decay for inertia weight\n        self.w = 0.4 + 0.5 * np.exp(-3 * progress)\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09224 with standard deviation 0.00071.", "error": "", "parent_ids": ["2e92f7a5-a452-45a8-a32e-82d1203eae3b"], "operator": null, "metadata": {"aucs": [0.09209039878107261, 0.09146102072400852, 0.09317353079080759]}}
{"id": "32cb90eb-b5e5-4195-9df8-3d67c5499ba5", "fitness": 0.09196226062214974, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced Dynamic Adaptive Swarm Optimization with dynamic topology and adaptive cognitive/social component modulation to improve convergence and robustness.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Elite-guided exploration\n        elite_factor = np.random.normal(0, 0.1, self.dim) * (self.global_best_position - self.positions[i])\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        \n        # Dynamic topology: influence of nearest neighbor\n        neighbor_index = (i + 1) % self.population_size\n        neighbor_influence = np.random.normal(0, 0.1, self.dim) * (self.best_positions[neighbor_index] - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component + elite_factor + neighbor_influence\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Non-linear decay for inertia weight\n        self.w = 0.4 + 0.5 * np.exp(-3 * progress)\n        # Adaptive modulation of cognitive and social components\n        self.c1 = 2.5 - 1.5 * (1 - progress)  # reduces as progress increases\n        self.c2 = 1.5 + 1.5 * progress  # increases as progress increases", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09196 with standard deviation 0.00084.", "error": "", "parent_ids": ["845cb49f-a575-452a-bb1d-b009417c89ef"], "operator": null, "metadata": {"aucs": [0.09080071853389116, 0.09277810286029053, 0.09230796047226753]}}
{"id": "3274360c-cc23-4f4a-9cea-840e0038fbcd", "fitness": 0.09151925618088341, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Introduced stochastic inertia weight variation to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb), abs(ub-lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Elite-guided exploration\n        elite_factor = np.random.normal(0, 0.1, self.dim) * (self.global_best_position - self.positions[i])\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component + elite_factor\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Non-linear decay for inertia weight\n        self.w = 0.4 + 0.5 * np.exp(-3 * progress) + np.random.normal(0, 0.05)\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09152 with standard deviation 0.00023.", "error": "", "parent_ids": ["845cb49f-a575-452a-bb1d-b009417c89ef"], "operator": null, "metadata": {"aucs": [0.0911946362309306, 0.09167472645096153, 0.0916884058607581]}}
{"id": "91fb9427-b67a-4b66-981a-6035cca6b01f", "fitness": 0.09395403467590209, "name": "AdvancedAdaptiveSwarm", "description": "Advanced Particle Swarm Optimization with Adaptive Learning Rates and Dynamic Neighborhood Topology for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Adaptive inertia weight and learning rates\n        self.w = 0.4 + 0.5 * np.exp(-3 * progress)\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress", "configspace": "", "generation": 14, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09395 with standard deviation 0.00054.", "error": "", "parent_ids": ["845cb49f-a575-452a-bb1d-b009417c89ef"], "operator": null, "metadata": {"aucs": [0.0932241542411103, 0.09414630642406074, 0.09449164336253524]}}
{"id": "361b5fd1-a8f8-426a-ba88-9534e1b1e982", "fitness": 0.09334207553944567, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization with Hybrid Dynamic Adjustment of Inertia Weight and Adaptive Topology for Improved Convergence on Diverse Black Box Problems.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.9\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Hybrid Neighborhood Strategy\n        if np.random.rand() < 0.5:\n            neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        else:\n            distances = np.linalg.norm(self.positions - self.positions[i], axis=1)\n            neighborhood_indices = np.argsort(distances)[:5]\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Dynamic inertia weight and learning rates\n        self.w = 0.5 + 0.4 * np.cos(np.pi * progress)\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09334 with standard deviation 0.00124.", "error": "", "parent_ids": ["91fb9427-b67a-4b66-981a-6035cca6b01f"], "operator": null, "metadata": {"aucs": [0.09438016428519758, 0.09159863984979799, 0.09404742248334141]}}
{"id": "cc3af7f7-c15b-4395-8b5f-4569eaae5fe3", "fitness": 0.09489383006652607, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization with Stochastic Inertia Weight and Neighborhood Exploration for better exploitation and exploration.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.7, 0.9) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Slightly altered Adaptive Components\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress", "configspace": "", "generation": 16, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09489 with standard deviation 0.00041.", "error": "", "parent_ids": ["91fb9427-b67a-4b66-981a-6035cca6b01f"], "operator": null, "metadata": {"aucs": [0.09451961350916138, 0.09546197412333535, 0.0946999025670815]}}
{"id": "39918079-b632-43dc-bebe-e58a19a2addc", "fitness": 0.09470348476567207, "name": "AdvancedAdaptiveSwarm", "description": "Introduced Dynamic Velocity Scaling and Improved Neighbor Selection to enhance convergence and solution quality.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Improved Neighbor Selection\n        neighborhood_indices = np.argsort(self.best_scores)[:5]\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        # Dynamic Velocity Scaling\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Slightly altered Adaptive Components\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress", "configspace": "", "generation": 17, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09470 with standard deviation 0.00029.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09501590088933454, 0.09431277707325048, 0.09478177633443119]}}
{"id": "cd7ce24f-b071-4425-afe1-b6450c27c293", "fitness": 0.0940271785170667, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced neighborhood influence with exponential decay on inertia weight for better convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.7, 0.9) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Slightly altered Adaptive Components\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 * np.exp(-5 * progress)  # Exponential decay on inertia weight", "configspace": "", "generation": 18, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09403 with standard deviation 0.00075.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09323601874413745, 0.0950259009314689, 0.09381961587559373]}}
{"id": "8c958c32-95db-4e3c-99c5-3f643618a4f2", "fitness": 0.09216624811093221, "name": "QuantumAdaptiveSwarm", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization enhances exploration and exploitation by incorporating quantum superposition principles and dynamic learning rates.", "code": "import numpy as np\n\nclass QuantumAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.9  # initial inertia weight\n        self.q_probability = 0.1  # probability of quantum jump\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Quantum Jump\n        if np.random.rand() < self.q_probability:\n            self.positions[i] = np.random.uniform(self.bounds.lb, self.bounds.ub)\n        \n        # Dynamic Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.7, 0.9) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] += self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Altered Adaptive Components\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 2.0 * progress\n        self.q_probability = 0.1 + 0.2 * progress  # Increase quantum jump probability over time", "configspace": "", "generation": 19, "feedback": "The algorithm QuantumAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09217 with standard deviation 0.00173.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.08980588442398163, 0.09277236403939915, 0.09392049586941587]}}
{"id": "1ff5ce00-dc99-4150-94b7-cab84358a194", "fitness": 0.09475722557554944, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization with Slow Convergence Adjustment for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.7, 0.95) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Slightly altered Adaptive Components\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress", "configspace": "", "generation": 20, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09476 with standard deviation 0.00026.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09440421302628654, 0.09503923377347945, 0.09482822992688233]}}
{"id": "c4e5b08e-1b28-4728-864a-c4f8062e3826", "fitness": 0.09328777163310638, "name": "AdvancedAdaptiveSwarm", "description": "Improved Dynamic Neighborhood and Adaptive Inertia in Particle Swarm Optimization for Enhanced Convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.9\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic Neighborhood Topology (changed size=5 to size=3)\n        neighborhood_indices = np.random.choice(self.population_size, size=3, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.w = 0.4 + 0.5 * (1 - self.func_evals / self.budget)  # Adapted inertia weight\n        self.velocities[i] = self.w * np.random.uniform(0.7, 0.9) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress", "configspace": "", "generation": 21, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09329 with standard deviation 0.00031.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09312251329182875, 0.09372033799003576, 0.09302046361745464]}}
{"id": "5878facc-9223-44d7-8544-099e5e708902", "fitness": 0.09285841211416841, "name": "QuantumSwarmOptimizer", "description": "Dynamic Quantum-inspired Particle Swarm Optimization with Adaptive Quantum Tunneling and Multi-Population Approach for improved convergence and diversity maintenance.", "code": "import numpy as np\n\nclass QuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 3, 30), self.budget // 8)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.8  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n        self.quantum_tunneling_prob = 0.1\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.quantum_tunneling_prob:\n                    self.quantum_tunneling(i)\n                else:\n                    self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Multi-Population Approach, using random elite selection\n        elite_indices = np.random.choice(self.population_size, size=10, replace=False)\n        elite_best_position = self.best_positions[elite_indices[np.argmin(self.best_scores[elite_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (elite_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.6, 0.9) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def quantum_tunneling(self, i):\n        # Quantum Tunneling to escape local optima\n        quantum_offset = np.random.normal(0, 0.1, self.dim)\n        new_position = self.global_best_position + quantum_offset\n        new_position = np.clip(new_position, self.bounds.lb, self.bounds.ub)\n        self.positions[i] = new_position\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 1.5 - 1.0 * progress\n        self.c2 = 1.5 + 1.0 * progress\n        self.quantum_tunneling_prob = 0.1 + 0.2 * (1 - progress)", "configspace": "", "generation": 22, "feedback": "The algorithm QuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09286 with standard deviation 0.00134.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09374275287972378, 0.09096292248308258, 0.0938695609796989]}}
{"id": "fe1d05db-ed29-4631-b41a-d8f25c8cb493", "fitness": 0.09406709628953051, "name": "ImprovedDynamicNeighborhoodPSO", "description": "Improved Dynamic Neighborhood Particle Swarm Optimization incorporating Adaptive Inertia Weight with Flexible Learning Rates for enhanced convergence and balance between exploration and exploitation.", "code": "import numpy as np\n\nclass ImprovedDynamicNeighborhoodPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1 * (ub - lb), 0.1 * (ub - lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Dynamic Neighborhood with a larger neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=min(7, self.population_size), replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates with inertia weight adjustment\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Adjust inertia weight dynamically during the run\n        self.w = 0.9 - (0.5 * progress)\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress", "configspace": "", "generation": 23, "feedback": "The algorithm ImprovedDynamicNeighborhoodPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09407 with standard deviation 0.00091.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09289076687386544, 0.09418898994864244, 0.09512153204608365]}}
{"id": "38357462-a3b1-47c6-9be6-f0713f4f3df0", "fitness": 0.09483623241308418, "name": "AdvancedAdaptiveSwarm", "description": "Improved exploitation by introducing a momentum term in velocity update for better convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.7, 0.9) * self.velocities[i] + cognitive_component + social_component + 0.1\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Slightly altered Adaptive Components\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress", "configspace": "", "generation": 24, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09484 with standard deviation 0.00050.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09452217959297948, 0.0955453988797007, 0.09444111876657235]}}
{"id": "1beb2622-35ba-4e4d-9130-0cb6acd1e7b4", "fitness": 0.0933842786624246, "name": "AdvancedAdaptiveSwarm", "description": "Introduced adaptive mechanism for inertia weight and more diverse neighborhood selection to enhance convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # More diverse Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=min(10, self.population_size), replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Adaptive inertia weight\n        self.w = 0.9 - 0.4 * progress\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress", "configspace": "", "generation": 25, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09338 with standard deviation 0.00192.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09296421934763643, 0.09591860160488697, 0.0912700150347504]}}
{"id": "8d4e4bab-04a3-439e-a32e-c87ccf7544f2", "fitness": 0.09079143888619623, "name": "MultiStrategyAdaptiveSwarm", "description": "Multi-Strategy Adaptive Swarm Optimization with Dynamic Inertia and Hybrid Update Rules for Enhanced Performance and Robust Convergence.", "code": "import numpy as np\n\nclass MultiStrategyAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n    \n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        # Hybrid Update Rule with random perturbations\n        exploration_component = np.random.uniform(-0.1, 0.1, self.dim) * (self.bounds.ub - self.bounds.lb)\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + cognitive_component + social_component + exploration_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] += self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Improved Adaptive Components\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        # Dynamic inertia weight for improved exploration-exploitation balance\n        self.w = 0.9 - progress * 0.5", "configspace": "", "generation": 26, "feedback": "The algorithm MultiStrategyAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09079 with standard deviation 0.00095.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09211627926515875, 0.08990290019013969, 0.09035513720329025]}}
{"id": "584e26af-5523-4b0d-a6e0-19312a100ef7", "fitness": 0.06023021587156011, "name": "QuantumAdaptiveSwarm", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization with Dynamic Neighborhood and Stochastic Inertia for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass QuantumAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Dynamic Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=min(5, self.population_size), replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Quantum-inspired update (with Stochastic Inertia)\n        self.w = 0.9 - (0.5 * (self.func_evals / self.budget))  # Dynamic inertia weight\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        # Quantum-inspired position update\n        phi = np.random.uniform(0, 1, self.dim)\n        delta_position = np.sign(phi - 0.5) * np.abs(self.positions[i] - self.global_best_position)\n        self.positions[i] += delta_position * np.random.normal(0, 1, self.dim)\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Slightly altered Adaptive Components\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress", "configspace": "", "generation": 27, "feedback": "The algorithm QuantumAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06023 with standard deviation 0.00823.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.0513955520036522, 0.058083522058753, 0.07121157355227514]}}
{"id": "31bb6b87-2e56-4725-9113-c1b333c1127b", "fitness": 0.09357227242443204, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization with Dynamically Adjusted Velocity Clamping for better exploitation and exploration.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic Neighborhood Topology\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Adaptive Learning Rates\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.7, 0.9) * self.velocities[i] + cognitive_component + social_component\n        velocity_clamp_factor = 0.1 * (self.bounds.ub - self.bounds.lb) * (0.9 + 0.1 * (self.func_evals / self.budget))  # Dynamically adjusted velocity clamping\n        self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp_factor, velocity_clamp_factor)\n        \n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        # Slightly altered Adaptive Components\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress", "configspace": "", "generation": 28, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09357 with standard deviation 0.00112.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09237131213499894, 0.09506606246709781, 0.09327944267119936]}}
{"id": "e856249b-81a9-49cf-8740-7f7dec7070bb", "fitness": 0.09513608637319308, "name": "AdvancedAdaptiveSwarm", "description": "Improved Particle Swarm Algorithm with Dynamic Inertia Weight and Enhanced Neighborhood Exploration", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 29, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09514 with standard deviation 0.00069.", "error": "", "parent_ids": ["cc3af7f7-c15b-4395-8b5f-4569eaae5fe3"], "operator": null, "metadata": {"aucs": [0.09479801004795374, 0.09610042158582977, 0.09450982748579573]}}
{"id": "a1f31c1b-72cd-436e-9751-7ced3f80bfd2", "fitness": 0.09265611743017681, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm with Self-Tuning Parameters and Dynamic Neighborhood Exploration for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.9\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1 * (ub - lb), 0.1 * (ub - lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        neighborhood_size = max(2, int(0.1 * self.population_size))\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * np.random.uniform(0.5, 1.0) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09266 with standard deviation 0.00091.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.0927618992614434, 0.0914919391489829, 0.0937145138801041]}}
{"id": "b1b6b87b-c9b0-4905-9838-6d27a3da23e9", "fitness": -Infinity, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm with Hierarchical Neighborhood Search and Adaptive Velocity Control for Improved Convergence in Black Box Optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1 * (ub - lb), 0.1 * (ub - lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.copy(self.positions[np.argmin([func(p) for p in self.positions])])\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=min(5, self.population_size), replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 31, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {}}
{"id": "c1717275-6491-4610-b96d-93ae445f436b", "fitness": 0.09396273697973838, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Swarm Algorithm with Progressive Inertia and Adaptive Neighborhood Size for Diverse Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Adaptive Neighborhood Size\n        neighborhood_size = max(3, min(10, int(self.population_size * (1 - self.func_evals / self.budget))))\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        # Progressive Inertia Weight\n        progressive_w = self.w * (0.5 + 0.5 * (self.func_evals / self.budget))\n        self.velocities[i] = progressive_w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        # The w parameter is now progressively updated in update_particle", "configspace": "", "generation": 32, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09396 with standard deviation 0.00112.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.0924576051738415, 0.09430798886466452, 0.09512261690070911]}}
{"id": "d9f2b4b4-a195-4c3e-9471-c3165c855ece", "fitness": -Infinity, "name": "AdvancedAdaptiveSwarm", "description": "Improved Particle Swarm Algorithm with Dynamic Inertia Weight and Enhanced Neighborhood Exploration", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 30, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": "\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.4% of the code, which means if the code has 100 lines, you can only change 1.4285714285714286 lines, and the rest of the lines should remain unchanged. This input code has 70 lines, so you can only change 1 lines, the rest 69 lines should remain unchanged. This changing rate 1.4% is the mandatory requirement, you cannot change more or less than this rate.\n    ", "metadata": {"aucs": [0.09479801004795374, 0.09610042158582977, 0.09450982748579573]}}
{"id": "968f3271-57d9-49e8-965e-fbd46c087b31", "fitness": 0.09434546047669172, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Swarm Intelligence with Adaptive Inertia and Neighborhood-Based Exploration for Optimized Search Efficiency", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.dynamic_range = 0.15\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.9) * self.velocities[i] + cognitive_component + social_component\n        velocity_limit = self.dynamic_range * (self.bounds.ub - self.bounds.lb)\n        self.velocities[i] = np.clip(self.velocities[i], -velocity_limit, velocity_limit)\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.5 * progress  # Reduced change rate for inertia weight\n        self.dynamic_range = 0.15 + 0.05 * np.sin(progress * np.pi)  # Sinusoidal adjustment for velocity limit", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09435 with standard deviation 0.00155.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09477551126683181, 0.09598577608682002, 0.09227509407642331]}}
{"id": "8aa52d2b-dca3-4ae6-901e-ffdb20f15cff", "fitness": 0.09446940997593205, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm incorporating a Nonlinear Dynamic Inertia Weight and Elite Learning Strategy.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 * (1 - progress**0.5)  # Nonlinear dynamic inertia weight adjustment", "configspace": "", "generation": 35, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09447 with standard deviation 0.00119.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09351891648692301, 0.09615362846035325, 0.09373568498051987]}}
{"id": "934d71d4-9ed0-4084-804c-2a2ba47c4649", "fitness": 0.09290087803862519, "name": "AdvancedAdaptiveSwarm", "description": "Slightly tweaked inertia and cognitive/social components for adaptive exploration.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.85  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.5 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.85 - 0.65 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 36, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09290 with standard deviation 0.00337.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.0944742159598927, 0.09601336719543974, 0.08821505096054316]}}
{"id": "36918584-8adb-4f77-a2ff-d14bdf2e6635", "fitness": 0.09305189770856503, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Swarm with Adaptive Learning Factors and Constriction Coefficient for Improved Exploration.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        constriction_coefficient = 0.729  # constriction coefficient\n        self.velocities[i] = (\n            constriction_coefficient * (\n                self.w * self.velocities[i] + cognitive_component + social_component\n            )\n        )\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 37, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09305 with standard deviation 0.00108.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.092020525958595, 0.09454017246065272, 0.09259499470644739]}}
{"id": "ff522968-fd3c-4e7c-b2ff-701ab4890dde", "fitness": 0.09432587114506936, "name": "AdvancedAdaptiveSwarm", "description": "Minor enhancement by dynamically modifying velocity update range to improve exploration balance.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        # Updated line for dynamic velocity range\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 38, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09433 with standard deviation 0.00035.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09385134862155597, 0.09467887335602754, 0.0944473914576246]}}
{"id": "53540f28-57e3-4e3d-96c5-2d2845e24a4f", "fitness": 0.08863340478153307, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Inertia, Neighborhood Learning, and Early Stopping to accelerate convergence and improve solution quality.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n        self.convergence_threshold = 1e-6  # threshold for early stopping\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            prev_global_best_score = self.global_best_score\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            if abs(prev_global_best_score - self.global_best_score) < self.convergence_threshold:\n                break\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08863 with standard deviation 0.00366.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.0863908045373637, 0.093796932161057, 0.08571247764617851]}}
{"id": "bfefe0f1-31e0-43bf-8129-532027b89286", "fitness": -Infinity, "name": "RefinedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Ring Topology and Time-Varying Acceleration Coefficients for Better Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass RefinedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 9)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1_max, self.c1_min = 2.5, 0.5\n        self.c2_max, self.c2_min = 2.5, 0.5\n        self.w_max, self.w_min = 0.9, 0.4\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Implementing ring topology by considering neighbor indices\n        left_neighbor = (i - 1) % self.population_size\n        right_neighbor = (i + 1) % self.population_size\n        neighborhood_best_position = self.best_positions[[left_neighbor, i, right_neighbor]].mean(axis=0)\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = self.c1_max - (self.c1_max - self.c1_min) * progress\n        self.c2 = self.c2_min + (self.c2_max - self.c2_min) * progress\n        self.w = self.w_max - (self.w_max - self.w_min) * progress", "configspace": "", "generation": 40, "feedback": "An exception occurred: AttributeError(\"'RefinedAdaptiveSwarm' object has no attribute 'c1'\").", "error": "AttributeError(\"'RefinedAdaptiveSwarm' object has no attribute 'c1'\")", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {}}
{"id": "d0236f80-1ca0-42d9-90e6-96a03271330b", "fitness": 0.0943962013427672, "name": "AdvancedAdaptiveSwarm", "description": "Introduced adaptive velocity scaling to refine particle convergence and exploration balance.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * (0.5 + 0.5 * r1) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 41, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09440 with standard deviation 0.00130.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09338476996197786, 0.09622516256241775, 0.09357867150390597]}}
{"id": "100d4e0f-2ece-4aac-8095-6e53ba22f806", "fitness": 0.09498497747728019, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm Algorithm with Adaptive Neighborhood Size and Velocity Control for Improved Global and Local Search", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # initial cognitive component\n        self.c2 = 2.05  # initial social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = int(np.clip(5 * (1 - self.func_evals / self.budget) + 2, 2, self.population_size))\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        velocity_control_factor = np.random.uniform(0.5, 1.0)\n        self.velocities[i] = self.w * self.velocities[i] * velocity_control_factor + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09498 with standard deviation 0.00085.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09470020113149624, 0.09613773113562363, 0.09411700016472069]}}
{"id": "3502231d-c097-4fd0-90ff-56e57dd48236", "fitness": 0.09400381589968998, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Neighborhood and Progressive Inertia Weight for Efficient Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 3, 30), self.budget // 5)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamically adjust neighborhood size based on progress\n        neighborhood_size = max(5, int(self.population_size * (1 - self.func_evals / self.budget)))\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress\n        self.w = 0.9 - 0.5 * progress  # Progressive inertia weight adjustment", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09400 with standard deviation 0.00043.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09348084922725308, 0.09454422759651915, 0.09398637087529771]}}
{"id": "2889d530-4198-4a06-8062-16cbf22b946f", "fitness": 0.09390716807963355, "name": "AdvancedAdaptiveSwarm", "description": "Add adaptive neighborhood size to enhance exploration in AdvancedAdaptiveSwarm.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = max(5, int(self.population_size * (1 - self.func_evals / self.budget)))  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 44, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09391 with standard deviation 0.00236.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09063605243286299, 0.096118537097447, 0.09496691470859064]}}
{"id": "d0f96230-ff20-4e47-b1eb-bbf8190088eb", "fitness": 0.0938937177631028, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Particle Swarm with Adaptive Neighborhood Size and Dynamic Learning Rates to Boost Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Adaptive neighborhood size based on progress\n        neighborhood_size = max(1, int(self.population_size * (1 - self.func_evals / self.budget)))\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09389 with standard deviation 0.00237.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.0906068186536767, 0.09611947029362555, 0.09495486434200617]}}
{"id": "3ed7c4ad-90d1-4002-8daa-008c4f2eff71", "fitness": 0.09316151561159573, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Neighborhood and Self-adaptive Parameters for Improved Convergence in Particle Swarm Optimization", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        neighborhood_size = int(np.sqrt(self.population_size))  # Change 1: enhance neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment\n        if self.func_evals > self.budget * 0.5:  # Change 2: adaptive velocity clamping\n            self.velocities = np.clip(self.velocities, -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))  # Change 3: adaptive velocity clamping", "configspace": "", "generation": 46, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09316 with standard deviation 0.00276.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.08943630476332065, 0.09604859223708251, 0.09399964983438402]}}
{"id": "22182343-bf0a-4320-815c-d2e883cfc3a5", "fitness": 0.09198648210945741, "name": "SynergisticSwarm", "description": "Synergistic Swarm Optimization with Adaptive Mutation and Dynamic Feedback Control for Enhanced Convergence.", "code": "import numpy as np\n\nclass SynergisticSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # initial cognitive component\n        self.c2 = 2.05  # initial social component\n        self.w = 0.9  # initial inertia weight\n        self.mutation_rate = 0.1\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        # Adaptive mutation for exploration\n        if np.random.rand() < self.mutation_rate:\n            mutation_vector = np.random.normal(0, 0.1, self.dim) * (self.bounds.ub - self.bounds.lb)\n            self.positions[i] = np.clip(self.positions[i] + mutation_vector, self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment\n\n        # Adaptive mutation rate based on progress\n        self.mutation_rate = max(0.1 - 0.05 * progress, 0.01)", "configspace": "", "generation": 47, "feedback": "The algorithm SynergisticSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09199 with standard deviation 0.00092.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09278324886362876, 0.09070403700271445, 0.092472160462029]}}
{"id": "37c80270-1db6-4e90-9b61-691ce7444473", "fitness": 0.09443179177794407, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm with Selective Velocity Reset for Improved Convergence Stability.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        if np.random.rand() < 0.1:\n            self.velocities[i] = np.zeros(self.dim)  # Selective velocity reset\n\n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 48, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09443 with standard deviation 0.00141.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09553217758182009, 0.09532348915194899, 0.09243970860006312]}}
{"id": "c3bbf007-ad55-4ae1-aed3-53d9d192f384", "fitness": 0.09397072540733338, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization with Dynamic Neighborhood and Adaptive Velocity Control for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 3, 30), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        # Dynamic neighborhood based on current best scores\n        neighborhood_size = max(5, self.population_size // 5)\n        neighborhood_indices = np.argsort(self.best_scores)[:neighborhood_size]\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n\n        # Adaptive velocity control based on progress\n        progress_factor = 1 - self.func_evals / self.budget\n        velocity_clamp = 0.15 * (self.bounds.ub - self.bounds.lb) * progress_factor\n        self.velocities[i] = (self.w * np.random.uniform(0.5, 0.9) * self.velocities[i]\n                             + cognitive_component + social_component)\n        self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 2.0 * progress\n        self.w = 0.9 - 0.5 * progress  # Slight adjustment to the inertia weight", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09397 with standard deviation 0.00036.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09438370487262515, 0.09350886450704332, 0.09401960684233168]}}
{"id": "cc47f557-7689-45a7-af7f-08b53d26e660", "fitness": 0.09442189751491355, "name": "HybridAdaptiveSwarm", "description": "Hybrid Swarm-Evolutionary Algorithm with Adaptive Neighborhood and Mutative Agents for Improved Global Search Efficiency.", "code": "import numpy as np\n\nclass HybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.mutation_rate = 0.2  # mutation rate for diversity\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    self.mutate_particle(i, func)\n                else:\n                    self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def mutate_particle(self, i, func):\n        mutation_step = np.random.normal(0, 0.1, self.dim) * (self.bounds.ub - self.bounds.lb)\n        mutant_position = self.positions[i] + mutation_step\n        mutant_position = np.clip(mutant_position, self.bounds.lb, self.bounds.ub)\n\n        score = func(mutant_position)\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = mutant_position\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = mutant_position\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 50, "feedback": "The algorithm HybridAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09442 with standard deviation 0.00058.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09457806787638168, 0.09364288221338013, 0.09504474245497885]}}
{"id": "067bfc19-10b6-4b8d-b6a6-0900f8ac6607", "fitness": 0.09268014702296579, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced AdvancedAdaptiveSwarm with Adaptive Learning Factors and Velocity Clamping for Improved Convergence and Precision.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 3, 30), self.budget // 8)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        neighborhood_indices = np.random.choice(self.population_size, size=min(7, self.population_size), replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))\n        \n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.0 + 1.0 * np.sin(np.pi * progress)\n        self.c2 = 2.0 + 1.0 * np.cos(np.pi * progress)\n        self.w = 0.9 - 0.5 * progress\n", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09268 with standard deviation 0.00065.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09323056939644903, 0.09176340320891352, 0.09304646846353481]}}
{"id": "dbbe0b6b-9028-4073-a6fe-7187fd2cf542", "fitness": 0.0924164133583466, "name": "EnhancedAdaptiveSwarm", "description": "Refined AdvancedAdaptiveSwarm with Adaptive Neighborhood Size and Stochastic Inertia to Enhance Exploration-Exploitation Balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic neighborhood size based on progress\n        neighborhood_size = max(5, int(self.population_size * (1 - self.func_evals / self.budget)))\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.5, 1.0) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = np.random.uniform(0.4, 0.9 - 0.5 * progress)  # Stochastic inertia weight for dynamic adaptation", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09242 with standard deviation 0.00362.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.08739753416083995, 0.09578073183597346, 0.0940709740782264]}}
{"id": "26f86780-4214-452f-8fe9-095acaff5667", "fitness": 0.09482163103106449, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Learning Rate Decay and Neighborhood Search.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.85) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 53, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09482 with standard deviation 0.00098.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09474174014692649, 0.09606431186626208, 0.09365884108000488]}}
{"id": "08890b0e-9d00-48e7-9850-60a3e70a59f0", "fitness": 0.09270971351408445, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm with Dynamic Topology Adjustment and Adaptive Learning Rates for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # initial cognitive component\n        self.c2 = 2.05  # initial social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = max(5, int(self.population_size * 0.2))  # dynamic neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress  # Adaptive learning rate based on progress\n        self.c2 = 1.5 + 1.5 * progress  # Adaptive learning rate based on progress\n        self.w = 0.9 - 0.5 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09271 with standard deviation 0.00088.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09146578126518123, 0.09341476592987796, 0.09324859334719415]}}
{"id": "23600165-30b8-498e-85a6-a2bb16680151", "fitness": 0.09114246946163389, "name": "QuantumHybridSwarm", "description": "Adaptive Quantum-Influenced Particle Swarm with Hybrid Local Search for Dynamic Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass QuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.9\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.quantum_influence(func)\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def quantum_influence(self, func):\n        # Apply quantum influence for further exploration\n        quantum_positions = self.positions + np.random.normal(0, 0.1, self.positions.shape)\n        quantum_positions = np.clip(quantum_positions, self.bounds.lb, self.bounds.ub)\n\n        for i in range(self.population_size):\n            score = func(quantum_positions[i])\n            self.func_evals += 1\n            \n            if score < self.best_scores[i]:\n                self.best_scores[i] = score\n                self.best_positions[i] = quantum_positions[i]\n\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = quantum_positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress", "configspace": "", "generation": 55, "feedback": "The algorithm QuantumHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09114 with standard deviation 0.00197.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09258881468211333, 0.09248074728134392, 0.0883578464214444]}}
{"id": "e27b7b6f-c406-49a8-8121-1b65c0203617", "fitness": 0.09430878378501417, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Velocity Clamping and Dynamic Population Resizing for Enhanced Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n            self.dynamic_population_resizing()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n\n        # Adaptive velocity clamping\n        velocity_clamp_factor = 0.15 * (1 - self.func_evals / self.budget)\n        self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp_factor * (self.bounds.ub - self.bounds.lb), velocity_clamp_factor * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment\n\n    def dynamic_population_resizing(self):\n        # Resize population size dynamically based on convergence and remaining budget\n        if self.func_evals / self.budget < 0.5 and self.population_size < self.budget // 5:\n            self.population_size += 1\n            new_position = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n            new_velocity = np.zeros(self.dim)\n            self.positions = np.vstack([self.positions, new_position])\n            self.velocities = np.vstack([self.velocities, new_velocity])\n            self.best_positions = np.vstack([self.best_positions, new_position])\n            self.best_scores = np.append(self.best_scores, float('inf'))", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09431 with standard deviation 0.00005.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09438470559856937, 0.09426490320007763, 0.09427674255639551]}}
{"id": "c3b4c724-6faa-4f4d-9d9e-b4e8875ab468", "fitness": 0.08744839668201272, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Swarm Algorithm with Adaptive Neighborhood and Dynamic Velocity Control for Improved Global Exploration and Local Exploitation", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.9\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = max(2, min(10, int(np.log(self.population_size))))\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 2.0 * progress  # Slightly more aggressive social component\n        self.w = 0.9 - 0.7 * progress", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08745 with standard deviation 0.00330.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09115595474094296, 0.08313704375424669, 0.08805219155084854]}}
{"id": "3d03bb8b-9628-43ca-84d4-1c1b907d64c1", "fitness": 0.09457402412093412, "name": "EnhancedSynergisticSwarm", "description": "Enhanced Particle Swarm Optimization with Dynamic Subpopulation Synergy and Adaptive Velocity Scaling", "code": "import numpy as np\n\nclass EnhancedSynergisticSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n        self.diversity_threshold = 0.1\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            diversity = self.calculate_diversity()\n            for i in range(self.population_size):\n                self.update_particle(i, func, diversity)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def calculate_diversity(self):\n        mean_position = np.mean(self.positions, axis=0)\n        diversity = np.mean(np.linalg.norm(self.positions - mean_position, axis=1))\n        return diversity\n\n    def update_particle(self, i, func, diversity):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        velocity_scale = 1.0 if diversity > self.diversity_threshold else 0.5\n        self.velocities[i] = (self.w * velocity_scale * self.velocities[i] +\n                              cognitive_component + social_component)\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedSynergisticSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09457 with standard deviation 0.00051.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09501791617597943, 0.0938673086826689, 0.094836847504154]}}
{"id": "fccfd7f2-5546-4ee1-8e77-5841cd8e7ca5", "fitness": 0.09373117328687904, "name": "EnhancedAdaptiveSwarm", "description": "Adaptive Momentum Particle Swarm Optimization with Self-adaptive Exploration-Exploitation Balance for Enhanced Convergence Performance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.momentum = 0.3  # adaptive momentum term\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = (self.w * self.velocities[i] + cognitive_component + \n                              social_component) * (1 - self.momentum)\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), \n                                     0.2 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.4 * progress  # Dynamic inertia weight adjustment\n        self.momentum = 0.5 * np.sin(np.pi * progress)  # Self-adaptive momentum", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09373 with standard deviation 0.00036.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.0935058467704738, 0.094238011460554, 0.09344966162960933]}}
{"id": "767efef7-1a0b-4675-b64e-61d4edfd9779", "fitness": 0.09513608637319308, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced velocity update using adaptive neighborhood size for improved local search.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = max(5, int(0.1 * self.population_size))  # Adapted neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 60, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09514 with standard deviation 0.00069.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09479801004795374, 0.09610042158582977, 0.09450982748579573]}}
{"id": "1d139da5-44e3-4d69-840a-f6b7176936b7", "fitness": 0.09486317886084017, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm with Time-Varying Acceleration Coefficients and Adaptive Neighborhood Size for Improved Convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = min(5 + int(self.func_evals / 100), self.population_size)  # Adjusted neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * np.sin(progress * np.pi)  # Time-varying cognitive coefficient\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 61, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09486 with standard deviation 0.00100.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09487839754444849, 0.09608484565932052, 0.0936262933787515]}}
{"id": "cd87a74c-f586-4676-81e7-a4271acdc3a7", "fitness": 0.09223080811777846, "name": "DiversifiedAdaptiveSwarm", "description": "Diversified Adaptive Swarm Optimization with Dynamic Learning and Adaptive Inertia Weight for Enhanced Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass DiversifiedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.adaptive_parameter_update()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Diversified neighborhood strategy\n        neighbors = np.random.choice(np.delete(np.arange(self.population_size), i), size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighbors[np.argmin(self.best_scores[neighbors])]]\n\n        # Dynamic cognitive and social learning\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        # Adaptive inertia weight\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        # Update position and apply bounds\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def adaptive_parameter_update(self):\n        progress = self.func_evals / self.budget\n        # Dynamic adjustment of cognitive and social components\n        self.c1 = max(1.5, 2.5 - 1.2 * progress)\n        self.c2 = min(2.5, 1.5 + 1.8 * progress)\n        # Adaptive inertia weight\n        self.w = 0.9 - 0.7 * progress", "configspace": "", "generation": 62, "feedback": "The algorithm DiversifiedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09223 with standard deviation 0.00283.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.08828561990854777, 0.09481591183733873, 0.0935908926074489]}}
{"id": "f87378d0-3432-4b02-a464-e8b7f7954660", "fitness": 0.09479714287039247, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization with Dynamic Subpopulation Strategies and Adaptive Learning Rates for Improved Convergence", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 3, 30), self.budget // 8)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # initial cognitive component\n        self.c2 = 2.05  # initial social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        subpop_size = max(5, self.population_size // 4)\n        neighborhood_indices = np.random.choice(self.population_size, size=subpop_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.5, 1.0) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.0 - 1.5 * progress  # Adjust cognitive component over time\n        self.c2 = 1.5 + 2.0 * progress  # Adjust social component over time\n        self.w = 0.8 - 0.5 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09480 with standard deviation 0.00024.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09455608890251599, 0.09471437630984203, 0.09512096339881937]}}
{"id": "05168fe2-4e52-485c-bf52-1c60031ae787", "fitness": 0.09503666673400073, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Particle Swarm with Adaptive Learning Strategies and Momentum Clamping", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.3 * progress\n        self.c2 = 1.5 + 1.7 * progress\n        self.w = 0.9 - 0.6 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 64, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09504 with standard deviation 0.00039.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09451385575693072, 0.09546591415811256, 0.09513023028695888]}}
{"id": "a5512c91-58b3-4dc0-a1a2-d5447c00f7d8", "fitness": 0.08317319759395847, "name": "HybridSwarmDifferentialEvolution", "description": "A hybrid swarm algorithm combining differential evolution with adaptive inertia and neighborhood strategies for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass HybridSwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Differential Evolution Mutation\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.positions[indices]\n        mutant_vector = a + self.F * (b - c)\n        mutant_vector = np.clip(mutant_vector, self.bounds.lb, self.bounds.ub)\n\n        # Crossover\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        trial_vector = np.where(crossover_mask, mutant_vector, self.positions[i])\n\n        # Evaluate trial vector\n        trial_score = func(trial_vector)\n        self.func_evals += 1\n\n        if trial_score < self.best_scores[i]:\n            self.best_scores[i] = trial_score\n            self.best_positions[i] = trial_vector\n\n        if trial_score < self.global_best_score:\n            self.global_best_score = trial_score\n            self.global_best_position = trial_vector\n\n        # PSO Update\n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 65, "feedback": "The algorithm HybridSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08317 with standard deviation 0.00205.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.08250036805866645, 0.08106228157945039, 0.08595694314375857]}}
{"id": "dcd402ae-6253-4a5d-9d8d-485393cd72f8", "fitness": 0.09477242978303473, "name": "AdvancedAdaptiveSwarm", "description": "Introduced a decay factor in the cognitive component for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (1 - self.func_evals / self.budget) * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 66, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09477 with standard deviation 0.00109.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.0948714779800095, 0.0960529050179958, 0.09339290635109887]}}
{"id": "3767c96f-4ac8-4c71-bca1-8fcb24d7c1e2", "fitness": 0.09461363598907642, "name": "AdvancedDynamicNeighborhoodSwarm", "description": "Dynamic Neighborhood and Adaptive Parameter PSO with Randomized Velocity Kick-Start for Enhanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass AdvancedDynamicNeighborhoodSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.7  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Kick-start with random small velocities\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.adaptive_parameter_adjustment()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Dynamic neighborhood size\n        neighborhood_size = np.random.randint(2, 7)\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def adaptive_parameter_adjustment(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.7 - 0.5 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 67, "feedback": "The algorithm AdvancedDynamicNeighborhoodSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09461 with standard deviation 0.00041.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.0941966553338982, 0.09516923085639295, 0.09447502177693812]}}
{"id": "50605d96-5d3e-4ee7-8433-c3c97d8431f2", "fitness": 0.0928809952844003, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced velocity update with adaptive mutation to improve exploration.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        mutation = np.random.normal(0, 0.01, self.dim)  # Add mutation\n        self.velocities[i] = np.clip(self.velocities[i] + mutation, -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 68, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09288 with standard deviation 0.00233.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.08979429928890448, 0.09541890666592678, 0.09342977989836965]}}
{"id": "1a882d8d-f273-4531-906b-aabc6b995c5e", "fitness": 0.09492758036288322, "name": "AdvancedAdaptiveSwarm", "description": "An enhanced particle swarm algorithm with adaptive inertia weight and modified cognitive-sociological balance for improved optimization performance.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=5, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.8 - 1.2 * progress  # Adjusted cognitive component decay\n        self.c2 = 1.2 + 1.8 * progress  # Adjusted social component growth\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 69, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09493 with standard deviation 0.00029.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.094653616204592, 0.09532607105672919, 0.09480305382732845]}}
{"id": "550d1ab4-4242-41b3-9ac4-807ed436194a", "fitness": 0.09375609656359414, "name": "ImprovedHybridSwarm", "description": "Hybrid Particle Swarm Optimization with Dynamic Neighborhood and Adaptive Velocity Clamping for Enhanced Exploration-Exploitation Balance.", "code": "import numpy as np\n\nclass ImprovedHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 3, 30), self.budget // 8)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n        self.vmax = None\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n        self.vmax = 0.2 * (ub - lb)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_indices = np.random.choice(self.population_size, size=7, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = (self.w * self.velocities[i] + cognitive_component + social_component)\n        self.velocities[i] = np.clip(self.velocities[i], -self.vmax, self.vmax)\n\n        self.positions[i] += self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.5 * progress  # Dynamic inertia weight adjustment\n        self.vmax = 0.2 * (1 - progress) * (self.bounds.ub - self.bounds.lb)  # Adaptive velocity clamping", "configspace": "", "generation": 70, "feedback": "The algorithm ImprovedHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09376 with standard deviation 0.00072.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.0928759405173244, 0.09374247665402713, 0.09464987251943091]}}
{"id": "fd2d99af-3e13-49ff-a413-de46355fb6c1", "fitness": 0.08506572272764128, "name": "EnhancedSwarmOptimization", "description": "Particle Swarm Optimization with Adaptive Velocity Clamping and Randomized Neighborhood Exploration for Enhanced Global Search.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = np.random.randint(2, 6)\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        velocity_clamp = 0.1 * (self.bounds.ub - self.bounds.lb) * (0.1 + (0.9 * (self.func_evals / self.budget)))\n        self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress\n        self.w = 0.9 - 0.6 * progress", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08507 with standard deviation 0.00025.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.08521712941635984, 0.08527083866993734, 0.08470920009662664]}}
{"id": "f72477ae-c9c2-442e-b563-d1e52b16874a", "fitness": 0.09389267976345417, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization with Dynamic Neighborhood Size for Improved Balance Between Exploration and Exploitation.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        dynamic_neighborhood_size = max(2, int(self.population_size * (1 - self.func_evals / self.budget)))  # Dynamic neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=dynamic_neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 72, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09389 with standard deviation 0.00237.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09060380577788929, 0.09611960449141166, 0.09495462902106155]}}
{"id": "809ddc74-2b54-4da2-bb7f-88ca2b5a80d1", "fitness": 0.09526089590691596, "name": "AdvancedAdaptiveSwarm", "description": "AdvancedAdaptiveSwarm with Improved Social Component and Adaptive Neighborhood Size for Enhanced Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 73, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09526 with standard deviation 0.00035.", "error": "", "parent_ids": ["e856249b-81a9-49cf-8740-7f7dec7070bb"], "operator": null, "metadata": {"aucs": [0.09512165639568981, 0.09573951676933146, 0.09492151455572662]}}
{"id": "d01063c2-c2e6-406b-b8d4-7ae1782914a9", "fitness": -Infinity, "name": "EnhancedAdaptiveSwarm", "description": "EnhancedAdaptiveSwarm with Dynamic Learning Strategy and Adaptive Inertia Weight for Improved Convergence and Exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1_initial = 2.5  # initial cognitive component\n        self.c2_initial = 1.5  # initial social component\n        self.w_initial = 0.9   # initial inertia weight\n        self.w_final = 0.4     # final inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        # Neighborhood best position based on dynamic adjustment\n        neighborhood_size = 3 + int(5 * (1 - self.func_evals / self.budget))\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        # Dynamic learning strategy\n        progress = self.func_evals / self.budget\n        self.c1 = self.c1_initial - progress\n        self.c2 = self.c2_initial + progress\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.1 * (self.bounds.ub - self.bounds.lb), 0.1 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.w = self.w_initial - (self.w_initial - self.w_final) * progress  # Adaptive inertia weight", "configspace": "", "generation": 74, "feedback": "An exception occurred: AttributeError(\"'EnhancedAdaptiveSwarm' object has no attribute 'w'\").", "error": "AttributeError(\"'EnhancedAdaptiveSwarm' object has no attribute 'w'\")", "parent_ids": ["809ddc74-2b54-4da2-bb7f-88ca2b5a80d1"], "operator": null, "metadata": {}}
{"id": "7c3c077a-169f-405c-b2d6-92cba87fdf46", "fitness": 0.09222226860763656, "name": "EnhancedAdaptiveSwarm", "description": "EnhancedAdaptiveSwarm with Dynamic Learning and Neighborhood Bests for Improved Convergence and Diversity Maintenance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.9\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(4 * self.func_evals / self.budget)  # Dynamic neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])  # Neighborhood best position for social component\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 2.0 * progress\n        self.w = 0.9 - 0.5 * progress  # Adjusted dynamic inertia weight", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09222 with standard deviation 0.00098.", "error": "", "parent_ids": ["809ddc74-2b54-4da2-bb7f-88ca2b5a80d1"], "operator": null, "metadata": {"aucs": [0.09137009241624061, 0.0935935043472742, 0.09170320905939489]}}
{"id": "d592b4ec-0f6a-4b8d-8a6e-7626e6d701a8", "fitness": 0.09177078577196385, "name": "EnhancedAdaptiveSwarm", "description": "EnhancedAdaptiveSwarm with Dynamic Multi-Swarm Strategy and Adaptive Learning Components for Improved Convergence and Exploration.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 3, 30), self.budget // 8)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            num_swarms = max(1, int(self.func_evals / self.budget * 5))  # Adaptive swarming strategy\n            swarm_size = self.population_size // num_swarms\n            \n            for i in range(self.population_size):\n                self.update_particle(i, func, swarm_size)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func, swarm_size):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        neighborhood_indices = np.random.choice(self.population_size, size=swarm_size, replace=False)\n        local_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (local_best_position - self.positions[i])  # Local best position for social component\n\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress\n        self.w = 0.9 - 0.5 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09177 with standard deviation 0.00156.", "error": "", "parent_ids": ["809ddc74-2b54-4da2-bb7f-88ca2b5a80d1"], "operator": null, "metadata": {"aucs": [0.09005826655532956, 0.09383893100783092, 0.09141515975273107]}}
{"id": "c8e5507a-f645-41d3-ade2-3ebc90b268b0", "fitness": 0.09337324830764952, "name": "EnhancedAdaptiveSwarm", "description": "EnhancedAdaptiveSwarm with Improved Adaptive Parameters and Local Search to Balance Exploration and Exploitation More Effectively.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        # Perform a final local search around the global best position\n        self.local_search(func)\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        neighborhood_size = 5 + int(3 * self.func_evals / self.budget)  # More adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + social_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.0 - 1.0 * progress\n        self.c2 = 1.5 + 2.0 * progress\n        self.w = 0.9 - 0.5 * progress  # Dynamic inertia weight adjustment\n\n    def local_search(self, func):\n        # Perform a small perturbation around the global best position\n        perturbation_scale = 0.1\n        for _ in range(5):  # Limited local search iterations\n            perturbation = np.random.normal(0, perturbation_scale, self.dim)\n            candidate_position = self.global_best_position + perturbation\n            candidate_position = np.clip(candidate_position, self.bounds.lb, self.bounds.ub)\n            score = func(candidate_position)\n            self.func_evals += 1\n\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = candidate_position", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09337 with standard deviation 0.00138.", "error": "", "parent_ids": ["809ddc74-2b54-4da2-bb7f-88ca2b5a80d1"], "operator": null, "metadata": {"aucs": [0.0925976260805994, 0.09531652932942747, 0.09220558951292168]}}
{"id": "7d19ab1e-d9b7-4462-9201-942509edcae1", "fitness": 0.09365934237303146, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Swarm Intelligence with Dynamic Cognitive Component and Adaptive Velocity Control for Improved Convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (neighborhood_best_position - self.positions[i])  # Changed to neighborhood best\n        self.velocities[i] = self.w * np.random.uniform(0.5, 1.0) * self.velocities[i] + cognitive_component + social_component  # Updated velocity scaling\n\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))  # Adjusted velocity limit\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 78, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09366 with standard deviation 0.00075.", "error": "", "parent_ids": ["809ddc74-2b54-4da2-bb7f-88ca2b5a80d1"], "operator": null, "metadata": {"aucs": [0.09348533074961651, 0.09464696942560169, 0.09284572694387616]}}
{"id": "9a56eeab-1b75-4245-bbae-797809346cd1", "fitness": 0.09654937976698057, "name": "AdvancedAdaptiveSwarm", "description": "Refined Adaptive Swarm with Enhanced Velocity Update Strategy for Improved Convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + 0.5 * social_component + 0.5 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 79, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09655 with standard deviation 0.00038.", "error": "", "parent_ids": ["809ddc74-2b54-4da2-bb7f-88ca2b5a80d1"], "operator": null, "metadata": {"aucs": [0.09622625152528319, 0.0970844774042382, 0.0963374103714203]}}
{"id": "2ef1e82f-8e56-417e-9c52-d51cc0ac4eb7", "fitness": 0.09590455055297109, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Particle Swarm with Dynamic Neighborhood Influence for Improved Exploration-Exploitation Balance.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        dynamic_social_factor = np.random.uniform(0.3, 0.7)  # Added dynamic factor for social component\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i]) * dynamic_social_factor\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + 0.5 * social_component + 0.5 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 80, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09590 with standard deviation 0.00095.", "error": "", "parent_ids": ["9a56eeab-1b75-4245-bbae-797809346cd1"], "operator": null, "metadata": {"aucs": [0.09492103101057425, 0.09718740808470305, 0.09560521256363597]}}
{"id": "a837501b-b7d6-4130-9861-5765849a7765", "fitness": 0.09653037450345858, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced velocity update and adaptive inertia for improved convergence and exploration.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n        \n        inertia = self.w * np.random.uniform(0.3, 0.7)  # Adjusted inertia multiplier\n        self.velocities[i] = inertia * self.velocities[i] + cognitive_component + 0.4 * social_component + 0.6 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.5 * progress  # Adjusted dynamic inertia weight", "configspace": "", "generation": 81, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09653 with standard deviation 0.00049.", "error": "", "parent_ids": ["9a56eeab-1b75-4245-bbae-797809346cd1"], "operator": null, "metadata": {"aucs": [0.09584618781048171, 0.09698315377967914, 0.0967617819202149]}}
{"id": "81344a64-2227-4d29-a7dc-1e9d4997de77", "fitness": 0.09485474729778225, "name": "DynamicNeighborhoodPSO", "description": "Dynamic Neighborhood-Pso: Enhanced Particle Swarm with Dynamic Neighborhood and Elite Exploitation for Faster Convergence.", "code": "import numpy as np\n\nclass DynamicNeighborhoodPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 5 + int(3 * self.func_evals / self.budget)  # Enhanced Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        \n        exploration_component = np.random.normal(0, 0.1) * (neighborhood_best_position - self.positions[i])\n        \n        self.velocities[i] = (self.w * np.random.uniform(0.4, 0.9) * self.velocities[i] \n                              + cognitive_component + 0.5 * social_component + 0.5 * exploration_component)\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), \n                                     0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 82, "feedback": "The algorithm DynamicNeighborhoodPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09485 with standard deviation 0.00031.", "error": "", "parent_ids": ["9a56eeab-1b75-4245-bbae-797809346cd1"], "operator": null, "metadata": {"aucs": [0.09445403041865996, 0.0949060196981949, 0.09520419177649186]}}
{"id": "bc27ce74-e551-436c-a277-e238a2388651", "fitness": 0.09572875466421109, "name": "MemoryEnrichedAdaptiveSwarm", "description": "Adaptive Particle Swarm Optimization with Progressive Memory Enrichment for Enhanced Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass MemoryEnrichedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.9\n        self.memory = []\n        self.memory_size = 5  # Memory size to store past global best positions\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n        \n        # Memory-based enrichment\n        if self.memory:\n            memory_r = np.random.rand()\n            memory_best_position = self.memory[np.random.choice(len(self.memory))]\n            memory_component = memory_r * (memory_best_position - self.positions[i])\n        else:\n            memory_component = np.zeros(self.dim)\n\n        self.velocities[i] = (self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] \n                              + cognitive_component + 0.5 * social_component \n                              + 0.5 * (neighborhood_best_position - self.positions[i]) \n                              + memory_component)\n        \n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n            self.memory.append(self.global_best_position)\n            if len(self.memory) > self.memory_size:\n                self.memory.pop(0)\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress", "configspace": "", "generation": 83, "feedback": "The algorithm MemoryEnrichedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09573 with standard deviation 0.00050.", "error": "", "parent_ids": ["9a56eeab-1b75-4245-bbae-797809346cd1"], "operator": null, "metadata": {"aucs": [0.09503971576666392, 0.0959535084092048, 0.09619303981676453]}}
{"id": "d2664cbc-ce24-4fbc-86fc-e938de370f6e", "fitness": 0.09538429761298979, "name": "EnhancedDynamicSwarm", "description": "Enhanced Dynamic Swarm Optimization with Adaptive Learning Rates for Accelerated Convergence and Robust Performance.", "code": "import numpy as np\n\nclass EnhancedDynamicSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.0  # initial cognitive component\n        self.c2 = 2.0  # initial social component\n        self.w = 0.8  # initial inertia weight\n        self.alpha = 0.5  # learning rate for position update\n        self.beta = 0.5  # learning rate for velocity update\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component + (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.alpha * self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress\n        self.w = 0.8 - 0.6 * progress\n        self.alpha = 0.5 + 0.4 * progress\n        self.beta = 0.5 + 0.4 * progress", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedDynamicSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09538 with standard deviation 0.00085.", "error": "", "parent_ids": ["9a56eeab-1b75-4245-bbae-797809346cd1"], "operator": null, "metadata": {"aucs": [0.09585640414038599, 0.09418852233540087, 0.09610796636318253]}}
{"id": "5e142fc6-f131-463f-96d7-61898f32c434", "fitness": 0.09629865265288502, "name": "AdvancedAdaptiveSwarm", "description": "Improved convergence by refining velocity update through dynamic neighborhood influence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n        \n        self.velocities[i] = self.w * np.random.uniform(0.4, 0.8) * self.velocities[i] + cognitive_component + 0.5 * social_component + 0.6 * (neighborhood_best_position - self.positions[i])  # Increased neighborhood influence\n        self.velocities[i] = np.clip(self.velocities[i], -0.15 * (self.bounds.ub - self.bounds.lb), 0.15 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.9 - 0.7 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 85, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09630 with standard deviation 0.00046.", "error": "", "parent_ids": ["9a56eeab-1b75-4245-bbae-797809346cd1"], "operator": null, "metadata": {"aucs": [0.09565653303807797, 0.09670245205701433, 0.09653697286356278]}}
{"id": "7998e496-4b58-45c2-88af-4d3eb3107ff1", "fitness": 0.0966167200525958, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced velocity update and dynamic parameter adaptation for improved exploration and convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Modified velocity update\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + 0.6 * cognitive_component + 0.4 * social_component + 0.6 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.88 - 0.65 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 86, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09662 with standard deviation 0.00023.", "error": "", "parent_ids": ["9a56eeab-1b75-4245-bbae-797809346cd1"], "operator": null, "metadata": {"aucs": [0.09671140178836823, 0.09684282528735488, 0.0962959330820643]}}
{"id": "4c8d0a7f-9fc6-4a7a-9245-3cdf487bda25", "fitness": 0.0953705252358606, "name": "EnhancedAdaptiveSwarm", "description": "Introduce hybrid local search with adaptive particle rejuvenation for enhanced diversity and convergence in swarm optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n        self.local_search_intensity = 0.1  # Probability of local search per particle\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n\n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n\n        # Modified velocity update with adaptive rejuvenation\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + 0.6 * cognitive_component + 0.4 * social_component + 0.6 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if np.random.rand() < self.local_search_intensity:\n            self.local_search(i, func)\n\n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def local_search(self, i, func):\n        local_search_steps = int(self.dim * 0.1)\n        for _ in range(local_search_steps):\n            perturbation = np.random.normal(scale=0.1, size=self.dim)\n            candidate_position = self.positions[i] + perturbation\n            candidate_position = np.clip(candidate_position, self.bounds.lb, self.bounds.ub)\n            candidate_score = func(candidate_position)\n            self.func_evals += 1\n\n            if candidate_score < self.best_scores[i]:\n                self.best_scores[i] = candidate_score\n                self.best_positions[i] = candidate_position\n                self.positions[i] = candidate_position\n\n            if candidate_score < self.global_best_score:\n                self.global_best_score = candidate_score\n                self.global_best_position = candidate_position\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.88 - 0.65 * progress  # Dynamic inertia weight adjustment\n        self.local_search_intensity = 0.1 * (1 - progress)  # Decreases as we progress", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09537 with standard deviation 0.00074.", "error": "", "parent_ids": ["7998e496-4b58-45c2-88af-4d3eb3107ff1"], "operator": null, "metadata": {"aucs": [0.09433906570297101, 0.0960585120800942, 0.09571399792451663]}}
{"id": "ed0283f4-3049-479b-a372-57283464b3c3", "fitness": 0.09660378270887704, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Adaptive Neighborhood and Velocity Update for Improved Convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 4 + int(3 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Modified velocity update\n        self.velocities[i] = self.w * np.random.uniform(0.6, 0.95) * self.velocities[i] + 0.7 * cognitive_component + 0.3 * social_component + 0.5 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.88 - 0.65 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 88, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09660 with standard deviation 0.00041.", "error": "", "parent_ids": ["7998e496-4b58-45c2-88af-4d3eb3107ff1"], "operator": null, "metadata": {"aucs": [0.09618655481663319, 0.09716225918198895, 0.09646253412800898]}}
{"id": "9ec7190e-09c4-4310-834b-6e7f086ad610", "fitness": 0.09564658528558068, "name": "AdvancedAdaptiveSwarm", "description": "Introduced adaptive mutation and improved cognitive-social balance for enhanced convergence and exploration.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Modified velocity update\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + 0.5 * cognitive_component + 0.5 * social_component + 0.6 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        # Adaptive mutation\n        mutation_factor = 0.1 * (1 - self.func_evals / self.budget)\n        mutated_position = self.positions[i] + np.random.normal(0, mutation_factor, self.dim)\n\n        self.positions[i] = mutated_position + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.88 - 0.65 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 89, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09565 with standard deviation 0.00066.", "error": "", "parent_ids": ["7998e496-4b58-45c2-88af-4d3eb3107ff1"], "operator": null, "metadata": {"aucs": [0.09613901474802344, 0.09471783002754575, 0.09608291108117284]}}
{"id": "92fbd9d0-544a-4ae9-8fbb-9f57904273ad", "fitness": 0.09675853084718204, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced swarm strategy with dynamic learning factors for improved convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Modified velocity update\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + 0.7 * cognitive_component + 0.3 * social_component + 0.6 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.88 - 0.65 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 90, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09676 with standard deviation 0.00031.", "error": "", "parent_ids": ["7998e496-4b58-45c2-88af-4d3eb3107ff1"], "operator": null, "metadata": {"aucs": [0.0964200463663678, 0.09716826700946724, 0.09668727916571107]}}
{"id": "6a09636b-22dd-4d57-9986-249416f7cfbe", "fitness": 0.09630496585285302, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced swarm strategy with adaptive local exploration and progressive velocity scaling for superior convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Progressive velocity scaling and local exploration\n        velocity_scaling_factor = (1 - self.func_evals / self.budget)\n        self.velocities[i] = (self.w * np.random.uniform(0.5, 1.0) * self.velocities[i] + \n                              0.7 * cognitive_component + \n                              0.3 * social_component + \n                              0.4 * (neighborhood_best_position - self.positions[i]) * velocity_scaling_factor)\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.88 - 0.65 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09630 with standard deviation 0.00094.", "error": "", "parent_ids": ["92fbd9d0-544a-4ae9-8fbb-9f57904273ad"], "operator": null, "metadata": {"aucs": [0.09520239629061988, 0.0974936847784369, 0.09621881648950226]}}
{"id": "99718d5c-dec2-49ec-bd06-60ce8cf11286", "fitness": 0.09649765652131077, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced swarm strategy with adaptive neighborhood learning and dynamic velocity control for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(3 * self.func_evals / self.budget)  # More adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i]) \n\n        # Modified velocity update with dynamic control\n        inertia_component = self.w * self.velocities[i] * (0.5 + 0.5 * np.random.rand())\n        neighborhood_component = 0.6 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = inertia_component + 0.7 * cognitive_component + 0.3 * social_component + neighborhood_component\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 2.0 * progress\n        self.w = 0.9 - 0.4 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09650 with standard deviation 0.00049.", "error": "", "parent_ids": ["92fbd9d0-544a-4ae9-8fbb-9f57904273ad"], "operator": null, "metadata": {"aucs": [0.09647905920456945, 0.0971069532337373, 0.09590695712562558]}}
{"id": "bd82b6c4-af5f-48e0-a4ea-f241b7a35381", "fitness": 0.09650756025993039, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced swarm strategy with adaptive personal and social learning factors, incorporating neighborhood-based velocity adjustment for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(3 * self.func_evals / self.budget)  # More adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Modified velocity update\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + 0.6 * cognitive_component + 0.4 * social_component + 0.5 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.2 * progress  # More aggressive adaptation\n        self.c2 = 1.5 + 1.8 * progress\n        self.w = 0.88 - 0.65 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09651 with standard deviation 0.00042.", "error": "", "parent_ids": ["92fbd9d0-544a-4ae9-8fbb-9f57904273ad"], "operator": null, "metadata": {"aucs": [0.09621867670640039, 0.09709785786730163, 0.09620614620608914]}}
{"id": "24190018-398e-4497-a5cc-b441619834c3", "fitness": 0.09601479542193465, "name": "HybridAdaptiveSwarm", "description": "Hybrid Swarm with Adaptive Neighborhood and Elite Learning (enhanced particle update using elite leader for diverse exploration and exploitation).", "code": "import numpy as np\n\nclass HybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n        self.elite_leader = None\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Calculate elite leader\n        elite_leader_idx = np.random.choice(neighborhood_indices)\n        self.elite_leader = self.positions[elite_leader_idx]\n        elite_component = 0.5 * np.random.rand() * (self.elite_leader - self.positions[i])\n\n        # Modified velocity update\n        self.velocities[i] = (self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + 0.5 * cognitive_component + \n                              0.3 * social_component + 0.6 * (neighborhood_best_position - self.positions[i]) + elite_component)\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.88 - 0.65 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 94, "feedback": "The algorithm HybridAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09601 with standard deviation 0.00091.", "error": "", "parent_ids": ["92fbd9d0-544a-4ae9-8fbb-9f57904273ad"], "operator": null, "metadata": {"aucs": [0.09481679006559296, 0.09619563857621416, 0.09703195762399686]}}
{"id": "26293a85-c31d-40cc-993e-6e0ace033d50", "fitness": 0.09644135604663, "name": "AdvancedAdaptiveSwarm", "description": "Adaptive swarm optimization with enhanced inertia and local search for faster convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w = 0.9\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n\n        # Modified velocity update\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + 0.5 * cognitive_component + 0.5 * social_component + 0.6 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.85 - 0.65 * progress  # Adjusted inertia weight start", "configspace": "", "generation": 95, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09644 with standard deviation 0.00041.", "error": "", "parent_ids": ["92fbd9d0-544a-4ae9-8fbb-9f57904273ad"], "operator": null, "metadata": {"aucs": [0.09596336019484175, 0.09696990063448963, 0.0963908073105586]}}
{"id": "7b18a506-3dd9-4a90-aed0-5154cb42cebd", "fitness": 0.09583337471831388, "name": "AdvancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm with improved local search exploitation using a dynamic deceleration factor.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Modified velocity update\n        deceleration_factor = 0.5 + 0.5 * (self.func_evals / self.budget)  # Dynamic deceleration factor\n        self.velocities[i] = self.w * deceleration_factor * self.velocities[i] + 0.7 * cognitive_component + 0.3 * social_component + 0.6 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.88 - 0.65 * progress  # Dynamic inertia weight adjustment", "configspace": "", "generation": 96, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09583 with standard deviation 0.00033.", "error": "", "parent_ids": ["92fbd9d0-544a-4ae9-8fbb-9f57904273ad"], "operator": null, "metadata": {"aucs": [0.09570677815318163, 0.09551165429935471, 0.0962816917024053]}}
{"id": "0f739b4a-de76-48f5-b666-1ab645c9114e", "fitness": 0.09663810840405611, "name": "OptimizedAdaptiveSwarm", "description": "Optimized Adaptive Swarm with nonlinear inertia reduction and adaptive neighborhood influence for faster convergence.", "code": "import numpy as np\n\nclass OptimizedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Modified velocity update\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + 0.6 * cognitive_component + 0.4 * social_component + 0.6 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        # Nonlinear inertia weight reduction\n        self.w = 0.88 * (1 - progress**2) ", "configspace": "", "generation": 97, "feedback": "The algorithm OptimizedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09664 with standard deviation 0.00033.", "error": "", "parent_ids": ["92fbd9d0-544a-4ae9-8fbb-9f57904273ad"], "operator": null, "metadata": {"aucs": [0.09636418355076304, 0.0971038556665762, 0.09644628599482907]}}
{"id": "8f72f28d-6dd7-493b-a2db-8a53bc4831e1", "fitness": 0.0931846423558107, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm with local search enhancement and adaptive inertia decay for precise exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Slight initial velocity\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)  # Adaptive neighborhood size\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])  # Global best position for social component\n\n        # Adjust velocity update with adaptive inertia decay\n        inertia = (0.5 + 0.5 * np.tanh((self.budget - self.func_evals) / self.budget))\n        \n        self.velocities[i] = inertia * self.velocities[i] + 0.7 * cognitive_component + 0.3 * social_component + 0.4 * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.2 * (self.bounds.ub - self.bounds.lb), 0.2 * (self.bounds.ub - self.bounds.lb))\n\n        # Update position with slight randomness for local search enhancement\n        perturbation = np.random.normal(0, 0.01, self.dim)\n        self.positions[i] = self.positions[i] + self.velocities[i] + perturbation\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.5 - 1.5 * progress\n        self.c2 = 1.5 + 1.5 * progress\n        self.w = 0.9 - 0.5 * progress  # More gradual inertia weight adjustment", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09318 with standard deviation 0.00177.", "error": "", "parent_ids": ["92fbd9d0-544a-4ae9-8fbb-9f57904273ad"], "operator": null, "metadata": {"aucs": [0.09285982494483125, 0.09549164748582994, 0.0912024546367709]}}
{"id": "f91eb93e-f03f-414c-a8b4-9e5771034e79", "fitness": 0.09478085374334184, "name": "ChaoticAdaptiveSwarm", "description": "Integrating chaotic maps with adaptive learning factors in a swarm optimization strategy for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass ChaoticAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(max(dim * 2, 20), self.budget // 10)\n        self.positions = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.c1 = 2.05  # cognitive component\n        self.c2 = 2.05  # social component\n        self.w = 0.9  # initial inertia weight\n        self.bounds = None\n        self.func_evals = 0\n\n    def initialize(self, bounds):\n        self.bounds = bounds\n        lb, ub = bounds.lb, bounds.ub\n        self.positions = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.best_positions = np.copy(self.positions)\n        self.best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.full(self.dim, (ub + lb) / 2)\n\n    def __call__(self, func):\n        self.initialize(func.bounds)\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.update_particle(i, func)\n\n            self.update_parameters()\n\n        return self.global_best_position, self.global_best_score\n\n    def logistic_map(self, x):\n        # Logistic map for chaotic sequence generation\n        return 4 * x * (1 - x)\n\n    def update_particle(self, i, func):\n        chaos_factor = self.logistic_map(np.random.rand())  # Chaotic factor\n        r1, r2 = np.random.rand(), np.random.rand()\n        \n        neighborhood_size = 3 + int(2 * self.func_evals / self.budget)\n        neighborhood_indices = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n        neighborhood_best_position = self.best_positions[neighborhood_indices[np.argmin(self.best_scores[neighborhood_indices])]]\n\n        cognitive_component = self.c1 * r1 * (self.best_positions[i] - self.positions[i])\n        social_component = self.c2 * r2 * (self.global_best_position - self.positions[i])\n\n        self.velocities[i] = self.w * np.random.uniform(0.5, 0.9) * self.velocities[i] + 0.7 * cognitive_component + 0.3 * social_component + 0.6 * chaos_factor * (neighborhood_best_position - self.positions[i])\n        self.velocities[i] = np.clip(self.velocities[i], -0.18 * (self.bounds.ub - self.bounds.lb), 0.18 * (self.bounds.ub - self.bounds.lb))\n\n        self.positions[i] = self.positions[i] + self.velocities[i]\n        self.positions[i] = np.clip(self.positions[i], self.bounds.lb, self.bounds.ub)\n\n        score = func(self.positions[i])\n        self.func_evals += 1\n        \n        if score < self.best_scores[i]:\n            self.best_scores[i] = score\n            self.best_positions[i] = self.positions[i]\n\n        if score < self.global_best_score:\n            self.global_best_score = score\n            self.global_best_position = self.positions[i]\n\n    def update_parameters(self):\n        progress = self.func_evals / self.budget\n        self.c1 = 2.4 - 1.1 * progress\n        self.c2 = 1.6 + 1.7 * progress\n        self.w = 0.88 - 0.65 * progress", "configspace": "", "generation": 99, "feedback": "The algorithm ChaoticAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09478 with standard deviation 0.00314.", "error": "", "parent_ids": ["92fbd9d0-544a-4ae9-8fbb-9f57904273ad"], "operator": null, "metadata": {"aucs": [0.09033560156470977, 0.0970217281718121, 0.09698523149350369]}}
