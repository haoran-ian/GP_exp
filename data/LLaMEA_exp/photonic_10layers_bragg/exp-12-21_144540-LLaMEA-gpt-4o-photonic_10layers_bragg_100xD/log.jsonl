{"id": "5e33a622-5c00-4b29-a26e-65fcf9cdaa9e", "fitness": 0.07863321582580225, "name": "AdaptiveMemorySearch", "description": "Adaptive Memory Search (AMS) - A metaheuristic that adaptively combines global exploration and local exploitation using a memory-based strategy to dynamically adjust search patterns based on past performance.", "code": "import numpy as np\n\nclass AdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size for storing best solutions\n        self.memory = []  # To store the best solutions found so far\n        self.iteration = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Explore around the selected memory solution\n            candidate_solution = self._explore(memory_solution, lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Select a random memory entry\n        idx = np.random.randint(len(self.memory))\n        return self.memory[idx]\n\n    def _explore(self, base_solution, lb, ub):\n        # Generate a candidate solution by perturbing the base solution\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim) * (ub - lb)\n        candidate_solution = base_solution + perturbation\n        # Ensure the solution is within bounds\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        # Add the solution to memory, maintaining memory size\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort memory by objective value\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()  # Remove the worst solution if memory is full", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07863 with standard deviation 0.00799.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.08241922199361451, 0.08595849784844622, 0.06752192763534604]}}
{"id": "ee56ecee-5bff-41c4-a05a-35fce2c828ef", "fitness": 0.09091057459423535, "name": "DynamicAdaptiveMemorySearch", "description": "Dynamic Adaptive Memory Search (DAMS) - An enhanced version of AMS that dynamically adjusts memory exploration and exploitation rates based on real-time performance feedback to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass DynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Adjust exploration/exploitation strategy\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Explore around the selected memory solution\n            candidate_solution = self._explore(memory_solution, lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _explore(self, base_solution, lb, ub):\n        # Dynamic perturbation based on adaptivity_rate\n        perturbation = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = base_solution + perturbation\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 1, "feedback": "The algorithm DynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09091 with standard deviation 0.00300.", "error": "", "parent_ids": ["5e33a622-5c00-4b29-a26e-65fcf9cdaa9e"], "operator": null, "metadata": {"aucs": [0.08674418440220621, 0.0936837594968768, 0.09230377988362304]}}
{"id": "8f42d0ff-6daf-427d-a0e3-a914e90297ae", "fitness": 0.08453472485499218, "name": "AdaptiveMemorySearchWithSelfTuning", "description": "Adaptive Memory Search with Self-Tuning Exploration - An enhanced dynamic memory search algorithm that automatically adjusts exploration and exploitation rates based on improvements in solution quality, optimizing convergence speed and robustness.", "code": "import numpy as np\n\nclass AdaptiveMemorySearchWithSelfTuning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.exploration_rate = 0.1  # Initial exploration rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Adjust exploration rate dynamically\n            improvement = max(0, best_value - memory_value)\n            self.exploration_rate = min(0.5, self.exploration_rate + 0.01 * improvement)\n\n            # Explore around the selected memory solution\n            candidate_solution = self._explore(memory_solution, lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on exploration_rate\n        probabilities = np.array([1.0 if i == 0 else self.exploration_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _explore(self, base_solution, lb, ub):\n        # Dynamic perturbation based on exploration_rate\n        perturbation = np.random.uniform(-self.exploration_rate, self.exploration_rate, self.dim) * (ub - lb)\n        candidate_solution = base_solution + perturbation\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveMemorySearchWithSelfTuning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08453 with standard deviation 0.00596.", "error": "", "parent_ids": ["ee56ecee-5bff-41c4-a05a-35fce2c828ef"], "operator": null, "metadata": {"aucs": [0.07786381325506897, 0.09232739779995947, 0.08341296350994809]}}
{"id": "b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31", "fitness": 0.09382061496112622, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Quantum-Inspired Dynamic Adaptive Memory Search (QI-DAMS) - Integrates quantum-inspired superposition and entanglement strategies into DAMS to enhance exploration and exploitation by probabilistically generating diverse solutions from memory.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 3, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09382 with standard deviation 0.00076.", "error": "", "parent_ids": ["ee56ecee-5bff-41c4-a05a-35fce2c828ef"], "operator": null, "metadata": {"aucs": [0.09315317884230967, 0.09343057574724978, 0.09487809029381922]}}
{"id": "8bbbc0d4-0b7c-4e2c-acbc-94d66dc2c2c3", "fitness": -Infinity, "name": "EnhancedQuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Adaptive Memory Search (EQI-DAMS) - Augments QI-DAMS with adaptive entanglement scaling and diversity-driven memory management to boost search efficiency and convergence speed. ", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.entanglement_scale = 1.0  # Initialize entanglement scale\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Adjust entanglement scale based on progress\n            self.entanglement_scale *= (0.99 + 0.01 * (1 - best_value / (memory_value + 1e-9)))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        total_values = np.array([value for _, value in self.memory])\n        probabilities = np.exp(-total_values / self.adaptivity_rate)\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate * self.entanglement_scale, \n                                         self.adaptivity_rate * self.entanglement_scale, \n                                         self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            diversity_index = np.argmax(\n                [np.std([pair[0] for pair in self.memory], axis=0).sum() for _ in self.memory]\n            )\n            self.memory.pop(diversity_index)", "configspace": "", "generation": 4, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {}}
{"id": "56e4539d-8b96-4f9a-bdc8-978a4c3f1922", "fitness": 0.09202406225173683, "name": "QuantumInspiredEnhancedMemorySearch", "description": "Quantum-Inspired Enhanced Memory Search (QI-EMS) - Enhances QI-DAMS by introducing variable memory size adaptation and multi-level quantum exploration to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass QuantumInspiredEnhancedMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = max(5, min(20, dim // 2))  # Adaptive memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Multi-level Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub, 2)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub, levels):\n        # Multi-level quantum superposition to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        candidate_solution = superposition\n        for level in range(levels):\n            entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n            candidate_solution = candidate_solution + entanglement / (level + 1)\n            candidate_solution = np.clip(candidate_solution, lb, ub)\n        return candidate_solution\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 5, "feedback": "The algorithm QuantumInspiredEnhancedMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09202 with standard deviation 0.00195.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.08943379766322868, 0.0924908907423484, 0.09414749834963343]}}
{"id": "2dd8ea3d-d830-4cac-b002-940e288ef714", "fitness": 0.09223520647806871, "name": "EnhancedQuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Adaptive Memory Search (E-QI-DAMS) - Introduces adaptive memory size and a more dynamic exploration strategy using modified quantum superposition for improved solution diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.dynamic_memory_scaling_factor = 0.5  # New scaling factor for memory\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n            # Adapt dynamic memory size\n            self.memory_size = min(max(5, int(self.dynamic_memory_scaling_factor * self.iteration)), 20)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition and dynamic exploration to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + 1.5 * entanglement  # Increased exploration\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedQuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09224 with standard deviation 0.00123.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.0920418303939774, 0.09083108847782684, 0.0938327005624019]}}
{"id": "e2533132-0e29-4367-a30a-bb560c779c7d", "fitness": 0.09376198686670933, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Adaptive Quantum Memory Search (EAQMS) - Incorporates adaptive mutation scaling and memory diversity reinforcement to improve exploration and convergence efficiency.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with adaptive scaling\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with diversity control\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate * 2, self.adaptivity_rate * 2, self.dim) * (ub - lb)  # Changed scaling factor\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n        if len(self.memory) > 1 and np.allclose(self.memory[0][0], self.memory[-1][0]):\n            self.memory[-1] = (np.random.uniform(lb, ub, self.dim), float('inf'))  # Reinforce diversity", "configspace": "", "generation": 7, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09376 with standard deviation 0.00098.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.09333383520183369, 0.09511544492995727, 0.09283668046833704]}}
{"id": "cece924f-cfba-4eec-bbd9-1caa3df19c81", "fitness": 0.09359129719261512, "name": "QuantumInspiredStochasticDifferentialExplorationExploitation", "description": "Quantum-Inspired Stochastic Differential Exploration and Exploitation (QI-SDEE) - Enhances exploration and exploitation through stochastic differential equations to refine search dynamics and balance adaptivity, leveraging quantum-inspired principles to create a more dynamic and responsive search process.", "code": "import numpy as np\n\nclass QuantumInspiredStochasticDifferentialExplorationExploitation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.sde_step_size = 0.05  # Step size for stochastic differential exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._sde_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _sde_explore(self, lb, ub):\n        # Apply stochastic differential equations for exploration\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        noise = np.random.normal(0, self.sde_step_size, self.dim)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + noise + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 8, "feedback": "The algorithm QuantumInspiredStochasticDifferentialExplorationExploitation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09359 with standard deviation 0.00110.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.09212000234703355, 0.09389954587738647, 0.09475434335342536]}}
{"id": "3bc1009d-b035-4f59-9a74-2127ed0ba9d8", "fitness": 0.0929276527809294, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Refined QI-DAMS by adjusting memory selection probability to enhance diversity.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate * np.exp(-i) for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 9, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09293 with standard deviation 0.00089.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.09180138773699198, 0.09301242769678875, 0.09396914290900749]}}
{"id": "6a94ac6d-3bd9-4db2-9526-a72c212854d6", "fitness": -Infinity, "name": "EnhancedQuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Adaptive Memory Search (EQI-DAMS) - Introduces adaptive memory size scaling and hybrid quantum-classical exploration to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize memory with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = 0.1 + 0.2 * (best_value - memory_value) / (abs(best_value) + 1e-8)\n\n            # Hybrid quantum-classical exploration\n            if np.random.rand() < self.adaptivity_rate:\n                candidate_solution = self._quantum_explore(lb, ub)\n            else:\n                candidate_solution = self._classical_explore(memory_solution, lb, ub)\n            \n            candidate_value = func(candidate_solution)\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n            # Dynamically adjust memory size based on progress\n            self.memory_size = max(5, int((1 - best_value / (abs(best_value) + 1e-8)) * 10))\n            self.memory = self.memory[:self.memory_size]\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _classical_explore(self, base_solution, lb, ub):\n        perturbation = np.random.normal(0, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = base_solution + perturbation\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 10, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {}}
{"id": "32cc5fbb-d121-4491-8fac-0fa222eb2288", "fitness": 0.09338772938081352, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced QI-DAMS with adaptive memory and dynamic exploration for improved solution diversity.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.normal(0, self.adaptivity_rate, self.dim) * (ub - lb)  # Changed to normal distribution\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 11, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09339 with standard deviation 0.00054.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.09262363136946827, 0.09379477084955112, 0.09374478592342117]}}
{"id": "d9fc07a9-03ca-4f74-99e6-0eb3bd2686c9", "fitness": 0.09289808072753976, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Refined QI-DAMS with adjusted initial adaptivity rate for improved exploration-exploitation synergy.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.2  # Adjusted initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 12, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09290 with standard deviation 0.00105.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.09237485167921011, 0.09435888710089924, 0.09196050340250994]}}
{"id": "38eaeaef-5eae-4848-a556-c278922391dc", "fitness": -Infinity, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced QI-DAMS with adaptive memory size and diversification strategy for improved exploration and exploitation.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Increase adaptivity_rate more effectively\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.02 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop(0)  # Remove the oldest entry for diversification", "configspace": "", "generation": 13, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {}}
{"id": "957e4f56-32b3-47fa-8f3c-c7d99d7072e4", "fitness": -Infinity, "name": "EnhancedQuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Adaptive Memory Search (EQI-DAMS) - Introduces adaptive quantum exploration using variance-based strategies and dynamic memory resizing for improved convergence and diversity maintenance.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Initial memory size\n        self.memory = []  # Store solutions and their fitness\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with adaptive variance\n            candidate_solution = self._adaptive_quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory and adjust memory size dynamically\n            self._update_memory(candidate_solution, candidate_value)\n            self._adjust_memory_size()\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _adaptive_quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        variance = np.var([sol for sol, _ in self.memory], axis=0)\n        adaptive_variance = np.maximum(variance, 0.1 * (ub - lb))\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * adaptive_variance\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n\n    def _adjust_memory_size(self):\n        # Dynamically adjust memory size based on performance\n        if len(self.memory) > 2 and self.memory[-1][1] > self.memory[-2][1]:\n            self.memory_size = max(5, int(self.memory_size * 0.9))\n        elif self.iteration > self.budget / 2 and len(self.memory) < self.memory_size:\n            self.memory_size = min(20, self.memory_size + 1)", "configspace": "", "generation": 14, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {}}
{"id": "05b442e5-50ed-4b00-997e-aee4fb1588ea", "fitness": 0.08705378212691613, "name": "EnhancedQuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Adaptive Memory Search (EQI-DAMS) - Utilizes adaptive quantum-inspired exploration with dynamic memory prioritization to more effectively balance exploration and exploitation, aiming to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Dynamic prioritization in memory selection\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Adaptive exploration strategy\n            self.adaptivity_rate = max(0.01, min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value)))\n\n            # Quantum-inspired exploration with adaptive variance\n            candidate_solution = self._quantum_explore(lb, ub, memory_solution)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Dynamic prioritization: prefer better solutions adaptively\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub, base_solution):\n        # Generate candidate with adaptive variance around a base solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.normal(0, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = base_solution + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedQuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08705 with standard deviation 0.00316.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.08774665451139863, 0.09053582010421712, 0.08287887176513264]}}
{"id": "e34ce03b-fd4e-44d2-b8ed-c2b64f3c6ccd", "fitness": 0.05818764494738208, "name": "EnhancedQuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Adaptive Memory Search (QEDAMS) - Introduces adaptive quantum superposition and entanglement scaling, alongside dynamic memory resizing based on convergence speed to enhance exploration and exploitation balance for improved solution discovery.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.convergence_rate = 0.01\n        self.successful_iterations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n            self.convergence_rate = 0.5 * (np.log1p(self.iteration) / self.budget)\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n                self.successful_iterations += 1\n\n            self._update_memory(candidate_solution, candidate_value)\n            self._dynamically_resize_memory()\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb) * self.convergence_rate\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n\n    def _dynamically_resize_memory(self):\n        if self.successful_iterations > self.memory_size and len(self.memory) < 2 * self.memory_size:\n            self.memory_size += 1\n            self.successful_iterations = 0", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedQuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05819 with standard deviation 0.01402.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.04333052111963931, 0.05423644017440521, 0.07699597354810173]}}
{"id": "3d21bdf8-288e-4f8a-a4de-a7c45827ccd7", "fitness": -Infinity, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Adaptive Memory Search (eQI-DAMS) - Refines adaptivity rate adjustment and memory update strategy for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.02 * (best_value - memory_value) / best_value)\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory = self.memory[:self.memory_size]", "configspace": "", "generation": 17, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {}}
{"id": "12bfc98b-bf64-44f0-826c-9aa76059403f", "fitness": 0.06057429852209506, "name": "QuantumInspiredAdaptiveMemorySearchWithGradientEstimation", "description": "Quantum-Inspired Adaptive Memory Search with Gradient Estimation (QI-AMSGE) - Enhances QI-DAMS by incorporating gradient estimation to refine candidate solutions and improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass QuantumInspiredAdaptiveMemorySearchWithGradientEstimation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with gradient estimation\n            candidate_solution = self._quantum_explore_with_gradient(lb, ub, func, memory_solution)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore_with_gradient(self, lb, ub, func, base_solution):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n\n        # Gradient estimation for refinement\n        eps = 1e-8\n        gradient = np.zeros(self.dim)\n        for i in range(self.dim):\n            perturb = np.zeros(self.dim)\n            perturb[i] = eps\n            gradient[i] = (func(np.clip(base_solution + perturb, lb, ub)) - func(np.clip(base_solution - perturb, lb, ub))) / (2 * eps)\n\n        refined_solution = candidate_solution - self.adaptivity_rate * gradient\n        return np.clip(refined_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 18, "feedback": "The algorithm QuantumInspiredAdaptiveMemorySearchWithGradientEstimation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06057 with standard deviation 0.01106.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.05863229358559785, 0.04810973256266382, 0.07498086941802351]}}
{"id": "a13caf33-b532-4e93-a1bc-268b4efba5a2", "fitness": 0.05924218078118393, "name": "QuantumInspiredDynamicAdaptiveMemorySearchWithAdaptiveQuantumExploration", "description": "Quantum-Inspired Dynamic Adaptive Memory Search with Adaptive Quantum Exploration (QI-DAMS-AQE) - Enhances QI-DAMS by incorporating dynamically adjusted quantum exploration parameters to balance exploration and exploitation based on convergence rate.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearchWithAdaptiveQuantumExploration:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.convergence_rate = 1.0  # Start with a high convergence rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on convergence rate\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * self.convergence_rate)\n\n            # Quantum-inspired exploration with dynamically adjusted parameters\n            candidate_solution = self._adaptive_quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n                # Update convergence rate\n                self.convergence_rate = 1.0 - (candidate_value / (best_value + 1e-9))\n            else:\n                # Decrease convergence rate when no improvement\n                self.convergence_rate *= 0.99\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _adaptive_quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        dynamic_range = (ub - lb) * self.convergence_rate\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * dynamic_range\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 19, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearchWithAdaptiveQuantumExploration got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05924 with standard deviation 0.01257.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.04976173864229916, 0.05095348151703205, 0.07701132218422058]}}
{"id": "0297efb3-f299-4ba1-98a8-87ba5716277d", "fitness": 0.09461659865539633, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Quantum-Inspired Dynamic Adaptive Memory Search (QI-DAMS) with Stochastic Adaptive Memory Strategy - Enhances the adaptivity by introducing stochastic adjustments in memory selection and control over exploration-exploitation balance.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [np.random.rand() if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])  # Line changed\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 20, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09462 with standard deviation 0.00049.", "error": "", "parent_ids": ["b1a4f7e2-9b9d-4d25-bab8-fe5d18b57f31"], "operator": null, "metadata": {"aucs": [0.09433471716388486, 0.0942046446793825, 0.09531043412292162]}}
{"id": "b3ecee4f-c28d-447a-b7fc-08b3eead0569", "fitness": 0.05769804634365335, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Memory Search with Adaptive Exploration Dynamics - Refines exploration by adjusting quantum entanglement based on solution diversity and enriches memory selection through a more data-driven approach.  ", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with diversity consideration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        fitness_scores = np.array([1.0 / (1.0 + val) for _, val in self.memory])\n        probabilities = fitness_scores / fitness_scores.sum()  # Updated line\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        diversity_factor = np.std([sol for sol, _ in self.memory], axis=0)  # Updated line\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * diversity_factor\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 21, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05770 with standard deviation 0.01310.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.04685423664503807, 0.050108515240080864, 0.07613138714584111]}}
{"id": "ffc7834b-74a3-4b59-b5dd-04bd78a76573", "fitness": -Infinity, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced QI-DAMS with Intelligent Memory Replacement - Incorporates an intelligent memory replacement strategy to retain diverse, high-quality solutions for improved convergence.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [np.random.rand() if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])  # Line changed\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            # Replace a random worse solution instead of the worst\n            self.memory.pop(np.random.randint(self.memory_size // 2, self.memory_size))  # Line changed", "configspace": "", "generation": 22, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {}}
{"id": "b64a42ed-cd74-4824-8bb8-900aa4d04d59", "fitness": 0.043210245285951555, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Adaptive Memory Search with Dynamic Entanglement Control - Improves exploration by dynamically adjusting entanglement based on objective variance and convergence trends.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(15, dim)  # Increased memory size for better diversity\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Quantum-inspired exploration with dynamic entanglement control\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with probability based on adaptivity_rate\n        scores = np.array([val for _, val in self.memory])\n        probabilities = np.exp(-self.adaptivity_rate * (scores - scores.min()) / (scores.max() - scores.min() + 1e-9))\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        # Dynamic entanglement based on memory variance\n        variance = np.var([val for _, val in self.memory])\n        dynamic_entanglement = (1.0 / (1.0 + variance)) * (ub - lb) * np.random.uniform(-1, 1, self.dim)\n        candidate_solution = superposition + dynamic_entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04321 with standard deviation 0.00477.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.041239778863945586, 0.03861030669064491, 0.04978065030326417]}}
{"id": "4f143cdd-470f-4835-8ca1-16f3f9434dc4", "fitness": 0.08437806559964207, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced QI-DAMS by refining memory selection with adaptive probabilistic distribution and optimizing quantum exploration step size.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array([1.0 / (i + 1) for i in range(len(self.memory))]) ** self.adaptivity_rate  # Line changed\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-0.5 * self.adaptivity_rate, 0.5 * self.adaptivity_rate, self.dim) * (ub - lb)  # Line changed\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 24, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08438 with standard deviation 0.00833.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.08394050261991992, 0.07439916282756542, 0.09479453135144089]}}
{"id": "1caeebd3-095f-459d-9d39-96a6286bbb6a", "fitness": 0.09372044718192803, "name": "EnhancedQuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Adaptive Memory Search (EQI-DAMS) with Hierarchical Memory Structuring and Adaptive Quantum Entanglement - Improves memory handling by introducing hierarchical layers and refines exploration with dynamically adjusted quantum entanglement based on convergence stages.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.primary_memory_size = min(10, dim)\n        self.secondary_memory_size = min(20, 2 * dim)\n        self.primary_memory = []  # High-quality solutions\n        self.secondary_memory = []  # Diverse solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.primary_memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.primary_memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from primary memory for exploitation\n            memory_solution, memory_value = self._select_from_primary_memory()\n\n            # Update adaptivity rate based on convergence\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with dynamic entanglement\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_primary_memory(self):\n        probabilities = np.array([1 / (i + 1) for i in range(len(self.primary_memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.primary_memory), p=probabilities)\n        return self.primary_memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        if len(self.secondary_memory) > 0:\n            superposition = np.mean([sol for sol, _ in self.secondary_memory], axis=0)\n        else:\n            superposition = np.mean([sol for sol, _ in self.primary_memory], axis=0)\n        \n        # Dynamic entanglement adjusted to convergence stage\n        entanglement_strength = (1 - self.iteration / self.budget) * self.adaptivity_rate\n        entanglement = np.random.uniform(-entanglement_strength, entanglement_strength, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.secondary_memory.append((solution, value))\n        self.secondary_memory.sort(key=lambda x: x[1])\n        if len(self.secondary_memory) > self.secondary_memory_size:\n            self.secondary_memory.pop()\n\n        if len(self.primary_memory) < self.primary_memory_size or value < self.primary_memory[-1][1]:\n            self.primary_memory.append((solution, value))\n            self.primary_memory.sort(key=lambda x: x[1])\n            if len(self.primary_memory) > self.primary_memory_size:\n                self.primary_memory.pop()", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedQuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09372 with standard deviation 0.00112.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.09216766253433473, 0.09421811249012135, 0.09477556652132801]}}
{"id": "9799071b-eddd-4e6f-92a6-17f0ee9f4136", "fitness": 0.09409767850603608, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Improved adaptivity in Quantum-Inspired Dynamic Adaptive Memory Search (QI-DAMS) by tweaking the exploration strategy and probability selection. ", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.02 * (best_value - memory_value))  # Changed\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [1 - np.random.rand() if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])  # Changed\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 26, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09410 with standard deviation 0.00089.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.09419031614058015, 0.09296368946772826, 0.09513902990979983]}}
{"id": "64c7ff58-1a93-4466-92fc-e1eb94731484", "fitness": 0.07699641896554221, "name": "EnhancedQuantumInspiredAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Adaptive Memory Search (EQI-AMS) incorporates diversity preservation in memory selection and adaptive quantum exploration to improve convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedQuantumInspiredAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(20, dim)  # Increased memory size for diversity\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a diverse solution from memory to exploit\n            memory_solution, memory_value = self._select_diverse_from_memory()\n\n            # Adaptive explore phase\n            candidate_solution = self._adaptive_quantum_explore(lb, ub, memory_solution)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_diverse_from_memory(self):\n        # Enhance diversity by selecting solutions with different characteristics\n        distances = np.array([np.linalg.norm(sol - self.memory[0][0]) for sol, _ in self.memory])\n        diversity_probabilities = distances / distances.sum()\n        idx = np.random.choice(len(self.memory), p=diversity_probabilities)\n        return self.memory[idx]\n\n    def _adaptive_quantum_explore(self, lb, ub, base_solution):\n        # Adaptive quantum exploration based on a base solution\n        superposition = np.array([base_solution])\n        scaled_adaptivity = self.adaptivity_rate * (ub - lb)\n        entanglement = np.random.uniform(-scaled_adaptivity, scaled_adaptivity, self.dim)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedQuantumInspiredAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07700 with standard deviation 0.00399.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.08238435517003606, 0.07284438619523281, 0.07576051553135776]}}
{"id": "c3f9f1fa-3178-4731-9318-47532a562fa1", "fitness": 0.055529702196100504, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Quantum-Inspired Dynamic Adaptive Memory Search with Adaptive Entanglement - Introduces dynamic entanglement scaling based on memory diversity to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = self._calculate_adaptivity_rate(best_value, memory_value)\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [np.random.rand() if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        diversity = np.std([sol for sol, _ in self.memory], axis=0)\n        dynamic_entanglement = self.adaptivity_rate * (ub - lb) * (1 + diversity.mean())\n        candidate_solution = superposition + np.random.uniform(-dynamic_entanglement, dynamic_entanglement, self.dim)\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _calculate_adaptivity_rate(self, best_value, memory_value):\n        change_rate = 0.01 * (best_value - memory_value)\n        return min(0.5, max(0.01, self.adaptivity_rate + change_rate))\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 28, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05553 with standard deviation 0.00527.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.06286782584769213, 0.05072801745863309, 0.05299326328197629]}}
{"id": "38d59854-60a2-4a34-bdc1-caf5e798fe93", "fitness": 0.09308281609984792, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Quantum-Inspired Dynamic Adaptive Memory Search (QI-DAMS) with Quantum Entanglement Adjustment - Introduces a dynamic entanglement adjustment mechanism to fine-tune exploration-exploitation balance based on historical performance.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.entanglement_factor = 0.1  # Initial entanglement factor\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Adjust entanglement factor dynamically\n            self.entanglement_factor = max(0.01, self.entanglement_factor * (1 + 0.01 * (best_value - memory_value)))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Probability proportional to adaptivity rate\n        probabilities = np.array([1.0 / (i + 1) for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.entanglement_factor, self.entanglement_factor, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 29, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09308 with standard deviation 0.00097.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.09181178934356582, 0.09325856835530777, 0.09417809060067017]}}
{"id": "4ba7c2d8-77c8-4018-9518-6a2452a9b127", "fitness": 0.0824951553403177, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Quantum-Inspired Dynamic Adaptive Memory Search (QI-DAMS) with Multi-level Adaptive Strategy - Introduces multi-level adaptivity to dynamically adjust exploration-exploitation balance and memory influence based on performance feedback.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.exploration_factor = 0.1  # Initial exploration factor\n        self.exploitation_factor = 0.1  # Initial exploitation factor\n        self.performance_history = []  # Track recent performance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update exploration and exploitation factors based on recent performance\n            self._update_adaptivity(memory_value, best_value)\n\n            # Quantum-inspired exploration with multi-level adaptivity\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n            # Track recent performance\n            self._track_performance(memory_value, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on exploitation_factor\n        probabilities = np.array(\n            [np.random.rand() if i == 0 else self.exploitation_factor for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.exploration_factor, self.exploration_factor, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n\n    def _update_adaptivity(self, memory_value, best_value):\n        # Adjust exploration and exploitation factors based on performance\n        performance_ratio = (best_value - memory_value) / max(abs(memory_value), 1e-10)\n        self.exploration_factor = min(0.5, self.exploration_factor + 0.01 * performance_ratio)\n        self.exploitation_factor = min(0.5, self.exploitation_factor + 0.01 * -performance_ratio)\n\n    def _track_performance(self, memory_value, candidate_value):\n        self.performance_history.append((memory_value, candidate_value))\n        if len(self.performance_history) > 10:\n            self.performance_history.pop(0)", "configspace": "", "generation": 30, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08250 with standard deviation 0.00501.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.080519064753789, 0.07758917042971214, 0.08937723083745197]}}
{"id": "841249c5-e8f7-4f86-97c9-51e5ee2830da", "fitness": 0.058591651131079926, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Memory Selection and Quantum Exploration with Dynamic Entanglement Strength - Improves search efficiency by adjusting entanglement based on memory diversity and improves memory selection for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [np.random.uniform(0.8, 1.2) if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])  # Changed line\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        diversity_factor = np.std([sol for sol, _ in self.memory], axis=0)  # Changed line\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb) * diversity_factor  # Changed line\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 31, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05859 with standard deviation 0.00767.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.0496525752041882, 0.06837398771833736, 0.05774839047071423]}}
{"id": "c291cbea-4820-4a1a-b477-006d7af5e8df", "fitness": -Infinity, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Memory Selection and Adaptive Exploration in Quantum-Inspired Dynamic Adaptive Memory Search (QI-DAMS) by fine-tuning the adaptivity rate and introducing adaptive memory pruning for improved performance.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.15  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value) / abs(memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [(1 - self.adaptivity_rate) if i == 0 else self.adaptivity_rate for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        unique_memory = list(dict.fromkeys(self.memory))  # Prune duplicates\n        if len(unique_memory) > self.memory_size:\n            unique_memory.pop()\n        self.memory = unique_memory", "configspace": "", "generation": 32, "feedback": "An exception occurred: TypeError(\"unhashable type: 'numpy.ndarray'\").", "error": "TypeError(\"unhashable type: 'numpy.ndarray'\")", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {}}
{"id": "8f061dde-2588-44cb-b4e5-8c248c80c121", "fitness": 0.09476932473731454, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Strategy with Self-Adaptive Learning Rate and Dynamic Memory Filtering to optimize search efficiency and solution quality.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with self-adaptive learning rate\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with dynamic filtering\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])  # Line changed\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 33, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09477 with standard deviation 0.00088.", "error": "", "parent_ids": ["0297efb3-f299-4ba1-98a8-87ba5716277d"], "operator": null, "metadata": {"aucs": [0.09563042656792031, 0.0935627669597835, 0.09511478068423984]}}
{"id": "43f89565-f3a4-4bd0-af2f-3bb57af0cef4", "fitness": 0.09476932473731454, "name": "QuantumInspiredAdaptiveDiversitySearch", "description": "Quantum-Inspired Strategy with Adaptive Diversity Preservation and Dynamic Memory Update for Enhanced Exploration and Convergence.", "code": "import numpy as np\n\nclass QuantumInspiredAdaptiveDiversitySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(20, dim)  # Increased memory size for diversity\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate\n        self.diversity_threshold = 0.05  # Diversity threshold for memory update\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with adaptive diversity preservation\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with dynamic filtering and diversity check\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        # Check for diversity and update memory\n        if not any(np.linalg.norm(solution - sol) < self.diversity_threshold for sol, _ in self.memory):\n            self.memory.append((solution, value))\n            self.memory.sort(key=lambda x: x[1])  # Sort by value\n            if len(self.memory) > self.memory_size:\n                self.memory.pop()", "configspace": "", "generation": 34, "feedback": "The algorithm QuantumInspiredAdaptiveDiversitySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09477 with standard deviation 0.00088.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.09563042656792031, 0.0935627669597835, 0.09511478068423984]}}
{"id": "271ee45d-c677-4ef3-8977-46d1f3f1d54b", "fitness": 0.08902501573143107, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Strategy with Adaptive Annealing and Dynamic Memory Filtering to further improve solution quality and convergence.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.temperature = 1.0  # New: Initial temperature for annealing\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n            \n            # New: Simulated annealing acceptance criterion\n            if candidate_value < best_value or np.exp((best_value - candidate_value) / self.temperature) > np.random.rand():\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n            \n            # New: Adaptive temperature update\n            self.temperature *= 0.99  \n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 35, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08903 with standard deviation 0.00239.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.09223486367115441, 0.08834618367236735, 0.08649399985077144]}}
{"id": "56b6e285-494e-4317-89f9-2ce468d715ca", "fitness": 0.09438987687363613, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Strategy with Multi-Scale Exploration and Adaptive Memory Recalibration for improved convergence efficiency and solution quality.  ", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.scale_factors = [0.5, 1.0, 2.0]  # Different scales for exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, max(0.01, self.adaptivity_rate + 0.01 * (best_value - memory_value)))\n\n            # Multi-Scale Quantum-inspired exploration\n            candidate_solution = self._multi_scale_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Recalibrate memory dynamically\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _multi_scale_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        scale = np.random.choice(self.scale_factors)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb) * scale\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory = sorted(self.memory, key=lambda x: x[1])[:self.memory_size]  # Sort and keep best", "configspace": "", "generation": 36, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09439 with standard deviation 0.00080.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.09488109400381894, 0.09503205907272283, 0.09325647754436661]}}
{"id": "696ad35d-baf3-4f0c-b78e-ced1a3aaef15", "fitness": -Infinity, "name": "ImprovedQuantumSwarmAdaptiveMemorySearch", "description": "Improved Quantum-Inspired Memory Search with Adaptive Quantum Swarm Intelligence and Confidence-Based Resource Allocation for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQuantumSwarmAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.confidence_level = 0.5  # Confidence level for resource allocation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired swarm exploration with adaptive learning rate\n            candidate_solution = self._quantum_swarm_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update confidence level for resource allocation\n            self.confidence_level = max(0.1, self.confidence_level * (1 + 0.01 * (best_value - candidate_value)))\n\n            # Allocate resources based on confidence\n            if self.confidence_level > 0.5:\n                candidate_solution = self._refine_solution(candidate_solution, lb, ub)\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with dynamic filtering\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_swarm_explore(self, lb, ub):\n        # Quantum superposition with swarm intelligence to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement_factor = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim)\n        swarm_influence = np.random.normal(0, 0.1, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement_factor + swarm_influence\n        return np.clip(candidate_solution, lb, ub)\n\n    def _refine_solution(self, solution, lb, ub):\n        # Small refinement step to improve solution quality\n        noise = np.random.normal(0, 0.01, self.dim) * (ub - lb)\n        refined_solution = solution + noise\n        return np.clip(refined_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 37, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {}}
{"id": "9a2cec1f-a454-42aa-a7b6-3e9241f69338", "fitness": -Infinity, "name": "AdvancedQuantumInspiredSearch", "description": "Advanced Quantum-Inspired Search with Dynamic Multi-Objective Memory and Adaptive Learning for Enhanced Optimization Efficiency.", "code": "import numpy as np\n\nclass AdvancedQuantumInspiredSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * abs(best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        values = np.array([value for _, value in self.memory])\n        probabilities = np.exp(-values / (self.adaptivity_rate * np.std(values) + 1e-9))\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 38, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {}}
{"id": "a5c4b2d1-99cb-4b7d-be44-ea12618cb735", "fitness": 0.09228823640680935, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Improved Quantum-Inspired Strategy with Adaptive Solution Replacement and Dynamic Exploration Range for Enhanced Solution Quality.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with self-adaptive learning rate\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with dynamic filtering\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.median([sol for sol, _ in self.memory], axis=0)])  # Change mean to median\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * np.random.rand(self.dim) * (ub - lb)  # Introduced dynamic range\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1]) \n        if len(self.memory) > self.memory_size:\n            self.memory.pop(-1)  # Replace the worst solution instead of removing the last", "configspace": "", "generation": 39, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09229 with standard deviation 0.00086.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.09199940193416956, 0.09345196605754569, 0.09141334122871281]}}
{"id": "5e27a6cf-a3bd-4ee1-87a3-88b93ecade98", "fitness": -Infinity, "name": "QuantumInspiredHierarchicalClusteringSearch", "description": "Enhanced Quantum-Inspired Strategy with Hierarchical Memory Clustering and Adaptive Phase Exploration for improved convergence efficiency and solution diversity.", "code": "import numpy as np\n\nclass QuantumInspiredHierarchicalClusteringSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.cluster_threshold = 0.2  # Threshold for clustering similar solutions\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Cluster memory to select diverse solutions\n            clustered_memory = self._cluster_memory()\n            memory_solution, memory_value = self._select_from_cluster(clustered_memory)\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with adaptive phase adjustment\n            candidate_solution = self._quantum_explore_with_phase(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with dynamic filtering\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _cluster_memory(self):\n        # Hierarchically cluster solutions in memory based on similarity\n        clusters = []\n        for sol, val in self.memory:\n            added_to_cluster = False\n            for cluster in clusters:\n                if np.linalg.norm(sol - cluster[0][0]) < self.cluster_threshold:\n                    cluster.append((sol, val))\n                    added_to_cluster = True\n                    break\n            if not added_to_cluster:\n                clusters.append([(sol, val)])\n        return clusters\n\n    def _select_from_cluster(self, clustered_memory):\n        # Select the best solution from a randomly chosen cluster\n        cluster = np.random.choice(clustered_memory)\n        best_in_cluster = min(cluster, key=lambda x: x[1])\n        return best_in_cluster\n\n    def _quantum_explore_with_phase(self, lb, ub):\n        # Quantum superposition with adaptive phase exploration\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        phase_shift = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim)\n        candidate_solution = superposition + phase_shift * (ub - lb)\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 40, "feedback": "An exception occurred: ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 3 dimensions. The detected shape was (10, 1, 2) + inhomogeneous part.').", "error": "ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 3 dimensions. The detected shape was (10, 1, 2) + inhomogeneous part.')", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {}}
{"id": "98a402dc-ea62-48d9-aa4c-1b238e613f7e", "fitness": 0.08829289645667282, "name": "QuantumInspiredHierarchicalDynamicMemorySearch", "description": "Quantum-Inspired Hierarchical Dynamic Memory Search with Adaptive Learning for enhanced exploration-exploitation balance and improved convergence.", "code": "import numpy as np\n\nclass QuantumInspiredHierarchicalDynamicMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(15, dim)  # Increased memory size for diversity\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate\n        self.hierarchy_levels = 3  # Hierarchical memory levels\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from hierarchical memory levels\n            memory_solution, memory_value = self._select_from_hierarchical_memory()\n\n            # Update adaptivity rate based on differences from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * np.abs(best_value - memory_value))\n\n            # Quantum-inspired exploration with self-adaptive learning rate\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with dynamic filtering\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_hierarchical_memory(self):\n        # Hierarchical memory selection for diverse exploitation\n        level_probabilities = np.linspace(0.5, 0.1, self.hierarchy_levels) / np.sum(np.linspace(0.5, 0.1, self.hierarchy_levels))\n        level = np.random.choice(self.hierarchy_levels, p=level_probabilities)\n        level_size = len(self.memory) // self.hierarchy_levels\n        level_start = level * level_size\n        level_end = min((level + 1) * level_size, len(self.memory))\n        \n        # Prefer better solutions within the selected level\n        probabilities = np.array([self.adaptivity_rate if i == 0 else np.random.rand() for i in range(level_start, level_end)])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(range(level_start, level_end), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 41, "feedback": "The algorithm QuantumInspiredHierarchicalDynamicMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08829 with standard deviation 0.00109.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.08881330277593225, 0.08677772586005283, 0.08928766073403338]}}
{"id": "ea369aae-ad5a-4a02-bfcc-ad195bf96a27", "fitness": 0.09354936940600578, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Strategy with Self-Adaptive Memory Compression for improved search efficiency and solution quality.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with self-adaptive learning rate\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with dynamic filtering\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.median([sol for sol, _ in self.memory], axis=0)])  # Changed mean to median\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory = self.memory[:self.memory_size]  # Changed to retain top solutions only", "configspace": "", "generation": 42, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09355 with standard deviation 0.00054.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.09366712961774704, 0.09414963811946409, 0.09283134048080621]}}
{"id": "d17b17eb-ecf1-4ccf-85d0-9bc2f524c5da", "fitness": 0.09476932473731454, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Quantum-Inspired Dynamic Adaptive Memory Search with Adaptive Quantum Fluctuations and Diversity Preservation for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.diversity_threshold = 0.2 * (np.max(self.dim) - np.min(self.dim)) \n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with adaptive quantum fluctuations\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with diversity preservation\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        fluctuation = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + fluctuation\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n        \n        # Ensure diversity\n        if self._calculate_diversity(solution) < self.diversity_threshold:\n            self.memory.pop()\n\n    def _calculate_diversity(self, new_solution):\n        distances = [np.linalg.norm(new_solution - sol) for sol, _ in self.memory]\n        return np.mean(distances)", "configspace": "", "generation": 43, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09477 with standard deviation 0.00088.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.09563042656792031, 0.0935627669597835, 0.09511478068423984]}}
{"id": "27611b01-1c24-4263-9721-0e7a109b40a9", "fitness": 0.09367002097690591, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Strategy with Self-Adaptive Learning Rate and Local Search Intensification for improved convergence efficiency and solution quality.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with self-adaptive learning rate\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Intensification step with local search\n            local_solution = self._local_search(candidate_solution, lb, ub, func)\n            local_value = func(local_solution)\n            self.iteration += 1\n\n            # Update the best found solution\n            if local_value < best_value:\n                best_value = local_value\n                best_solution = local_solution\n\n            # Update the memory with dynamic filtering\n            self._update_memory(local_solution, local_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])  # Line changed\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n\n    def _local_search(self, solution, lb, ub, func):\n        # Conduct a simple local search around the candidate solution\n        perturbation = np.random.uniform(-0.05, 0.05, self.dim) * (ub - lb)\n        new_solution = solution + perturbation\n        return np.clip(new_solution, lb, ub)", "configspace": "", "generation": 44, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09367 with standard deviation 0.00111.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.0921067722792801, 0.09455757340230009, 0.09434571724913754]}}
{"id": "c7078f4a-e813-452c-afe9-0db54fde98f5", "fitness": 0.08243832479251396, "name": "QuantumInspiredAdaptiveExploration", "description": "Quantum-Inspired Adaptive Exploration with Progressive Memory Reinforcement for Enhanced Search Efficiency and Solution Robustness.", "code": "import numpy as np\n\nclass QuantumInspiredAdaptiveExploration:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(15, dim)  # Increased memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.momentum_factor = 0.9  # Momentum factor for progressive memory reinforcement\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory with momentum reinforcement\n            memory_solution, memory_value = self._select_with_momentum()\n\n            # Update adaptivity rate based on improvement needed\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with adaptive learning rate\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with dynamic filtering\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_with_momentum(self):\n        # Apply momentum to favor recently improved solutions\n        probabilities = np.exp(-self.momentum_factor * np.arange(len(self.memory)))[::-1]\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 45, "feedback": "The algorithm QuantumInspiredAdaptiveExploration got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08244 with standard deviation 0.01071.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.06877155711781369, 0.08362589054254199, 0.09491752671718623]}}
{"id": "3ef8156f-be9d-439f-afdc-d7456ab3d7f8", "fitness": 0.045448084278973254, "name": "QuantumGuidedAdaptiveMultiPhaseOptimization", "description": "Quantum-Guided Adaptive Multi-Phase Optimization combines quantum-inspired exploration with adaptive phase transitions to enhance convergence efficiency and solution robustness.", "code": "import numpy as np\n\nclass QuantumGuidedAdaptiveMultiPhaseOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.phase_length = 10  # Number of iterations before switching phases\n        self.current_phase = 0  # Start with exploration phase\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            if self.iteration % self.phase_length == 0:\n                self.current_phase = (self.current_phase + 1) % 2  # Alternate between phases\n\n            if self.current_phase == 0:\n                # Exploration phase\n                candidate_solution = self._quantum_explore(lb, ub)\n            else:\n                # Exploitation phase\n                candidate_solution, _ = self._select_from_memory()\n\n            candidate_value = func(candidate_solution)\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Adjust adaptivity rate with a sinusoidal function for dynamic transitions\n            self.adaptivity_rate = 0.5 * (1 + np.sin(self.iteration * np.pi / self.phase_length))\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array([self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 46, "feedback": "The algorithm QuantumGuidedAdaptiveMultiPhaseOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04545 with standard deviation 0.00297.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.04125457132838972, 0.04747722660801945, 0.04761245490051058]}}
{"id": "4309b027-6d38-4655-be07-7db000aee083", "fitness": -Infinity, "name": "AdaptiveQuantumInspiredMemorySearch", "description": "Adaptive Quantum-Inspired Memory Search with Dynamic Self-Tuning Mechanism to optimize convergence through learning rate and population diversity adjustments.", "code": "import numpy as np\n\nclass AdaptiveQuantumInspiredMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.learning_rate = 0.1  # Introducing a self-tuning learning rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Self-tuning mechanism: adaptation based on progress\n            progress = (best_value - memory_value) / (1 + abs(memory_value))\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * progress)\n            self.learning_rate = min(0.2, self.learning_rate + 0.005 * progress)\n\n            candidate_solution = self._quantum_explore(lb, ub, memory_solution)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub, memory_solution):\n        # Utilize the current best memory solution and learning rate for exploration\n        superposition = np.array([memory_solution])\n        entanglement = np.random.uniform(-self.learning_rate, self.learning_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 47, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {}}
{"id": "6644cfdc-62b7-4acc-b933-8a9163496f1a", "fitness": 0.09457027891356518, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Strategy with Improved Memory Selection and Adaptive Exploration to optimize search efficiency and solution quality.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            # Select a solution from memory to exploit\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity rate based on difference from best\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum-inspired exploration with self-adaptive learning rate\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.iteration += 1\n\n            # Update the best found solution\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update the memory with dynamic filtering\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Prefer better solutions with a probability based on adaptivity_rate\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities += [0.1] * len(probabilities)  # Line changed\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        # Quantum superposition to generate new candidate solution\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement * 0.9  # Line changed\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])  # Sort by value (objective)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 48, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09457 with standard deviation 0.00096.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.0954914249049742, 0.0932410156918525, 0.09497839614386883]}}
{"id": "4281a9e4-b943-4d5f-b0f8-83a056dc0d54", "fitness": 0.09493863075177955, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Introduced Stochastic Tunneling and Memory Refinement to enhance convergence by diversifying search space exploration.  ", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.tunnel_rate = 0.05  # New parameter for stochastic tunneling\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < self.tunnel_rate:  # Apply stochastic tunneling\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * 0.1\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 49, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09494 with standard deviation 0.00002.", "error": "", "parent_ids": ["8f061dde-2588-44cb-b4e5-8c248c80c121"], "operator": null, "metadata": {"aucs": [0.0949664368575277, 0.09491419824683955, 0.0949352571509714]}}
{"id": "877ee16a-63ca-48ea-a70d-4a3287c10863", "fitness": 0.08724120569301945, "name": "EnhancedQuantumAdaptiveSearch", "description": "Introduce Dynamic Inertia Weighting and Quantum Superposition Interference to enhance convergence by balancing exploration and exploitation phases.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(15, dim)  # Increased memory size for diversity\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.inertia_weight = 0.9  # Inertia weight for exploration/exploitation balance\n        self.inertia_decay = 0.99  # Decay rate for inertia weight\n        self.tunnel_rate = 0.05  # Parameter for stochastic tunneling\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initial population with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            candidate_solution = self._quantum_explore(lb, ub, memory_solution)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < self.tunnel_rate:  # Apply stochastic tunneling\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * 0.1\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                if tunneling_value < candidate_value:\n                    candidate_solution, candidate_value = tunneling_candidate, tunneling_value\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n            # Update inertia weight dynamically\n            self.inertia_weight *= self.inertia_decay\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array([1 / (i + 1) for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub, memory_solution):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = self.inertia_weight * (memory_solution - superposition)\n        candidate_solution = superposition + entanglement + np.random.uniform(-self.inertia_weight, self.inertia_weight, self.dim) * (ub - lb)\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedQuantumAdaptiveSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08724 with standard deviation 0.00063.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.08761058481204986, 0.08775950271517374, 0.08635352955183473]}}
{"id": "b7940f20-1f12-49a3-8608-98cc1099e213", "fitness": -Infinity, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced local search by introducing adaptive tunneling scale and probabilistic memory updates.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.tunnel_rate = 0.05  # New parameter for stochastic tunneling\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            adaptive_tunnel_scale = 0.1 * (1.0 - candidate_value / best_value)  # Changed line\n            if np.random.rand() < self.tunnel_rate:  # Apply stochastic tunneling\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * adaptive_tunnel_scale  # Changed line\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            if np.random.rand() < self.adaptivity_rate:  # Changed line\n                self.memory.pop()  # Changed line", "configspace": "", "generation": 51, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {}}
{"id": "6cf6be0a-8010-48a5-88b3-8ea362e59eb6", "fitness": 0.09430994422028838, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced adaptive tunneling and dynamic memory management to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(15, dim)  # Increased memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.tunnel_rate = 0.1  # Increased tunnel rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < self.tunnel_rate:  # Apply stochastic tunneling\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * 0.1\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 52, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09431 with standard deviation 0.00068.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.09500167944633275, 0.09339188478099603, 0.09453626843353635]}}
{"id": "13907b99-91a4-4e5e-91a6-dd1b91ebf846", "fitness": 0.09306549251964243, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Improved exploration by enhancing stochastic tunneling and refining memory adaptation dynamically.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.tunnel_rate = 0.05  # New parameter for stochastic tunneling\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < self.tunnel_rate:  # Apply stochastic tunneling\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * 0.2  # More aggressive tunneling\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 53, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09307 with standard deviation 0.00267.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.0949664368575277, 0.08929478355042819, 0.0949352571509714]}}
{"id": "2ee0c586-cd88-47e2-990f-3d337b595931", "fitness": 0.09306549251964243, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Introduced dynamic quantum tunneling to improve exploration and convergence efficiency.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.tunnel_rate = 0.05  # New parameter for stochastic tunneling\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < self.tunnel_rate:  # Modify tunneling based on iteration\n                tunneling_effect = np.exp(-self.iteration / self.budget)  # Dynamic tunneling effect\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * tunneling_effect\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 54, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09307 with standard deviation 0.00267.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.0949664368575277, 0.08929478355042819, 0.0949352571509714]}}
{"id": "c6f38207-a8eb-49cc-9bce-3470a38fd6d6", "fitness": -Infinity, "name": "ImprovedQuantumMemoryGradientSearch", "description": "Improved Quantum Memory Gradient Search incorporates a dynamic gradient-based quantum memory adjustment to enhance convergence and accuracy in diverse optimization tasks.", "code": "import numpy as np\n\nclass ImprovedQuantumMemoryGradientSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.tunnel_rate = 0.05\n        self.gradient_impact = 0.1  # New parameter for gradient adjustment\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub, best_solution)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < self.tunnel_rate:\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * 0.1\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (\n                    candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub, best_solution):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        gradient_adjustment = self.gradient_impact * (superposition - best_solution)\n        candidate_solution = superposition + entanglement + gradient_adjustment\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 55, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {}}
{"id": "e65b4577-3b97-4008-9a8b-616a571d9678", "fitness": 0.09314488527298063, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Adaptive Memory Search with Dynamic Stochastic Tunneling leveraging a self-adaptive tunnel rate and dynamic memory adaptation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(15, max(5, dim // 2))  # Dynamic memory size based on dimension\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.tunnel_rate = 0.05  # Initial tunnel rate for stochastic tunneling\n        self.tunnel_rate_decay = 0.995  # Decay rate for tunnel rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < self.tunnel_rate:  # Apply dynamic stochastic tunneling\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * self.tunnel_rate\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n            self.tunnel_rate *= self.tunnel_rate_decay  # Decay tunnel rate to encourage exploitation over iterations\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09314 with standard deviation 0.00288.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.08909717784048565, 0.09474859815555148, 0.09558887982290476]}}
{"id": "f69d769f-fc68-436d-a440-1ed8cb6da402", "fitness": 0.09397263186747502, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Enhanced convergence by incorporating adaptive tunneling rate and elite solution reinforcement to refine exploration and exploitation balance.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.tunnel_rate = 0.05  # New parameter for stochastic tunneling\n        self.elite_solution = None  # Store elite solution\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n        self.elite_solution = best_solution  # Initialize elite solution\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n            self.tunnel_rate = 0.1 * (1 - best_value / (best_value + 1))  # Adaptive tunneling rate\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < self.tunnel_rate:  # Apply stochastic tunneling\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * 0.1\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n                self.elite_solution = best_solution  # Update elite solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 57, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09397 with standard deviation 0.00083.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.09494019043229784, 0.09291440477051716, 0.09406330039961008]}}
{"id": "674a3db9-21bc-4e46-8f85-a43577bcf609", "fitness": 0.08183070585253142, "name": "ParetoEnhancedQuantumSearch", "description": "Incorporate multi-objective optimization principles by integrating Pareto dominance to balance exploration and exploitation, enhancing solution diversity and convergence.", "code": "import numpy as np\n\nclass ParetoEnhancedQuantumSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.tunnel_rate = 0.05\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < self.tunnel_rate:\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * 0.1\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        pareto_front = self._pareto_filter(self.memory)\n        return min(pareto_front, key=lambda x: x[1])\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        if len(self.memory) > self.memory_size:\n            self.memory = self._pareto_filter(self.memory)\n\n    def _pareto_filter(self, memories):\n        memories = sorted(memories, key=lambda x: x[1])\n        pareto_front = [memories[0]]\n        for sol, val in memories[1:]:\n            if val < pareto_front[-1][1]:\n                pareto_front.append((sol, val))\n        return pareto_front", "configspace": "", "generation": 58, "feedback": "The algorithm ParetoEnhancedQuantumSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08183 with standard deviation 0.00629.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.08423247405216405, 0.08804694355238274, 0.07321269995304747]}}
{"id": "651bf0ab-0111-4ebc-ad57-941bbfdfca98", "fitness": 0.09493863075177955, "name": "EnhancedQuantumMemoryAdaptiveSearch", "description": "Enhanced Quantum Memory Exploration with Adaptive Tunneling and Dynamic Memory Adjustment for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumMemoryAdaptiveSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.tunnel_rate = 0.05\n        self.dynamic_memory_adjustment = 0.01  # New parameter for dynamic memory adjustment\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize memory with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Adjust adaptivity rate based on performance\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Generate a candidate solution through quantum exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply adaptive stochastic tunneling\n            if np.random.rand() < self.tunnel_rate:\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * 0.1\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            # Update the best solution found so far\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update memory with new candidate\n            self._update_memory(candidate_solution, candidate_value)\n\n            # Dynamically adjust memory size\n            self.memory_size = min(int(self.memory_size * (1 + self.dynamic_memory_adjustment)), self.budget - self.iteration)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedQuantumMemoryAdaptiveSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09494 with standard deviation 0.00002.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.0949664368575277, 0.09491419824683955, 0.0949352571509714]}}
{"id": "f6ea8b59-63b6-4d45-a288-84bb796b6abd", "fitness": 0.0930481215636132, "name": "EnhancedQuantumMemorySearch", "description": "Enhanced Quantum-Inspired Memory Search by integrating Dynamic Probabilistic Tunneling and Adaptive Intensity Scaling for improved convergence and exploration balance.", "code": "import numpy as np\n\nclass EnhancedQuantumMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.tunnel_rate = 0.05\n        self.intensity_scale = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Dynamic adaptation of tunnel rate based on current progress\n            progress_factor = 1 - (best_value - memory_value) / abs(memory_value)\n            dynamic_tunnel_rate = self.tunnel_rate * (1 + progress_factor)\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            if np.random.rand() < dynamic_tunnel_rate:\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * self.intensity_scale\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedQuantumMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09305 with standard deviation 0.00052.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.09375812463902333, 0.09285363973389293, 0.09253260031792332]}}
{"id": "2d99107c-bc22-41bb-b5ad-f07a43f3a35f", "fitness": -Infinity, "name": "QuantumInspiredDynamicAdaptiveMemorySearch", "description": "Added exploration refinement through adaptive tunneling rate to enhance local search capabilities.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.tunnel_rate = 0.05  # New parameter for stochastic tunneling\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            self.tunnel_rate = min(0.2, self.tunnel_rate + 0.01 * (best_value - memory_value)) # Adaptive tunneling rate\n\n            if np.random.rand() < self.tunnel_rate:  # Apply stochastic tunneling\n                tunneling_candidate = candidate_solution + np.random.normal(size=self.dim) * (ub - lb) * 0.1\n                tunneling_candidate = np.clip(tunneling_candidate, lb, ub)\n                tunneling_value = func(tunneling_candidate)\n                candidate_solution, candidate_value = (tunneling_candidate, tunneling_value) if tunneling_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 61, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {}}
{"id": "3b7252f2-d511-45e0-976e-94fde8dff22e", "fitness": 0.09539656078139853, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Search with Adaptive Memory by integrating a novel phase shift mechanism to improve solution diversity and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09540 with standard deviation 0.00043.", "error": "", "parent_ids": ["4281a9e4-b943-4d5f-b0f8-83a056dc0d54"], "operator": null, "metadata": {"aucs": [0.09487688416026774, 0.09592218589524759, 0.09539061228868029]}}
{"id": "8dd87e27-2ef8-4372-9cf1-db19c9cbcc51", "fitness": 0.09347486554059521, "name": "EnhancedQuantumAdaptiveMemorySearchWithCrossover", "description": "Enhanced Quantum Adaptive Memory Search with Dynamic Crossover for improved exploration and exploitation balance using quantum-inspired dynamics and adaptive crossover strategies.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearchWithCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # Phase shift diversification parameter\n        self.crossover_rate = 0.5  # Probability for crossover operation\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n        \n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n        \n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n            \n            if np.random.rand() < self.crossover_rate:\n                # Apply crossover strategy\n                crossover_solution = self._crossover(memory_solution)\n                candidate_solution = self._quantum_explore(lb, ub, crossover_solution)\n            else:\n                candidate_solution = self._quantum_explore(lb, ub)\n\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub, crossover_solution=None):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        if crossover_solution is not None:\n            candidate_solution = (candidate_solution + crossover_solution) / 2\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _crossover(self, solution):\n        partner_idx = np.random.randint(0, len(self.memory))\n        partner_solution = self.memory[partner_idx][0]\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        new_solution = np.where(mask, solution, partner_solution)\n        return new_solution\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearchWithCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09347 with standard deviation 0.00046.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09331759444150756, 0.09409941669763788, 0.09300758548264021]}}
{"id": "923f3314-44f1-48f0-9198-ea1f043133c0", "fitness": 0.09350930499464043, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Refined Quantum Adaptive Memory Search by introducing adaptive memory size and improved selection strategy to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))  # Unchanged\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n            self.memory_size = min(int(self.budget / 10), len(self.memory))  # Adaptive memory size\n\n        return best_solution\n\n    def _select_from_memory(self):\n        sorted_memory = sorted(self.memory, key=lambda x: x[1])\n        probabilities = np.exp(-0.1 * np.arange(len(sorted_memory)))  # Improved selection strategy\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(sorted_memory), p=probabilities)\n        return sorted_memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09351 with standard deviation 0.00191.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09082130560882884, 0.09510694018045829, 0.09459966919463414]}}
{"id": "476ab0db-6099-4b26-bf71-b79b16c940d2", "fitness": 0.08388539469261365, "name": "GradientEnhancedQuantumAdaptiveMemorySearch", "description": "Quantum-Inspired Adaptive Memory Search with Gradient-Assisted Exploration, enhancing exploitation via local gradient-based perturbations and maintaining solution diversity through adaptive memory updates.", "code": "import numpy as np\n\nclass GradientEnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # Parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_solution = self._gradient_perturb(candidate_solution, func, lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _gradient_perturb(self, solution, func, lb, ub):\n        epsilon = 1e-5\n        grad = np.zeros(self.dim)\n        for i in range(self.dim):\n            perturb = np.zeros(self.dim)\n            perturb[i] = epsilon\n            grad[i] = (func(solution + perturb) - func(solution - perturb)) / (2 * epsilon)\n        \n        candidate_solution = solution - self.adaptivity_rate * grad\n        return np.clip(candidate_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 65, "feedback": "The algorithm GradientEnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08389 with standard deviation 0.00172.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.08146751079353842, 0.08532155715549816, 0.08486711612880438]}}
{"id": "4c3eef0d-5a89-4ff8-a846-0ded7437b64f", "fitness": 0.09352279934861048, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Refined Enhanced Quantum-Inspired Dynamic Search by improving memory selection mechanism to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Slightly refined selection strategy to improve balance in exploration-exploitation\n        probabilities = np.array([0.3 if i == 0 else 0.7/len(self.memory) for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09352 with standard deviation 0.00192.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09082665968407377, 0.09518486953813332, 0.09455686882362435]}}
{"id": "a76b9c02-7224-43e5-8032-c0da9b243484", "fitness": 0.09198714383122138, "name": "OptimizedQuantumAdaptiveMemorySearch", "description": "Optimized Quantum Adaptive Memory Search with Enhanced Phase Shift and Memory Compression, improving convergence by dynamically tuning exploration parameters and compressing memory for faster adaptation.", "code": "import numpy as np\n\nclass OptimizedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = max(10, dim // 2)  # Dynamic memory size for better adaptability\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # Phase shift rate for diversification\n        self.compression_factor = 0.5  # Compression factor for solution memory\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        # Main loop\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Dynamically adjust adaptivity rate\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.02 * (best_value - memory_value))\n\n            # Quantum-inspired exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Enhanced phase shift for diversification\n            phase_shift_candidate = self._enhanced_phase_shift(candidate_solution, best_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            if phase_shift_value < candidate_value:\n                candidate_solution, candidate_value = phase_shift_candidate, phase_shift_value\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Select with dynamically weighted probabilities\n        probabilities = np.array([1.0 / (i + 1) for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _enhanced_phase_shift(self, solution, best_solution, lb, ub):\n        # Use a blend of the current and best solution to enhance exploration\n        blend = (solution + best_solution) / 2\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = blend + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        # Compress memory to keep most relevant solutions\n        if len(self.memory) > self.memory_size:\n            self.memory = self.memory[:int(len(self.memory) * self.compression_factor)]", "configspace": "", "generation": 67, "feedback": "The algorithm OptimizedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09199 with standard deviation 0.00406.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.08625817994595375, 0.09524180731961551, 0.09446144422809488]}}
{"id": "9a0e5c55-b45a-47aa-909c-298dc9db13e3", "fitness": 0.091998303413018, "name": "OptimizedQuantumAdaptiveMemorySearch", "description": "Optimized Quantum Dynamic Search with an Adaptive Memory and Cross-Generational Influence integrating a multi-parent crossover mechanism for enhanced exploration and convergence speed.", "code": "import numpy as np\n\nclass OptimizedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # Parameter for phase shift diversification\n        self.crossover_rate = 0.5  # Rate for multi-parent crossover\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize memory with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Exploration with quantum-inspired approach\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply multi-parent crossover\n            crossover_solution = self._crossover(lb, ub)\n            crossover_value = func(crossover_solution)\n            candidate_solution, candidate_value = (crossover_solution, crossover_value) if crossover_value < candidate_value else (candidate_solution, candidate_value)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _crossover(self, lb, ub):\n        if len(self.memory) < 2:\n            return np.random.uniform(lb, ub, self.dim)\n        \n        parents = np.random.choice(len(self.memory), size=min(3, len(self.memory)), replace=False)\n        offspring = sum(self.memory[i][0] for i in parents) / len(parents)\n        return np.clip(offspring, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 68, "feedback": "The algorithm OptimizedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09200 with standard deviation 0.00022.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.0917063394450578, 0.09203763555017141, 0.09225093524382477]}}
{"id": "6a39d616-fe23-49d2-a14d-f300cdecd1af", "fitness": 0.09471741470870909, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Quantum-Inspired Adaptive Memory Search with Dynamic Phase Shift Adjustment to Enhance Exploration-Exploitation Trade-off and Solution Quality.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply dynamic phase shift adaptive to the improvement in best_value\n            self.phase_shift_rate = max(0.01, self.phase_shift_rate * (1.1 if candidate_value < best_value else 0.9))\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09472 with standard deviation 0.00035.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09423076205916936, 0.09491338579853181, 0.0950080962684261]}}
{"id": "7fdd8b25-f493-4168-9c36-afd86842d638", "fitness": 0.091853120488115, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Search with Adaptive Memory by introducing a novel group-based phase shift and dynamic adaptivity rate adjustment for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value) / (self.iteration + 1))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply group-based phase shift for diversification\n            phase_shift_candidate = self._group_phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _group_phase_shift(self, solution, lb, ub):\n        group_size = max(1, self.dim // 5)\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, group_size) * (ub[:group_size] - lb[:group_size])\n        shifted_solution = np.copy(solution)\n        shifted_solution[:group_size] += shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09185 with standard deviation 0.00088.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09061209751447741, 0.09244430441722773, 0.09250295953263987]}}
{"id": "88103cb8-e8ab-48ff-af80-ce7724727d6c", "fitness": -Infinity, "name": "AdaptiveQuantumDynamicMemorySearch", "description": "Adaptive Quantum-Inspired Search with Dynamic Memory and Phase Shift Mechanism improving exploration-exploitation balance via learning-based adaptive strategy refining diversity and convergence.", "code": "import numpy as np\n\nclass AdaptiveQuantumDynamicMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n        self.learning_factor = 0.02  # Learning rate to adjust adaptivity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Learning-based adaptivity adjustment\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + self.learning_factor * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 71, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {}}
{"id": "f4a37f0e-1b83-4c70-9ce0-6e2f87e43be1", "fitness": -Infinity, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Introducing a hybrid search mechanism by integrating differential evolution-based mutation to enhance solution exploration and adaptability.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n            \n            # Integrate differential evolution-based mutation\n            de_candidate = self._differential_mutation(lb, ub)\n            de_value = func(de_candidate)\n            candidate_solution, candidate_value = (de_candidate, de_value) if de_value < candidate_value else (candidate_solution, candidate_value)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _differential_mutation(self, lb, ub):\n        if len(self.memory) < 3:\n            return np.random.uniform(lb, ub, self.dim)\n        a, b, c = np.random.choice(self.memory, 3, replace=False)\n        mutant = a[0] + 0.8 * (b[0] - c[0])\n        return np.clip(mutant, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 72, "feedback": "An exception occurred: ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 2 dimensions. The detected shape was (10, 2) + inhomogeneous part.').", "error": "ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 2 dimensions. The detected shape was (10, 2) + inhomogeneous part.')", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {}}
{"id": "a6bba5c1-8e1f-42a3-8b81-60d301498537", "fitness": 0.09209581574506787, "name": "ImprovedQuantumAdaptiveSearch", "description": "Improved Quantum-Inspired Adaptive Search using Dynamic Population and Exploration Strategy to enhance solution diversity and convergence speed.", "code": "import numpy as np\n\nclass ImprovedQuantumAdaptiveSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(20, dim * 2)  # Increased population size for better diversity\n        self.population = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.2  # Increased phase shift rate for more diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initial population\n        for _ in range(self.population_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_population(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.population_size\n\n        while self.iteration < self.budget:\n            population_solution, population_value = self._select_from_population()\n\n            # Dynamic adaptivity rate adjustment\n            self.adaptivity_rate = min(0.7, max(0.1, self.adaptivity_rate + 0.01 * (best_value - population_value) / (abs(best_value) + 1e-8)))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_population(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_population(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.population))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.population), p=probabilities)\n        return self.population[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.population], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_population(self, solution, value):\n        self.population.append((solution, value))\n        self.population.sort(key=lambda x: x[1])\n        if len(self.population) > self.population_size:\n            self.population.pop()", "configspace": "", "generation": 73, "feedback": "The algorithm ImprovedQuantumAdaptiveSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09210 with standard deviation 0.00088.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.0910638292509589, 0.0932232192652801, 0.0920003987189646]}}
{"id": "4f9c9bf3-7f05-4940-b94c-127d0adc285e", "fitness": 0.09268896313541752, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Search with Adaptive Memory and Optimized Phase Shift Bias to improve solution diversity and convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Adjust phase shift mechanism for better convergence\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        # Introduce a dynamic bias based on adaptivity_rate\n        shift = np.random.uniform(-self.phase_shift_rate * self.adaptivity_rate, self.phase_shift_rate * self.adaptivity_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09269 with standard deviation 0.00128.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09325638602210817, 0.09091875693441431, 0.09389174644973008]}}
{"id": "589a4ae9-28a3-4339-adcc-5c25d5d62709", "fitness": 0.09074940901662894, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Search with Adaptive Memory and Stochastic Gradient Adjustments to refine exploitation using gradient approximations.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            # New: Gradient-based refinement step\n            candidate_solution = self._stochastic_gradient_refinement(candidate_solution, func, lb, ub)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n\n    def _stochastic_gradient_refinement(self, solution, func, lb, ub):\n        epsilon = 1e-8\n        perturbation = np.random.randn(self.dim) * epsilon\n        gradient_approx = (func(solution + perturbation) - func(solution)) / epsilon\n        refined_solution = solution - 0.01 * gradient_approx * (ub - lb)\n        return np.clip(refined_solution, lb, ub)\n", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09075 with standard deviation 0.00102.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.08930982722307168, 0.0913687653891635, 0.09156963443765165]}}
{"id": "2a59536c-576f-446f-b34c-a4320e1e6df5", "fitness": -Infinity, "name": "AdvancedQuantumMemorySearch", "description": "Advanced Quantum Memory Search utilizing adaptive convergence acceleration and stochastic phase modulation for improved exploration-exploitation dynamics.", "code": "import numpy as np\n\nclass AdvancedQuantumMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n        self.convergence_rate = 0.05  # New parameter for adaptive convergence acceleration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Adjust adaptivity rate based on the convergence rate and memory value\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + self.convergence_rate * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply stochastic phase shift for improved diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift_direction = np.random.choice([-1, 1], self.dim)\n        shift_magnitude = np.random.uniform(0, self.phase_shift_rate, self.dim) * (ub - lb)\n        shift = shift_direction * shift_magnitude\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 76, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {}}
{"id": "ca64e360-25a2-4a36-9b1c-c000fe38b8fa", "fitness": 0.09513846090284046, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Slightly enhanced adaptivity rate increment to potentially better balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.015 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09514 with standard deviation 0.00024.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09486837480566035, 0.09508986730685942, 0.09545714059600163]}}
{"id": "34d1e019-9d0a-4100-8d25-6415f12b4f27", "fitness": -Infinity, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Search with Adaptive Phase Shift and Memory Update for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.normal(0, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop(0)", "configspace": "", "generation": 78, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {}}
{"id": "4927c9f0-0a6e-4ed4-8c97-88d5459d3ff9", "fitness": 0.09539656078139853, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Search with Adaptive Memory by integrating a novel phase shift mechanism and dynamic adaptivity rate adjustment to improve solution diversity and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, max(0.01, self.adaptivity_rate + 0.01 * (best_value - memory_value)))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09540 with standard deviation 0.00043.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09487688416026774, 0.09592218589524759, 0.09539061228868029]}}
{"id": "ebe28c23-560b-4050-9ff7-ac021454fa15", "fitness": 0.08392765730312131, "name": "HybridQuantumAdaptiveSearch", "description": "Hybrid Quantum-Inspired Dynamic Search with Adaptive Memory and Gradient-Based Refinement for Improved Solution Convergence and Diversity.", "code": "import numpy as np\n\nclass HybridQuantumAdaptiveSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n\n            # Apply gradient-based refinement for exploitation\n            refined_candidate = self._gradient_refinement(phase_shift_candidate, func)\n            refined_value = func(refined_candidate)\n\n            # Select the best candidate from all transformations\n            candidates = [(candidate_solution, candidate_value),\n                          (phase_shift_candidate, phase_shift_value),\n                          (refined_candidate, refined_value)]\n            best_candidate, best_candidate_value = min(candidates, key=lambda x: x[1])\n\n            self.iteration += 3\n\n            if best_candidate_value < best_value:\n                best_value = best_candidate_value\n                best_solution = best_candidate\n\n            self._update_memory(best_candidate, best_candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _gradient_refinement(self, solution, func):\n        epsilon = 1e-5\n        gradient = np.zeros(self.dim)\n        for i in range(self.dim):\n            perturb = np.zeros(self.dim)\n            perturb[i] = epsilon\n            grad = (func(solution + perturb) - func(solution - perturb)) / (2 * epsilon)\n            gradient[i] = grad\n        refined_solution = solution - 0.01 * gradient\n        return np.clip(refined_solution, func.bounds.lb, func.bounds.ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 80, "feedback": "The algorithm HybridQuantumAdaptiveSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08393 with standard deviation 0.00188.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.08126971449902443, 0.08543296326384309, 0.08508029414649643]}}
{"id": "64f6fb22-1320-4550-9d75-b9988ff0a0e1", "fitness": 0.09063529629605353, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Search with Adaptive Memory by integrating a novel phase shift mechanism to improve solution diversity and exploitation balance, now with smarter adaptivity rate adjustment based on phase shift performance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if phase_shift_value < best_value:  # Adjust adaptivity based on phase shift performance\n                self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.05)\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09064 with standard deviation 0.00431.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09414601539364698, 0.09319809127848366, 0.08456178221602995]}}
{"id": "a39f0d11-6d40-455f-8834-95afc6aaabda", "fitness": 0.08894283564476431, "name": "QuantumDualPhaseAdaptiveMemorySearch", "description": "Quantum Dual-Phase Adaptive Memory Search with Enhanced Exploitation and Exploration through a Dual-Phase Update and Adaptive Memory Dynamics.", "code": "import numpy as np\n\nclass QuantumDualPhaseAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(15, dim)  # Increased memory size for better diversity\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.2  # More aggressive initial adaptivity rate\n        self.phase_shift_rate = 0.15  # Adjusted phase shift for better diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Dual-phase adaptivity rate adjustment\n            self.adaptivity_rate = max(0.05, min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value)))\n            \n            # Quantum exploration with adaptive dual-phase\n            candidate_solution = self._quantum_explore(lb, ub, memory_solution)\n\n            # Evaluation and phase shift\n            candidate_value = func(candidate_solution)\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        weights = np.array([1.0 / (i + 1) for i in range(len(self.memory))])  # Inversely weighted selection\n        probabilities = weights / weights.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub, memory_solution):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement + 0.5 * (memory_solution - superposition)\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 82, "feedback": "The algorithm QuantumDualPhaseAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08894 with standard deviation 0.00109.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.08745713008478251, 0.09005300542750339, 0.08931837142200705]}}
{"id": "60093ce4-84bc-424e-aa41-7a5aae777211", "fitness": 0.09519015364406343, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Search with Adaptive Memory by integrating a dynamic phase shift rate for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n            \n            # Update phase shift rate dynamically based on adaptivity rate\n            self.phase_shift_rate = np.clip(self.adaptivity_rate * 0.2, 0.05, 0.2)\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09519 with standard deviation 0.00034.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09475945714469514, 0.09558710209781851, 0.09522390168967665]}}
{"id": "2459999b-ab21-42de-9112-a2431d159075", "fitness": 0.09414340432198638, "name": "AdvancedQuantumInteractiveArchive", "description": "Advanced Quantum-Inspired Search with Dynamic Adaptivity and Interactive Archive for enhanced diversity and local exploitation through a novel archive interaction mechanism.", "code": "import numpy as np\n\nclass AdvancedQuantumInteractiveArchive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.archive = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.phase_shift_rate = 0.1\n        self.archive_interaction_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            archive_candidate = self._archive_interaction(candidate_solution, lb, ub)\n            archive_value = func(archive_candidate)\n            \n            candidate_solution, candidate_value = (archive_candidate, archive_value) if archive_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _archive_interaction(self, solution, lb, ub):\n        if not self.archive:\n            return solution\n        archive_solution = np.mean(self.archive, axis=0)\n        interaction = np.random.uniform(-self.archive_interaction_rate, self.archive_interaction_rate, self.dim) * (ub - lb)\n        interacted_solution = (solution + archive_solution) / 2 + interaction\n        return np.clip(interacted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n        if np.random.rand() < self.archive_interaction_rate:\n            self.archive.append(solution)\n            if len(self.archive) > self.memory_size:\n                self.archive.pop(0)", "configspace": "", "generation": 84, "feedback": "The algorithm AdvancedQuantumInteractiveArchive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09414 with standard deviation 0.00113.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09267128875068065, 0.09435279963753662, 0.09540612457774189]}}
{"id": "3bfbebeb-57a4-4267-b93d-6ed37a44aa74", "fitness": 0.09519015364406343, "name": "QuantumMemoryOptimization", "description": "Quantum-Inspired Memory-Based Optimization with Adaptive Exploration-Exploitation Trade-off utilizing a dynamic superposition update and enhanced phase shift for better diversity and convergence.", "code": "import numpy as np\n\nclass QuantumMemoryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.05  # Adjusted for finer diversification\n        self.superposition = np.zeros(self.dim)  # Initial superposition state\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            self._update_superposition()\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply enhanced phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (\n                phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (\n                candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = self.superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n\n    def _update_superposition(self):\n        self.superposition = np.mean([sol for sol, _ in self.memory], axis=0)", "configspace": "", "generation": 85, "feedback": "The algorithm QuantumMemoryOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09519 with standard deviation 0.00034.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09475945714469514, 0.09558710209781851, 0.09522390168967665]}}
{"id": "b1c2c458-bd98-4c49-896b-b9b359d64446", "fitness": -Infinity, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Search with Dynamic Memory and Adaptive Phase Modulation, leveraging memory diversification and adaptive phase modulation for improved exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = max(10, int(dim / 2))  # Dynamically adjust memory size based on dimension\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # Phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initialize memory with random solutions\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Adaptive exploration-exploitation balance based on improvement\n            self.adaptivity_rate = min(0.6, self.adaptivity_rate + 0.02 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply adaptive phase shift for enhanced diversification\n            if np.random.rand() < self.adaptivity_rate:\n                phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n                phase_shift_value = func(phase_shift_candidate)\n                candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _phase_shift(self, solution, lb, ub):\n        adapt_phase_shift_rate = self.phase_shift_rate * (1 - self.adaptivity_rate)\n        shift = np.random.uniform(-adapt_phase_shift_rate, adapt_phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 86, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {}}
{"id": "864b833b-52ab-4e87-a1a0-129691af8b37", "fitness": 0.09168393871190535, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Adaptive Memory Search with Multi-phase Diversity Integration introduces multi-phase shifting and entropy-based selection to boost exploration and maintain solution diversity.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []  # Store solutions as tuples of (solution, value)\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # Parameter for phase shift diversification\n        self.multi_phase_factor = 0.05  # Factor for additional phase shifts\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Update adaptivity based on performance\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * max(0, best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Multi-phase shifts for enhanced diversification\n            phase_shift_candidate = self._multi_phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Entropy-based selection from memory for diverse exploration\n        probabilities = np.array(\n            [np.exp(-i / len(self.memory)) for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _multi_phase_shift(self, solution, lb, ub):\n        total_shift = np.zeros(self.dim)\n        for _ in range(2):  # Perform multiple phase shifts\n            shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n            total_shift += shift\n        shifted_solution = solution + total_shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09168 with standard deviation 0.00116.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09038024958828306, 0.09146532806841479, 0.09320623847901821]}}
{"id": "885f5831-4d8a-426b-95f1-536ef97d8673", "fitness": -Infinity, "name": "ImprovedEnhancedQuantumAdaptiveMemorySearch", "description": "Improved Enhanced Quantum Adaptive Memory Search with dynamic adaptation of phase shift rate for better exploitation and exploration balance.", "code": "import numpy as np\n\nclass ImprovedEnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.phase_shift_rate = 0.1\n        self.dynamic_shift_factor = 0.01\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n            self.phase_shift_rate = self.dynamic_shift_factor * (best_value - memory_value)\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 88, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {}}
{"id": "91fc89f9-46f4-4831-b4bf-ee2bc9d4b3ab", "fitness": 0.0926570235570802, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Adaptive Memory Search with Dynamic Memory Size and Contextual Phase Shift to improve convergence and diversity balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Initial memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # Parameter for phase shift diversification\n        self.dynamic_memory_scaling = 0.1  # Scaling factor for dynamic memory size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        # Initial memory population\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Adjust adaptivity rate based on improvement\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            # Quantum exploration\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Contextual phase shift for diversification\n            phase_shift_candidate = self._contextual_phase_shift(candidate_solution, best_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            # Update memory and dynamically adjust memory size\n            self._update_memory(candidate_solution, candidate_value)\n            self.memory_size = min(len(self.memory), max(5, int(self.dynamic_memory_scaling * self.budget / self.iteration)))\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _contextual_phase_shift(self, solution, best_solution, lb, ub):\n        direction = best_solution - solution\n        shift_magnitude = np.random.uniform(0, self.phase_shift_rate, self.dim) * (ub - lb)\n        shift = direction * shift_magnitude\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09266 with standard deviation 0.00084.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09301562264326768, 0.09149259047607872, 0.09346285755189421]}}
{"id": "8fe0a23a-6f8d-4d56-9c52-6dd8c97f76b4", "fitness": 0.0928772696736841, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Dynamic Search with Adaptive Memory using Gaussian perturbation for improved local search and convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n            \n            # Apply Gaussian perturbation for local search\n            perturb_candidate = self._gaussian_perturb(candidate_solution, lb, ub)\n            perturb_value = func(perturb_candidate)\n            candidate_solution, candidate_value = (perturb_candidate, perturb_value) if perturb_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _gaussian_perturb(self, solution, lb, ub):\n        # New method for Gaussian perturbation\n        perturb = np.random.normal(0, self.phase_shift_rate, self.dim) * (ub - lb)\n        perturbed_solution = solution + perturb\n        return np.clip(perturbed_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09288 with standard deviation 0.00043.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09257971582227187, 0.0934852803839552, 0.09256681281482526]}}
{"id": "82ab1dca-f4e1-4573-8462-a46bb1edce14", "fitness": -Infinity, "name": "EnhancedQuantumAdaptiveMemorySearchV2", "description": "Enhanced Quantum-Inspired Adaptive Search with Dynamic Memory Adjustment and Phase Shift for improved exploitation and exploration balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop(0)  # Remove worst solution instead of the last one", "configspace": "", "generation": 91, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {}}
{"id": "14855fac-54a3-4e3f-819a-1faae89c02fe", "fitness": 0.09233728370534107, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Improved Enhanced Quantum-Inspired Dynamic Search by incorporating adaptive memory pruning for better exploitation and adaptive exploration using chaotic maps to enhance diversity.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n        self.chaotic_map = np.random.rand(dim)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._chaotic_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _chaotic_explore(self, lb, ub):\n        # Using a Logistic map for chaotic exploration\n        self.chaotic_map = 4.0 * self.chaotic_map * (1 - self.chaotic_map)\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = (self.chaotic_map - 0.5) * 2 * self.adaptivity_rate * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n\n        # Adaptive memory pruning\n        if len(self.memory) > self.memory_size // 2:\n            self.memory = self.memory[:self.memory_size // 2]", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09234 with standard deviation 0.00208.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09425161296462059, 0.08944419853220198, 0.09331603961920065]}}
{"id": "ba4117bc-04f9-4765-b686-ba5697238924", "fitness": 0.09329715667595366, "name": "QuantumEnhancedAdaptiveMemorySearch", "description": "Quantum-Enhanced Adaptive Memory Search with Self-Tuning Mechanism to dynamically adjust exploration and exploitation balance through an adaptive learning rate and dynamic memory management.", "code": "import numpy as np\n\nclass QuantumEnhancedAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.phase_shift_rate = 0.1\n        self.learning_rate = 0.01  # Adds learning rate for adaptive updates\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            # Self-tuning adaptivity rate\n            self.adaptivity_rate = min(0.5, max(0.01, self.adaptivity_rate + self.learning_rate * (best_value - memory_value)))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        # Memory selection with adaptive probabilities\n        scores = np.array([v for _, v in self.memory])\n        probabilities = np.exp(-scores / (self.adaptivity_rate + 1e-9))\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory = self.memory[:self.memory_size]", "configspace": "", "generation": 93, "feedback": "The algorithm QuantumEnhancedAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09330 with standard deviation 0.00144.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09125544565005805, 0.09436672502249932, 0.09426929935530359]}}
{"id": "b0e6ac7c-00ed-4eb7-be30-bea154f47bf8", "fitness": -Infinity, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum Search with Memory Rejuvenation by reinvigorating memory entries for heightened diversity and adaptability.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop(0)  # Rejuvenate by removing the oldest entry", "configspace": "", "generation": 94, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {}}
{"id": "ac0bcfc3-66b7-45a8-9012-c5dc60e0d8b3", "fitness": 0.09280341050883223, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhanced Quantum-Inspired Adaptive Memory Search with Gaussian Perturbation and Dynamic Phase Shift for improved exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  \n        self.memory = []  \n        self.iteration = 0\n        self.adaptivity_rate = 0.1  \n        self.phase_shift_rate = 0.1  \n        self.gaussian_std = 0.1  \n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            gaussian_perturbed = self._gaussian_perturbation(candidate_solution, lb, ub)\n            gaussian_value = func(gaussian_perturbed)\n\n            if gaussian_value < candidate_value:\n                candidate_solution, candidate_value = gaussian_perturbed, gaussian_value\n\n            phase_shift_candidate = self._dynamic_phase_shift(candidate_solution, lb, ub, candidate_value, best_value)\n            phase_shift_value = func(phase_shift_candidate)\n\n            if phase_shift_value < candidate_value:\n                candidate_solution, candidate_value = phase_shift_candidate, phase_shift_value\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.mean([sol for sol, _ in self.memory], axis=0)\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub)\n\n    def _gaussian_perturbation(self, solution, lb, ub):\n        perturbation = np.random.normal(0, self.gaussian_std, self.dim) * (ub - lb)\n        perturbed_solution = solution + perturbation\n        return np.clip(perturbed_solution, lb, ub)\n\n    def _dynamic_phase_shift(self, solution, lb, ub, candidate_value, best_value):\n        dynamic_shift_rate = self.phase_shift_rate * (1 + (best_value - candidate_value) / max(1e-9, best_value))\n        shift = np.random.uniform(-dynamic_shift_rate, dynamic_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09280 with standard deviation 0.00039.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.0931933841462309, 0.09293881471047116, 0.09227803266979462]}}
{"id": "fb874b2d-a8ab-433f-91db-480311c64438", "fitness": 0.09193095013068135, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Improved Quantum Adaptive Memory Search with Dynamic Learning and Enhanced Evolution Strategy for diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)\n        self.memory = []\n        self.iteration = 0\n        self.adaptivity_rate = 0.1\n        self.phase_shift_rate = 0.1\n        self.diversification_factor = 0.2  # Added diversification factor\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            enhanced_candidate = self._evolve_solution(candidate_solution, lb, ub)  # Enhanced evolution strategy\n            enhanced_value = func(enhanced_candidate)\n            candidate_solution, candidate_value = (enhanced_candidate, enhanced_value) if enhanced_value < candidate_value else (candidate_solution, candidate_value)\n\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()\n\n    def _evolve_solution(self, solution, lb, ub):\n        mutation = np.random.normal(0, self.diversification_factor, self.dim)\n        evolved_solution = solution + mutation\n        return np.clip(evolved_solution, lb, ub)", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09193 with standard deviation 0.00111.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09036513474683094, 0.09274293649416931, 0.09268477915104378]}}
{"id": "5a7ea928-c9e8-4a11-830b-ec56dc1b71ff", "fitness": 0.09345164378059541, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Quantum-Inspired Dynamic Search with Enhanced Adaptive Memory using multi-phase shifts for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim) + 5  # Increased memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply multiple phase shifts for diversification\n            for _ in range(3):  # Apply three phase shifts\n                phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n                phase_shift_value = func(phase_shift_candidate)\n                if phase_shift_value < candidate_value:\n                    candidate_solution, candidate_value = phase_shift_candidate, phase_shift_value\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09345 with standard deviation 0.00129.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09162628835603437, 0.0943881737039618, 0.09434046928179007]}}
{"id": "ed33f43f-a5ab-4c3c-a583-bbb4d679cbbe", "fitness": 0.09212440822625197, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Improved Adaptive Memory Update by incorporating a dynamic memory size adjustment based on convergence progress.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.01 * (best_value - memory_value))\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        self.memory_size = max(5, min(10, int(self.budget / (self.budget - self.iteration + 1))))  # Adjust memory size dynamically\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedQuantumAdaptiveMemorySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09212 with standard deviation 0.00047.", "error": "", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {"aucs": [0.09256707321539692, 0.09147640125518064, 0.09232975020817835]}}
{"id": "a2349109-36f3-4aff-b2ee-66bfd74fe367", "fitness": -Infinity, "name": "EnhancedQuantumAdaptiveMemorySearch", "description": "Enhancing Quantum Memory Search with Adaptive Rate Adjustment for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveMemorySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = min(10, dim)  # Fixed memory size\n        self.memory = []  # Store solutions\n        self.iteration = 0\n        self.adaptivity_rate = 0.1  # Initial adaptivity rate for exploration/exploitation balance\n        self.phase_shift_rate = 0.1  # New parameter for phase shift diversification\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        best_solution = None\n        best_value = float('inf')\n\n        for _ in range(self.memory_size):\n            solution = np.random.uniform(lb, ub, self.dim)\n            value = func(solution)\n            self._update_memory(solution, value)\n            if value < best_value:\n                best_value = value\n                best_solution = solution\n\n        self.iteration += self.memory_size\n\n        while self.iteration < self.budget:\n            memory_solution, memory_value = self._select_from_memory()\n\n            self.adaptivity_rate = min(0.5, self.adaptivity_rate + 0.02 * (best_value - memory_value))  # Changed from 0.01 to 0.02\n\n            candidate_solution = self._quantum_explore(lb, ub)\n            candidate_value = func(candidate_solution)\n\n            # Apply phase shift for diversification\n            phase_shift_candidate = self._phase_shift(candidate_solution, lb, ub)\n            phase_shift_value = func(phase_shift_candidate)\n            candidate_solution, candidate_value = (phase_shift_candidate, phase_shift_value) if phase_shift_value < candidate_value else (candidate_solution, candidate_value)\n\n            self.iteration += 1\n\n            if candidate_value < best_value:\n                best_value = candidate_value\n                best_solution = candidate_solution\n\n            self._update_memory(candidate_solution, candidate_value)\n\n        return best_solution\n\n    def _select_from_memory(self):\n        probabilities = np.array(\n            [self.adaptivity_rate if i == 0 else np.random.rand() for i in range(len(self.memory))])\n        probabilities /= probabilities.sum()\n        idx = np.random.choice(len(self.memory), p=probabilities)\n        return self.memory[idx]\n\n    def _quantum_explore(self, lb, ub):\n        superposition = np.array([np.mean([sol for sol, _ in self.memory], axis=0)])\n        entanglement = np.random.uniform(-self.adaptivity_rate, self.adaptivity_rate, self.dim) * (ub - lb)\n        candidate_solution = superposition + entanglement\n        return np.clip(candidate_solution, lb, ub).flatten()\n\n    def _phase_shift(self, solution, lb, ub):\n        shift = np.random.uniform(-self.phase_shift_rate, self.phase_shift_rate, self.dim) * (ub - lb)\n        shifted_solution = solution + shift\n        return np.clip(shifted_solution, lb, ub)\n\n    def _update_memory(self, solution, value):\n        self.memory.append((solution, value))\n        self.memory.sort(key=lambda x: x[1])\n        if len(self.memory) > self.memory_size:\n            self.memory.pop()", "configspace": "", "generation": 99, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["3b7252f2-d511-45e0-976e-94fde8dff22e"], "operator": null, "metadata": {}}
