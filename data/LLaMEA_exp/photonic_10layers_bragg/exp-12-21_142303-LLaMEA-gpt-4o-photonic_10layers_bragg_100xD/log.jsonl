{"id": "3ad80265-e4d9-4228-b57f-aff26f6478ce", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Adaptive Quantum-inspired Evolutionary Algorithm (AQEA) combines quantum-inspired representation with an adaptive mutation strategy for efficient black-box optimization.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 0, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "4d9ead46-ccc3-4163-bad7-6ce03cc32b12", "fitness": 0.005618322835866274, "name": "EAQEA", "description": "Enhanced AQEA (EAQEA) introduces an elitism strategy and dynamic population resizing to balance exploration and exploitation, improving convergence efficiency.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _elitism_selection(self, real_population, fitness):\n        elite_count = max(1, self.population_size // 10)\n        elite_indices = fitness.argsort()[:elite_count]\n        elite_population = real_population[elite_indices]\n        self.q_population[:elite_count] = elite_population\n\n    def _dynamic_population_resize(self, evaluations):\n        if evaluations < self.budget // 2:\n            self.population_size = min(self.initial_population_size * 2, self.population_size + 5)\n        else:\n            self.population_size = max(self.initial_population_size // 2, self.population_size - 5)\n        self.q_population = np.resize(self.q_population, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            self._elitism_selection(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n            self._dynamic_population_resize(evaluations)\n\n        return self.best_solution", "configspace": "", "generation": 1, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "6906fe84-0885-4c61-89c9-fa3837ad12d3", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced AQEA with a dual-adaptive strategy for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.exploration_factor = 0.1  # New line for dual adaptivity\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05 * self.exploration_factor, self.q_population.shape))  # Adjusted mutation\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _dynamic_exploration(self, evaluations):  # New function\n        self.exploration_factor = 1 - (evaluations / self.budget)  # Dynamically adjust exploration factor\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._dynamic_exploration(evaluations)\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 2, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "f7387a5c-cc72-4e81-a201-d326478661fe", "fitness": 0.005618322835866274, "name": "EAQEA", "description": "Enhanced Adaptive Quantum-inspired Evolutionary Algorithm (EAQEA) introduces an elite preservation mechanism and dynamic quantum observation for improved black-box optimization.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_fraction = 0.1  # Fraction of elite solutions to preserve\n\n    def _quantum_observation(self, dynamic_factor=0.1):\n        angles = np.arccos(1 - 2 * self.q_population)\n        dynamic_adjustment = (np.random.rand(*angles.shape) < dynamic_factor).astype(float)\n        return ((np.cos(angles) > np.random.rand(*angles.shape)) + dynamic_adjustment).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _preserve_elite(self, real_population, fitness):\n        elite_count = int(self.elite_fraction * self.population_size)\n        elite_indices = np.argsort(fitness)[:elite_count]\n        elite_solutions = real_population[elite_indices]\n        elite_fitness = fitness[elite_indices]\n        return elite_solutions, elite_fitness\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            \n            # Preserve elite solutions\n            elite_solutions, elite_fitness = self._preserve_elite(real_population, fitness)\n            \n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n            # Inject elite solutions back into the population\n            elite_count = len(elite_solutions)\n            self.q_population[:elite_count] = np.random.uniform(0, 1, (elite_count, self.dim))\n            real_population[:elite_count] = elite_solutions\n\n        return self.best_solution", "configspace": "", "generation": 3, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "b103e8d0-686c-4438-94b1-1a8b8c671830", "fitness": 0.005618322835866274, "name": "EQEA", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) incorporates a dynamic selection pressure mechanism and adaptive population size for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass EQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.dynamic_selection_pressure = 0.5\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _dynamic_selection(self, fitness):\n        sorted_indices = np.argsort(fitness)\n        top_individuals = sorted_indices[:int(self.dynamic_selection_pressure * self.population_size)]\n        self.q_population = self.q_population[top_individuals]\n        self.population_size = len(top_individuals)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            self._dynamic_selection(fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n            # Refill population if reduced too much\n            if self.population_size < self.initial_population_size / 2:\n                additional_individuals = self.initial_population_size - self.population_size\n                new_individuals = np.random.uniform(0, 1, (additional_individuals, self.dim))\n                self.q_population = np.vstack((self.q_population, new_individuals))\n                self.population_size = self.q_population.shape[0]\n\n        return self.best_solution", "configspace": "", "generation": 4, "feedback": "The algorithm EQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "bb9b4c27-97cc-4acb-8aec-348661c3e349", "fitness": 0.0049547381330536195, "name": "AQEA", "description": "Improved AQEA with enhanced adaptive mutation and dynamic population size adjustment for better black-box optimization performance.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.1, self.q_population.shape))  # Increased mutation strength\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n        if np.mean(self.q_population) < 0.5:  # Dynamic population size adjustment\n            self.population_size = min(self.population_size + 5, 50)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 5, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00495 with standard deviation 0.00047.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.004622945781647347, 0.005618322835866274, 0.004622945781647236]}}
{"id": "d4a11b69-fb19-4631-91a5-9761046a4b03", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced AQEA with an improved adaptive mutation strategy for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape) * 2  # Increased variability\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 6, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "c2ba161d-5e7c-4459-90e4-f4959d75a3af", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced Adaptive Quantum-inspired Evolutionary Algorithm (AQEA) with improved adaptive mutation using a dynamic scaling factor based on population diversity for efficient black-box optimization.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        diversity_factor = np.std(self.q_population, axis=0)  # Change: Dynamic scaling based on population diversity\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5) * (1 + diversity_factor)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 7, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "e70de1ba-8d92-4fb3-a5dc-5799fdc3c4b3", "fitness": 0.005618322835866274, "name": "EAQEA", "description": "Enhanced Adaptive Quantum-inspired Evolutionary Algorithm (E-AQEA) leverages dynamic population resizing and elite preservation to improve convergence in black-box optimization.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_fraction = 0.1  # Fraction of elite individuals to preserve\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _preserve_elites(self, real_population, fitness):\n        elite_count = max(1, int(self.elite_fraction * self.population_size))\n        elite_indices = np.argsort(fitness)[:elite_count]\n        self.q_population[:elite_count] = real_population[elite_indices]\n\n    def _dynamic_population_resizing(self, evaluations):\n        # Gradually increase/decrease population size based on budget consumption\n        factor = (1 - evaluations / self.budget)\n        self.population_size = max(5, int(self.initial_population_size * factor))\n        self.q_population = np.resize(self.q_population, (self.population_size, self.dim))\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            self._preserve_elites(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n            self._dynamic_population_resizing(evaluations)\n\n        return self.best_solution", "configspace": "", "generation": 8, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "dfc25477-5ee9-430c-96ec-a091112c886e", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced AQEA with a refined adaptive mutation strategy for improved convergence.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        # Edited line: Modified mutation strategy for more significant adaptation\n        self.q_population += 0.5 * mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 9, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "5ab22f24-f326-412e-8e94-24902fdd37f0", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) introduces a dynamic population size to improve convergence in black-box optimization.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        # Change: Implement a dynamic population size\n        self.population_size = max(20, int(self.budget / 10))  \n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 10, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "a82716e3-d386-428c-963d-5fe97a0a865a", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Improved Adaptive Quantum-inspired Evolutionary Algorithm (AQEA) incorporating rank-based selection and dynamic mutation scaling for enhanced convergence.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        ranked_fitness = np.argsort(np.argsort(self.q_population.sum(axis=1)))\n        mutation_strength = 0.01 / (1 + ranked_fitness)\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength.reshape(-1, 1) * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 11, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "a218f584-28de-44c3-9ae0-61339a495a43", "fitness": -Infinity, "name": "EQEA", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) integrates a dynamic population size adjustment and elite retention strategy to improve exploration and exploitation balance for black-box optimization.", "code": "import numpy as np\n\nclass EQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.initial_population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.elite_fraction = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, evaluations):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n        # Dynamically adjust the population size based on budget utilization\n        self.population_size = int(self.initial_population_size * (1 + evaluations / self.budget))\n        self.q_population = np.resize(self.q_population, (self.population_size, self.dim))\n        self.q_population = np.clip(np.random.uniform(0, 1, self.q_population.shape), 0, 1)\n\n    def _retain_elites(self, real_population, fitness):\n        elite_count = max(1, int(self.elite_fraction * self.population_size))\n        elite_indices = np.argsort(fitness)[:elite_count]\n        return real_population[elite_indices], fitness[elite_indices]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            elites, elite_fitness = self._retain_elites(real_population, fitness)\n\n            if evaluations < self.budget:\n                self._adaptive_mutation(evaluations)\n                self.q_population[:len(elites)] = elites  # Retain best solutions\n\n        return self.best_solution", "configspace": "", "generation": 12, "feedback": "An exception occurred: AttributeError(\"'EQEA' object has no attribute 'population_size'\").", "error": "AttributeError(\"'EQEA' object has no attribute 'population_size'\")", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {}}
{"id": "14d34136-3c0b-42a7-bb8e-e9d4e126a54d", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Improved Adaptive Quantum-inspired Evolutionary Algorithm (IAQEA) refines adaptive mutation by scaling mutation strength with a dynamic factor based on iterations for enhanced convergence.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, iter_count, max_iter):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        dynamic_factor = 1 - (iter_count / max_iter)\n        self.q_population += mutation_strength * (adapt_factor - 0.5) * dynamic_factor\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n        max_iter = self.budget // self.population_size\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            self._adaptive_mutation(evaluations // self.population_size, max_iter)\n            evaluations += self.population_size\n\n        return self.best_solution", "configspace": "", "generation": 13, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "674e9602-a350-4f35-9d85-362344c05e21", "fitness": -Infinity, "name": "QSA_DE", "description": "Quantum-Self-Adaptive Differential Evolution (QSA-DE) leverages a quantum-inspired initialization and adaptive differential mutation strategy to enhance black-box optimization efficiency.", "code": "import numpy as np\n\nclass QSA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _differential_mutation(self, population, bounds, F=0.5, CR=0.9):\n        mutated_population = np.empty_like(population)\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = population[indices]\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, 0, 1)\n            trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n            trial_real = bounds.lb + trial * (bounds.ub - bounds.lb)\n            if func(trial_real) < func(population[i]):\n                mutated_population[i] = trial\n            else:\n                mutated_population[i] = population[i]\n        return mutated_population\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self.q_population = self._differential_mutation(self.q_population, bounds)\n\n        return self.best_solution", "configspace": "", "generation": 14, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {}}
{"id": "e4a3c297-023a-4d06-885c-4ffd09f4966e", "fitness": -Infinity, "name": "EAQEA", "description": "Enhanced Adaptive Quantum-inspired Evolutionary Algorithm (EAQEA) introduces a hybrid exploration-exploitation strategy by integrating a global search phase using Levy flights to improve convergence in black-box optimization.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def _global_search(self, bounds):\n        for _ in range(self.population_size):\n            random_individual = np.random.uniform(bounds.lb, bounds.ub, self.dim)\n            step_size = self._levy_flight(self.dim)\n            random_individual += 0.01 * step_size * (random_individual - self.best_solution)\n            random_individual = np.clip(random_individual, bounds.lb, bounds.ub)\n            yield random_individual\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            # Hybrid exploration-exploitation strategy\n            if evaluations < self.budget // 2:\n                self._adaptive_mutation()\n            else:\n                for individual in self._global_search(bounds):\n                    ind_fitness = func(individual)\n                    if ind_fitness < self.best_fitness:\n                        self.best_fitness = ind_fitness\n                        self.best_solution = individual\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n\n        return self.best_solution", "configspace": "", "generation": 15, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {}}
{"id": "3628cae9-567c-4a5b-b2db-ac4a5be146de", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced AQEA with dynamic population size to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n            self.q_population = np.random.uniform(0, 1, (self.population_size + evaluations // self.budget, self.dim))\n\n        return self.best_solution", "configspace": "", "generation": 16, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "996426dc-4bf6-452f-a924-e8d8222d2c54", "fitness": -Infinity, "name": "QADE", "description": "Quantum Adaptive Differential Evolution (QADE) integrates quantum-inspired representation with differential evolution strategies for enhanced exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass QADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _differential_evolution(self, real_population, fitness):\n        for i in range(self.population_size):\n            a, b, c = np.random.choice(self.population_size, 3, replace=False)\n            mutant = real_population[a] + self.F * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, 0, 1)\n            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, real_population[i])\n            if func(trial) < fitness[i]:\n                real_population[i] = trial\n                fitness[i] = func(trial)\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            self._differential_evolution(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 17, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {}}
{"id": "7b5763da-00fb-4adb-b78c-973da4dd4387", "fitness": 0.005618322835866274, "name": "ImprovedAQEA", "description": "Improved AQEA with Quantum Rotation Gate and Dynamic Population Strategy for enhanced exploration and exploitation balance in black-box optimization.", "code": "import numpy as np\n\nclass ImprovedAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, dim * 2)  # Dynamic population size based on dimension\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.rotation_angle = 0.05  # Quantum rotation gate parameter\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _quantum_rotation_gate(self):\n        rotation_matrix = np.array(\n            [[np.cos(self.rotation_angle), -np.sin(self.rotation_angle)], \n             [np.sin(self.rotation_angle), np.cos(self.rotation_angle)]]\n        )\n        for i in range(self.population_size):\n            obs = self._quantum_observation()[i]\n            angle = np.arccos(1 - 2 * obs)\n            new_angle = angle + self.rotation_angle * (2 * np.random.rand(self.dim) - 1)\n            self.q_population[i] = (1 - np.cos(new_angle)) / 2\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._quantum_rotation_gate()  # Apply quantum rotation gate\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 18, "feedback": "The algorithm ImprovedAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "fd09e031-788b-41e3-82f4-709a0d2382cb", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced Adaptive Quantum-inspired Evolutionary Algorithm (EAQEA) introduces non-uniform mutation scaling and elitism to improve convergence.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5) * (0.5 - self.q_population)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 19, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "0178924c-9f78-43c4-9a17-d85316df5f59", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced AQEA by refining adaptive mutation to incorporate fitness-based scaling for more precise exploration.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        fitness_based_scaling = 1 - np.exp(-self.best_fitness)\n        self.q_population += mutation_strength * (adapt_factor - 0.5) * fitness_based_scaling\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 20, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "0815b9ac-74e8-4613-ba83-fc206d580318", "fitness": 0.005618322835866274, "name": "AQEA", "description": "AQEA with Enhanced Quantum Mutation employs an improved mutation step to boost exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.randn(*self.q_population.shape)  # Line modified for improved exploration/exploitation\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 21, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "063c6ebc-36e8-49b1-8aba-8584714394ea", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Improved Adaptive Quantum-inspired Evolutionary Algorithm (AQEA) by refining mutation strategy to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        # Change the mutation strategy for more balanced exploration and exploitation.\n        self.q_population += mutation_strength * (adapt_factor - 0.25)  \n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 22, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "2e538b91-dbe1-44c3-8379-22ef3549325e", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced AQEA introduces elite solution retention by preserving the best solution at each iteration.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            self.q_population[0] = self.best_solution  # Retain elite solution\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 23, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "ff1dccd9-dd5d-4230-9667-65d84a362da0", "fitness": 0.005618322835866274, "name": "EAQEA", "description": "Enhanced Adaptive Quantum-inspired Evolutionary Algorithm (EAQEA) introduces a dynamic population size strategy and self-adjusting mutation rate to improve convergence speed and solution accuracy in black-box optimization.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_rate = 0.05\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, self.mutation_rate, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _dynamic_population_size(self, evaluations):\n        progress_rate = evaluations / self.budget\n        new_size = int(self.initial_population_size * (1 - progress_rate) + 5)\n        if new_size != self.population_size:\n            self.population_size = new_size\n            self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def _adjust_mutation_rate(self, evaluations):\n        progress_rate = evaluations / self.budget\n        self.mutation_rate = 0.05 * (1 - progress_rate) + 0.01\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._dynamic_population_size(evaluations)\n            self._adjust_mutation_rate(evaluations)\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 24, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "9c8aacfe-e26e-4be5-9fd2-6e6c27c8e288", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced Adaptive Quantum-inspired Evolutionary Algorithm (EAQEA) integrates an elite preservation mechanism for improved convergence performance.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n            elite_idx = np.argmin(fitness)\n            self.q_population[0] = real_population[elite_idx] / (bounds.ub - bounds.lb)  # Elite preservation\n\n        return self.best_solution", "configspace": "", "generation": 25, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "75eae67c-a02e-4ebf-b8f6-0c89a17eee75", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Enhanced AQEA using dynamic population size for improved convergence while maintaining efficiency.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, budget // dim)  # Changed to dynamically adjust based on budget and dimension\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 26, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "c9abecf2-1902-45a0-93b6-af77baa2b685", "fitness": 0.005618322835866274, "name": "EAQEA", "description": "Enhanced Adaptive Quantum-inspired Evolutionary Algorithm (EAQEA) combines quantum representation with adaptive mutation and diversity management to improve exploration and convergence in black-box optimization.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.diversity_threshold = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n        self._enforce_diversity()\n\n    def _enforce_diversity(self):\n        # Enforcing diversity to avoid premature convergence\n        diversity = np.std(self.q_population, axis=0)\n        if np.any(diversity < self.diversity_threshold):\n            self.q_population += np.random.uniform(-0.1, 0.1, self.q_population.shape)\n            self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 27, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "490a0124-9e6b-411e-89ac-479e9a8aedb0", "fitness": 0.005618322835866274, "name": "AQEA", "description": "Adaptive Quantum-inspired Evolutionary Algorithm (AQEA) now incorporates a hybrid crossover to enhance solution diversity and convergence.", "code": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _hybrid_crossover(self, real_population):\n        crossover_rate = 0.1\n        for i in range(0, self.population_size, 2):\n            if np.random.rand() < crossover_rate:\n                crossover_point = np.random.randint(1, self.dim - 1)\n                real_population[i, crossover_point:], real_population[i + 1, crossover_point:] = \\\n                real_population[i + 1, crossover_point:], real_population[i, crossover_point:]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            self._hybrid_crossover(real_population)\n            evaluations += self.population_size\n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 28, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "e786407c-ed75-471b-9468-e967f0b346c7", "fitness": 0.02330030153818108, "name": "HQEA", "description": "Hybrid Quantum-inspired Evolutionary Algorithm (HQEA) enhances AQEA by integrating a differential evolution strategy and a dynamic adaptation mechanism for more efficient exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass HQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds):\n        trial_population = np.copy(real_population)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            trial_population = self._differential_evolution(real_population, bounds)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n            \n            self._adaptive_mutation()\n\n        return self.best_solution", "configspace": "", "generation": 29, "feedback": "The algorithm HQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02330 with standard deviation 0.00079.", "error": "", "parent_ids": ["3ad80265-e4d9-4228-b57f-aff26f6478ce"], "operator": null, "metadata": {"aucs": [0.022221186109822155, 0.024108571140032065, 0.023571147364689016]}}
{"id": "285b811e-58b0-42f4-8859-fe94d2a9496d", "fitness": 0.0212941346744366, "name": "EQEA", "description": "Enhanced Quantum-inspired Evolutionary Algorithm (EQEA) improves HQEA by introducing a dynamic population size mechanism and an adaptive crossover rate to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass EQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.initial_population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population_growth_rate = 1.05\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self):\n        mutation_strength = np.abs(np.random.normal(0, 0.05, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _adaptive_crossover(self):\n        self.crossover_rate = 0.5 + 0.5 * (self.budget - self.remaining_budget) / self.budget\n\n    def _differential_evolution(self, real_population, bounds):\n        trial_population = np.copy(real_population)\n        for i in range(real_population.shape[0]):\n            indices = [idx for idx in range(real_population.shape[0]) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n        self.remaining_budget = self.budget\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += real_population.shape[0]\n            self.remaining_budget -= real_population.shape[0]\n            trial_population = self._differential_evolution(real_population, bounds)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(real_population.shape[0]):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n            \n            self._adaptive_mutation()\n            self._adaptive_crossover()\n\n            # Dynamic population size adjustment\n            if self.remaining_budget > 0:\n                new_population_size = int(self.q_population.shape[0] * self.population_growth_rate)\n                if new_population_size > self.remaining_budget:\n                    new_population_size = self.remaining_budget\n                self.q_population = np.random.uniform(0, 1, (new_population_size, self.dim))\n\n        return self.best_solution", "configspace": "", "generation": 30, "feedback": "The algorithm EQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02129 with standard deviation 0.00184.", "error": "", "parent_ids": ["e786407c-ed75-471b-9468-e967f0b346c7"], "operator": null, "metadata": {"aucs": [0.01993743123928704, 0.02390230142094185, 0.02004267136308091]}}
{"id": "cab31f0f-70b0-486d-bb59-24bfd8bfb3aa", "fitness": 0.03786354497963137, "name": "EAQEA", "description": "Enhanced Adaptive Quantum Evolutionary Algorithm (EAQEA) improves HQEA by introducing a learning component that adapts mutation strength and crossover rates dynamically based on population diversity to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n            \n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 31, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03786 with standard deviation 0.00315.", "error": "", "parent_ids": ["e786407c-ed75-471b-9468-e967f0b346c7"], "operator": null, "metadata": {"aucs": [0.04055192114777406, 0.03959768217915183, 0.03344103161196821]}}
{"id": "084220e6-59d2-44f9-9308-f4800aa91496", "fitness": -Infinity, "name": "DQIDE", "description": "Dynamic Quantum-Inspired Differential Evolution (DQIDE) enhances EAQEA by incorporating real-time diversity assessment to dynamically adapt population size and implement adaptive crossover strategies, improving convergence efficiency and robustness.", "code": "import numpy as np\n\nclass DQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.max_population_size = 50\n        self.q_population = np.random.uniform(0, 1, (self.initial_population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        population_size = min(self.initial_population_size + int(20 * diversity), self.max_population_size)\n        trial_population = np.copy(real_population[:population_size])\n        for i in range(population_size):\n            indices = [idx for idx in range(population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += len(real_population)\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(len(trial_population)):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n            \n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 32, "feedback": "An exception occurred: IndexError('index 44 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 44 is out of bounds for axis 0 with size 30')", "parent_ids": ["cab31f0f-70b0-486d-bb59-24bfd8bfb3aa"], "operator": null, "metadata": {}}
{"id": "016ac00e-d7cc-46f5-bcef-ea4811f1c3c6", "fitness": 0.005618322835866274, "name": "EAQEA", "description": "Enhanced Adaptive Quantum Evolutionary Algorithm with Diversity-Driven Dynamic Strategy (EAQEA-DDDS) enhances EAQEA by incorporating a diversity-driven dynamic strategy where both mutation and crossover rates are dynamically adapted based on the diversity index to enhance convergence and performance on various problem landscapes.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        adjusted_mutation_factor = 0.5 + 0.5 * (1 - diversity)\n        adjusted_crossover_rate = 0.7 + 0.2 * diversity\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + adjusted_mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (adjusted_crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n            \n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 33, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["cab31f0f-70b0-486d-bb59-24bfd8bfb3aa"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "db9e738a-6e98-4e1c-8f22-57f6c2c27755", "fitness": 0.03792587126475725, "name": "EAQEA", "description": "EAQEA+ introduces a diversity boost mechanism to enhance exploration by periodically injecting random solutions, maintaining exploration and exploitation balance.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.diversity_boost_interval = 100  # New line: interval for diversity boost\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:  # New line: check diversity boost interval\n                self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))  # New line: inject randomness\n            \n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 34, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03793 with standard deviation 0.00306.", "error": "", "parent_ids": ["cab31f0f-70b0-486d-bb59-24bfd8bfb3aa"], "operator": null, "metadata": {"aucs": [0.04055192114777406, 0.03959768217915183, 0.03362801046734587]}}
{"id": "5f1d555e-6473-4912-ab82-ed2688cae0f9", "fitness": 0.03792587126475725, "name": "EAQEA", "description": "EAQEA++ introduces adaptive crossover rate adjustment based on diversity to enhance convergence without sacrificing exploration.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.diversity_boost_interval = 100  # New line: interval for diversity boost\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            adaptive_crossover_rate = self.crossover_rate * (1 + diversity)  # Change: Use adaptive crossover rate\n            crossover = np.random.rand(self.dim) < adaptive_crossover_rate  # Change: Adjust crossover probability\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:  # New line: check diversity boost interval\n                self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))  # New line: inject randomness\n            \n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 35, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03793 with standard deviation 0.00306.", "error": "", "parent_ids": ["db9e738a-6e98-4e1c-8f22-57f6c2c27755"], "operator": null, "metadata": {"aucs": [0.04055192114777406, 0.03959768217915183, 0.03362801046734587]}}
{"id": "69c86df0-2916-4c45-8275-9bc467cb75e7", "fitness": 0.005618322835866274, "name": "EAQEA", "description": "EAQEA++ enhances search efficiency by adjusting the mutation factor dynamically based on diversity, improving convergence speed.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.diversity_boost_interval = 100  # New line: interval for diversity boost\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            self.mutation_factor = 0.3 + 0.4 * diversity  # Modified line: dynamic mutation factor\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:  # New line: check diversity boost interval\n                self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))  # New line: inject randomness\n            \n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 36, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["db9e738a-6e98-4e1c-8f22-57f6c2c27755"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "d1c0a435-98c1-412d-8129-d689e538ed0f", "fitness": 0.005618322835866274, "name": "EAQEA", "description": "EAQEA++ enhances diversity by introducing adaptive diversity boost frequency and improved crossover strategy.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.diversity_boost_interval = 100  # New line: interval for diversity boost\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover_prob = self.crossover_rate * (1.0 - diversity)  # Modified line: improved crossover strategy\n            crossover = np.random.rand(self.dim) < crossover_prob\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % max(1, int(self.diversity_boost_interval * (1.0 - diversity))) == 0:  # Modified line: adaptive diversity boost frequency\n                self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n            \n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 37, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["db9e738a-6e98-4e1c-8f22-57f6c2c27755"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "70704558-639c-4f81-bb05-f298a8c99859", "fitness": 0.03802534976064006, "name": "EAQEA", "description": "EAQEA++ enhances diversity by resetting half of the population to random values at each diversity boost interval.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.diversity_boost_interval = 100  # New line: interval for diversity boost\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:  # New line: check diversity boost interval\n                self.q_population[:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2, self.dim))  # Adjusted line: partially reset population\n            \n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 38, "feedback": "The algorithm EAQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03803 with standard deviation 0.00325.", "error": "", "parent_ids": ["db9e738a-6e98-4e1c-8f22-57f6c2c27755"], "operator": null, "metadata": {"aucs": [0.04055192114777406, 0.0400830965221779, 0.03344103161196821]}}
{"id": "8990fb03-ac6d-4596-a41f-e41d5b07d7fd", "fitness": -Infinity, "name": "EAQEA", "description": "EAQEA+++ further boosts exploration by dynamically adjusting mutation and crossover rates based on convergence speed and diversity metrics.", "code": "import numpy as np\n\nclass EAQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.diversity_boost_interval = 100\n        self.convergence_threshold = 1e-5  # New line: threshold for convergence speed\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity, convergence_speed):\n        mutation_strength = np.abs(np.random.normal(0, diversity * convergence_speed, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity, convergence_speed):\n        trial_population = np.copy(real_population)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * convergence_speed * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity * convergence_speed)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _calculate_convergence_speed(self, fitness_history):\n        if len(fitness_history) < 2:\n            return 1.0\n        change = np.abs(np.diff(fitness_history))\n        speed = change[-1] / max(change[:-1].max(), self.convergence_threshold)\n        return min(speed, 2.0)  # Cap the speed factor to avoid excessive mutation\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n        fitness_history = []\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            fitness_history.append(np.min(fitness))\n            \n            diversity = self._calculate_diversity(real_population)\n            convergence_speed = self._calculate_convergence_speed(fitness_history)\n            trial_population = self._differential_evolution(real_population, bounds, diversity, convergence_speed)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2, self.dim))\n            \n            self._adaptive_mutation(diversity, convergence_speed)\n\n        return self.best_solution", "configspace": "", "generation": 39, "feedback": "An exception occurred: ValueError('zero-size array to reduction operation maximum which has no identity').", "error": "ValueError('zero-size array to reduction operation maximum which has no identity')", "parent_ids": ["70704558-639c-4f81-bb05-f298a8c99859"], "operator": null, "metadata": {}}
{"id": "4ee83014-553b-4a6e-a2bc-57ec86a8aae3", "fitness": 0.03802534976064006, "name": "EAQEAPlusPlusPlus", "description": "EAQEA+++ incorporates strategic elitism by preserving a subset of the best solutions across generations while maintaining diversity through randomized population resets and adaptive mutation.", "code": "import numpy as np\n\nclass EAQEAPlusPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.elite_size = 5  # New line: size of the elite population\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.diversity_boost_interval = 100\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            # Preserve the elite solutions\n            elite_indices = np.argsort(fitness)[:self.elite_size]\n            elites = real_population[elite_indices]\n            \n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2, self.dim))\n            \n            # Re-inject elites\n            real_population[:self.elite_size] = elites\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 40, "feedback": "The algorithm EAQEAPlusPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03803 with standard deviation 0.00325.", "error": "", "parent_ids": ["70704558-639c-4f81-bb05-f298a8c99859"], "operator": null, "metadata": {"aucs": [0.04055192114777406, 0.0400830965221779, 0.03344103161196821]}}
{"id": "f98a6cf6-a559-4188-a46a-c722311200b8", "fitness": 0.03936696290011384, "name": "EAQEAPlusPlus", "description": "EAQEA+++ introduces dynamic population size and elitism to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2  # New line: Number of elite solutions to retain\n        self.diversity_boost_interval = 100\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 41, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03937 with standard deviation 0.00168.", "error": "", "parent_ids": ["70704558-639c-4f81-bb05-f298a8c99859"], "operator": null, "metadata": {"aucs": [0.04054020617616694, 0.04056352291209098, 0.03699715961208361]}}
{"id": "4d552cc1-590f-4a87-985c-f6b12f40e969", "fitness": 0.005618322835866274, "name": "EAQEAPlusPlus", "description": "EAQEA+++ enhanced with adaptive mutation factor based on current diversity to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2  # Number of elite solutions to retain\n        self.diversity_boost_interval = 100\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + (self.mutation_factor + diversity) * (real_population[b] - real_population[c])  # Changed this line\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 42, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "0643a586-fa12-41a1-afad-e20812f43dac", "fitness": 0.038927528980629754, "name": "EAQEAPlusPlus", "description": "EAQEA+++ with enhanced mutation strategy using adaptive diversity scaling for improved fitness convergence.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2  # New line: Number of elite solutions to retain\n        self.diversity_boost_interval = 100\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity * (1 + evaluations/self.budget))  # Line changed\n\n        return self.best_solution", "configspace": "", "generation": 43, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03893 with standard deviation 0.00230.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.04054020617616694, 0.04056352291209098, 0.03567885785363134]}}
{"id": "8523f3d8-ada0-4001-8b60-34253ac09d8f", "fitness": 0.03936696290011384, "name": "EAQEAPlusPlus", "description": "EAQEA+++ with Periodic Reinitialization introduces periodic reset of the worst half of the population to improve exploration and avoid local optima.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.reinit_interval = 200  # New line: Interval for reinitialization\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            if evaluations % self.reinit_interval == 0:  # New block: Periodic reinitialization\n                worst_half = np.argsort(fitness)[self.population_size // 2:]\n                self.q_population[worst_half] = np.random.uniform(0, 1, (len(worst_half), self.dim))\n                \n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 44, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03937 with standard deviation 0.00168.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.04054020617616694, 0.04056352291209098, 0.03699715961208361]}}
{"id": "095ccfe7-f562-458a-ac6e-bf074b81cc01", "fitness": 0.037029019723264854, "name": "EAQEAPlusPlusEnhanced", "description": "EAQEA+++ with adaptive elitism and diversity control enhances convergence by dynamically adjusting elitism based on population diversity.", "code": "import numpy as np\n\nclass EAQEAPlusPlusEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_elite_threshold = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adjust_elitism(self, diversity):\n        if diversity < self.dynamic_elite_threshold:\n            self.elite_count = max(1, self.elite_count - 1)\n        else:\n            self.elite_count = min(5, self.elite_count + 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adjust_elitism(diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 45, "feedback": "The algorithm EAQEAPlusPlusEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03703 with standard deviation 0.00287.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.04050359291163186, 0.033465482471467856, 0.03711798378669484]}}
{"id": "f0c0aa7f-1b8c-4b47-b2f6-1244841ba1ea", "fitness": 0.03683721386209171, "name": "EAQEAOpt", "description": "EAQEAOpt introduces adaptive crossover and strategic diversity preservation to enhance convergence and solution quality.", "code": "import numpy as np\n\nclass EAQEAOpt:  # Changed class name\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _adaptive_crossover(self, diversity):  # New function\n        return np.clip(self.crossover_rate + 0.1 * diversity, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < self._adaptive_crossover(diversity)  # Modified\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 3] = np.random.uniform(0, 1, (self.population_size // 3 - self.elite_count, self.dim))  # Modified\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 46, "feedback": "The algorithm EAQEAOpt got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03684 with standard deviation 0.00282.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.04072233000027292, 0.03411045373237087, 0.03567885785363134]}}
{"id": "396337f0-dedf-4069-b1ce-089fcc6b67e1", "fitness": 0.03677650592072305, "name": "EAQEAPlusPlus", "description": "EAQEA+++ with Dual-Diversity Boost leverages dual-phase diversity enhancement by alternating between quantum and real-space diversity boosts to improve convergence and solution quality.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.phase_toggle = True  # New line: Toggle for dual-phase diversity boost\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                if self.phase_toggle:\n                    self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                else:\n                    self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n                self.phase_toggle = not self.phase_toggle\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 47, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03678 with standard deviation 0.00274.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.04054020617616694, 0.03411045373237087, 0.03567885785363134]}}
{"id": "d5b29aad-ea33-40a9-a075-c53d0ae6c20b", "fitness": 0.034862445629487815, "name": "EAQEAPlusPlus", "description": "Enhance exploration by increasing diversity boost frequency for quicker convergence.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2  # New line: Number of elite solutions to retain\n        self.diversity_boost_interval = 50  # Changed from 100 to 50\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 48, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03486 with standard deviation 0.00690.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.04054020617616694, 0.038903059894346836, 0.02514407081794967]}}
{"id": "a63c351a-8499-4f64-bf53-3b506be490c3", "fitness": 0.005618322835866274, "name": "EAQEAPlusPlus", "description": "Enhancing elitism retention and adaptive mutation balance, while introducing dynamic mutation and crossover rates based on optimization progress.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_mutation_factor = 0.1  # New line: Initial dynamic mutation factor\n        self.dynamic_crossover_rate = 0.5  # New line: Initial dynamic crossover rate\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        self.dynamic_mutation_factor = 0.3 * (1 - diversity)  # New line: Dynamic mutation adjustment\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.dynamic_mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.dynamic_crossover_rate + diversity)  # Modified line\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 49, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "98e01251-d4a5-49c9-b606-657dcdd7d027", "fitness": 0.03936696290011384, "name": "EAQEAPlusPlus", "description": "Enhanced crossover strategy for better exploration-exploitation trade-off in EAQEA+++.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8  # Modified line: Slightly increased crossover rate for enhanced exploration\n        self.elite_count = 2  # New line: Number of elite solutions to retain\n        self.diversity_boost_interval = 100\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 50, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03937 with standard deviation 0.00168.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.04054020617616694, 0.04056352291209098, 0.03699715961208361]}}
{"id": "f9dec7d7-ad62-4988-8548-aa8166d334b2", "fitness": -Infinity, "name": "EAQEAPlusPlusPlus", "description": "EAQEA++++ introduces a hierarchical adaptive strategy with local refinement and adaptive crossover rates to improve convergence speed and accuracy.", "code": "import numpy as np\n\nclass EAQEAPlusPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.local_refinement_interval = 50  # New line: Interval for local refinement\n        self.adaptive_crossover = True  # New line: Enable adaptive crossover rates\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover_probability = self.crossover_rate * (1 + diversity) if self.adaptive_crossover else self.crossover_rate\n            crossover = np.random.rand(self.dim) < crossover_probability\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _local_refinement(self, bounds):\n        # New method: Local refinement strategy\n        for i in range(self.elite_count):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            candidate = self.best_solution + perturbation\n            candidate = np.clip(candidate, bounds.lb, bounds.ub)\n            candidate_fitness = func(candidate)\n            if candidate_fitness < self.best_fitness:\n                self.best_fitness = candidate_fitness\n                self.best_solution = candidate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            if evaluations % self.local_refinement_interval == 0:\n                self._local_refinement(bounds)\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 51, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {}}
{"id": "b2946cd2-b047-483a-93b1-ce6c540ca9f6", "fitness": 0.037287817403530044, "name": "EAQEAPlusPlus", "description": "Enhanced EAQEA Plus with dynamic mutation and diversity adaptation to improve exploration and balance.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.6  # Modified: Changed mutation_factor for more aggressive mutation\n        self.crossover_rate = 0.8  # Modified: Increased crossover_rate to enhance recombination\n        self.elite_count = 2\n        self.diversity_boost_interval = 80  # Modified: Changed interval for more frequent diversity boost\n        self.mutation_boost_factor = 1.5  # New line: Factor to boost mutation\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape)) * self.mutation_boost_factor\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 52, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03729 with standard deviation 0.00230.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.03993203234679965, 0.03432644121479633, 0.03760497864899415]}}
{"id": "716332ec-4c60-4425-81b9-2ee422118a4a", "fitness": -Infinity, "name": "EAQEAPlusPlusPlus", "description": "EAQEA++++ introduces a multi-level adaptive mutation strategy and diversity reinforcement to enhance convergence and robustness.", "code": "import numpy as np\n\nclass EAQEAPlusPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.adaptive_mutation_levels = [0.1, 0.5, 1.0]  # New: Levels of adaptive mutation\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        # New: Multi-level adaptive mutation based on diversity\n        mutation_level = self.adaptive_mutation_levels[int(diversity * len(self.adaptive_mutation_levels))]\n        mutation_strength = np.abs(np.random.normal(0, mutation_level, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 53, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {}}
{"id": "82ec7922-56ee-4110-a1b1-5626f4d3778d", "fitness": 0.005618322835866274, "name": "EAQEAPlusPlus", "description": "Introducing a dynamic mutation factor based on population diversity to improve convergence speed.", "code": "import numpy as np\n\nclass EAQEAPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2  # New line: Number of elite solutions to retain\n        self.diversity_boost_interval = 100\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        self.mutation_factor = 0.3 + 0.4 * diversity  # Changed line: Dynamic mutation factor\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 54, "feedback": "The algorithm EAQEAPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "5a6f2ce5-1503-48f6-9162-d0135c77b21d", "fitness": 0.01529778837597362, "name": "EAQEAPlusPlusPlus", "description": "EAQEA++++ introduces dynamic elitism, adaptive mutation strength based on convergence rate, and enhanced diversity mechanisms for robust exploration and exploitation.", "code": "import numpy as np\n\nclass EAQEAPlusPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.evaluation_count = 0\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity, convergence_rate):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (1 - convergence_rate), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity, convergence_rate):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity * (1 - convergence_rate))\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _calculate_convergence_rate(self, previous_best_fitness):\n        if self.best_fitness < previous_best_fitness:\n            return (previous_best_fitness - self.best_fitness) / previous_best_fitness\n        else:\n            return 0\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            convergence_rate = self._calculate_convergence_rate(previous_best_fitness)\n            previous_best_fitness = self.best_fitness\n\n            trial_population = self._differential_evolution(real_population, bounds, diversity, convergence_rate)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity, convergence_rate)\n\n        return self.best_solution", "configspace": "", "generation": 55, "feedback": "The algorithm EAQEAPlusPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01530 with standard deviation 0.00258.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.01168039739628457, 0.01748654015097295, 0.01672642758066334]}}
{"id": "ebc1af54-708b-428d-a377-ba71eca235e8", "fitness": 0.037686601389364936, "name": "EAQEAPlusPlusPlus", "description": "EAQEA++++ enhances adaptive dynamics with strategic diversity boosts and localized exploration to improve convergence performance.", "code": "import numpy as np\n\nclass EAQEAPlusPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _local_search(self, individual, bounds):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        local_candidate = individual + perturbation\n        local_candidate = np.clip(local_candidate, bounds.lb, bounds.ub)\n        return local_candidate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n                for i in range(self.elite_count, self.population_size):\n                    local_candidate = self._local_search(real_population[i], bounds)\n                    local_fitness = func(local_candidate)\n                    if local_fitness < fitness[i]:\n                        real_population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 56, "feedback": "The algorithm EAQEAPlusPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03769 with standard deviation 0.00207.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.04054020617616694, 0.036840740138296524, 0.03567885785363134]}}
{"id": "4fe7633c-2b9c-4c0a-bd67-67c1f04202f1", "fitness": 0.03936696290011384, "name": "EAQEAPlusPlusPlus", "description": "EAQEA++++ incorporates a diversity-guided adaptive mutation and hybrid selection process to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass EAQEAPlusPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.selection_pressure = 0.3  # New parameter: Adjusts selection pressure\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _hybrid_selection(self, real_population, fitness, trial_population, trial_fitness):\n        combined_pop = np.vstack((real_population, trial_population))\n        combined_fit = np.hstack((fitness, trial_fitness))\n        sorted_indices = np.argsort(combined_fit)\n        selected_indices = sorted_indices[:self.population_size]\n        return combined_pop[selected_indices], combined_fit[selected_indices]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            real_population, fitness = self._hybrid_selection(real_population, fitness, trial_population, trial_fitness)\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 57, "feedback": "The algorithm EAQEAPlusPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03937 with standard deviation 0.00168.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.04054020617616694, 0.04056352291209098, 0.03699715961208361]}}
{"id": "60c02920-4add-4a92-9689-c4d499a1a614", "fitness": 0.04028524288609107, "name": "EAQEAPlusPlusAdvanced", "description": "EAQEA+++ Advanced refines adaptive diversity control and selection pressure to improve convergence and robustness.", "code": "import numpy as np\n\nclass EAQEAPlusPlusAdvanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True  # New line: Toggles dynamic adaptation of rates\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity, self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations):\n        # New function: Adapt mutation and crossover rates based on progress\n        if self.dynamic_adaptation:\n            self.mutation_factor = max(0.5 - 0.1 * (evaluations / self.budget), 0.1)\n            self.crossover_rate = min(0.7 + 0.1 * (evaluations / self.budget), 0.9)\n    \n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations)  # Adapt rates based on evaluations\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 58, "feedback": "The algorithm EAQEAPlusPlusAdvanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04029 with standard deviation 0.00279.", "error": "", "parent_ids": ["f98a6cf6-a559-4188-a46a-c722311200b8"], "operator": null, "metadata": {"aucs": [0.0407030096928912, 0.043470150758619486, 0.03668256820676252]}}
{"id": "f34fc80c-efa5-430d-b6c9-f493f819e72c", "fitness": 0.04169673522410352, "name": "EAQEAPlusPlusAdvanced", "description": "EAQEA+++ Advanced refines adaptive diversity control and selection pressure with improved mutation strategy for better convergence.", "code": "import numpy as np\n\nclass EAQEAPlusPlusAdvanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True  # New line: Toggles dynamic adaptation of rates\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))  # Slightly changed: optimized mutation strength\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations):\n        # New function: Adapt mutation and crossover rates based on progress\n        if self.dynamic_adaptation:\n            self.mutation_factor = max(0.5 - 0.1 * (evaluations / self.budget), 0.1)\n            self.crossover_rate = min(0.7 + 0.1 * (evaluations / self.budget), 0.9)\n    \n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations)  # Adapt rates based on evaluations\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 59, "feedback": "The algorithm EAQEAPlusPlusAdvanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04170 with standard deviation 0.00225.", "error": "", "parent_ids": ["60c02920-4add-4a92-9689-c4d499a1a614"], "operator": null, "metadata": {"aucs": [0.0407030096928912, 0.04481511025125706, 0.03957208572816229]}}
{"id": "bcb71366-5673-46eb-b807-79f995601139", "fitness": 0.03079993776406705, "name": "EnhancedQuantumAdaptiveEvolutionaryStrategy", "description": "Enhanced Quantum Adaptive Evolutionary Strategy (EQAES) improves convergence by introducing stochastic quantum tunneling and adaptive mutation based on fitness variance.", "code": "import numpy as np\n\nclass EnhancedQuantumAdaptiveEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, fitness_variance):\n        mutation_strength = np.abs(np.random.normal(0, fitness_variance * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _calculate_fitness_variance(self, fitness):\n        return np.var(fitness)\n\n    def _adaptive_rates(self, evaluations):\n        if self.dynamic_adaptation:\n            self.mutation_factor = max(0.5 - 0.1 * (evaluations / self.budget), 0.1)\n            self.crossover_rate = min(0.7 + 0.1 * (evaluations / self.budget), 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            fitness_variance = self._calculate_fitness_variance(fitness)\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(fitness_variance)\n\n        return self.best_solution", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedQuantumAdaptiveEvolutionaryStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03080 with standard deviation 0.00701.", "error": "", "parent_ids": ["f34fc80c-efa5-430d-b6c9-f493f819e72c"], "operator": null, "metadata": {"aucs": [0.0407030096928912, 0.02548604172182034, 0.026210761877489608]}}
{"id": "f79a15b2-b0ac-46b0-ba93-b5c7cf0853ee", "fitness": -Infinity, "name": "EAQEAPlusPlusPro", "description": "EAQEA+++ Pro refines convergence by dynamically adjusting parameters with an entropy-based diversity metric for robust exploration-exploitation balance.", "code": "import numpy as np\n\nclass EAQEAPlusPlusPro:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _entropy_based_diversity(self, real_population):\n        # New function: Calculate diversity based on entropy\n        hist, _ = np.histogramdd(real_population, bins=10, range=[(lb, ub) for lb, ub in zip(real_population.min(axis=0), real_population.max(axis=0))])\n        probabilities = hist / np.sum(hist)\n        probabilities = probabilities[probabilities > 0]\n        entropy = -np.sum(probabilities * np.log(probabilities))\n        return entropy\n\n    def _adaptive_mutation(self, entropy):\n        mutation_strength = np.abs(np.random.normal(0, entropy * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, entropy):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + entropy)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _adaptive_rates(self, evaluations, entropy):\n        if self.dynamic_adaptation:\n            self.mutation_factor = max(0.5 - 0.1 * (evaluations / self.budget), 0.1)\n            self.crossover_rate = min(0.7 + 0.1 * (evaluations / self.budget), 0.9)\n            self.crossover_rate += entropy * 0.05\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            entropy = self._entropy_based_diversity(real_population)\n            self._adaptive_rates(evaluations, entropy)\n            trial_population = self._differential_evolution(real_population, bounds, entropy)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(entropy)\n\n        return self.best_solution", "configspace": "", "generation": 61, "feedback": "An exception occurred: MemoryError((61917364224,), dtype('int64')).", "error": "MemoryError((61917364224,), dtype('int64'))", "parent_ids": ["f34fc80c-efa5-430d-b6c9-f493f819e72c"], "operator": null, "metadata": {}}
{"id": "d3d72277-2302-4e07-885d-e6a35e6b5e64", "fitness": 0.03563175248903838, "name": "EAQEAPlusPlusUltra", "description": "EAQEA+++ Ultra refines adaptive diversity control and selection pressure with an enhanced probabilistic elitism strategy and adaptive learning rate for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EAQEAPlusPlusUltra:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n        self.learning_rate = 0.5\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        learning_adjustment = self.learning_rate * (adapt_factor - 0.5)\n        self.q_population += mutation_strength * learning_adjustment\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations):\n        if self.dynamic_adaptation:\n            progress_ratio = evaluations / self.budget\n            self.mutation_factor = max(0.5 - 0.1 * progress_ratio, 0.1)\n            self.crossover_rate = min(0.7 + 0.1 * progress_ratio, 0.9)\n            self.learning_rate = 0.5 + 0.5 * (1 - progress_ratio)  # New line: Adjust learning rate\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n                else:\n                    if np.random.rand() < 0.1:  # New line: Probabilistic elitism\n                        real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 62, "feedback": "The algorithm EAQEAPlusPlusUltra got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03563 with standard deviation 0.00486.", "error": "", "parent_ids": ["f34fc80c-efa5-430d-b6c9-f493f819e72c"], "operator": null, "metadata": {"aucs": [0.0407030096928912, 0.02908458603809061, 0.037107661736133335]}}
{"id": "8d52225b-0882-41c1-89c2-8eb7640d26e0", "fitness": 0.03475459268491621, "name": "EAQEAPlusPlusAdvanced", "description": "EAQEA+++ Enhanced introduces elitism protection and dynamic elite count adaptation to balance exploration and exploitation for better optimization.", "code": "import numpy as np\n\nclass EAQEAPlusPlusAdvanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations):\n        if self.dynamic_adaptation:\n            self.mutation_factor = max(0.5 - 0.1 * (evaluations / self.budget), 0.1)\n            self.crossover_rate = min(0.7 + 0.1 * (evaluations / self.budget), 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n            # New line: Adjust elite count dynamically based on diversity\n            self.elite_count = min(3, max(1, int(diversity * self.population_size)))\n\n        return self.best_solution", "configspace": "", "generation": 63, "feedback": "The algorithm EAQEAPlusPlusAdvanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03475 with standard deviation 0.00557.", "error": "", "parent_ids": ["f34fc80c-efa5-430d-b6c9-f493f819e72c"], "operator": null, "metadata": {"aucs": [0.04168869743557735, 0.028055329031556386, 0.03451975158761489]}}
{"id": "ccff2c25-2107-43e0-b90f-dfdd750fdffd", "fitness": 0.0400671647504612, "name": "EAQEAPlusPlusEnhanced", "description": "EAQEA+++ Enhanced integrates memory-based population restart and adaptive diversity scaling to improve convergence and escape local optima.", "code": "import numpy as np\n\nclass EAQEAPlusPlusEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n        self.memory_size = 5  # New: Memory to store best solutions\n        self.memory = np.zeros((self.memory_size, self.dim))\n        self.memory_fitness = np.full(self.memory_size, float('inf'))\n    \n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n        # Update memory with new best solutions\n        max_mem_idx = np.argmax(self.memory_fitness)\n        if fitness[min_idx] < self.memory_fitness[max_mem_idx]:\n            self.memory[max_mem_idx] = real_population[min_idx]\n            self.memory_fitness[max_mem_idx] = fitness[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations):\n        if self.dynamic_adaptation:\n            self.mutation_factor = max(0.5 - 0.1 * (evaluations / self.budget), 0.1)\n            self.crossover_rate = min(0.7 + 0.1 * (evaluations / self.budget), 0.9)\n\n    def _restart_population(self, bounds):\n        # New function: Restart population using memory of best solutions\n        for i in range(self.memory_size):\n            idx = np.random.choice(self.population_size)\n            self.q_population[idx] = (self.memory[i] - bounds.lb) / (bounds.ub - bounds.lb)\n        self.q_population[self.memory_size:] = np.random.uniform(0, 1, (self.population_size - self.memory_size, self.dim))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self._restart_population(bounds)\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 64, "feedback": "The algorithm EAQEAPlusPlusEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04007 with standard deviation 0.00047.", "error": "", "parent_ids": ["f34fc80c-efa5-430d-b6c9-f493f819e72c"], "operator": null, "metadata": {"aucs": [0.0407030096928912, 0.03992639883033011, 0.03957208572816229]}}
{"id": "34e932b7-6ceb-4f5f-be24-4eb402b7724e", "fitness": 0.04169673522410352, "name": "EAQEAPlusPlusAdvancedEnhanced", "description": "Enhanced adaptive diversity control and convergence acceleration through multi-objective dynamic adaptation for improved optimization efficiency.", "code": "import numpy as np\n\nclass EAQEAPlusPlusAdvancedEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n        self.multi_objective_factor = 0.5  # New parameter for dynamic adaptation\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress_factor = evaluations / self.budget\n            self.mutation_factor = max(0.5 - 0.1 * progress_factor, 0.1)\n            self.crossover_rate = min(0.7 + 0.1 * progress_factor, 0.9)\n            self.multi_objective_factor = 0.5 * (1 - 0.5 * (diversity / self.dim))  # Adjusted for dynamic adaptation\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 65, "feedback": "The algorithm EAQEAPlusPlusAdvancedEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04170 with standard deviation 0.00225.", "error": "", "parent_ids": ["f34fc80c-efa5-430d-b6c9-f493f819e72c"], "operator": null, "metadata": {"aucs": [0.0407030096928912, 0.04481511025125706, 0.03957208572816229]}}
{"id": "6da048fd-3c52-4057-9984-c0fc32c6702f", "fitness": 0.03830075119811368, "name": "EAQEAPlusPlusAdvanced", "description": "EAQEA+++ Advanced introduces a diversity-based dynamic elite replacement to enhance convergence stability and exploration.", "code": "import numpy as np\n\nclass EAQEAPlusPlusAdvanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True  # New line: Toggles dynamic adaptation of rates\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))  # Slightly changed: optimized mutation strength\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations):\n        # New function: Adapt mutation and crossover rates based on progress\n        if self.dynamic_adaptation:\n            self.mutation_factor = max(0.5 - 0.1 * (evaluations / self.budget), 0.1)\n            self.crossover_rate = min(0.7 + 0.1 * (evaluations / self.budget), 0.9)\n    \n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations)  # Adapt rates based on evaluations\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n            \n            # Change: Dynamic elite replacement based on diversity\n            if diversity < 0.1: \n                self.elite_count = max(1, self.elite_count - 1)\n            else:\n                self.elite_count = min(5, self.elite_count + 1)\n\n        return self.best_solution", "configspace": "", "generation": 66, "feedback": "The algorithm EAQEAPlusPlusAdvanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03830 with standard deviation 0.00592.", "error": "", "parent_ids": ["f34fc80c-efa5-430d-b6c9-f493f819e72c"], "operator": null, "metadata": {"aucs": [0.04168753094120725, 0.04323159670400678, 0.029983125949127]}}
{"id": "f23f73e1-a754-4d8a-858d-907b3bed5cce", "fitness": 0.04208437191412284, "name": "QuantumEnhancedADE", "description": "Quantum Enhanced Adaptive Differential Evolution (QE-ADE) dynamically adjusts mutation and crossover strategies based on fitness landscape estimation for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass QuantumEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            if diversity < 0.2:  # If diversity is low, increase mutation for exploration\n                self.mutation_factor = min(0.7, 0.5 + 0.2 * progress)\n            else:  # If diversity is high, improve exploitation\n                self.mutation_factor = max(0.3, 0.5 - 0.2 * progress)\n            self.crossover_rate = min(0.9, 0.7 + 0.2 * (1 - diversity))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 67, "feedback": "The algorithm QuantumEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04208 with standard deviation 0.00230.", "error": "", "parent_ids": ["f34fc80c-efa5-430d-b6c9-f493f819e72c"], "operator": null, "metadata": {"aucs": [0.04079168127540378, 0.04532118996522061, 0.04014024450174414]}}
{"id": "271e49ca-7119-4f88-851c-b3929bbda236", "fitness": 0.005618322835866274, "name": "QuantumEnhancedADE", "description": "Enhanced crossover strategy to improve trial solution quality in Quantum Enhanced Adaptive Differential Evolution.", "code": "import numpy as np\n\nclass QuantumEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity * 0.1)  # Changed the crossover strategy\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            if diversity < 0.2:  # If diversity is low, increase mutation for exploration\n                self.mutation_factor = min(0.7, 0.5 + 0.2 * progress)\n            else:  # If diversity is high, improve exploitation\n                self.mutation_factor = max(0.3, 0.5 - 0.2 * progress)\n            self.crossover_rate = min(0.9, 0.7 + 0.2 * (1 - diversity))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 68, "feedback": "The algorithm QuantumEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00000.", "error": "", "parent_ids": ["f23f73e1-a754-4d8a-858d-907b3bed5cce"], "operator": null, "metadata": {"aucs": [0.005618322835866274, 0.005618322835866274, 0.005618322835866274]}}
{"id": "2ea45347-bae1-40cf-af6c-c7c3a740f3bf", "fitness": 0.0414441534844792, "name": "QuantumEnhancedADEQRG", "description": "Quantum-Enhanced Adaptive Differential Evolution with Quantum Rotation Gate (QE-ADE-QRG) enhances exploration by introducing quantum rotation gates for population update, promoting diverse solutions.", "code": "import numpy as np\n\nclass QuantumEnhancedADEQRG:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.rotation_angle = 0.1  # New parameter for quantum rotation\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _quantum_rotation(self):\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                rotation_matrix = np.array([[np.cos(self.rotation_angle), -np.sin(self.rotation_angle)],\n                                            [np.sin(self.rotation_angle), np.cos(self.rotation_angle)]])\n                state_vector = np.array([self.q_population[i, j], np.sqrt(1 - self.q_population[i, j]**2)])\n                rotated_vector = rotation_matrix @ state_vector\n                self.q_population[i, j] = rotated_vector[0]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            if diversity < 0.2:  # If diversity is low, increase mutation for exploration\n                self.mutation_factor = min(0.7, 0.5 + 0.2 * progress)\n            else:  # If diversity is high, improve exploitation\n                self.mutation_factor = max(0.3, 0.5 - 0.2 * progress)\n            self.crossover_rate = min(0.9, 0.7 + 0.2 * (1 - diversity))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self._quantum_rotation()\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 69, "feedback": "The algorithm QuantumEnhancedADEQRG got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04144 with standard deviation 0.00097.", "error": "", "parent_ids": ["f23f73e1-a754-4d8a-858d-907b3bed5cce"], "operator": null, "metadata": {"aucs": [0.04079168127540378, 0.04281197883092136, 0.04072880034711246]}}
{"id": "a6c22f54-0fe1-4887-9d85-93e403d913f0", "fitness": 0.03372333412901666, "name": "QuantumInspiredADE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Quantum Gates utilizes quantum-inspired dynamic adaptation of quantum gates to enhance exploration-exploitation balance and improve optimization performance.", "code": "import numpy as np\n\nclass QuantumInspiredADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.3 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.3 * progress)\n            self.crossover_rate = min(0.95, 0.7 + 0.25 * (1 - diversity))\n\n    def _dynamic_quantum_gates(self, evaluations):\n        # Adding dynamic quantum gates adaptation\n        gate_strength = min(0.1, 0.1 * (1 - evaluations / self.budget))\n        self.q_population += gate_strength * np.random.normal(0, 1, self.q_population.shape)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n            self._dynamic_quantum_gates(evaluations)\n\n        return self.best_solution", "configspace": "", "generation": 70, "feedback": "The algorithm QuantumInspiredADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03372 with standard deviation 0.00645.", "error": "", "parent_ids": ["f23f73e1-a754-4d8a-858d-907b3bed5cce"], "operator": null, "metadata": {"aucs": [0.04209618625698386, 0.026409187617299157, 0.03266462851276697]}}
{"id": "b0d1a761-8f9d-4f88-a7d8-ebfbab89a5d3", "fitness": 0.022857882870341628, "name": "QuantumDualPhaseADE", "description": "Quantum Dual-Phase Adaptive Differential Evolution (QDPADE) introduces a dual-phase exploration-exploitation strategy by alternating between quantum-enhanced exploration and adaptive differential evolution to maintain diversity and accelerate convergence.", "code": "import numpy as np\n\nclass QuantumDualPhaseADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.phase_switch_interval = 50\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n        self.exploration_phase = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            if diversity < 0.2:\n                self.mutation_factor = min(0.7, 0.5 + 0.2 * progress)\n            else:\n                self.mutation_factor = max(0.3, 0.5 - 0.2 * progress)\n            self.crossover_rate = min(0.9, 0.7 + 0.2 * (1 - diversity))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            \n            if self.exploration_phase:\n                trial_population = self._quantum_observation() * (bounds.ub - bounds.lb) + bounds.lb\n            else:\n                trial_population = self._differential_evolution(real_population, bounds, diversity)\n            \n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n            if evaluations % self.phase_switch_interval == 0:\n                self.exploration_phase = not self.exploration_phase\n\n        return self.best_solution", "configspace": "", "generation": 71, "feedback": "The algorithm QuantumDualPhaseADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02286 with standard deviation 0.00225.", "error": "", "parent_ids": ["f23f73e1-a754-4d8a-858d-907b3bed5cce"], "operator": null, "metadata": {"aucs": [0.025679287376700444, 0.02017596350863038, 0.02271839772569406]}}
{"id": "9485376d-dd3d-4152-b993-c412c5b80dd8", "fitness": 0.041766096525434095, "name": "QuantumEnhancedADE", "description": "Enhanced Quantum Differential Evolution with strategic mutation and crossover adaptation to boost convergence.", "code": "import numpy as np\n\nclass QuantumEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 100\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            if diversity < 0.2:  # If diversity is low, increase mutation for exploration\n                self.mutation_factor = min(0.75, 0.5 + 0.25 * progress)  # Adjusted value\n            else:  # If diversity is high, improve exploitation\n                self.mutation_factor = max(0.25, 0.5 - 0.25 * progress)  # Adjusted value\n            self.crossover_rate = min(0.9, 0.7 + 0.2 * (1 - diversity))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n            \n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n            \n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 72, "feedback": "The algorithm QuantumEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04177 with standard deviation 0.00166.", "error": "", "parent_ids": ["f23f73e1-a754-4d8a-858d-907b3bed5cce"], "operator": null, "metadata": {"aucs": [0.040808190784491716, 0.044106700524013664, 0.04038339826779691]}}
{"id": "4105f5ff-f1be-423a-b536-63f6ba33e697", "fitness": 0.04223259406464345, "name": "QuantumDiversityEnhancedADE", "description": "Quantum Diversity Enhanced Adaptive Differential Evolution (QDE-ADE) integrates dynamic diversity enhancement and adaptive parameter tuning to improve exploration-exploitation balance and convergence efficiency.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 5)  # New diversity-based control\n            if diversity < 0.2:  # If diversity is low, increase mutation for exploration\n                self.mutation_factor = min(0.8, 0.5 + 0.3 * progress)\n            else:  # If diversity is high, improve exploitation\n                self.mutation_factor = max(0.2, 0.5 - 0.3 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 73, "feedback": "The algorithm QuantumDiversityEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04223 with standard deviation 0.00217.", "error": "", "parent_ids": ["f23f73e1-a754-4d8a-858d-907b3bed5cce"], "operator": null, "metadata": {"aucs": [0.04080610813737229, 0.045293167366105336, 0.04059850669045273]}}
{"id": "3f693f27-45ab-4c4f-a0e7-de0155187dd5", "fitness": 0.02942826882504738, "name": "QuantumDiversityEnhancedADE", "description": "Quantum Diversity Enhanced Adaptive Differential Evolution (QDE-ADE) now incorporates a stochastic crossover mechanism and diversity-triggered mutation scaling for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + diversity * np.random.rand())\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 5)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.3 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.3 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 74, "feedback": "The algorithm QuantumDiversityEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02943 with standard deviation 0.00185.", "error": "", "parent_ids": ["4105f5ff-f1be-423a-b536-63f6ba33e697"], "operator": null, "metadata": {"aucs": [0.03204270855433433, 0.028191483002947382, 0.028050614917860428]}}
{"id": "e92240fc-f0e2-46b0-9463-986272a79a03", "fitness": 0.043544672203552105, "name": "QuantumDiversityEnhancedADE", "description": "Quantum Diversity Enhanced ADE (QDE-ADE) with Improved Dynamic Adaptation introduces a more sensitive adaptive mechanism and refined crossover to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)  # Modified crossover\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)  # Modified diversity-based control\n            if diversity < 0.2:  # If diversity is low, increase mutation for exploration\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)  # Tweaked mutation factor\n            else:  # If diversity is high, improve exploitation\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)  # Tweaked mutation factor\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 75, "feedback": "The algorithm QuantumDiversityEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04354 with standard deviation 0.00376.", "error": "", "parent_ids": ["4105f5ff-f1be-423a-b536-63f6ba33e697"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.04885206327264713, 0.0411692634858859]}}
{"id": "06208aa4-5bc5-44cf-ad72-15205b5ba508", "fitness": 0.03926672389269281, "name": "EnhancedQuantumDiversityEnhancedADE", "description": "Enhanced Quantum Diversity Enhanced ADE (EQDE-ADE) with Cluster-Based Adaptive Mechanism introduces cluster-based analysis for more efficient adaptation to diverse problem landscapes, boosting both exploration and exploitation.", "code": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EnhancedQuantumDiversityEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.cluster_count = 3\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _cluster_based_adaptation(self, real_population):\n        kmeans = KMeans(n_clusters=self.cluster_count, n_init=10, random_state=0)\n        labels = kmeans.fit_predict(real_population)\n\n        cluster_diversities = []\n        for k in range(self.cluster_count):\n            cluster_points = real_population[labels == k]\n            if len(cluster_points) > 0:\n                centroid = np.mean(cluster_points, axis=0)\n                cluster_diversity = np.mean(np.linalg.norm(cluster_points - centroid, axis=1))\n                cluster_diversities.append(cluster_diversity)\n\n        overall_diversity = np.mean(cluster_diversities) if len(cluster_diversities) > 0 else 0\n        return overall_diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._cluster_based_adaptation(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedQuantumDiversityEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03927 with standard deviation 0.00231.", "error": "", "parent_ids": ["e92240fc-f0e2-46b0-9463-986272a79a03"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.03601821834006924, 0.0411692634858859]}}
{"id": "da93dfeb-8521-407b-b13d-43012944624a", "fitness": 0.04300278820149217, "name": "QuantumDiversityEnhancedADE", "description": "A refined adaptive mutation strategy and diversity management to enhance the balance of exploration and exploitation in QDE-ADE.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.4 * diversity)  # Modified crossover\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 8)  # Modified diversity-based control\n            if diversity < 0.25:  # If diversity is low, increase mutation for exploration\n                self.mutation_factor = min(0.9, 0.6 + 0.5 * progress)  # Tweaked mutation factor\n            else:  # If diversity is high, improve exploitation\n                self.mutation_factor = max(0.2, 0.5 - 0.4 * progress)  # Tweaked mutation factor\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 77, "feedback": "The algorithm QuantumDiversityEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04300 with standard deviation 0.00305.", "error": "", "parent_ids": ["e92240fc-f0e2-46b0-9463-986272a79a03"], "operator": null, "metadata": {"aucs": [0.040747007582002226, 0.047318724649120236, 0.04094263237335405]}}
{"id": "566a5dde-bffd-45f2-beb5-d588ac137a32", "fitness": 0.043544672203552105, "name": "QuantumDiversityEnhancedADE", "description": "Quantum Diversity Enhanced ADE with Adaptive Periodic Reinitialization introduces a novel periodic reinitialization strategy based on performance to enhance diversity and convergence.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.dynamic_adaptation = True\n        self.evaluation_interval = 100  # New parameter for adaptive reinitialization\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def _adaptive_reinitialization(self, evaluations, fitness):\n        if evaluations % self.evaluation_interval == 0:\n            worst_idx = np.argmax(fitness)\n            self.q_population[worst_idx] = np.random.uniform(0, 1, self.dim)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            self._adaptive_mutation(diversity)\n            self._adaptive_reinitialization(evaluations, fitness)\n\n        return self.best_solution", "configspace": "", "generation": 78, "feedback": "The algorithm QuantumDiversityEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04354 with standard deviation 0.00376.", "error": "", "parent_ids": ["e92240fc-f0e2-46b0-9463-986272a79a03"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.04885206327264713, 0.0411692634858859]}}
{"id": "bb7e2e6b-be67-4180-94fd-af71652ce6b0", "fitness": 0.03324398164976505, "name": "QuantumDiversityEnhancedADE", "description": "Enhanced differential mutation factor for improved convergence speed.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + 0.55 * (real_population[b] - real_population[c])  # Adjusted factor\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 79, "feedback": "The algorithm QuantumDiversityEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03324 with standard deviation 0.00371.", "error": "", "parent_ids": ["e92240fc-f0e2-46b0-9463-986272a79a03"], "operator": null, "metadata": {"aucs": [0.029246599440815313, 0.03229985360330345, 0.038185491905176394]}}
{"id": "c83b57b4-9c63-47ea-b6ee-95f2c1e1447a", "fitness": 0.025897305503441787, "name": "QuantumRobustnessEnhancedADE", "description": "Quantum-Robustness Enhanced ADE (QRE-ADE) integrates adaptive quantum observation and enhanced robustness mechanisms to improve solution accuracy and convergence speed.", "code": "import numpy as np\n\nclass QuantumRobustnessEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        observation = (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n        observation_noise = np.random.normal(0, 0.01, self.q_population.shape)  # Added observation noise\n        return np.clip(observation + observation_noise, 0, 1)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:  # Increase mutation for exploration\n                self.mutation_factor = min(0.9, 0.6 + 0.5 * progress)  # Enhanced mutation factor\n            else:  # Improve exploitation\n                self.mutation_factor = max(0.1, 0.4 - 0.5 * progress)  # Enhanced mutation factor\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 80, "feedback": "The algorithm QuantumRobustnessEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02590 with standard deviation 0.00085.", "error": "", "parent_ids": ["e92240fc-f0e2-46b0-9463-986272a79a03"], "operator": null, "metadata": {"aucs": [0.02642298331420423, 0.026571050642123062, 0.024697882553998074]}}
{"id": "4e787b11-3701-4089-9793-c4e06351f68f", "fitness": 0.043544672203552105, "name": "QuantumDiversityEnhancedADE", "description": "Introduce an adaptive diversity boost mechanism triggered by stagnation to enhance exploration.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.stagnation_counter = 0\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n            self.stagnation_counter = 0  # Reset stagnation counter on improvement\n        else:\n            self.stagnation_counter += 1  # Increment on no improvement\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)  # Modified crossover\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)  # Modified diversity-based control\n            if diversity < 0.2:  # If diversity is low, increase mutation for exploration\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)  # Tweaked mutation factor\n            else:  # If diversity is high, improve exploitation\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)  # Tweaked mutation factor\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0 or self.stagnation_counter > 10:  # Trigger boost on stagnation\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 81, "feedback": "The algorithm QuantumDiversityEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04354 with standard deviation 0.00376.", "error": "", "parent_ids": ["e92240fc-f0e2-46b0-9463-986272a79a03"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.04885206327264713, 0.0411692634858859]}}
{"id": "ff32cecb-42f7-4245-ad68-6b9ea3ddf78d", "fitness": -Infinity, "name": "QuantumEnhancedADE", "description": "Quantum Enhanced Adaptive Differential Evolution (QE-ADE) refines dynamic adaptation and introduces adaptive control strategies in both crossover and mutation to enhance convergence and robustness.", "code": "import numpy as np\n\nclass QuantumEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity, evaluations):\n        trend_factor = np.random.normal(0, 1)\n        mutation_strength = np.abs(np.random.normal(0, diversity * (1 + trend_factor) * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.4 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.9, 0.5 + 0.4 * progress)\n            else:\n                self.mutation_factor = max(0.3, 0.5 - 0.4 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity, evaluations)\n\n        return self.best_solution", "configspace": "", "generation": 82, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["e92240fc-f0e2-46b0-9463-986272a79a03"], "operator": null, "metadata": {}}
{"id": "f7f6e3bb-42b1-4bf4-bba9-96f8e2c831bf", "fitness": 0.03875853543933442, "name": "QuantumConstrainedAdaptiveDE", "description": "Quantum-Constrained Adaptive Differential Evolution enhances solution quality by integrating quantum superposition principles with constraint handling and adaptive mutation strategies.", "code": "import numpy as np\n\nclass QuantumConstrainedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        progress = evaluations / self.budget\n        diversity_penalty = 1 - np.exp(-diversity * 10)\n        self.mutation_factor = 0.5 + 0.3 * (1 - diversity_penalty)\n        self.crossover_rate = 0.7 + 0.3 * (1 - diversity_penalty)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 83, "feedback": "The algorithm QuantumConstrainedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03876 with standard deviation 0.00152.", "error": "", "parent_ids": ["e92240fc-f0e2-46b0-9463-986272a79a03"], "operator": null, "metadata": {"aucs": [0.04054020617616694, 0.03683625533193746, 0.03889914480989887]}}
{"id": "84436ccf-5aaf-427b-872d-5344b07f431b", "fitness": 0.04368863406490845, "name": "QuantumDiversityEnhancedADEALA", "description": "Quantum Diversity Enhanced ADE with Adaptive Learning Automata (QDE-ADE-ALA) integrates a learning automata mechanism to dynamically adjust mutation and crossover rates for improved search efficiency.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 84, "feedback": "The algorithm QuantumDiversityEnhancedADEALA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04369 with standard deviation 0.00397.", "error": "", "parent_ids": ["e92240fc-f0e2-46b0-9463-986272a79a03"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.04929101358954657, 0.04116219875305549]}}
{"id": "920b948d-f2ba-4116-9e87-a4045cf47453", "fitness": -Infinity, "name": "EnhancedQuantumDiversityAdaptiveAlgorithm", "description": "Enhanced Quantum Diversity Adaptive Algorithm (EQDAA) refines mutation control using entropy-based diversity metrics to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass EnhancedQuantumDiversityAdaptiveAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _entropy_based_diversity(self, real_population):\n        normalized_pop = (real_population - np.min(real_population, axis=0)) / (np.max(real_population, axis=0) - np.min(real_population, axis=0) + 1e-9)\n        entropy = -np.sum(normalized_pop * np.log(normalized_pop + 1e-9), axis=0)\n        return np.mean(entropy)\n\n    def _adaptive_mutation(self, entropy_diversity):\n        mutation_strength = np.abs(np.random.normal(0, entropy_diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, entropy_diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * entropy_diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _adaptive_rates(self, evaluations, entropy_diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            self.mutation_factor = 0.5 + 0.3 * (1 - entropy_diversity)\n            self.crossover_rate = 0.7 + 0.2 * entropy_diversity\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if entropy_diversity < 0.3 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            entropy_diversity = self._entropy_based_diversity(real_population)\n            self._adaptive_rates(evaluations, entropy_diversity)\n            trial_population = self._differential_evolution(real_population, bounds, entropy_diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(entropy_diversity)\n\n        return self.best_solution", "configspace": "", "generation": 85, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {}}
{"id": "8db92cec-5d2d-4371-b84c-7328d116b97a", "fitness": 0.037893668345369, "name": "QuantumAdaptiveDEwithDynamicMemory", "description": "Quantum Adaptive DE with Dynamic Memory (QADDM) introduces memory-based adaptation and dynamic parameter tuning to enhance convergence rates and maintain diversity.", "code": "import numpy as np\n\nclass QuantumAdaptiveDEwithDynamicMemory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.memory_size = 5\n        self.memory = []\n        self.learning_automata_rate = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n            self.memory.append(self.best_solution)\n            if len(self.memory) > self.memory_size:\n                self.memory.pop(0)\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            if self.memory:\n                memory_solution = self.memory[np.random.randint(0, len(self.memory))]\n                mutant += 0.1 * (memory_solution - real_population[i])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        progress = evaluations / self.budget\n        diversity_penalty = 1 - np.exp(-diversity * 10)\n        if diversity < 0.2:\n            self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n        else:\n            self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n        self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n        if np.random.rand() < self.learning_automata_rate:\n            reward = 1.0 if diversity < 0.2 else -1.0\n            self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n            self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 86, "feedback": "The algorithm QuantumAdaptiveDEwithDynamicMemory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03789 with standard deviation 0.00313.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.04205965078202556, 0.03711543820428154, 0.03450591604979991]}}
{"id": "eb727256-a3f3-4887-af91-bcf51434e66b", "fitness": -Infinity, "name": "QuantumDiversityEnhancedADEALA", "description": "Quantum Diversity Enhanced ADE with Adaptive Learning Automata and Stochastic Rank-based Selection integrates stochastic rank-based selection to enhance solution diversity and convergence by prioritizing high-performing solutions.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self._stochastic_rank_selection(indices, fitness)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _stochastic_rank_selection(self, indices, fitness):\n        sorted_indices = sorted(indices, key=lambda idx: fitness[idx])\n        probabilities = np.linspace(1.0, 0.1, len(indices))  # Higher probability for higher ranks\n        probabilities /= probabilities.sum()  # Normalize to sum to 1\n        selected = np.random.choice(sorted_indices, 3, replace=False, p=probabilities)\n        return selected\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 87, "feedback": "An exception occurred: NameError(\"name 'fitness' is not defined\").", "error": "NameError(\"name 'fitness' is not defined\")", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {}}
{"id": "056d989a-5080-4984-9cfe-227d0ef6289a", "fitness": 0.04368863406490845, "name": "QuantumDiversityEnhancedADEALA", "description": "Introduce a minor adjustment to the mutation factor to enhance diversity management in QuantumDiversityEnhancedADEALA.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.25, 0.5 - 0.5 * progress)  # Changed from 0.2 to 0.25\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.25, 0.8)  # Changed from 0.2 to 0.25\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 88, "feedback": "The algorithm QuantumDiversityEnhancedADEALA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04369 with standard deviation 0.00397.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.04929101358954657, 0.04116219875305549]}}
{"id": "482b910e-40ef-4b60-aa7a-9a5baa9e3de2", "fitness": 0.04368863406490845, "name": "QuantumDiversityEnhancedADEALA", "description": "Refined QDE-ADE-ALA with Enhanced Mutation Strategy and Dynamic Population Resizing for improved adaptability and convergence.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n            # Dynamic population resizing\n            if evaluations % self.diversity_boost_interval == 0 and diversity < 0.2:\n                self.population_size = min(100, self.population_size + 5)\n                self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 89, "feedback": "The algorithm QuantumDiversityEnhancedADEALA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04369 with standard deviation 0.00397.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.04929101358954657, 0.04116219875305549]}}
{"id": "c7bb4115-a41f-48bd-b6e6-4a91bb15ed73", "fitness": 0.03339495703937482, "name": "QuantumDiversityEnhancedSARALA", "description": "Quantum Diversity Enhanced ADE with Stochastic Adaptive Learning Automata (QDE-SA-ALA) optimizes mutation and crossover rates by dynamically adjusting them using stochastic approximations to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedSARALA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.learning_automata_rate = 0.1\n        self.adaptation_rate = 0.05\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        progress = evaluations / self.budget\n        diversity_penalty = 1 - np.exp(-diversity * 10)\n        self.mutation_factor = 0.5 + 0.3 * np.sin(progress * np.pi) - 0.1 * diversity_penalty\n        self.crossover_rate = 0.7 + 0.2 * np.sin(progress * np.pi) + 0.1 * diversity_penalty\n\n        # Stochastic Learning Automata for adaptive adjustment\n        if np.random.rand() < self.learning_automata_rate:\n            reward = 1.0 if diversity < 0.2 else -1.0\n            self.mutation_factor += reward * self.adaptation_rate * np.random.randn()\n            self.crossover_rate += reward * self.adaptation_rate * np.random.randn()\n            self.mutation_factor = np.clip(self.mutation_factor, 0.2, 0.8)\n            self.crossover_rate = np.clip(self.crossover_rate, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 90, "feedback": "The algorithm QuantumDiversityEnhancedSARALA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03339 with standard deviation 0.00498.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.026479010728724384, 0.03572387979932945, 0.03798198059007063]}}
{"id": "5b01533b-8c27-4fd9-8de2-ba897abe4745", "fitness": 0.03307989548295309, "name": "QuantumDiversityEnhancedIDEAL", "description": "Quantum Diversity Enhanced DE with Improved Adaptive Learning (QDE-IDEAL) incorporates a dynamic learning strategy and entropy-based diversity control for enhanced search capability and convergence efficiency.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedIDEAL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.learning_automata_rate = 0.1\n        self.entropy_threshold = 0.5\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _calculate_entropy(self, real_population):\n        probabilities = np.var(real_population, axis=0)\n        probabilities /= probabilities.sum()\n        entropy = -np.sum(probabilities * np.log(probabilities + 1e-12))\n        return entropy / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity, entropy):\n        progress = evaluations / self.budget\n        if entropy < self.entropy_threshold:\n            self.mutation_factor = max(0.4, 0.6 - 0.2 * progress)\n            self.crossover_rate = min(0.9, 0.6 + 0.3 * progress)\n        else:\n            self.mutation_factor = min(0.9, 0.5 + 0.4 * progress)\n            self.crossover_rate = max(0.5, 0.7 - 0.2 * progress)\n\n        if np.random.rand() < self.learning_automata_rate:\n            reward = 1.0 if diversity < 0.2 else -1.0\n            self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.9)\n            self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            entropy = self._calculate_entropy(real_population)\n            self._adaptive_rates(evaluations, diversity, entropy)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 91, "feedback": "The algorithm QuantumDiversityEnhancedIDEAL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03308 with standard deviation 0.00411.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.028593667964101677, 0.03212503682630996, 0.03852098165844764]}}
{"id": "fad003f4-8928-4ef0-ab72-5134cade2b57", "fitness": 0.03657337180790299, "name": "QuantumDiversityEnhancedADEAVC", "description": "Quantum Diversity Enhanced ADE with Adaptive Velocity Control adjusts the velocity of solutions in the search space to improve convergence speed and exploration.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEAVC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.inertia_weight = 0.5\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def _update_velocity(self, real_population, bounds):\n        r1, r2 = np.random.rand(), np.random.rand()\n        cognitive_component = r1 * (self.best_solution - real_population)\n        social_component = r2 * (np.mean(real_population, axis=0) - real_population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive_component + social_component\n        real_population += self.velocity\n        return np.clip(real_population, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n            real_population = self._update_velocity(real_population, bounds)\n\n        return self.best_solution", "configspace": "", "generation": 92, "feedback": "The algorithm QuantumDiversityEnhancedADEAVC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03657 with standard deviation 0.00369.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.04178445011579668, 0.03377860438526814, 0.034157060922644145]}}
{"id": "c22b50ad-d95c-4390-833f-b349f30e35d9", "fitness": 0.039984557873513106, "name": "QuantumDiversityEnhancedADEALA", "description": "Introduced a dynamic diversity-aware selection mechanism and a feedback loop for mutation factor enhancement.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n        self.feedback_mutation_increase = 0.02  # Feedback loop addition\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n            if np.mean(trial_population[i]) < np.mean(real_population[i]):  # Dynamic selection\n                trial_population[i] = real_population[i]  # Feedback loop application\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n                self.mutation_factor = np.clip(self.mutation_factor + self.feedback_mutation_increase, 0.2, 0.8)  # Feedback loop\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 93, "feedback": "The algorithm QuantumDiversityEnhancedADEALA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03998 with standard deviation 0.00764.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.04048782502546178, 0.04908195751035338, 0.03038389108472417]}}
{"id": "e474a183-3fb8-4579-84f3-fdbd233d7825", "fitness": -Infinity, "name": "QuantumDiversityEnhancedADEALAPlus", "description": "Quantum Diversity Enhanced ADE with Adaptive Learning Automata Plus (QDE-ADE-ALA+), incorporates dynamic population resizing and fitness-based elitism for further exploration and exploitation balance.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALAPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n        self.dynamic_population_resizing = True\n        self.min_population_size = 10\n        self.max_population_size = 50\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def _resize_population(self, evaluations):\n        if self.dynamic_population_resizing:\n            progress = evaluations / self.budget\n            new_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n            new_size = max(self.min_population_size, min(new_size, self.max_population_size))\n            self.q_population = self.q_population[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            self._resize_population(evaluations)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 94, "feedback": "An exception occurred: IndexError('index 38 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 38 is out of bounds for axis 0 with size 30')", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {}}
{"id": "4fd2d769-0be6-4455-a69c-161a86616b13", "fitness": 0.029857523872804197, "name": "QuantumDiversityEnhancedADEALA", "description": "Refined Quantum Diversity Enhanced ADE with Multi-strategy Adaptive Mechanism (QDEMS-ADE) boosts search efficiency with diverse adaptive strategies and enhanced exploration capabilities.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n        self.explore_factor = 0.6  # New attribute to control exploration\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.explore_factor * (real_population[b] - real_population[c])  # Adjusted mutation\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 95, "feedback": "The algorithm QuantumDiversityEnhancedADEALA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02986 with standard deviation 0.00468.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.02744469981811215, 0.025727356485038433, 0.036400515315262005]}}
{"id": "d1373410-4c4b-44f7-8b33-1d1da4a721fc", "fitness": 0.03685850410098349, "name": "QuantumDiversityEnhancedADEALA_SQW", "description": "Enhanced QDE-ADE-ALA with Stochastic Quantum Walks (QDE-ADE-ALA-SQW) leverages stochastic quantum walks for solution exploration and dynamic parameter adjustments based on population variance.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALA_SQW:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.learning_automata_rate = 0.1\n        self.stochastic_factor = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _stochastic_quantum_walk(self, diversity):\n        walks = np.random.normal(0, diversity * self.stochastic_factor, self.q_population.shape)\n        self.q_population += walks\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        progress = evaluations / self.budget\n        diversity_penalty = 1 - np.exp(-diversity * 10)\n        if diversity < 0.2:\n            self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n        else:\n            self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n        self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n        # Learning automata for adaptive adjustment\n        if np.random.rand() < self.learning_automata_rate:\n            reward = 1.0 if diversity < 0.2 else -1.0\n            self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n            self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._stochastic_quantum_walk(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 96, "feedback": "The algorithm QuantumDiversityEnhancedADEALA_SQW got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03686 with standard deviation 0.00266.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.03506331101253635, 0.03489951143829084]}}
{"id": "58abbb1c-ab08-41de-9975-911eea2dd9c8", "fitness": 0.03592124000040997, "name": "QuantumDiversityEnhancedADEALA", "description": "Enhancing exploration by modifying the elite_count for better diversity management.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 3  # Modified from 2 to improve diversity\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.8)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 97, "feedback": "The algorithm QuantumDiversityEnhancedADEALA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03592 with standard deviation 0.00329.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.0405759866768185, 0.0334849187098093, 0.03370281461460212]}}
{"id": "ade7d1cb-201c-40f9-9263-2edf0b8188bf", "fitness": 0.04368863406490845, "name": "QuantumDiversityEnhancedADEALA", "description": "Improved adaptive learning automata integration for better dynamic parameter control.", "code": "import numpy as np\n\nclass QuantumDiversityEnhancedADEALA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 50\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.2:\n                self.mutation_factor = min(0.8, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                diversity_reward = 1.0 if diversity < 0.2 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + diversity_reward * 0.05, 0.2, 0.8)  # Changed reward to diversity_reward \n                self.crossover_rate = np.clip(self.crossover_rate + diversity_reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 98, "feedback": "The algorithm QuantumDiversityEnhancedADEALA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04369 with standard deviation 0.00397.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.04929101358954657, 0.04116219875305549]}}
{"id": "d6f6ae70-1e0f-4364-ab3f-eae121287851", "fitness": 0.04406687715064391, "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Diversity Preservation integrates quantum observation with dynamic mutation and crossover strategies, maintaining diversity to prevent premature convergence and improve global search efficiency.", "code": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.q_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.elite_count = 2\n        self.diversity_boost_interval = 40\n        self.dynamic_adaptation = True\n        self.learning_automata_rate = 0.1\n\n    def _quantum_observation(self):\n        angles = np.arccos(1 - 2 * self.q_population)\n        return (np.cos(angles) > np.random.rand(*angles.shape)).astype(float)\n\n    def _evaluate_population(self, func, bounds):\n        real_population = bounds.lb + self._quantum_observation() * (bounds.ub - bounds.lb)\n        fitness = np.array([func(ind) for ind in real_population])\n        return real_population, fitness\n\n    def _update_best(self, real_population, fitness):\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = real_population[min_idx]\n\n    def _adaptive_mutation(self, diversity):\n        mutation_strength = np.abs(np.random.normal(0, diversity * (self.best_fitness / 10), self.q_population.shape))\n        adapt_factor = np.random.rand(*self.q_population.shape)\n        self.q_population += mutation_strength * (adapt_factor - 0.5)\n        self.q_population = np.clip(self.q_population, 0, 1)\n\n    def _differential_evolution(self, real_population, bounds, diversity):\n        trial_population = np.copy(real_population)\n        for i in range(self.elite_count, self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = real_population[a] + self.mutation_factor * (real_population[b] - real_population[c])\n            mutant = np.clip(mutant, bounds.lb, bounds.ub)\n            crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.5 * diversity)\n            trial_population[i] = np.where(crossover, mutant, real_population[i])\n        return trial_population\n\n    def _calculate_diversity(self, real_population):\n        centroid = np.mean(real_population, axis=0)\n        diversity = np.mean(np.linalg.norm(real_population - centroid, axis=1))\n        return diversity / self.dim\n\n    def _adaptive_rates(self, evaluations, diversity):\n        if self.dynamic_adaptation:\n            progress = evaluations / self.budget\n            diversity_penalty = 1 - np.exp(-diversity * 10)\n            if diversity < 0.3:\n                self.mutation_factor = min(0.9, 0.5 + 0.5 * progress)\n            else:\n                self.mutation_factor = max(0.2, 0.5 - 0.5 * progress)\n            self.crossover_rate = min(1.0, 0.7 + 0.3 * (1 - diversity_penalty))\n\n            # Learning automata for adaptive adjustment\n            if np.random.rand() < self.learning_automata_rate:\n                reward = 1.0 if diversity < 0.3 else -1.0\n                self.mutation_factor = np.clip(self.mutation_factor + reward * 0.05, 0.2, 0.9)\n                self.crossover_rate = np.clip(self.crossover_rate + reward * 0.03, 0.4, 0.9)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        evaluations = 0\n\n        while evaluations < self.budget:\n            real_population, fitness = self._evaluate_population(func, bounds)\n            self._update_best(real_population, fitness)\n            evaluations += self.population_size\n\n            diversity = self._calculate_diversity(real_population)\n            self._adaptive_rates(evaluations, diversity)\n            trial_population = self._differential_evolution(real_population, bounds, diversity)\n            trial_fitness = np.array([func(ind) for ind in trial_population])\n\n            for i in range(self.elite_count, self.population_size):\n                if trial_fitness[i] < fitness[i]:\n                    fitness[i] = trial_fitness[i]\n                    real_population[i] = trial_population[i]\n\n            if evaluations % self.diversity_boost_interval == 0:\n                self.q_population[:self.elite_count] = np.random.uniform(0, 1, (self.elite_count, self.dim))\n                self.q_population[self.elite_count:self.population_size // 2] = np.random.uniform(0, 1, (self.population_size // 2 - self.elite_count, self.dim))\n\n            self._adaptive_mutation(diversity)\n\n        return self.best_solution", "configspace": "", "generation": 99, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04407 with standard deviation 0.00376.", "error": "", "parent_ids": ["84436ccf-5aaf-427b-872d-5344b07f431b"], "operator": null, "metadata": {"aucs": [0.040612689852123296, 0.04929101358954657, 0.04229692801026186]}}
