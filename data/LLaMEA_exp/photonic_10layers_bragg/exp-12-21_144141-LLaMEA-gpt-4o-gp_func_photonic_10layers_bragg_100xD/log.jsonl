{"id": "476588d4-660b-40f7-a1ce-ba197bd8de42", "fitness": 0.05364550648299024, "name": "EliteGuidedAdaptiveDE", "description": "An Elite-guided Adaptive Differential Evolution algorithm that dynamically adjusts mutation strategies based on performance feedback to efficiently explore diverse search spaces.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.5, 0.8]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success):\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) for p in self.strategy_probabilities\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) for p in self.strategy_probabilities\n            ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True)\n                else:\n                    self.adapt_strategy_probabilities(False)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 0, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05365 with standard deviation 0.00238.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.04943538886266641, 0.05352022808391732, 0.05123698540826127, 0.05233794618767251, 0.056664819390635834, 0.05424397909153322, 0.05301773436732804, 0.05740338292637348, 0.054949094028524104]}}
{"id": "e6105ee1-bc2f-43ca-a1a1-0ab6b121264e", "fitness": -Infinity, "name": "AdaptiveDEWithReinforcement", "description": "Adaptive Differential Evolution with Dynamic Strategy Reinforcement, enhancing exploration and exploitation by dynamically adjusting strategy probabilities based on success and introducing a reward mechanism to reinforce successful strategies.", "code": "import numpy as np\n\nclass AdaptiveDEWithReinforcement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.5, 0.8]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.reward = [0.0, 0.0]  # Reward scores for strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant, strategy\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self):\n        total_reward = sum(self.reward)\n        if total_reward > 0:\n            self.strategy_probabilities = [r / total_reward for r in self.reward]\n        else:\n            self.strategy_probabilities = [0.5, 0.5]  # Reset to equal probability\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant, strategy = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.reward[strategy] += 1.0  # Reward the successful strategy\n                else:\n                    self.reward[strategy] -= 0.5  # Penalize the unsuccessful strategy\n\n                self.adapt_strategy_probabilities()\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 1, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["476588d4-660b-40f7-a1ce-ba197bd8de42"], "operator": null, "metadata": {}}
{"id": "7a68466d-ba9d-4e09-b214-c73436727389", "fitness": 0.05333750027246206, "name": "MultiStrategyEliteGuidedDE", "description": "A Multi-Strategy Elite-guided DE algorithm that integrates adaptive learning rates and dynamic parameter adjustments to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass MultiStrategyEliteGuidedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]  # Probabilities for DE/rand/1, DE/best/1, and DE/current-to-best/1\n        self.mutation_factors = [0.5, 0.8, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.learning_rate = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:  # DE/current-to-best/1\n            mutant = self.population[target_idx] + self.learning_rate * (self.best_individual - self.population[target_idx]) + self.mutation_factors[2] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success):\n        if success:\n            self.strategy_probabilities = [\n                min(p + self.learning_rate, 1.0) for p in self.strategy_probabilities\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - self.learning_rate, 0.0) for p in self.strategy_probabilities\n            ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True)\n                else:\n                    self.adapt_strategy_probabilities(False)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 2, "feedback": "The algorithm MultiStrategyEliteGuidedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05334 with standard deviation 0.00278.", "error": "", "parent_ids": ["476588d4-660b-40f7-a1ce-ba197bd8de42"], "operator": null, "metadata": {"aucs": [0.04900282545718826, 0.05408592586784333, 0.050220540489756216, 0.05187673326427955, 0.05726720131910612, 0.053165062136459884, 0.05254951474552383, 0.05801473125910406, 0.053854967912897345]}}
{"id": "9dfa7421-ea59-4269-8121-5617302f416b", "fitness": -Infinity, "name": "EliteGuidedAdaptiveDEWithLocalSearch", "description": "An Elite-guided Adaptive Differential Evolution with Adaptive Mutation Strategies and Local Search Integration to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDEWithLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 15 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.3, 0.2]  # Added a local search strategy\n        self.mutation_factors = [0.5, 0.8, 0.1]  # Local search has a smaller factor\n        self.crossover_probability = 0.9\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:  # DE/rand/1\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:  # DE/best/1\n            a, b = np.random.choice(indices, 2, replace=False)\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[a] - self.population[b])\n        else:  # Local search\n            perturbation = np.random.normal(0, self.mutation_factors[2], self.dim)\n            mutant = self.population[target_idx] + perturbation\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        if success:\n            self.strategy_probabilities[strategy] += 0.1\n        else:\n            self.strategy_probabilities[strategy] -= 0.1\n\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [max(0.1, p / total) for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 3, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_ids": ["476588d4-660b-40f7-a1ce-ba197bd8de42"], "operator": null, "metadata": {}}
{"id": "cfc47a24-50d7-4e40-b9e3-44d9f12e7caa", "fitness": 0.05347246722809936, "name": "EliteGuidedAdaptiveDE", "description": "A slight modification in mutation strategies for improved diversity in search space.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.5, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success):\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) for p in self.strategy_probabilities\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) for p in self.strategy_probabilities\n            ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True)\n                else:\n                    self.adapt_strategy_probabilities(False)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 4, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05347 with standard deviation 0.00256.", "error": "", "parent_ids": ["476588d4-660b-40f7-a1ce-ba197bd8de42"], "operator": null, "metadata": {"aucs": [0.04884331021266641, 0.05352022808391732, 0.051333643383368543, 0.05170931815477464, 0.056664819390635834, 0.05434550717949427, 0.052380206620431524, 0.05740338292637348, 0.05505178910123221]}}
{"id": "61184102-a1b1-4969-bf7c-bfdcd8cd0170", "fitness": 0.05571788584499629, "name": "EliteGuidedAdaptiveDE", "description": "Enhanced Elite-guided Adaptive Differential Evolution with strategy adjustment based on recent performance history.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.5, 0.8]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]  # Track successful applications of strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) if idx == strategy else max(p - 0.1, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) if idx == strategy else min(p + 0.1, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 5, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05572 with standard deviation 0.00263.", "error": "", "parent_ids": ["476588d4-660b-40f7-a1ce-ba197bd8de42"], "operator": null, "metadata": {"aucs": [0.051507131535635686, 0.05603664163045485, 0.052588531126538274, 0.05453085700601845, 0.059348156905367766, 0.05567836791274827, 0.0552400449782694, 0.06012759300842063, 0.05640364850151325]}}
{"id": "691682ee-fb0e-470f-8dc1-81f14cec040e", "fitness": 0.057260189239642934, "name": "EliteGuidedAdaptiveDE", "description": "A slight adjustment in mutation factor values to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]  # Track successful applications of strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) if idx == strategy else max(p - 0.1, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) if idx == strategy else min(p + 0.1, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 6, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05726 with standard deviation 0.00251.", "error": "", "parent_ids": ["61184102-a1b1-4969-bf7c-bfdcd8cd0170"], "operator": null, "metadata": {"aucs": [0.052545470449292475, 0.05528539238982555, 0.056710415319804475, 0.055632936650098275, 0.058544547451108264, 0.06008012773069793, 0.056357643360036125, 0.059311114745521865, 0.060874055060401444]}}
{"id": "60cf5b7a-4a07-4135-aec5-79725dc103f3", "fitness": 0.05339058601326796, "name": "EliteGuidedAdaptiveDE", "description": "Increase mutation diversity by adjusting the mutation factors dynamically based on fitness improvement.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]  # Track successful applications of strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) if idx == strategy else max(p - 0.1, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) if idx == strategy else min(p + 0.1, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                    self.mutation_factors[strategy] = min(1.0, self.mutation_factors[strategy] + 0.01)  # Adjust mutation factor\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 7, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05339 with standard deviation 0.00302.", "error": "", "parent_ids": ["691682ee-fb0e-470f-8dc1-81f14cec040e"], "operator": null, "metadata": {"aucs": [0.05155035470326952, 0.053921847189046246, 0.04798317793133233, 0.054581168474048036, 0.05709278314572408, 0.05079868013615152, 0.055292156551968064, 0.05783779164391245, 0.05145731434395939]}}
{"id": "f708c88d-8615-4817-967f-0bd271b6f55a", "fitness": 0.053415383781184045, "name": "EliteGuidedAdaptiveDE", "description": "Slightly adjust strategy probability update rules for better adaptation.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]  # Track successful applications of strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment = 0.05  # Changed from 0.1 to 0.05\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment, 1.0) if idx == strategy else max(p - adjustment, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment, 0.0) if idx == strategy else min(p + adjustment, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 8, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05342 with standard deviation 0.00241.", "error": "", "parent_ids": ["691682ee-fb0e-470f-8dc1-81f14cec040e"], "operator": null, "metadata": {"aucs": [0.050553271667509, 0.05352022808391732, 0.04945853197578154, 0.05351721102378826, 0.056664819390635834, 0.05236429195570658, 0.054211824354789884, 0.05740338292637348, 0.05304489265215451]}}
{"id": "7cd9e182-1c6b-41c6-88ee-0a81d047979f", "fitness": 0.05502294297272251, "name": "EliteGuidedAdaptiveDE", "description": "Introduce a dynamic adjustment to the crossover probability to improve adaptability.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]  # Track successful applications of strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < max(0.5, self.crossover_probability * (self.best_fitness / np.median(self.fitness)))\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) if idx == strategy else max(p - 0.1, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) if idx == strategy else min(p + 0.1, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 9, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05502 with standard deviation 0.00269.", "error": "", "parent_ids": ["691682ee-fb0e-470f-8dc1-81f14cec040e"], "operator": null, "metadata": {"aucs": [0.04961115747195888, 0.053798426376616915, 0.052739054186969225, 0.0547639564302993, 0.056664819390635834, 0.05510127392837194, 0.05547731617296947, 0.05756578614072916, 0.05948469665595191]}}
{"id": "de9a2f38-1ae0-4910-b42d-83f1b58d3b2b", "fitness": 0.056208392937474955, "name": "EliteGuidedAdaptiveDE", "description": "Introducing adaptive learning rates and dynamic crossover probabilities to enhance exploration and exploitation balance in Differential Evolution.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]  # Track successful applications of strategies\n        self.adaptive_lr = 0.1  # Adaptive learning rate for strategy adjustment\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n\n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        dynamic_cp = self.crossover_probability + np.random.randn() * 0.1  # Dynamic crossover probability\n        dynamic_cp = np.clip(dynamic_cp, 0.1, 1.0)\n        cross_points = np.random.rand(self.dim) < dynamic_cp\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment = self.adaptive_lr if success else -self.adaptive_lr\n        self.strategy_probabilities = [\n            min(p + adjustment, 1.0) if idx == strategy else max(p - adjustment, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 10, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05621 with standard deviation 0.00259.", "error": "", "parent_ids": ["691682ee-fb0e-470f-8dc1-81f14cec040e"], "operator": null, "metadata": {"aucs": [0.055879673957240916, 0.054247674363488096, 0.051388986953495586, 0.059199287430132475, 0.05744117901751378, 0.054417675498892315, 0.05998103460948789, 0.05819173249382492, 0.055128292113198585]}}
{"id": "9e47dfab-4b6b-4000-aba6-ba3aeddfe942", "fitness": 0.0535119379183349, "name": "EliteGuidedAdaptiveDE", "description": "Slightly adjusted crossover probability to enhance trial vector diversity.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.95  # Adjusted crossover probability\n        self.success_history = [0, 0]  # Track successful applications of strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) if idx == strategy else max(p - 0.1, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) if idx == strategy else min(p + 0.1, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 11, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05351 with standard deviation 0.00233.", "error": "", "parent_ids": ["691682ee-fb0e-470f-8dc1-81f14cec040e"], "operator": null, "metadata": {"aucs": [0.050466227617331993, 0.05352022808391732, 0.04982557960266687, 0.0534249484839282, 0.056664819390635834, 0.05274950510652443, 0.05411829361216913, 0.05740338292637348, 0.05343445644146683]}}
{"id": "861ad080-832f-4c6f-86d8-c19a322a846d", "fitness": 0.05765756790454261, "name": "EliteGuidedAdaptiveDE", "description": "Introduce dynamic adjustment of crossover probability based on the success history to improve adaptability.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]  # Track successful applications of strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) if idx == strategy else max(p - 0.1, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)  # Adjust crossover probability\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) if idx == strategy else min(p + 0.1, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)  # Adjust crossover probability\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 12, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05766 with standard deviation 0.00195.", "error": "", "parent_ids": ["691682ee-fb0e-470f-8dc1-81f14cec040e"], "operator": null, "metadata": {"aucs": [0.05423172047499292, 0.055212205184024366, 0.056235458695461094, 0.05742938462317726, 0.058466874947851855, 0.059571690583100856, 0.05818104485796538, 0.05923235116488368, 0.06035738060942608]}}
{"id": "2ba7bacc-38b6-4573-a81e-2614e1c1b8cb", "fitness": 0.05765756790454261, "name": "EliteGuidedAdaptiveDE", "description": "Introduce strategy adaptation based on the success rate relative to the best historical fitness.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]  # Track successful applications of strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) if idx == strategy else max(p - 0.1, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)  # Adjust crossover probability\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) if idx == strategy else min(p + 0.1, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)  # Adjust crossover probability\n        \n        # Introduce relative success adaptation\n        self.strategy_probabilities = [p * (self.best_fitness / (1 + self.best_fitness)) for p in self.strategy_probabilities]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 13, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05766 with standard deviation 0.00195.", "error": "", "parent_ids": ["861ad080-832f-4c6f-86d8-c19a322a846d"], "operator": null, "metadata": {"aucs": [0.05423172047499292, 0.055212205184024366, 0.056235458695461094, 0.05742938462317726, 0.058466874947851855, 0.059571690583100856, 0.05818104485796538, 0.05923235116488368, 0.06035738060942608]}}
{"id": "57b68717-c2d8-4225-9911-c1bf47df7faf", "fitness": 0.0623132660296692, "name": "EliteGuidedAdaptiveDE", "description": "Introduce adaptive mutation factor adjustments based on success history to improve convergence.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]  # Mutation factors for the strategies\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]  # Track successful applications of strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) if idx == strategy else max(p - 0.1, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)  # Adjust crossover probability\n            self.mutation_factors[strategy] = min(self.mutation_factors[strategy] + 0.05, 1.0)  # Adjust mutation factor\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) if idx == strategy else min(p + 0.1, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)  # Adjust crossover probability\n            self.mutation_factors[strategy] = max(self.mutation_factors[strategy] - 0.05, 0.0)  # Adjust mutation factor\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 14, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06231 with standard deviation 0.00279.", "error": "", "parent_ids": ["861ad080-832f-4c6f-86d8-c19a322a846d"], "operator": null, "metadata": {"aucs": [0.061940121963553585, 0.05966124892033442, 0.05728790427869612, 0.06573001400320322, 0.06323854956956054, 0.06071983214021426, 0.0666286003175619, 0.06408361708701027, 0.061529505986888444]}}
{"id": "5b9f5561-6307-4e2c-9f6e-fd20b8cf35b1", "fitness": 0.05703200296181121, "name": "EliteGuidedAdaptiveDE", "description": "Introduce adaptive learning rates and self-adaptive population size adjustments to efficiently explore and exploit the search space.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 2)\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.4, 0.6]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.5, 0.8]  # Mutation factors for the strategies\n        self.crossover_probability = 0.85\n        self.success_history = [0, 0]\n        self.learning_rate = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:  # DE/rand/1\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:  # DE/best/1\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + self.learning_rate, 1.0) if idx == strategy else max(p - self.learning_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.02, 1.0)\n            self.mutation_factors[strategy] = min(self.mutation_factors[strategy] + 0.03, 1.0)\n        else:\n            self.strategy_probabilities = [\n                max(p - self.learning_rate, 0.0) if idx == strategy else min(p + self.learning_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.02, 0.1)\n            self.mutation_factors[strategy] = max(self.mutation_factors[strategy] - 0.03, 0.1)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 15, "feedback": "The algorithm EliteGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05703 with standard deviation 0.00319.", "error": "", "parent_ids": ["57b68717-c2d8-4225-9911-c1bf47df7faf"], "operator": null, "metadata": {"aucs": [0.05434740693211659, 0.057883550507592196, 0.051645328994865514, 0.05755668646809686, 0.06132778728748822, 0.05468184741732396, 0.05831126175351242, 0.06213993078914748, 0.05539422650615766]}}
{"id": "ebfd6ed9-2390-4d25-b147-e483f650d675", "fitness": 0.07251586312814129, "name": "EliteGuidedAdaptiveDETournament", "description": "Adaptive strategy adjustment with tournament selection enhances diversity and exploration for robust optimization.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]  # Probabilities for DE/rand/1 and DE/best/1\n        self.mutation_factors = [0.6, 0.9]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        if success:\n            self.strategy_probabilities = [\n                min(p + 0.1, 1.0) if idx == strategy else max(p - 0.1, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)\n            self.mutation_factors[strategy] = min(self.mutation_factors[strategy] + 0.05, 1.0)\n        else:\n            self.strategy_probabilities = [\n                max(p - 0.1, 0.0) if idx == strategy else min(p + 0.1, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)\n            self.mutation_factors[strategy] = max(self.mutation_factors[strategy] - 0.05, 0.0)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 3\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx = min(participants, key=lambda idx: self.fitness[idx])\n        return best_idx\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 16, "feedback": "The algorithm EliteGuidedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07252 with standard deviation 0.00487.", "error": "", "parent_ids": ["57b68717-c2d8-4225-9911-c1bf47df7faf"], "operator": null, "metadata": {"aucs": [0.06763904495975082, 0.07463480461706562, 0.06530288478491986, 0.07193373898526068, 0.07959573982192625, 0.06940452209962822, 0.07295923765995094, 0.0807908359821965, 0.07038195924257273]}}
{"id": "8ab5da99-d6b2-46e8-a164-cb9319d8ef88", "fitness": 0.0747383307673074, "name": "EnhancedAdaptiveDETournament", "description": "Incorporate dynamic parameter tuning and enhanced elitism to further drive adaptation and convergence in DE tournaments.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]\n        self.mutation_factors = [0.6, 0.9]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]\n        self.dynamic_adjustment_rate = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)\n            self.mutation_factors[strategy] = min(self.mutation_factors[strategy] + 0.05, 1.0)\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)\n            self.mutation_factors[strategy] = max(self.mutation_factors[strategy] - 0.05, 0.0)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 3\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx = min(participants, key=lambda idx: self.fitness[idx])\n        return best_idx\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07474 with standard deviation 0.00390.", "error": "", "parent_ids": ["ebfd6ed9-2390-4d25-b147-e483f650d675"], "operator": null, "metadata": {"aucs": [0.07321858188304542, 0.0732879552643072, 0.06732437392202839, 0.07803310846914324, 0.07812576678263716, 0.07157966868638477, 0.07919059661231398, 0.07928973354940327, 0.0725951917365032]}}
{"id": "e319c64d-da30-4fb6-9a49-37ffbdd454ac", "fitness": 0.07151595343245382, "name": "HybridCrossoverDETournament", "description": "Introduce a hybrid crossover mechanism combining local and global exploration to enhance convergence and diversity in DE tournaments.", "code": "import numpy as np\n\nclass HybridCrossoverDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]\n        self.mutation_factors = [0.6, 0.9]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]\n        self.dynamic_adjustment_rate = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def hybrid_crossover(self, target, mutant):\n        global_cross = np.random.rand(self.dim) < self.crossover_probability\n        local_cross = np.random.rand(self.dim) < (1 - self.crossover_probability)\n        combined_cross = np.logical_or(global_cross, local_cross)\n        if not np.any(combined_cross):\n            combined_cross[np.random.randint(0, self.dim)] = True\n        trial = np.where(combined_cross, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)\n            self.mutation_factors[strategy] = min(self.mutation_factors[strategy] + 0.05, 1.0)\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)\n            self.mutation_factors[strategy] = max(self.mutation_factors[strategy] - 0.05, 0.0)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 3\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx = min(participants, key=lambda idx: self.fitness[idx])\n        return best_idx\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.hybrid_crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 18, "feedback": "The algorithm HybridCrossoverDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07152 with standard deviation 0.00628.", "error": "", "parent_ids": ["8ab5da99-d6b2-46e8-a164-cb9319d8ef88"], "operator": null, "metadata": {"aucs": [0.06924790649128287, 0.07442491847234778, 0.06115884104457481, 0.0736701137380611, 0.07932025158256928, 0.06486039633017837, 0.07472741282153061, 0.08049735208105635, 0.06573638833048312]}}
{"id": "c52682fc-fa78-4c1d-b490-97d01947d7f4", "fitness": 0.07996814323716352, "name": "EnhancedAdaptiveDETournament", "description": "Enhanced exploration-exploitation balance and dynamic adjustment based on success diversity for improved convergence in DE tournaments.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.5, 0.5]\n        self.mutation_factors = [0.6, 0.9]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0]\n        self.dynamic_adjustment_rate = 0.1  # Increased adjustment rate for faster adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            # More aggressive tuning of factors and probability\n            self.crossover_probability = min(self.crossover_probability + 0.02, 1.0)\n            self.mutation_factors[strategy] = min(self.mutation_factors[strategy] + 0.1, 1.0)\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.02, 0.0)\n            self.mutation_factors[strategy] = max(self.mutation_factors[strategy] - 0.1, 0.0)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4  # Increased tournament size for more competition\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx = min(participants, key=lambda idx: self.fitness[idx])\n        return best_idx\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07997 with standard deviation 0.00323.", "error": "", "parent_ids": ["8ab5da99-d6b2-46e8-a164-cb9319d8ef88"], "operator": null, "metadata": {"aucs": [0.0740067587121408, 0.07676801921940535, 0.07759981385209958, 0.07891563450129391, 0.08194357349041992, 0.08294608006483206, 0.08009770111195269, 0.08319356834035829, 0.08424213984196904]}}
{"id": "64e7596f-d047-41ca-bbbb-fbc141aa7e14", "fitness": 0.08445894328317213, "name": "ImprovedAdaptiveDETournament", "description": "Introduce dynamic multi-strategy mutation and adaptive crossover to enhance diversity and convergence in DE tournaments.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.02, 1.0)\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.02, 0.0)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx = min(participants, key=lambda idx: self.fitness[idx])\n        return best_idx\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 20, "feedback": "The algorithm ImprovedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08446 with standard deviation 0.00366.", "error": "", "parent_ids": ["c52682fc-fa78-4c1d-b490-97d01947d7f4"], "operator": null, "metadata": {"aucs": [0.07819037213667934, 0.0798395669121802, 0.08283233670091539, 0.08357858323056155, 0.08528970386335577, 0.08873348602142872, 0.08488498915470699, 0.08660890587577152, 0.09017254565294974]}}
{"id": "6fc26007-fc14-4fa0-9833-f529c222eb46", "fitness": 0.0862092273847284, "name": "ImprovedAdaptiveDETournament", "description": "Introduce elitism in selection and fine-tune adaptive rates to enhance convergence in DE tournaments.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05  # Adjusted from 0.1 to 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)  # Adjusted from 0.02 to 0.01\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)  # Adjusted from 0.02 to 0.01\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4\n        elite_idx = np.argmin(self.fitness)  # Added elite selection\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 21, "feedback": "The algorithm ImprovedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08621 with standard deviation 0.00352.", "error": "", "parent_ids": ["64e7596f-d047-41ca-bbbb-fbc141aa7e14"], "operator": null, "metadata": {"aucs": [0.08011704183583734, 0.08175378225926089, 0.08356074547304959, 0.08581955388924789, 0.0875653919604501, 0.08968585832156561, 0.08721051439558536, 0.08898265642865177, 0.09118750189890701]}}
{"id": "7dbe71c7-b67a-483e-b9a0-7d1f7ebe8950", "fitness": 0.08908943516173731, "name": "ImprovedAdaptiveDETournament", "description": "Enhance exploration by dynamically adjusting mutation factors and tournament size.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.6, 0.8, 1.2]  # Modified from [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 5  # Modified from 4\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 22, "feedback": "The algorithm ImprovedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08909 with standard deviation 0.00377.", "error": "", "parent_ids": ["6fc26007-fc14-4fa0-9833-f529c222eb46"], "operator": null, "metadata": {"aucs": [0.08447408236939924, 0.08640155471796418, 0.08246696799942244, 0.09070292919666356, 0.09281129043092318, 0.08843481900036998, 0.09223172608826657, 0.09438669581466674, 0.0898948508379599]}}
{"id": "39ab5b4e-14d4-439b-9052-dd8a970f451c", "fitness": 0.08848782831381644, "name": "ImprovedAdaptiveDETournament", "description": "Refine strategy adaptation by enhancing mutation diversity and dynamically adjusting tournament size.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.6, 0.7, 1.2]  # Changed from [0.6, 0.8, 1.2]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.015, 1.0)  # Changed from +0.01\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.015, 0.0)  # Changed from -0.01\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = np.random.randint(3, 7)  # Changed from fixed 5\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 23, "feedback": "The algorithm ImprovedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08849 with standard deviation 0.00388.", "error": "", "parent_ids": ["7dbe71c7-b67a-483e-b9a0-7d1f7ebe8950"], "operator": null, "metadata": {"aucs": [0.08193779306209015, 0.08645598151458966, 0.08333153313751429, 0.0877968365094497, 0.09284037309359927, 0.08944667527310424, 0.08922694193676306, 0.0944080692125916, 0.09094625108464593]}}
{"id": "5db6381d-e706-4920-95da-d4dbf2df33f0", "fitness": 0.057623323149773996, "name": "EnhancedAdaptiveDE", "description": "Introduce adaptive learning of mutation strategies through a reward-based mechanism to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.6, 0.8, 1.2]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.strategy_rewards = [0.0, 0.0, 0.0]\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant, strategy\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self):\n        total_rewards = sum(self.strategy_rewards)\n        if total_rewards > 0:\n            self.strategy_probabilities = [r / total_rewards for r in self.strategy_rewards]\n        self.strategy_rewards = [0.0, 0.0, 0.0]\n\n    def tournament_selection(self, func):\n        tournament_size = 5\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant, strategy = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.strategy_rewards[strategy] += 1\n                else:\n                    self.strategy_rewards[strategy] -= 1\n\n                if evaluations >= self.budget:\n                    break\n\n            self.adapt_strategy_probabilities()\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05762 with standard deviation 0.00412.", "error": "", "parent_ids": ["7dbe71c7-b67a-483e-b9a0-7d1f7ebe8950"], "operator": null, "metadata": {"aucs": [0.05268622461068517, 0.060209054253875016, 0.05266654776695523, 0.055780844559569775, 0.06381443628737538, 0.05577468754448334, 0.0565072652944445, 0.06466618130594237, 0.056504666724635166]}}
{"id": "2119b9c8-8b0f-4a00-a24d-fbd03668c5cb", "fitness": 0.08838605404823195, "name": "ImprovedAdaptiveDETournament", "description": "Fine-tune mutation strategy probabilities to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.30, 0.35, 0.35]  # Fine-tuned from [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.6, 0.8, 1.2]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 5\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 25, "feedback": "The algorithm ImprovedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08839 with standard deviation 0.00385.", "error": "", "parent_ids": ["7dbe71c7-b67a-483e-b9a0-7d1f7ebe8950"], "operator": null, "metadata": {"aucs": [0.0825594773338274, 0.08640155471796418, 0.08246696799942244, 0.0885292639521853, 0.09281129043092318, 0.08843481900036998, 0.08998956634676847, 0.09438669581466674, 0.0898948508379599]}}
{"id": "684600ac-deed-47d0-a585-efcb2a667154", "fitness": 0.08881617215372203, "name": "EnhancedDiversityDETournament", "description": "Introduce diversity preservation by incorporating probabilistic crowding and adaptive mutation to enhance exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedDiversityDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.6, 0.8, 1.2]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.diversity_threshold = 0.1  # Added threshold for diversity preservation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + 0.01, 1.0)\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - 0.01, 0.0)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 5\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def probabilistic_crowding(self, trial, trial_fitness, target_idx):\n        target = self.population[target_idx]\n        target_fitness = self.fitness[target_idx]\n        distance_target = np.linalg.norm(trial - target)\n        is_replaced = False\n\n        if distance_target > self.diversity_threshold:\n            if trial_fitness < target_fitness:\n                is_replaced = True\n        else:\n            prob = 1 / (1 + np.exp(distance_target - self.diversity_threshold))\n            if np.random.rand() < prob:\n                is_replaced = True\n\n        return is_replaced\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if self.probabilistic_crowding(trial, trial_fitness, i):\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedDiversityDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08882 with standard deviation 0.00387.", "error": "", "parent_ids": ["7dbe71c7-b67a-483e-b9a0-7d1f7ebe8950"], "operator": null, "metadata": {"aucs": [0.08447408236939924, 0.08629250253949106, 0.08184466690975845, 0.09070292919666356, 0.09266580304505401, 0.08773209561326023, 0.09223172608826657, 0.09423077145218473, 0.08917097216942049]}}
{"id": "2cd4f972-969c-4de2-a51f-c68d54f551e3", "fitness": 0.08992218677444529, "name": "ImprovedAdaptiveDETournament", "description": "Improve adaptation by introducing dynamic crossover rates and enhanced strategy selection.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.6, 0.8, 1.2]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02  # New parameter\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + self.dynamic_crossover_rate, 1.0)  # Modified line\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - self.dynamic_crossover_rate, 0.0)  # Modified line\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)  # Modified line\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 27, "feedback": "The algorithm ImprovedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08992 with standard deviation 0.00381.", "error": "", "parent_ids": ["7dbe71c7-b67a-483e-b9a0-7d1f7ebe8950"], "operator": null, "metadata": {"aucs": [0.0829762234459902, 0.08600764364206881, 0.08668708982320428, 0.08899184805801885, 0.09233493090707179, 0.09317677207456121, 0.09046403184529628, 0.09388753527116989, 0.09477360590262629]}}
{"id": "7ce5d2d5-94d3-4d5b-9ec2-0ed62ab325eb", "fitness": 0.09074388539625133, "name": "EnhancedAdaptiveDETournament", "description": "Enhance adaptation by dynamically adjusting mutation factors and incorporating a weighted strategy selection based on recent successes.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]  # Adjusted mutation factors\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01  # New parameter for mutation adjustment\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        \n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + self.dynamic_crossover_rate, 1.0)\n            self.mutation_factors = [min(f + self.dynamic_mutation_adjustment, 2.0) for f in self.mutation_factors]  # Adjust mutation factors\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - self.dynamic_crossover_rate, 0.0)\n            self.mutation_factors = [max(f - self.dynamic_mutation_adjustment, 0.1) for f in self.mutation_factors]  # Adjust mutation factors\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09074 with standard deviation 0.00357.", "error": "", "parent_ids": ["2cd4f972-969c-4de2-a51f-c68d54f551e3"], "operator": null, "metadata": {"aucs": [0.08576848450997965, 0.08719808351951863, 0.08496407074739443, 0.09211722449745263, 0.09367982941481223, 0.09123858963804343, 0.093676399287423, 0.09527315615726517, 0.09277913079437283]}}
{"id": "219d4be3-338c-47e3-bc12-cfde39416463", "fitness": 0.09074388539625133, "name": "EnhancedAdaptiveDETournament", "description": "Enhance adaptation by refining mutation and crossover strategies and adding elitism to improve convergence and performance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]  # Adjusted mutation factors\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01  # New parameter for mutation adjustment\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        # Refined mutation strategies\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        \n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + self.dynamic_crossover_rate, 1.0)\n            self.mutation_factors = [min(f + self.dynamic_mutation_adjustment, 2.0) for f in self.mutation_factors]  # Adjust mutation factors\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - self.dynamic_crossover_rate, 0.0)\n            self.mutation_factors = [max(f - self.dynamic_mutation_adjustment, 0.1) for f in self.mutation_factors]  # Adjust mutation factors\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09074 with standard deviation 0.00357.", "error": "", "parent_ids": ["7ce5d2d5-94d3-4d5b-9ec2-0ed62ab325eb"], "operator": null, "metadata": {"aucs": [0.08576848450997965, 0.08719808351951863, 0.08496407074739443, 0.09211722449745263, 0.09367982941481223, 0.09123858963804343, 0.093676399287423, 0.09527315615726517, 0.09277913079437283]}}
{"id": "0d4e3a8c-b848-40f7-883e-6d55101ed2bc", "fitness": 0.09122233710164604, "name": "EnhancedAdaptiveDETournament", "description": "Enhance selection and exploration by incorporating elitism in tournament and adaptive differential evolution with dynamic learning rate.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0] \n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01  \n        self.elite_preservation_rate = 0.1  # Line 1: new parameter for elitism\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        \n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + self.dynamic_crossover_rate, 1.0)\n            self.mutation_factors = [min(f + self.dynamic_mutation_adjustment, 2.0) for f in self.mutation_factors]  \n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - self.dynamic_crossover_rate, 0.0)\n            self.mutation_factors = [max(f - self.dynamic_mutation_adjustment, 0.1) for f in self.mutation_factors]  \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:  # Line 2: added elitism\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09122 with standard deviation 0.00358.", "error": "", "parent_ids": ["7ce5d2d5-94d3-4d5b-9ec2-0ed62ab325eb"], "operator": null, "metadata": {"aucs": [0.08711915618393029, 0.08697360697299428, 0.08517548991470503, 0.09360800856851537, 0.09343560149038754, 0.0914595773097886, 0.09520343766507611, 0.09502411076227979, 0.09300204504713738]}}
{"id": "18afa7d3-27fd-4530-97b9-8f0852bcee08", "fitness": 0.09122233710164604, "name": "EnhancedAdaptiveMultiMutationDETournament", "description": "Augment the algorithm by introducing a multi-mutation strategy with fitness-based adjustment, enhancing diversity and convergence speed.", "code": "import numpy as np\n\nclass EnhancedAdaptiveMultiMutationDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0] \n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01  \n        self.elite_preservation_rate = 0.1\n        self.mutation_strategies = [\n            lambda a, b, c: self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c]),\n            lambda a, b, c: self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c]),\n            lambda a, b, c: self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        ]\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        mutant = self.mutation_strategies[strategy](a, b, c)\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        \n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + self.dynamic_crossover_rate, 1.0)\n            self.mutation_factors = [min(f + self.dynamic_mutation_adjustment, 2.0) for f in self.mutation_factors]  \n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - self.dynamic_crossover_rate, 0.0)\n            self.mutation_factors = [max(f - self.dynamic_mutation_adjustment, 0.1) for f in self.mutation_factors]  \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedAdaptiveMultiMutationDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09122 with standard deviation 0.00358.", "error": "", "parent_ids": ["0d4e3a8c-b848-40f7-883e-6d55101ed2bc"], "operator": null, "metadata": {"aucs": [0.08711915618393029, 0.08697360697299428, 0.08517548991470503, 0.09360800856851537, 0.09343560149038754, 0.0914595773097886, 0.09520343766507611, 0.09502411076227979, 0.09300204504713738]}}
{"id": "7be9e7dd-823a-4a89-90fa-3ffaad972f02", "fitness": 0.09122233710164604, "name": "EnhancedAdaptiveDETournament", "description": "Enhance exploration-exploitation balance by implementing adaptive multi-strategy mutation and progressive elitism in an adaptive differential evolution framework.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.elite_progression_rate = 0.01  # New rate to progressively increase elitism\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        \n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + self.dynamic_crossover_rate, 1.0)\n            self.mutation_factors = [min(f + self.dynamic_mutation_adjustment, 2.0) for f in self.mutation_factors]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - self.dynamic_crossover_rate, 0.0)\n            self.mutation_factors = [max(f - self.dynamic_mutation_adjustment, 0.1) for f in self.mutation_factors]\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                self.elite_preservation_rate = min(self.elite_preservation_rate + self.elite_progression_rate, 0.5)  # Progressive elitism increment\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09122 with standard deviation 0.00358.", "error": "", "parent_ids": ["0d4e3a8c-b848-40f7-883e-6d55101ed2bc"], "operator": null, "metadata": {"aucs": [0.08711915618393029, 0.08697360697299428, 0.08517548991470503, 0.09360800856851537, 0.09343560149038754, 0.0914595773097886, 0.09520343766507611, 0.09502411076227979, 0.09300204504713738]}}
{"id": "a5d053f3-2277-4bc7-8bb3-7d6900178bb9", "fitness": 0.09047570094647339, "name": "EnhancedAdaptiveDETournamentV2", "description": "Improve exploration-exploitation balance with adaptive local search and dynamic learning via decomposed elitist retrieval.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournamentV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.local_search_probability = 0.1  # Line 1: new parameter for local search\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice(\n            [0, 1, 2], p=self.strategy_probabilities\n        )\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success / (sum(self.success_history) + 1)))\n        \n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = min(self.crossover_probability + self.dynamic_crossover_rate, 1.0)\n            self.mutation_factors = [min(f + self.dynamic_mutation_adjustment, 2.0) for f in self.mutation_factors]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n            self.crossover_probability = max(self.crossover_probability - self.dynamic_crossover_rate, 0.0)\n            self.mutation_factors = [max(f - self.dynamic_mutation_adjustment, 0.1) for f in self.mutation_factors]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def local_search(self, individual):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        new_individual = individual + perturbation\n        new_individual = np.clip(new_individual, self.bounds.lb, self.bounds.ub)\n        return new_individual\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                if np.random.rand() < self.local_search_probability:\n                    trial = self.local_search(self.population[i])\n                else:\n                    mutant = self.mutate(i)\n                    strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                    trial = self.crossover(self.population[i], mutant)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedAdaptiveDETournamentV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09048 with standard deviation 0.00344.", "error": "", "parent_ids": ["0d4e3a8c-b848-40f7-883e-6d55101ed2bc"], "operator": null, "metadata": {"aucs": [0.08604673732057955, 0.08517725595329084, 0.08598028922168788, 0.09241139809158494, 0.09140127007660948, 0.09239317593158969, 0.09397413734492199, 0.09292681570890671, 0.09397022886908946]}}
{"id": "7a68e924-d1a5-42bb-8073-6e43aecbb94b", "fitness": 0.09299529948217752, "name": "EnhancedAdaptiveDETournament", "description": "Improve exploration and exploitation by integrating self-adaptive parameter adjustments with fitness-based adaptive mutation and crossover rates in an enhanced adaptive differential evolution algorithm.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99  # New: decay rate for fitness-based adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))  # New: Compute success rate\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09300 with standard deviation 0.00366.", "error": "", "parent_ids": ["0d4e3a8c-b848-40f7-883e-6d55101ed2bc"], "operator": null, "metadata": {"aucs": [0.08736695137065198, 0.0890116091111397, 0.08765939869495742, 0.09413171833267053, 0.09570771439481196, 0.09421146407178971, 0.09568996165093324, 0.09735719536227316, 0.09582168235037003]}}
{"id": "424bf04a-541b-4ae2-9f44-f409f3670449", "fitness": 0.09240378047320408, "name": "EnhancedAdaptiveDETournament", "description": "Fine-tune exploration and exploitation by using an adaptive mutation factor based on fitness variance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99  # New: decay rate for fitness-based adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            fitness_variance = np.var(self.fitness) + 1e-9  # New: add variance of fitness to adjust mutation\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment / fitness_variance\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))  # New: Compute success rate\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09240 with standard deviation 0.00379.", "error": "", "parent_ids": ["7a68e924-d1a5-42bb-8073-6e43aecbb94b"], "operator": null, "metadata": {"aucs": [0.08684574905944054, 0.08686356242762616, 0.08770263970663283, 0.09398553672081966, 0.09465237855881148, 0.09410578416145787, 0.0960268767716781, 0.09602412231403468, 0.09542737453833539]}}
{"id": "f21db8e0-4d01-4fdd-8a2d-4a4e03838f8a", "fitness": 0.09291788826265492, "name": "EnhancedAdaptiveDETournament", "description": "Enhance mutation strategy using best of random selection to improve exploration and solution quality.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99  # New: decay rate for fitness-based adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            # Improve selection by using the best among random selections\n            d = np.random.choice(indices)\n            e = np.random.choice(indices)\n            best_rand = min([d, e], key=lambda idx: self.fitness[idx])\n            mutant = self.population[a] + self.mutation_factors[2] * (self.population[best_rand] - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))  # New: Compute success rate\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09292 with standard deviation 0.00373.", "error": "", "parent_ids": ["7a68e924-d1a5-42bb-8073-6e43aecbb94b"], "operator": null, "metadata": {"aucs": [0.08754749105585913, 0.08934249761492563, 0.08684760755536913, 0.09368952522999308, 0.09567502037555053, 0.09454509700123581, 0.09564837118207292, 0.09775683091384757, 0.09520855343504042]}}
{"id": "9f186ef1-a7a3-4df5-87dd-acc64a172ea6", "fitness": 0.09299529948217752, "name": "RefinedAdaptiveDETournament", "description": "Incorporate adaptive dimensional crossover and mutation rates with self-tuning strategy selection to enhance convergence in diverse environments.", "code": "import numpy as np\n\nclass RefinedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 37, "feedback": "The algorithm RefinedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09300 with standard deviation 0.00366.", "error": "", "parent_ids": ["7a68e924-d1a5-42bb-8073-6e43aecbb94b"], "operator": null, "metadata": {"aucs": [0.08736695137065198, 0.0890116091111397, 0.08765939869495742, 0.09413171833267053, 0.09570771439481196, 0.09421146407178971, 0.09568996165093324, 0.09735719536227316, 0.09582168235037003]}}
{"id": "21f1828c-9694-463b-a316-c9c82c6d51a5", "fitness": 0.09342222656811817, "name": "EnhancedAdaptiveDETournament", "description": "Enhance convergence by increasing crossover probability and decreasing dynamic adjustment rate for improved adaptability.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95  # Changed: increased from 0.9 to 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04  # Changed: decreased from 0.05 to 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99  # New: decay rate for fitness-based adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))  # New: Compute success rate\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09342 with standard deviation 0.00360.", "error": "", "parent_ids": ["7a68e924-d1a5-42bb-8073-6e43aecbb94b"], "operator": null, "metadata": {"aucs": [0.08844798485679817, 0.08887008766030802, 0.08803318940235316, 0.09505048987652542, 0.09556215284257952, 0.09463352205441933, 0.09673353760311154, 0.09721092178714952, 0.09625815302981888]}}
{"id": "6672c4f5-4995-4cb2-9304-424509bc2b5f", "fitness": 0.09224216708660583, "name": "AdaptiveEliteDE", "description": "Introduce adaptive mutation balance and elite-driven exploration for improved convergence and diversity.", "code": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.03  # Further decreased for stability\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.02  # Increased for better diversity\n        self.elite_preservation_rate = 0.15  # Increased to emphasize elite individuals\n        self.fitness_decay_rate = 0.98  # Adjusted for responsive adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 39, "feedback": "The algorithm AdaptiveEliteDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09224 with standard deviation 0.00385.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08673100192958794, 0.08879812179219604, 0.08614164569345706, 0.09317196674619221, 0.09545866007777815, 0.0924779387465654, 0.09626941865097427, 0.09709847368745284, 0.09403227645524859]}}
{"id": "30b182d4-3cd8-41ac-8266-e41c4cd46815", "fitness": 0.09202940573665437, "name": "EnhancedAdaptiveDETournament", "description": "Introduced a success-based dynamic mutation adjustment to enhance adaptability and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        # Adjust mutation factors based on success rate\n        self.mutation_factors = [factor * (1 + success_rate) for factor in self.mutation_factors]  # Modified line\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09203 with standard deviation 0.00373.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08508182031615408, 0.08757911194170809, 0.0882844255694264, 0.09353601695620395, 0.0930861562969606, 0.09462754482990676, 0.09529748491129697, 0.09521658242600184, 0.0955555083822307]}}
{"id": "f37a5f39-3069-405b-99a9-bb506df596ee", "fitness": 0.09297140003173693, "name": "EnhancedAdaptiveDETournament", "description": "Enhance algorithm by refining mutation strategy and improving adaptation based on success history.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.8, 1.0]  # Changed: adjusted from [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.995  # Changed: adjusted from 0.99\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09297 with standard deviation 0.00369.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08729256329101365, 0.0888700876603058, 0.08766489526916199, 0.0938218172513492, 0.09556215284257596, 0.09463352205441922, 0.09542848709984242, 0.09721092178714552, 0.09625815302981866]}}
{"id": "8b53ba17-f403-43b2-82c6-2286a1ebef65", "fitness": 0.0559541199160829, "name": "RankBasedAdaptiveDE", "description": "Introduce rank-based selection and adaptive mutation scaling for enhanced diversity and convergence in differential evolution.", "code": "import numpy as np\n\nclass RankBasedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.elite_preservation_rate = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n\n        ranks = np.argsort(self.fitness)\n        rank_factor = 1.0 - (np.where(ranks == target_idx)[0][0] / self.pop_size)\n        \n        mutant = self.population[a] + rank_factor * self.mutation_factors[0] * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * 0.99 + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 42, "feedback": "The algorithm RankBasedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05595 with standard deviation 0.00282.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.053314854290787084, 0.056373439958793736, 0.05111610404734612, 0.056457356315684715, 0.059705373557844, 0.05411563636295147, 0.057195608718809354, 0.06048977212744011, 0.054818933865089514]}}
{"id": "4860fc0c-a581-4ef7-b03e-972d5393f63a", "fitness": 0.09061599573173562, "name": "RefinedAdaptiveDETournament", "description": "Enhance adaptability by integrating dynamic elite selection with fitness-dependent parameter adjustments to improve convergence.", "code": "import numpy as np\n\nclass RefinedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.15  # Increased for more elite preservation\n        self.fitness_decay_rate = 0.98  # Slightly decreased to enhance adaptability\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def dynamic_elite_selection(self, func, evaluations):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        return best_idx_among_participants if evaluations % 2 == 0 else elite_idx\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.dynamic_elite_selection(func, evaluations)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 43, "feedback": "The algorithm RefinedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09062 with standard deviation 0.00383.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08453792830569073, 0.08792311444967715, 0.0852725920136207, 0.0900254323926869, 0.09446805691569848, 0.0920810463539885, 0.0913299391898349, 0.09627503952438066, 0.09363081244004257]}}
{"id": "d9b15c96-2bdc-469e-aa07-8beb1ca2c014", "fitness": -Infinity, "name": "EnhancedAdaptiveDETournament", "description": "Further enhance convergence by adjusting mutation strategy probabilities based on recent improvements dynamically.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n        # Dynamic adjustment of strategy probabilities based on recent improvements (New change)\n        recent_successes = sum(self.success_history)\n        for i in range(len(self.strategy_probabilities)):\n            self.strategy_probabilities[i] = self.strategy_probabilities[i] * (1 + 0.1 * (self.success_history[i] / (recent_successes + 1e-9)))\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 44, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {}}
{"id": "f95eeb6a-41a3-427e-a612-228e0fd333c6", "fitness": 0.0704157392041551, "name": "EnhancedAdaptiveDETournamentV2", "description": "Enhance convergence by incorporating adaptive strategy selection and fitness improvement mechanisms with modified tournament selection.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournamentV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.dynamic_adjustment_rate = 0.03\n        self.elite_preservation_rate = 0.2\n        self.tournament_pressure = 0.75  # New: Probability of selecting more fit individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        adjustment = self.dynamic_adjustment_rate * (1 if success else -1)\n        self.strategy_probabilities[strategy] += adjustment\n        self.strategy_probabilities = np.clip(self.strategy_probabilities, 0.1, 0.8)\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self):\n        tournament_size = 4 + np.random.randint(2)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        fitness_sorted_idxs = sorted(participants, key=lambda idx: self.fitness[idx])\n\n        prob = np.random.uniform()\n        for i, idx in enumerate(fitness_sorted_idxs):\n            if prob < self.tournament_pressure * (1 - (i / tournament_size)):\n                return idx\n        return fitness_sorted_idxs[0]\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection()\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, np.random.choice([0, 1, 2], p=self.strategy_probabilities))\n                else:\n                    self.adapt_strategy_probabilities(False, np.random.choice([0, 1, 2], p=self.strategy_probabilities))\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedAdaptiveDETournamentV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07042 with standard deviation 0.00841.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.05947567361155759, 0.07744971579143856, 0.0647108642044415, 0.06303756736778288, 0.08269171070608072, 0.06878390317538619, 0.06387876338089093, 0.08395871376729802, 0.06975474083251954]}}
{"id": "a4e4cc84-cec0-404c-8812-98e45a9ab766", "fitness": 0.09324847917710168, "name": "RefinedAdaptiveDETournament", "description": "Integrates adaptive mutation strategies with stochastic tournament selection and elite preservation to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.03\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.98  # Adjusted decay rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 46, "feedback": "The algorithm RefinedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09325 with standard deviation 0.00365.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08843851662778757, 0.08908332085824733, 0.08735039794151678, 0.09503950816108508, 0.09580776144410952, 0.0938638755173955, 0.09672214406268531, 0.0974652650331489, 0.09546552294793909]}}
{"id": "711ab73b-3e32-4089-a1f4-9c70516ea177", "fitness": 0.09168224995007465, "name": "ImprovedAdaptiveDETournament", "description": "Dynamically adjusts crossover probability and mutation factors based on historical performance for enhanced adaptive convergence.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.03\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.98\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability *= success_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] *= success_rate\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 47, "feedback": "The algorithm ImprovedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09168 with standard deviation 0.00368.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08786801175123804, 0.08743463411772234, 0.08528264437519262, 0.09444688363382558, 0.09393256348427514, 0.09152347034945185, 0.09606930967122196, 0.09552977737958956, 0.09305295478815478]}}
{"id": "f8cba521-daff-4099-b293-0a9a950cda34", "fitness": 0.06632173276242004, "name": "EnhancedAdaptiveDETournamentV2", "description": "Introduce a dynamic selection pressure mechanism and adaptive learning for mutation strategies to enhance convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournamentV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.elite_preservation_rate = 0.1\n        self.learning_rate = 0.01\n        self.selection_pressure = 0.5  # New: initial selection pressure\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy):\n        self.success_history[strategy] += int(success)\n        if success:\n            self.strategy_probabilities[strategy] += self.learning_rate\n        else:\n            self.strategy_probabilities[strategy] -= self.learning_rate\n\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self):\n        tournament_size = int(np.ceil(self.selection_pressure * self.pop_size))\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx = min(participants, key=lambda idx: self.fitness[idx])\n        return best_idx\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection()\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedAdaptiveDETournamentV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06632 with standard deviation 0.00396.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.05893827891214587, 0.06589539414618861, 0.06548137259349218, 0.062455358511427916, 0.06994673502328408, 0.06951299190343752, 0.0632853793625382, 0.0709092477935892, 0.07047083661567677]}}
{"id": "ecc193d5-16a0-4023-9d16-8082710aa3fd", "fitness": 0.09238362205434768, "name": "EnhancedAdaptiveDETournament", "description": "Optimize adaptability by refining mutation strategy and incorporating diversity preservation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.population[b] - self.population[c])  # Changed: promote diversity by using b and c\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09238 with standard deviation 0.00362.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08694579516039769, 0.08879835378036471, 0.08695207502119118, 0.09307074100275137, 0.09533764008681711, 0.09323252157424833, 0.09486659192094804, 0.09709003593808341, 0.09515884400432728]}}
{"id": "6885f48d-ce51-45dc-a735-afcd8f920160", "fitness": 0.09281522400348659, "name": "EnhancedAdaptiveDEWithDiversityPreservation", "description": "Introduce fitness diversity preservation by implementing a weighted mutation strategy to enhance exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDEWithDiversityPreservation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_preservation_factor = 0.1  # New: factor for diversity preservation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            # Weighted mutation for diversity preservation\n            weight = np.random.uniform(0, self.diversity_preservation_factor)\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a]) \\\n                     + weight * (self.population[b] - self.population[c])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedAdaptiveDEWithDiversityPreservation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09282 with standard deviation 0.00351.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08745429107904723, 0.08832131046125236, 0.08859213468744354, 0.09378444833950605, 0.09481564384106544, 0.09395351765855242, 0.09550979497793721, 0.09793860263019505, 0.09496727235638003]}}
{"id": "2e723db5-2ccb-40ad-a577-05ee7463702a", "fitness": 0.09130566210582915, "name": "EnhancedAdaptiveDETournament", "description": "Improve convergence by integrating adaptive learning coefficients and incorporating a novel hybrid mutation strategy for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.03\n        self.dynamic_crossover_rate = 0.015\n        self.dynamic_mutation_adjustment = 0.02\n        self.elite_preservation_rate = 0.1\n        self.learning_coefficient = 0.1  # New: learning coefficient for adaptive adjustment\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a] + self.population[b] - self.population[c])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * 0.99 + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Adaptive adjustment with learning coefficient\n        self.crossover_probability += self.learning_coefficient * (success_rate - 0.5)\n        self.crossover_probability = np.clip(self.crossover_probability, 0.1, 1.0)\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] += self.learning_coefficient * (success_rate - 0.5)\n            self.mutation_factors[i] = np.clip(self.mutation_factors[i], 0.1, 2.0)\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09131 with standard deviation 0.00367.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.088265891464966, 0.08542101173940542, 0.08540569779673024, 0.09405815206645873, 0.09333708619229764, 0.09174409269751238, 0.09471559729452428, 0.0944941577356655, 0.09430927196490213]}}
{"id": "d1088595-14f9-4212-8090-3b65866ee68f", "fitness": 0.09316047055251035, "name": "EnhancedAdaptiveDETournament", "description": "Adjust mutation factors for improved exploration and diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.6, 0.7, 1.0]  # Changed: Adjusted the mutation factor\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))  # New: Compute success rate\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09316 with standard deviation 0.00361.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.0876996520618859, 0.08887008766030802, 0.08803318940235316, 0.09428874427993006, 0.09556215284257952, 0.09463352205441933, 0.09588781185414874, 0.09721092178714952, 0.09625815302981888]}}
{"id": "c09552eb-77e2-4807-bdc7-bc41a94ea67f", "fitness": 0.09296444196211513, "name": "EnhancedAdaptiveDEFeedback", "description": "Employ a feedback-driven dynamic mutation and crossover adaptation to further improve the convergence rate.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDEFeedback:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.03\n        self.dynamic_crossover_rate = 0.03\n        self.dynamic_mutation_adjustment = 0.02\n        self.elite_preservation_rate = 0.15\n        self.fitness_decay_rate = 0.98\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Feedback-driven adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedAdaptiveDEFeedback got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09296 with standard deviation 0.00382.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08696443946928889, 0.08946418409196899, 0.08738575538163562, 0.0933253460360477, 0.09620935048709178, 0.09389907168431544, 0.09605970087834081, 0.09787150278552048, 0.09550062684482652]}}
{"id": "908cf047-05a4-4be7-a156-16f147f5525d", "fitness": 0.09342222656811817, "name": "EnhancedAdaptiveDETournament", "description": "Introduce dynamic elite preservation based on success rate to enhance adaptability in the optimization process.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95  # Changed: increased from 0.9 to 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04  # Changed: decreased from 0.05 to 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99  # New: decay rate for fitness-based adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        \n        # Modify elite preservation based on success rate\n        dynamic_elite_preservation_rate = self.elite_preservation_rate * (self.best_fitness / (self.fitness[elite_idx] + 1e-9))\n        \n        if np.random.rand() < dynamic_elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))  # New: Compute success rate\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09342 with standard deviation 0.00360.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08844798485679817, 0.08887008766030802, 0.08803318940235316, 0.09505048987652542, 0.09556215284257952, 0.09463352205441933, 0.09673353760311154, 0.09721092178714952, 0.09625815302981888]}}
{"id": "d446b608-4bce-4437-ab24-d01e908fe0b2", "fitness": 0.09349076383862956, "name": "EnhancedAdaptiveDETournament", "description": "Improve convergence by incorporating adaptive scaling of mutation based on diversity and fitness improvements.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 55, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00381.", "error": "", "parent_ids": ["21f1828c-9694-463b-a316-c9c82c6d51a5"], "operator": null, "metadata": {"aucs": [0.08748948045527993, 0.08935512637011411, 0.08797576293256981, 0.09529459690227826, 0.09610625755184699, 0.09455178612183945, 0.09669909154414147, 0.09777061355815297, 0.096174159111443]}}
{"id": "b8ec0a08-fba7-4b87-a9cb-bf98689bf723", "fitness": 0.09349076383862956, "name": "DynamicAdaptiveDETournament", "description": "Introduce dynamic strategy adaptation based on population diversity and success history to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = np.array([0.33, 0.33, 0.34])\n        self.mutation_factors = np.array([0.5, 0.7, 1.0])\n        self.crossover_probability = 0.95\n        self.success_history = np.zeros(3)\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                p + adjustment_rate if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                p - adjustment_rate if idx == strategy else p + adjustment_rate\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = np.array(self.strategy_probabilities) / total\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 56, "feedback": "The algorithm DynamicAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00381.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08748948045527993, 0.08935512637011411, 0.08797576293256981, 0.09529459690227826, 0.09610625755184699, 0.09455178612183945, 0.09669909154414147, 0.09777061355815297, 0.096174159111443]}}
{"id": "5bb7d1f4-54be-44fa-b959-e6d38156e2b7", "fitness": 0.09349076383862956, "name": "EnhancedAdaptiveDETournament", "description": "Incorporate elitism in tournament selection to ensure the best solutions are preserved while adapting strategy probabilities for diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.15  # Changed from 0.1 to 0.15\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00381.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08748948045527993, 0.08935512637011411, 0.08797576293256981, 0.09529459690227826, 0.09610625755184699, 0.09455178612183945, 0.09669909154414147, 0.09777061355815297, 0.096174159111443]}}
{"id": "8801058f-52e5-41c7-9eff-c796f3e42199", "fitness": 0.09349076383862956, "name": "AdaptiveLearningDETournament", "description": "Introduce adaptive learning of crossover and mutation rates based on evolutionary success to enhance convergence speed and accuracy.", "code": "import numpy as np\n\nclass AdaptiveLearningDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 58, "feedback": "The algorithm AdaptiveLearningDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00381.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08748948045527993, 0.08935512637011411, 0.08797576293256981, 0.09529459690227826, 0.09610625755184699, 0.09455178612183945, 0.09669909154414147, 0.09777061355815297, 0.096174159111443]}}
{"id": "ef8c9306-0015-4939-a471-459ba0db2846", "fitness": 0.05698032158591163, "name": "EnhancedAdaptiveMultiStrategyDE", "description": "Enhance convergence by integrating adaptive multi-faceted mutation strategies and tournament selection with elite preservation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.4, 0.3, 0.3]\n        self.mutation_factors = [0.6, 0.8, 1.2]\n        self.crossover_probability = 0.9\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.03\n        self.dynamic_mutation_adjustment = 0.02\n        self.elite_preservation_rate = 0.15\n        self.fitness_decay_rate = 0.98\n        self.diversity_threshold = 0.2\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n    def tournament_selection(self, func):\n        tournament_size = 3 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedAdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05698 with standard deviation 0.00266.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.052949370548224906, 0.05352022808391732, 0.05725591225115967, 0.05606258689806054, 0.056664819390635834, 0.06068238675688231, 0.05679357769345028, 0.05740338292637348, 0.06149062972450037]}}
{"id": "44d6e7f7-2c47-4c6a-9fb4-21e6db00c6c0", "fitness": 0.09335571397706602, "name": "EnhancedAdaptiveDETournament", "description": "Enhance convergence by introducing a dynamic mutation factor scaling based on population diversity and fitness variance to maintain exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        fitness_variance = np.var(self.fitness)  # New: calculate fitness variance\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9)) * (1 + fitness_variance)  # Updated scaling factor\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09336 with standard deviation 0.00387.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08662953141576646, 0.08897323759090336, 0.08911139723017114, 0.0930371970956243, 0.09565696267940971, 0.09584951191830482, 0.09612810304984476, 0.0973049518203265, 0.09751053299324308]}}
{"id": "945aa9b7-5a31-4600-af1d-2a0334c119db", "fitness": 0.09349076383862956, "name": "EnhancedAdaptiveDETournament", "description": "Further enhance convergence by increasing the elite preservation rate adaptively based on diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        # Changed line: Increase elite preservation rate based on diversity\n        adaptive_elite_preservation_rate = self.elite_preservation_rate + 0.05 * (np.std(self.fitness) / (self.best_fitness + 1e-9))\n        if np.random.rand() < adaptive_elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00381.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08748948045527993, 0.08935512637011411, 0.08797576293256981, 0.09529459690227826, 0.09610625755184699, 0.09455178612183945, 0.09669909154414147, 0.09777061355815297, 0.096174159111443]}}
{"id": "3899c476-7184-42ca-a243-9c63d539f2e7", "fitness": 0.0932304389428781, "name": "EnhancedAdaptiveDETournament", "description": "Enhance adaptive mutation scaling by introducing a diversity-aware mutation factor for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        diversity_aware_factor = 1.0 + 0.5 * self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + diversity_aware_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09323 with standard deviation 0.00366.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08741557097740027, 0.08849575473197169, 0.08864023792281162, 0.09443733871552107, 0.09511537716153129, 0.09533206581340725, 0.0959120772509292, 0.09674424346774513, 0.09698128444458531]}}
{"id": "7282a68a-66d5-4249-a0ee-e58fa64a5555", "fitness": 0.09324223051747547, "name": "EnhancedAdaptiveDETournament", "description": "Enhance the mutation strategy by introducing diversity-based scaling in mutation factors for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        self.mutation_factors = [f * scaling_factor for f in self.mutation_factors]  # Change: update mutation factors\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09324 with standard deviation 0.00366.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08785307744673088, 0.0892733020772204, 0.08780524454954053, 0.09361813890412451, 0.09598474184380612, 0.09465174319272218, 0.09606290289067698, 0.09764630665029306, 0.09628461710216463]}}
{"id": "f8adcad4-fbb7-4a62-8081-254a48fefc80", "fitness": 0.09200233829451207, "name": "EnhancedAdaptiveDETournament", "description": "Enhanced convergence through diversity-informed adaptive mutation and hybrid selection mechanism.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.diversity_penalty = 0.2  # New: penalty for low diversity\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        if diversity < self.diversity_threshold:\n            scaling_factor *= self.diversity_penalty\n\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 3 + np.random.randint(3)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09200 with standard deviation 0.00355.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08711285973292393, 0.0869247804776695, 0.08749359848470362, 0.09264309085586409, 0.09332543184185382, 0.09403357355071129, 0.09594885725542046, 0.094896219203784, 0.09564263324767797]}}
{"id": "dfc78df9-4988-43a7-9b1b-6fd8dbdaac58", "fitness": 0.09297565799625063, "name": "EnhancedAdaptiveDETournamentV2", "description": "Introduce dynamic selection pressure and environment-driven mutation to enhance diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournamentV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.selection_pressure = 0.5  # New: dynamic selection pressure\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        # Environment-driven mutation\n        environment_factor = (self.fitness[target_idx] - self.best_fitness) / (self.best_fitness + 1e-9)\n        mutant = mutant + environment_factor * (np.random.rand(self.dim) - 0.5)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = int(4 + self.selection_pressure * np.random.randint(2))\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedAdaptiveDETournamentV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09298 with standard deviation 0.00366.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.0868898018268015, 0.08856644682719195, 0.08865182606096633, 0.09336082122946365, 0.09519939790939247, 0.09534023282495208, 0.09495179864350578, 0.0968322220216915, 0.09698837462229037]}}
{"id": "87812738-e99a-495c-ae55-8467e0a573f1", "fitness": 0.06716896931092313, "name": "EnhancedDynamicDiversityDE", "description": "Enhance convergence by introducing a novel dynamic diversity-based mutation and crossover probability adaptation technique.", "code": "import numpy as np\n\nclass EnhancedDynamicDiversityDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_weight = 0.5  # Adjusted: weight for diversity-based adjustments\n        self.diversity_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Dynamic diversity-based mutation scaling\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_weight * self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness and diversity-based adaptive mutation and crossover rate adjustments\n        diversity = np.std(self.population, axis=0).mean()\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate * (1 + self.diversity_weight * diversity)\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment * (1 + self.diversity_weight * diversity)\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedDynamicDiversityDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06717 with standard deviation 0.00405.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.06428303407710623, 0.06018857942621658, 0.06813148714471162, 0.06850234384850162, 0.06379725629674637, 0.07238982862671106, 0.06916067467247011, 0.06464907059030778, 0.07341844911553674]}}
{"id": "e162a61b-bb50-4b72-a084-19c659c9ae71", "fitness": 0.09320257820170798, "name": "EnhancedAdaptiveDETournamentV2", "description": "Enhance convergence and exploration by dynamically adjusting mutation strategies based on population diversity and fitness landscape ruggedness.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournamentV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.ruggedness_threshold = 0.05  # New: threshold for fitness landscape ruggedness\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        fitness_ruggedness = np.var(self.fitness) / (np.abs(np.mean(self.fitness)) + 1e-9)\n        \n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        ruggedness_factor = 1.0 + self.ruggedness_threshold * fitness_ruggedness\n\n        mutant = self.best_individual + scaling_factor * ruggedness_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedAdaptiveDETournamentV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09320 with standard deviation 0.00368.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.0874538041211369, 0.08921908328922923, 0.08811754844779562, 0.09445516582833324, 0.09551972973327927, 0.09360436749353296, 0.09613048631040944, 0.09697750664144666, 0.09734551195020846]}}
{"id": "b9a294ef-21dd-45c2-8c82-3546339c1e62", "fitness": 0.09349076383862956, "name": "EnhancedAdaptiveDETournament", "description": "Introduce dynamic adjustment of elite preservation rate based on current optimization performance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n        \n        # Dynamic elite preservation rate adjustment\n        self.elite_preservation_rate = min(0.5, self.elite_preservation_rate * (1 + 0.1 * success_rate))\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00381.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08748948045527993, 0.08935512637011411, 0.08797576293256981, 0.09529459690227826, 0.09610625755184699, 0.09455178612183945, 0.09669909154414147, 0.09777061355815297, 0.096174159111443]}}
{"id": "d547cebe-4d70-4dc8-8ddb-1765e0911874", "fitness": 0.08971698553700129, "name": "EnhancedAdaptiveDETournament", "description": "Enhance exploration by introducing a dynamic adjustment to crossover probability based on diversity and success rate.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n        # Introduce dynamic adjustment to crossover probability based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        self.crossover_probability = min(1.0, max(0.1, self.crossover_probability * (1.0 + 0.5 * diversity)))\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08972 with standard deviation 0.00384.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08470374829790484, 0.08604687387940846, 0.08341291008425078, 0.09288800286224508, 0.09200113977543667, 0.08942019624194131, 0.09454623803828865, 0.09353702754570026, 0.09089673310783553]}}
{"id": "d41ff900-2818-43bc-aae9-68b7aa1b10ea", "fitness": 0.09331743601733761, "name": "EnhancedAdaptiveDETournament", "description": "Integrate a dynamic learning rate for adaptive strategy probability adjustments based on historical performance to improve convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # Threshold for diversity-based mutation scaling\n        self.learning_rate = 0.1  # New: Dynamic learning rate for strategy adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        # Dynamic learning rate adjustment\n        dynamic_rate = self.learning_rate / (1 + np.sqrt(sum(self.success_history)))\n        \n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate * dynamic_rate, 1.0) if idx == strategy else max(p - adjustment_rate * dynamic_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate * dynamic_rate, 0.0) if idx == strategy else min(p + adjustment_rate * dynamic_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09332 with standard deviation 0.00371.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.0874062329588805, 0.08940447258334905, 0.08799842765445076, 0.09499356391682134, 0.09615590871988011, 0.09461051949704968, 0.09522889584973504, 0.0978201568934447, 0.09623874608242733]}}
{"id": "f2d3626f-3523-4277-ab1a-6a0f9e1c54c8", "fitness": 0.0705088782246334, "name": "EnhancedAdaptiveDETournament", "description": "Refine crossover strategy by incorporating dynamic scaling with diversity to enhance exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        diversity = np.std(self.population, axis=0).mean()\n        dynamic_crossover_probability = min(0.95, 0.5 + 0.5 * (diversity / (np.linalg.norm(self.best_individual) + 1e-9)))\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07051 with standard deviation 0.00312.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.07099761958911599, 0.0691175191881176, 0.06584158342949498, 0.06555462658825328, 0.07351373842544073, 0.06993165600891027, 0.07415393890006527, 0.07456451811653331, 0.07090470377576918]}}
{"id": "911d082b-ed71-4048-8c4e-124e570d6128", "fitness": 0.09345889093645647, "name": "EnhancedAdaptiveDETournament", "description": "Introducing elitism and diversity-based mutation scaling to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.15  # Modified: increased elite preservation rate\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.2  # Modified: increased threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09346 with standard deviation 0.00367.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08871067288285339, 0.08923889898878146, 0.08749197793668195, 0.09540525899455199, 0.09596363371922201, 0.09401932257082213, 0.09705495308320866, 0.09762070404506329, 0.09562459620692332]}}
{"id": "12d903ef-e6d6-453b-b910-b562d51cd37e", "fitness": -Infinity, "name": "EnhancedAdaptiveDELearning", "description": "Introduce a learning-based adaptive strategy, dynamically adjusting mutation and crossover rates based on historical performance to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDELearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = np.zeros(3)\n        self.adaptive_memory = np.zeros((3, 2))  # memory of [successes, trials] for each strategy\n        self.learning_rate = 0.1  # learning rate for adjusting strategy probabilities\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx, strategy):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self):\n        success_rates = self.adaptive_memory[:, 0] / (self.adaptive_memory[:, 1] + 1e-9)\n        total_success = np.sum(success_rates)\n        if total_success > 0:\n            new_probabilities = (1 - self.learning_rate) * self.strategy_probabilities + \\\n                                self.learning_rate * (success_rates / total_success)\n        else:\n            new_probabilities = self.strategy_probabilities\n\n        self.strategy_probabilities = new_probabilities / np.sum(new_probabilities)\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                mutant = self.mutate(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adaptive_memory[strategy, 0] += 1  # increase success count\n\n                self.adaptive_memory[strategy, 1] += 1  # increase trial count\n\n                if evaluations >= self.budget:\n                    break\n\n            self.adapt_strategy_probabilities()\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 73, "feedback": "An exception occurred: TypeError(\"can't multiply sequence by non-int of type 'float'\").", "error": "TypeError(\"can't multiply sequence by non-int of type 'float'\")", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {}}
{"id": "0714a730-b06c-4a4b-bac6-084e952165eb", "fitness": 0.08163481537399597, "name": "HierarchicalAdaptiveDETournament", "description": "Incorporate hierarchical strategy selection and dynamic population resizing to enhance convergence and adaptability in black box optimization.", "code": "import numpy as np\n\nclass HierarchicalAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.hierarchical_threshold = 0.05  # New: threshold for hierarchical strategy adaptation\n        self.population_size_growth = 2  # New: factor for increasing population size\n\n    def initialize_population(self):\n        self.pop_size = self.initial_pop_size\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def increase_population_if_needed(self):\n        if self.pop_size < 2 * self.initial_pop_size and np.std(self.fitness) < self.hierarchical_threshold * self.best_fitness:\n            additional_pop = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.initial_pop_size, self.dim))\n            additional_fitness = np.full(self.initial_pop_size, float('inf'))\n            self.population = np.vstack([self.population, additional_pop])\n            self.fitness = np.concatenate([self.fitness, additional_fitness])\n            self.pop_size += self.initial_pop_size\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        return elite_idx if np.random.rand() < self.elite_preservation_rate else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            self.increase_population_if_needed()\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 74, "feedback": "The algorithm HierarchicalAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08163 with standard deviation 0.00742.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.06898190937652582, 0.08629378960377532, 0.072861282621272, 0.08461540064730977, 0.09156728626683708, 0.0776369171092387, 0.08212319439312854, 0.09184913312184262, 0.0787844252260339]}}
{"id": "a5b98678-d748-43ff-8369-9ceebb7f0529", "fitness": 0.09216071043823247, "name": "EnhancedAdaptiveDETournamentV2", "description": "Enhance convergence by dynamically adapting crossover and mutation rates based on population diversity and fitness trends.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournamentV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05  # Increased adaptation rate\n        self.dynamic_crossover_rate = 0.03  # More aggressive crossover adjustment\n        self.dynamic_mutation_adjustment = 0.02\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.98  # More aggressive decay\n        self.diversity_threshold = 0.05  # Adjusted diversity threshold for mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedAdaptiveDETournamentV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09216 with standard deviation 0.00394.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08636575425434023, 0.08907376929670185, 0.08581958522100841, 0.09402339258238679, 0.09576193898858776, 0.0920593354345135, 0.0953276001707215, 0.097408811991748, 0.0936062060040842]}}
{"id": "a934cf19-fd0c-407f-bad3-7f8cba9a623d", "fitness": 0.09323706495040024, "name": "EnhancedAdaptiveDETournament", "description": "Refine mutation strategy by integrating diversity scaling directly into the mutation factors for improved adaptability.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n\n        if strategy == 0:\n            mutant = self.population[a] + scaling_factor * self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + scaling_factor * self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + scaling_factor * self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09324 with standard deviation 0.00363.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.0881297637631353, 0.08835719416536858, 0.08839633292685778, 0.09372338829985138, 0.09494466954031067, 0.09531861010046971, 0.09629508795055297, 0.09652701371687455, 0.09744152409018125]}}
{"id": "1908f69a-b005-479a-ac34-e45267491c1b", "fitness": 0.09345889093645647, "name": "EnhancedAdaptiveDETournament", "description": "Refine mutation strategy by enhancing diversity impact and improving mutation scaling factor.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on enhanced diversity impact\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + 2 * self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09346 with standard deviation 0.00367.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08871067288285339, 0.08923889898878146, 0.08749197793668195, 0.09540525899455199, 0.09596363371922201, 0.09401932257082213, 0.09705495308320866, 0.09762070404506329, 0.09562459620692332]}}
{"id": "60189b61-9485-46b7-886c-52bb264fe231", "fitness": 0.09349076383862956, "name": "EnhancedAdaptiveDETournament", "description": "Enhance adaptability by dynamically adjusting the elite preservation rate based on population fitness variance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n        \n        # Dynamic adjustment of elite preservation rate\n        fitness_variance = np.var(self.fitness)\n        self.elite_preservation_rate = 0.1 + 0.5 * (1 - np.exp(-fitness_variance))\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00381.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08748948045527993, 0.08935512637011411, 0.08797576293256981, 0.09529459690227826, 0.09610625755184699, 0.09455178612183945, 0.09669909154414147, 0.09777061355815297, 0.096174159111443]}}
{"id": "f1cf8d7a-01f8-401f-8fb8-26e56846c05b", "fitness": -Infinity, "name": "EnhancedAdaptiveDETournament", "description": "Enhance strategy adaptation by dynamically adjusting elite preservation rate based on diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n        # New: Dynamically adjust elite preservation rate based on diversity\n        self.elite_preservation_rate = 0.1 + 0.1 * (diversity / (self.pop_size + 1e-9))\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 79, "feedback": "An exception occurred: NameError(\"name 'diversity' is not defined\").", "error": "NameError(\"name 'diversity' is not defined\")", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {}}
{"id": "d4575bd4-9c0f-4b71-8aa3-a6c0fed2649b", "fitness": 0.07831532065498965, "name": "EnhancedAdaptiveDEDualMutation", "description": "Introduce dynamic parameter tuning using individual success rates and introduce dual mutation strategies to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDEDualMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_success = [0, 0, 0]\n        self.strategy_usage = [0, 0, 0]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.dynamic_adjustment_rate = 0.04\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx, strategy):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, strategy, success):\n        self.strategy_success[strategy] = self.strategy_success[strategy] * self.fitness_decay_rate + success\n        self.strategy_usage[strategy] += 1\n\n        for i in range(len(self.mutation_factors)):\n            success_rate = (self.strategy_success[i] / (self.strategy_usage[i] + 1e-9))\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * 0.5\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * 0.5\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                strategy = np.random.choice([0, 1, 2])\n                mutant = self.mutate(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success = trial_fitness < self.fitness[i]\n                if success:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n\n                self.adapt_parameters(strategy, success)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedAdaptiveDEDualMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07832 with standard deviation 0.00320.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.07571841119737943, 0.07585073516806728, 0.07228897581057514, 0.0807455042811257, 0.08095179100103367, 0.07700532015147066, 0.08195614341366275, 0.08218346503843221, 0.07813753983316007]}}
{"id": "4180da1a-5d8f-41ba-b07d-7ccb09a090ca", "fitness": 0.0780975600168542, "name": "EnhancedAdaptiveDETournament", "description": "Enhance exploration by dynamically adjusting mutation factors based on diversity and current fitness.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1  # New: threshold for diversity-based mutation scaling\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        # Dynamically adjust mutation factor based on diversity and fitness\n        self.mutation_factors = [mf * (1 + 0.1 * (diversity / (np.abs(self.best_fitness) + 1e-9))) for mf in self.mutation_factors]\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07810 with standard deviation 0.00541.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08259195018977805, 0.07468920292963555, 0.06660440046560001, 0.08351355122502879, 0.08120756350166813, 0.08442234361003742, 0.07950844996768103, 0.07603109279314746, 0.07430948546911131]}}
{"id": "f38177bc-be40-474b-ad81-5683ad6312d6", "fitness": 0.09349076383862956, "name": "EnhancedAdaptiveDETournament", "description": "Introduce a diversity-controlled adaptive learning mechanism to enhance mutation scaling and crossover strategies based on population diversity and fitness dynamics.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n\n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00381.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08748948045527993, 0.08935512637011411, 0.08797576293256981, 0.09529459690227826, 0.09610625755184699, 0.09455178612183945, 0.09669909154414147, 0.09777061355815297, 0.096174159111443]}}
{"id": "9f9cc692-1c7f-4ef5-a2a4-923400c4c1e4", "fitness": 0.09326886680249163, "name": "RefinedAdaptiveDEEliteSelection", "description": "Leverage dynamic diversity-driven adaptation and elite-centric strategies for improved exploration-exploitation balance in optimization.", "code": "import numpy as np\n\nclass RefinedAdaptiveDEEliteSelection:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.2  # Increased elite preservation for balance\n        self.fitness_decay_rate = 0.98      # Slightly adjusted decay rate for faster adaptation\n        self.diversity_threshold = 0.05     # Reduced threshold for more sensitive diversity adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        # Adaptive mutation scaling based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        # Fitness-based adaptive mutation and crossover rate adjustments\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 83, "feedback": "The algorithm RefinedAdaptiveDEEliteSelection got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09327 with standard deviation 0.00366.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08741557097740027, 0.0885931318091806, 0.08864023792281162, 0.09445721588546563, 0.09522766180802511, 0.09533206581340725, 0.0959120772509292, 0.09686055531061966, 0.09698128444458531]}}
{"id": "2c0a65c4-d48f-4e7c-b258-f02472665358", "fitness": 0.09248811606440413, "name": "EnhancedDynamicDETournament", "description": "Enhance convergence by integrating an adaptive learning rate based on population diversity and a dynamic strategy selection mechanism.", "code": "import numpy as np\n\nclass EnhancedDynamicDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.learning_rate = 0.1  # New: adaptive learning rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n\n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n\n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        # Apply adaptive learning rate\n        learning_adjustment = self.learning_rate * (diversity / (np.linalg.norm(mutant) + 1e-9))\n        mutant += learning_adjustment * (self.best_individual - mutant)\n\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        if success:\n            self.strategy_probabilities = [\n                min(p + adjustment_rate, 1.0) if idx == strategy else max(p - adjustment_rate, 0.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        else:\n            self.strategy_probabilities = [\n                max(p - adjustment_rate, 0.0) if idx == strategy else min(p + adjustment_rate, 1.0)\n                for idx, p in enumerate(self.strategy_probabilities)\n            ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n\n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedDynamicDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09249 with standard deviation 0.00349.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08773958303048068, 0.08809887788500637, 0.08714977892292719, 0.09431224930949766, 0.0946723298032115, 0.0936295833905827, 0.0952791680223758, 0.09628924587949306, 0.0952222283360622]}}
{"id": "0fd8d642-59c0-45b0-a71b-3dca024089f8", "fitness": 0.09349344500269983, "name": "EnhancedAdaptiveDETournament", "description": "Enhance convergence and adaptability by integrating dynamic feedback loops that adjust mutation, crossover rates, and selection pressure based on historical performance metrics.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1  # Feedback scaling for dynamic adjustment\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00384.", "error": "", "parent_ids": ["d446b608-4bce-4437-ab24-d01e908fe0b2"], "operator": null, "metadata": {"aucs": [0.08742887021731982, 0.08918089742187651, 0.08807857394960172, 0.09529734445377791, 0.09602788334943668, 0.09455540152519137, 0.09700465592421359, 0.0976894074291681, 0.09617797075371282]}}
{"id": "f1f4e322-d01f-4bbf-9a5d-5e45ed8da67d", "fitness": 0.09297789218186643, "name": "EnhancedAdaptiveDETournamentRefined", "description": "Incorporate adaptive diversity control and multi-strategy exploration to dynamically balance convergence and exploration, enhancing performance on diverse black-box optimization problems.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournamentRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1\n        self.diversity_control_factor = 0.05\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_control_factor * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedAdaptiveDETournamentRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09298 with standard deviation 0.00398.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.08552688844130318, 0.08887297021024132, 0.08860887628254033, 0.09344566177663982, 0.09554942738270122, 0.09500737388476221, 0.09595022332324055, 0.09719420568234627, 0.09664540265302302]}}
{"id": "6f8c1fd8-71aa-44c6-a0e6-7b9335cf5742", "fitness": -Infinity, "name": "EnhancedAdaptiveDETournament", "description": "Improve convergence by enhancing feedback scaling and reducing decay rate for better stability in strategy adaptation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.995  # Original: 0.99, slightly decreased decay rate\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.15  # Original: 0.1, increased for better feedback\n \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 87, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {}}
{"id": "7820036f-5ef2-48d4-b4a3-d42a917ac12e", "fitness": 0.09311071562575433, "name": "EnhancedAdaptiveDETournament", "description": "Introduce a strategy probability adjustment factor to optimize exploration and exploitation trade-off dynamically.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1  # Feedback scaling for dynamic adjustment\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5) + 0.02  # Added adjustment factor\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09311 with standard deviation 0.00364.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.08746586890135322, 0.08919053662635279, 0.08799300972836732, 0.09363123153089792, 0.09601316770200019, 0.09460426200844929, 0.09519191475406574, 0.09767418805637818, 0.09623226132392437]}}
{"id": "fb4ae653-1e57-4d72-b21b-97ca2e0d724b", "fitness": -Infinity, "name": "EnhancedAdaptiveDETournament", "description": "Enhance diversity and adaptive control by slightly increasing the mutation factor adjustment rate and lowering the feedback scaling factor.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.02  # Increased mutation adjustment rate\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.05  # Reduced feedback scaling for dynamic adjustment\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 89, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {}}
{"id": "e58537ce-e01b-41c5-ae96-23cddd5db603", "fitness": 0.09336313313323327, "name": "EnhancedAdaptiveDETournament", "description": "Refine adaptive mechanisms by incorporating momentum-based adjustments in strategy probabilities and integrating a diversity preservation component to optimize convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1  \n        self.momentum_factor = 0.9  # Added for momentum in adjustment\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n\n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.momentum_factor * self.success_history[strategy] + (1 - self.momentum_factor) * success  # Updated adaptation\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09336 with standard deviation 0.00367.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.08747921023179639, 0.08936123027330412, 0.0881341086494799, 0.09529734445377791, 0.09592184023171169, 0.09475290843689843, 0.09535942585013035, 0.09757956308184568, 0.09638256699015502]}}
{"id": "e1226590-f00f-4283-986d-ec7d1a5c92da", "fitness": 0.09349344500269983, "name": "EnhancedAdaptiveDETournament", "description": "Introduce an adaptive elite preservation mechanism based on fitness improvement to enhance global exploration.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        improvement_factor = np.exp(-self.fitness[elite_idx] + self.best_fitness) # Change 1\n        if np.random.rand() < self.elite_preservation_rate * improvement_factor: # Change 2\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00384.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.08742887021731982, 0.08918089742187651, 0.08807857394960172, 0.09529734445377791, 0.09602788334943668, 0.09455540152519137, 0.09700465592421359, 0.0976894074291681, 0.09617797075371282]}}
{"id": "7b98c963-1902-4da4-9a30-35d35f057f17", "fitness": 0.09349344500269983, "name": "EnhancedAdaptiveDETournament", "description": "Refine strategy by dynamically tuning the elite preservation rate based on historical success to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1  # Feedback scaling for dynamic adjustment\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n        \n        self.elite_preservation_rate = 0.1 * (1 + success_rate * 0.5)\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09349 with standard deviation 0.00384.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.08742887021731982, 0.08918089742187651, 0.08807857394960172, 0.09529734445377791, 0.09602788334943668, 0.09455540152519137, 0.09700465592421359, 0.0976894074291681, 0.09617797075371282]}}
{"id": "9fe6a660-2274-48e0-9d85-fe38693fe31b", "fitness": 0.093089835334226, "name": "RefinedAdaptiveDE", "description": "Introduce adaptive population sizing and dynamic crossover strategies to enhance convergence and exploration-exploitation balance in differential evolution.", "code": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1\n        self.adaptive_pop_scaling = 0.5  # New: Adaptive population scaling factor\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        diversity = np.std(self.population, axis=0).mean()\n        adaptive_crossover_prob = self.crossover_probability * (1 + self.adaptive_pop_scaling * (diversity / (np.linalg.norm(self.best_individual) + 1e-9)))\n        cross_points = np.random.rand(self.dim) < adaptive_crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 93, "feedback": "The algorithm RefinedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09309 with standard deviation 0.00345.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.08834242297864936, 0.08933294769461742, 0.08796810701567426, 0.09306317928366536, 0.09602788334943668, 0.09456147889883426, 0.09463882381687161, 0.0976894074291681, 0.09618426754111697]}}
{"id": "2448eef9-fc26-4191-bce7-687036ff5bee", "fitness": 0.09333380441300392, "name": "EnhancedAdaptiveDETournament", "description": "Improve exploration-exploitation balance by adjusting diversity threshold and strategy probabilities based on success rate feedback.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.15  # Adjusted from 0.1\n        self.feedback_scaling = 0.1  # Feedback scaling for dynamic adjustment\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09333 with standard deviation 0.00359.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.08794955992241626, 0.08866391884272595, 0.088499771129115, 0.09488273207093423, 0.09531047913324242, 0.09516907100200678, 0.09542131056374659, 0.097245477707121, 0.09686191934572697]}}
{"id": "ef340b9d-ef4c-4f40-a570-a83ed8fb5c79", "fitness": 0.09299028628037304, "name": "EnhancedDynamicScalingDETournament", "description": "Introduce dynamic scaling factor adjustments based on population diversity and elite perturbation to enhance exploration and exploitation balance in Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDynamicScalingDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        if np.random.rand() < 0.5:  # Introduce perturbation with a small probability\n            perturbation = np.random.randn(self.dim) * 0.01\n            mutant += perturbation\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedDynamicScalingDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09299 with standard deviation 0.00360.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.08743829117454516, 0.08828050257511966, 0.0883529758973366, 0.0940633815800268, 0.09487071349179255, 0.09501366005143996, 0.09575506518930388, 0.09649197639339901, 0.09664601017039365]}}
{"id": "75666c6a-6334-481f-8b4e-63423b80d2b6", "fitness": -Infinity, "name": "EnhancedAdaptiveDETournament", "description": "Enhance adaptability and convergence by incorporating selective crossover probability adjustment based on diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1  # Feedback scaling for dynamic adjustment\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        # Adjust crossover probability based on diversity\n        diversity = np.std(self.population, axis=0).mean()\n        self.crossover_probability = 0.95 * (1.0 - min(0.5, diversity / 10.0))\n        \n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 96, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {}}
{"id": "de10a052-f6a5-4058-8b08-8a177cc35e14", "fitness": -Infinity, "name": "EnhancedAdaptiveDETournament", "description": "Enhance convergence by adjusting the dynamic mutation adjustment rate and elite preservation strategy to improve adaptability under constrained change budget.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.02  # Adjusted mutation adjustment rate\n        self.elite_preservation_rate = 0.15  # Increased elite preservation rate\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.12  # Increased feedback scaling for dynamic adjustment\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 97, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {}}
{"id": "36f4ee6c-2b66-49f7-b4f1-7e72da437274", "fitness": 0.09209688367958407, "name": "EnhancedAdaptiveDETournament", "description": "Improve algorithm exploration by dynamically adjusting tournament size and introducing adaptive mutation scaling based on fitness variance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDETournament:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.04\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.fitness_decay_rate = 0.99\n        self.diversity_threshold = 0.1\n        self.feedback_scaling = 0.1\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.diversity_threshold * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        fitness_variance = np.var(self.fitness)\n        scaling_factor *= 1 + 0.5 * fitness_variance  # Adaptive mutation scaling\n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * self.fitness_decay_rate + success\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n        \n        feedback = self.feedback_scaling * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * success_rate + (1 - success_rate) * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * success_rate + (1 - success_rate) * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        average_fitness = np.mean(self.fitness)\n        tournament_size = 4 + int(2 * (1 - (self.best_fitness / (average_fitness + 1e-9))))  # Dynamic tournament size\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedAdaptiveDETournament got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09210 with standard deviation 0.00353.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.08656670644729836, 0.0877069999822242, 0.08743475994551508, 0.09305300652096993, 0.09422006776228498, 0.09391735085896868, 0.0946340236867288, 0.09582076335103573, 0.09551827456123085]}}
{"id": "a38d2f8d-d9fc-477e-a0b0-19c5b55f666c", "fitness": 0.05126477972698884, "name": "EnhancedAdaptiveDEStochastic", "description": "Improve the convergence and diversity management by incorporating adaptive learning rates and stochastic gradient information to adjust mutation and crossover parameters dynamically.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDEStochastic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n        self.bounds = None\n        self.strategy_probabilities = [0.33, 0.33, 0.34]\n        self.mutation_factors = [0.5, 0.7, 1.0]\n        self.crossover_probability = 0.95\n        self.success_history = [0, 0, 0]\n        self.dynamic_adjustment_rate = 0.05\n        self.dynamic_crossover_rate = 0.02\n        self.dynamic_mutation_adjustment = 0.01\n        self.elite_preservation_rate = 0.1\n        self.learning_rate = 0.1\n        self.smoothing_factor = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.bounds.lb, self.bounds.ub, (self.pop_size, self.dim)\n        )\n        self.fitness = np.full(self.pop_size, float('inf'))\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == float('inf'):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_individual = self.population[i].copy()\n                    \n    def mutate(self, target_idx):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n        \n        if strategy == 0:\n            mutant = self.population[a] + self.mutation_factors[0] * (self.population[b] - self.population[c])\n        elif strategy == 1:\n            mutant = self.best_individual + self.mutation_factors[1] * (self.population[b] - self.population[c])\n        else:\n            mutant = self.population[a] + self.mutation_factors[2] * (self.best_individual - self.population[a])\n        \n        diversity = np.std(self.population, axis=0).mean()\n        scaling_factor = 1.0 + self.smoothing_factor * (diversity / (np.linalg.norm(self.best_individual) + 1e-9))\n        mutant = self.best_individual + scaling_factor * (mutant - self.best_individual)\n        \n        mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n        return mutant\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def adapt_strategy_probabilities(self, success, strategy, success_rate):\n        self.success_history[strategy] = self.success_history[strategy] * (1 - self.learning_rate) + success * self.learning_rate\n        adjustment_rate = self.dynamic_adjustment_rate * (1 - (success_rate / (sum(self.success_history) + 1)))\n\n        feedback = self.learning_rate * (success_rate - 0.5)\n        self.strategy_probabilities = [\n            min(p + adjustment_rate + feedback, 1.0) if idx == strategy else max(p - adjustment_rate - feedback, 0.0)\n            for idx, p in enumerate(self.strategy_probabilities)\n        ]\n        \n        total = sum(self.strategy_probabilities)\n        self.strategy_probabilities = [p / total for p in self.strategy_probabilities]\n        \n        self.crossover_probability = self.crossover_probability * (1 - success_rate) + success_rate * self.dynamic_crossover_rate\n        for i in range(len(self.mutation_factors)):\n            self.mutation_factors[i] = self.mutation_factors[i] * (1 - success_rate) + success_rate * self.dynamic_mutation_adjustment\n\n    def tournament_selection(self, func):\n        tournament_size = 4 + np.random.randint(2)\n        elite_idx = np.argmin(self.fitness)\n        participants = np.random.choice(self.pop_size, tournament_size, replace=False)\n        best_idx_among_participants = min(participants, key=lambda idx: self.fitness[idx])\n        if np.random.rand() < self.elite_preservation_rate:\n            return elite_idx\n        else:\n            return elite_idx if self.fitness[elite_idx] < self.fitness[best_idx_among_participants] else best_idx_among_participants\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.initialize_population()\n        self.evaluate_population(func)\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for _ in range(self.pop_size):\n                i = self.tournament_selection(func)\n                mutant = self.mutate(i)\n                strategy = np.random.choice([0, 1, 2], p=self.strategy_probabilities)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                success_rate = 1.0 - (trial_fitness / (self.best_fitness + 1e-9))\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_individual = trial.copy()\n                    self.adapt_strategy_probabilities(True, strategy, success_rate)\n                else:\n                    self.adapt_strategy_probabilities(False, strategy, success_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedAdaptiveDEStochastic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05126 with standard deviation 0.00360.", "error": "", "parent_ids": ["0fd8d642-59c0-45b0-a71b-3dca024089f8"], "operator": null, "metadata": {"aucs": [0.047010047280664935, 0.05352022808391732, 0.046818380167382045, 0.049770842233598844, 0.056664819390635834, 0.049568174365564044, 0.05041623692461761, 0.05740338292637348, 0.05021090617014545]}}
