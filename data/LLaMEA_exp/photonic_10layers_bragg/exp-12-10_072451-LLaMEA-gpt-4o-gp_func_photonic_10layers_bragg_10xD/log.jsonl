{"id": "e85746c8-511c-412c-b876-42faa72d325d", "fitness": -Infinity, "name": "HybridPSO_DE", "description": "A novel hybrid metaheuristic algorithm combining particle swarm optimization (PSO) and differential evolution (DE) for adaptive exploration and exploitation in continuous search spaces.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub-lb), high=abs(ub-lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 0, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 130, in evaluate_gp_func\n    algorithm(problem)\n  File \"<string>\", line 76, in __call__\n  File \"<string>\", line 34, in update_personal_best\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 130, in evaluate_gp_func\n    algorithm(problem)\n  File \"<string>\", line 76, in __call__\n  File \"<string>\", line 34, in update_personal_best\nNameError: name 'func' is not defined\n", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "c6db6719-36e8-4209-9c27-74de98ba666e", "fitness": -Infinity, "name": "HybridPSO_DE", "description": "Enhanced the Hybrid PSO-DE algorithm by fixing the function call error and ensuring accurate personal best updates with the correct fitness evaluation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub-lb), high=abs(ub-lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):  # Added func parameter\n        for i in range(self.population_size):\n            current_fitness = func(self.best_positions[i])  # Evaluate fitness\n            if fitness[i] < current_fitness:  # Compare with current fitness\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)  # Pass func to update_personal_best\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)  # Pass func to update_personal_best\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 1, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["e85746c8-511c-412c-b876-42faa72d325d"], "operator": null, "metadata": {}}
{"id": "e9cf1285-5680-4d6e-983f-f2a725a2262b", "fitness": -Infinity, "name": "HybridPSO_DE", "description": "A hybrid algorithm that combines PSO and DE with a correction to properly update personal best positions.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub-lb), high=abs(ub-lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 2, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["e85746c8-511c-412c-b876-42faa72d325d"], "operator": null, "metadata": {}}
{"id": "77ea44f5-00ad-4996-b7b6-b18f49d45949", "fitness": -Infinity, "name": "HybridPSO_DE", "description": "An improved version of HybridPSO_DE that corrects the function scope issue in the personal best update method.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub-lb), high=abs(ub-lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):  # Added func as a parameter\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 3, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["e85746c8-511c-412c-b876-42faa72d325d"], "operator": null, "metadata": {}}
{"id": "4d2779b2-4e55-40f3-b194-bfc37bcf91b2", "fitness": -Infinity, "name": "HybridPSO_DE", "description": "A refined hybrid metaheuristic algorithm combining particle swarm optimization (PSO) and differential evolution (DE) with a corrected personal best update to enhance adaptive exploration and exploitation in continuous search spaces.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub-lb), high=abs(ub-lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):  # Change made here by adding func as parameter\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 4, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["e85746c8-511c-412c-b876-42faa72d325d"], "operator": null, "metadata": {}}
{"id": "1be68f31-3e01-4c94-b2cb-55a2834a5c8c", "fitness": -Infinity, "name": "RefinedHybridPSO_DE", "description": "A refined hybrid metaheuristic algorithm integrating particle swarm optimization (PSO) and differential evolution (DE) with enhanced personal best update for effective exploration and exploitation in continuous spaces.", "code": "import numpy as np\n\nclass RefinedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.best_fitness = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub-lb), high=abs(ub-lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.best_fitness = np.full(self.population_size, float('inf'))\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < self.best_fitness[i]:\n                self.best_fitness[i] = fitness[i]\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 5, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["e85746c8-511c-412c-b876-42faa72d325d"], "operator": null, "metadata": {}}
{"id": "a0ba9cba-e515-4ebd-8c45-dd97cac7fa92", "fitness": -Infinity, "name": "HybridPSO_DE", "description": "A refined hybrid metaheuristic algorithm combining PSO and DE with correct scoping for adaptive exploration and exploitation in continuous search spaces.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub-lb), high=abs(ub-lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):  # Added func as a parameter\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 6, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["e85746c8-511c-412c-b876-42faa72d325d"], "operator": null, "metadata": {}}
{"id": "cca1e94b-8b2e-4d72-8e47-4a519602d86e", "fitness": -Infinity, "name": "HybridPSO_DE", "description": "A refined hybrid metaheuristic algorithm combining PSO and DE for enhanced exploration and exploitation in continuous search spaces.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub-lb), high=abs(ub-lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 7, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["e85746c8-511c-412c-b876-42faa72d325d"], "operator": null, "metadata": {}}
{"id": "8db3f239-fab4-4eca-8c91-d8cac45eef97", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Hybridization of Particle Swarm Optimization and Differential Evolution with enhanced error handling for adaptive exploration and exploitation in continuous search spaces.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["e85746c8-511c-412c-b876-42faa72d325d"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "68c16f32-485b-4cab-ac60-f4f2701242eb", "fitness": 0.05446272622582239, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with dynamic parameter adaptation and archive-based learning for improved convergence in complex search spaces.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_inertia = 0.9\n        self.final_inertia = 0.4\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.archive = []\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n            self.archive.append(self.global_best_position.copy())\n\n    def dynamic_inertia_weight(self):\n        return self.final_inertia + (self.base_inertia - self.final_inertia) * ((self.budget - self.eval_count) / self.budget)\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        inertia_weight = self.dynamic_inertia_weight()\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def archive_learning(self, func):\n        if len(self.archive) > 0:\n            best_from_archive = min(self.archive, key=func)\n            archive_fitness = func(best_from_archive)\n            if archive_fitness < self.global_best_fitness:\n                self.global_best_position = best_from_archive\n                self.global_best_fitness = archive_fitness\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n            self.archive_learning(func)\n\n        return self.global_best_position", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "0aa9bc72-edf9-4800-9954-3c0824305d9d", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Improved HybridPSO_DE with adaptive parameter adjustment for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def adjust_parameters(self):\n        if self.eval_count < self.budget / 2:\n            self.inertia_weight = 0.9  # More exploration\n        else:\n            self.inertia_weight = 0.4  # More exploitation\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.adjust_parameters()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "4a15697d-7bec-4189-b19f-b1fd12bc5637", "fitness": 0.05446272622582239, "name": "EnhancedHybridPSO_DE", "description": "Introduce a self-adaptive mechanism for inertia weight and crossover probability to enhance the balance between exploration and exploitation in the Hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.CR_min = 0.1\n        self.CR_max = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def update_adaptive_parameters(self):\n        # Update inertia weight based on progress\n        progress = self.eval_count / self.budget\n        self.inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * progress\n        # Update crossover probability adaptively\n        self.CR = self.CR_max - (self.CR_max - self.CR_min) * progress\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_adaptive_parameters()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "6c887d25-1fd5-42b1-ad84-e7d0cec6f94d", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Improved Hybrid PSO and DE algorithm with adaptive parameters and velocity damping for enhanced convergence. ", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Increased inertia for better exploration\n        self.c1 = 1.5\n        self.c2 = 2.0  # Increased social component for better convergence\n        self.F = 0.9  # Adjusted DE scaling factor for diversity\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.velocities *= 0.9  # Velocity damping to control exploration\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 12, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "56cf2885-3006-4116-baa4-33d0fdfe2c78", "fitness": 0.05446272622582239, "name": "AdaptiveSwarmDifferentialEvolution", "description": "Adaptive Swarm Differential Evolution (ASDE): Enhances HybridPSO_DE by introducing adaptive parameters and constraining velocity updates for robust convergence across diverse optimization landscapes.", "code": "import numpy as np\n\nclass AdaptiveSwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # start with higher inertia weight\n        self.c1 = 2.0  # cognitive scaling factor\n        self.c2 = 2.0  # social scaling factor\n        self.F = 0.5  # reduced Differential evolution scaling factor\n        self.CR = 0.8  # slightly reduced Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.velocity_clamp = 0.1  # clamp velocity updates\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Adaptive inertia weight reduction\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 13, "feedback": "The algorithm AdaptiveSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "10e10b23-ead1-4e48-850d-ccd5fc7e015e", "fitness": -Infinity, "name": "EnhancedHybridPSO_DE", "description": "Enhancing convergence through adaptive velocity adjustment and dynamic crossover schemes in a hybrid PSO-DE framework.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        adaptive_inertia = self.global_best_fitness / (np.abs(fitness - self.global_best_fitness) + 1e-9)\n        self.velocities *= adaptive_inertia[:, np.newaxis]\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def adaptive_differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = np.arange(self.population_size)\n            indices = indices[indices != i]\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover_rate = self.CR * (0.5 + np.random.rand() / 2)\n            crossover = np.random.rand(self.dim) < crossover_rate\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.adaptive_differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 14, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {}}
{"id": "3d71bb71-0c8a-497f-abe7-42351db2f225", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Introducing dynamic adjustment to inertia weight for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Change 1: Introduce dynamic inertia weight adjustment\n        self.inertia_weight = 0.4 + 0.5 * (self.budget - self.eval_count) / self.budget\n\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 15, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "a1f6b574-e714-44b1-ae95-d0c006a2be42", "fitness": 0.05446272622582239, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Adaptive Hybrid PSO-DE with dynamic parameter adaptation and diversity preservation for robust exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F = 0.5  # Differential evolution scaling factor\n        self.CR = 0.7  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def adapt_parameters(self):\n        # Adaptive parameter tuning based on iteration\n        self.inertia_weight = 0.9 - self.eval_count / self.budget * (0.9 - 0.4)\n        self.F = 0.5 + 0.3 * np.sin(np.pi * self.eval_count / self.budget)\n        self.CR = 0.7 + 0.2 * np.cos(2 * np.pi * self.eval_count / self.budget)\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.adapt_parameters()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "1a54377c-2786-49ea-9b09-4e19384a56fc", "fitness": 0.05446272622582239, "name": "AdvancedHybridPSO_DE", "description": "Advanced Adaptive Hybrid PSO-DE with dynamic parameter tuning and elite solution preservation to enhance convergence speed and solution quality in diverse optimization landscapes.", "code": "import numpy as np\n\nclass AdvancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_weight_decay = 0.99\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.elite_rate = 0.1\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n        self.inertia_weight *= self.inertia_weight_decay  # Decaying inertia\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        elite_size = int(self.elite_rate * self.population_size)\n        elite_indices = np.argsort(fitness)[:elite_size]\n        non_elite_indices = np.argsort(fitness)[elite_size:]\n\n        for i in non_elite_indices:\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n\n        for i in elite_indices:  # Preserve elites\n            new_population[i] = self.population[i]\n\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 17, "feedback": "The algorithm AdvancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "3949fe67-4b10-49a0-9030-69873dd8cd65", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced exploration-exploitation balance with adaptive parameters in a hybrid PSO-DE framework.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7 # Changed from 0.5 to 0.7 for increased exploration\n        self.c1 = 2.0 # Changed from 1.5 to 2.0 for more aggressive cognitive component\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 18, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "1ed545ca-e1c2-4ed1-afa7-8935fc6d2f75", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Refinement of HybridPSO_DE by dynamically adjusting inertia weight and introducing elitism for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Adjusted to start high for exploration\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Dynamic adjustment\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        fittest_index = np.argmin(fitness)  # Elitism addition\n        new_population[fittest_index] = self.global_best_position  # Preserve the best solution\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 19, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "3bba3eb1-8960-42dc-8bcb-6df0c7eabc88", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Incorporate an adaptive inertia weight strategy for improved convergence speed and accuracy in the hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Starting value for adaptive inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.inertia_weight = 0.4 + 0.5 * (self.budget - self.eval_count) / self.budget  # Adaptive inertia weight\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 20, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "18217af7-7489-40ac-837c-e8c68b277bf5", "fitness": 0.05446272622582239, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Inertia and Dynamic Crossover for improved search space exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Start with higher inertia\n        self.inertia_weight_min = 0.4\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.initial_budget = budget\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_inertia_weight(self):\n        # Linearly decrease inertia weight\n        self.inertia_weight = self.inertia_weight_min + (\n            (self.inertia_weight - self.inertia_weight_min) *\n            ((self.initial_budget - self.eval_count) / self.initial_budget)\n        )\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            # Dynamic crossover based on progress\n            dynamic_CR = self.CR - 0.5 * (self.eval_count / self.budget)\n            crossover = np.random.rand(self.dim) < dynamic_CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_inertia_weight()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "d5c94300-1a12-49a5-a134-d4be6a83ebd2", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced the HybridPSO_DE by incorporating adaptive parameters and introducing a mutation mechanism to improve convergence and exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        self.c1 = 1.5 + np.random.rand()  # Adaptive c1\n        self.c2 = 1.5 + np.random.rand()  # Adaptive c2\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            if np.random.rand() < 0.1:  # Mutation mechanism with 10% probability\n                trial += 0.001 * np.random.randn(self.dim)\n            trial = np.clip(trial, lb, ub)\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 22, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "44465c9c-c0fb-4490-b073-141c723c9c74", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight and enhanced crossover strategy to improve convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Adaptive initial inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.7  # Adjusted crossover probability for diversity\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.inertia_weight *= 0.99  # Adaptive inertia weight decay\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 23, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "8bcbbcdb-31d9-492c-82fa-905b468a2225", "fitness": 0.05446272622582239, "name": "AdaptiveHybridPSO_DE", "description": "Introduce Adaptive Inertia and Crossover strategies to enhance exploration-exploitation balance dynamically in a hybrid PSO-DE framework.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR_max = 0.9\n        self.CR_min = 0.1\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                    (self.eval_count / self.budget))\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        CR = self.CR_max - ((self.CR_max - self.CR_min) * (self.eval_count / self.budget))\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 24, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "6e00cdcd-1448-4982-9673-293277e5407a", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhancements in velocity and mutation strategies increase balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Adjusted to enhance exploration\n        self.c1 = 1.7  # Adjusted to enhance exploitation\n        self.c2 = 1.7  # Adjusted to enhance exploitation\n        self.F = 0.9  # Increased DE scaling factor for aggressive mutations\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 25, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "abf3ffb7-13b0-4f6a-9dd3-d206cd547c20", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Improved HybridPSO_DE by incorporating adaptive inertia weights and elite selection for better convergence speed and accuracy.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Adjusted for adaptive inertia\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.elite_count = 5  # Added for elite selection\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.inertia_weight = 0.4 + 0.5 * (self.budget - self.eval_count) / self.budget  # Adaptive inertia weight\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n            # Elite selection to maintain best individuals\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            self.population[elite_indices] = self.population[elite_indices]\n\n        return self.global_best_position", "configspace": "", "generation": 26, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "480d263b-5c28-493a-afb2-d84a9938f409", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive inertia weight and crossover probability for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight_max = 0.9  # Changed from 0.5\n        self.inertia_weight_min = 0.4  # New line\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        inertia_weight = self.inertia_weight_max - (\n            (self.inertia_weight_max - self.inertia_weight_min) * (self.eval_count / self.budget)\n        )  # New line for adaptive inertia weight\n\n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            adaptive_CR = self.CR * (1 - self.eval_count / self.budget) + 0.1 * (self.eval_count / self.budget)  # New line\n            crossover = np.random.rand(self.dim) < adaptive_CR  # Modified line\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 27, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "03f30112-21c6-44cb-ab64-1ad4c38ccf10", "fitness": -Infinity, "name": "HybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with adaptive parameters and opposition-based learning for improved convergence and exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n        self.opposition_based_initialization(lb, ub)\n\n    def opposition_based_initialization(self, lb, ub):\n        opposite_population = lb + ub - self.population\n        opposite_fitness = np.array([func(ind) for ind in opposite_population])\n        original_fitness = np.array([func(ind) for ind in self.population])\n        for i in range(self.population_size):\n            if opposite_fitness[i] < original_fitness[i]:\n                self.population[i] = opposite_population[i]\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        adaptive_w = 0.5 + 0.5 * np.random.rand()\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = adaptive_w * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 28, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {}}
{"id": "a9eece67-70b2-460b-a05f-6ffcebc7c7d4", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Improved stochastic parameters in HybridPSO_DE for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Changed from 0.5\n        self.c1 = 1.7  # Changed from 1.5\n        self.c2 = 1.7  # Changed from 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 29, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "b2517e00-9a84-42e7-866d-d02a320aee05", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE by introducing a dynamic inertia weight and adaptive mutation factor to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.5  # Adaptive scaling factor initialization\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Dynamic update of inertia weight\n        self.inertia_weight = 0.9 - 0.8 * (self.eval_count / self.budget)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            # Adaptive mutation factor based on progress\n            self.F = 0.5 + 0.4 * (1 - self.eval_count / self.budget)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 30, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "3ac781a7-eff5-4fd4-9750-9f68b12e8f98", "fitness": 0.05446272622582239, "name": "AdaptiveSwarmDE", "description": "Adaptive Swarm Differential Evolution (ASDE) combines adaptive parameter tuning with hybrid Particle Swarm and Differential Evolution to enhance convergence in dynamic environments.", "code": "import numpy as np\n\nclass AdaptiveSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.F_initial = 0.8\n        self.CR_initial = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1 = np.random.rand(self.population_size, self.dim)\n        r2 = np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1_initial * r1 * (self.best_positions - self.population)\n        social_component = self.c2_initial * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        \n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F_initial * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR_initial\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        \n        self.population = new_population\n\n    def adaptive_parameters(self):\n        # Adaptive parameter adjustment based on current convergence\n        progress = 1 - (self.eval_count / self.budget)\n        self.inertia_weight = 0.4 + 0.3 * progress\n        self.c1_initial = 1.5 + 0.5 * (1 - progress)\n        self.c2_initial = 1.5 + 0.5 * progress\n        self.F_initial = 0.5 + 0.3 * (1 - progress)\n        self.CR_initial = 0.7 + 0.2 * (progress)\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.adaptive_parameters()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "c42c2f41-73d6-4400-90f9-0b408c2f78f2", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhancement of Hybrid PSO-DE algorithm by incorporating adaptive parameter tuning and mutation strategy for improved convergence efficiency.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            self.F = np.random.uniform(0.5, 1.0)  # Adaptive scaling factor\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 32, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "6442338b-043f-4d82-9422-ad90d015c03e", "fitness": -Infinity, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE using Adaptive Parameter Tuning and Opposition-based Learning for improved convergence and robustness in diverse optimization landscapes.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Start with higher inertia\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n        \n        # Adaptive inertia weight\n        self.inertia_weight = 0.4 + 0.5 * ((self.budget - self.eval_count) / self.budget)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def opposition_based_learning(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        opposite_population = lb + ub - self.population\n        opposite_population = np.clip(opposite_population, lb, ub)\n        return opposite_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n            # Opposition-based learning\n            if self.eval_count < self.budget:\n                opposite_population = self.opposition_based_learning(func_bounds)\n                opposite_fitness = np.array([func(ind) for ind in opposite_population])\n                self.eval_count += self.population_size\n                better_indices = opposite_fitness < fitness\n                self.population[better_indices] = opposite_population[better_indices]\n                fitness[better_indices] = opposite_fitness[better_indices]\n                self.update_personal_best(fitness)\n                self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 33, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {}}
{"id": "e5a07bfe-e0b4-4d98-9419-c968bf9a4749", "fitness": 0.05446272622582239, "name": "AdaptiveHybridPSO_DE", "description": "Adaptive Hybrid PSO-DE with dynamic parameter tuning to improve convergence efficiency by balancing exploration and exploitation phases.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Starting inertia weight\n        self.inertia_weight_decay = 0.99  # Decay factor for inertia weight\n        self.c1 = 2.0  # Cognitive component factor\n        self.c2 = 2.0  # Social component factor\n        self.F = 0.5  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n        self.inertia_weight *= self.inertia_weight_decay  # Decay inertia weight\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 34, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "6777349b-90eb-47f8-8df7-85ce63335bdd", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Improved HybridPSO_DE by introducing an adaptive inertia weight and dynamic population size adjustment to enhance convergence and exploration balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Adjusted for better exploration\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n\n        # Adaptive inertia weight update\n        self.inertia_weight *= 0.99\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 35, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "5dc5bf2a-ac67-4b7b-8389-a249355ca37b", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Hybridizes Particle Swarm Optimization and Differential Evolution with adaptive parameters and environment awareness for improved exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Adaptive inertia weight\n        dynamic_inertia = self.inertia_weight * (1 - (self.eval_count / self.budget))\n        self.velocities = dynamic_inertia * self.velocities + cognitive_component + social_component\n        \n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 36, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "c8a083bf-2fb6-43a0-8620-020940404a38", "fitness": 0.05446272622582239, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive parameter tuning for real-time balancing of exploration and exploitation to improve convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.c1_initial = 2.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        t = self.eval_count / self.budget  # Normalized timestep\n        inertia_weight = self.inertia_weight_initial * (1 - t) + self.inertia_weight_final * t\n        c1 = self.c1_initial * (1 - t) + self.c1_final * t\n        c2 = self.c2_initial * (1 - t) + self.c2_final * t\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = c1 * r1 * (self.best_positions - self.population)\n        social_component = c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "615d5381-38b8-4c9e-96d9-37e30de4d6eb", "fitness": 0.05446272622582239, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with adaptive parameter tuning and elite selection for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.elite_ratio = 0.2\n        self.elite_size = int(self.population_size * self.elite_ratio)\n        self.decay_factor = 0.99\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def elite_selection(self, fitness):\n        elite_indices = np.argsort(fitness)[:self.elite_size]\n        self.population[:self.elite_size] = self.population[elite_indices]\n        self.velocities[:self.elite_size] = self.velocities[elite_indices]\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n            self.elite_selection(fitness)\n            self.inertia_weight *= self.decay_factor  # Decaying inertia weight for better convergence\n\n        return self.global_best_position", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "943961af-66ed-4aaf-92a6-291026a7cc24", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Improved balance between exploration and exploitation by dynamically adjusting the inertia weight and scaling factor based on fitness variance in HybridPSO_DE.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.inertia_weight = 0.9 - 0.5 * np.var(self.velocities)  # Adjust inertia weight\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            self.F = 0.5 + 0.3 * np.var(fitness)  # Adjust scaling factor\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 39, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "8ac68145-daad-449c-864b-87da2229eaaf", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with adaptive parameters for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Increased inertia weight for better exploration\n        self.c1 = 1.2  # Reduced cognitive factor for more global search\n        self.c2 = 1.7  # Increased social factor for better convergence\n        self.F = 0.85  # Adjusted differential evolution scaling factor\n        self.CR = 0.85  # Adjusted crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 40, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "35de56c6-caec-4835-9e38-0da050d39c14", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced adaptive control with dynamic inertia and mutation rate adjustments for improved convergence in hybrid PSO-DE.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Changed from 0.5 to 0.9 for dynamic adjustment\n        self.inertia_weight_min = 0.4  # New minimum inertia weight\n        self.inertia_weight_max = 0.9  # New maximum inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Dynamic inertia weight adjustment\n        weight_range = self.inertia_weight_max - self.inertia_weight_min\n        self.inertia_weight = self.inertia_weight_max - ((self.eval_count / self.budget) ** 2) * weight_range\n\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        # Adjust mutation factor F dynamically\n        adaptive_F = self.F + 0.2 * np.random.randn() * (1 - self.eval_count / self.budget)\n        adaptive_F = np.clip(adaptive_F, 0.5, 1.0)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 41, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "f75d6482-5786-406b-8418-ace6b3048610", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Hybrid PSO-DE with a dynamic inertia weight for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Start with higher inertia weight\n        self.final_inertia_weight = 0.4  # Lower final inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n\n        # Update inertia weight dynamically\n        self.inertia_weight = (self.final_inertia_weight + \n                               (self.inertia_weight - self.final_inertia_weight) * \n                               (1 - self.eval_count/self.budget))\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 42, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "22216bcd-6496-4680-9414-10f920c2176d", "fitness": 0.05446272622582239, "name": "AdaptiveHybridPSO_DE", "description": "Introduced adaptive parameter control in HybridPSO_DE to dynamically adjust exploration and exploitation trade-offs based on convergence speed and diversity, enhancing convergence efficiency and solution quality.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.diversity_threshold = 0.1  # Threshold to adjust diversification\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def adaptive_control(self, fitness):\n        diversity = np.mean(np.std(self.population, axis=0))\n        if diversity < self.diversity_threshold:\n            # Increase exploration if diversity is low\n            self.inertia_weight = min(0.9, self.inertia_weight + 0.1)\n        else:\n            # Increase exploitation if diversity is high\n            self.inertia_weight = max(0.4, self.inertia_weight - 0.1)\n        \n        # Adjust mutation factor and crossover probability based on convergence\n        improvement = np.ptp(fitness)\n        if improvement < 1e-5:\n            self.F = min(1.0, self.F + 0.1)\n            self.CR = min(1.0, self.CR + 0.1)\n        else:\n            self.F = max(0.5, self.F - 0.1)\n            self.CR = max(0.6, self.CR - 0.1)\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n            self.adaptive_control(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 43, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "fa22e37a-3470-45bd-8bf6-0b9be2b67a53", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced Hybrid PSO-DE algorithm with adaptive inertia weight and crossover probability for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Increase to start higher\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.5  # Start lower for adaptive crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            # Adjust inertia weight and crossover probability based on progress\n            self.inertia_weight = max(0.4, self.inertia_weight - 0.005)  # Gradually decrease\n            self.CR = min(0.9, self.CR + 0.005)  # Gradually increase\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 44, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "5407b25c-62e2-4374-a1ab-7bfe4051bb9e", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Integration of adaptive parameters and elite selection strategy for enhanced hybrid PSO-DE optimization.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n\n        if self.eval_count > self.budget / 2:\n            self.inertia_weight = 0.3  # Adaptive inertia weight\n\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        elite_indices = np.argsort(fitness)[:5]  # Elite selection\n        for i in range(self.population_size):\n            if i in elite_indices:\n                continue\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 45, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "60e64cdf-c434-49f5-bef9-bd1d70f8b3d6", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with adaptive parameter tuning for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        self.inertia_weight = 0.9 - (0.5 * (self.eval_count / self.budget))  # Adaptive inertia weight\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 46, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "f4698d63-e4f8-437e-a5cd-7cf91daae9b2", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with adaptive parameters and boundary handling for improved convergence and stability.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.4 + 0.1 * (self.global_best_fitness / self.budget)\n        self.F = 0.7 + 0.1 * (1 - self.global_best_fitness / self.budget)\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.adapt_parameters()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 47, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "16e827fc-408d-493d-aa81-0550f8f507ac", "fitness": 0.05446272622582239, "name": "ImprovedHybridPSO_DE", "description": "Hybridization of Particle Swarm Optimization and Differential Evolution with dynamic parameter adaptation for improved balance between exploration and exploitation across diverse problem landscapes.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        \n        # Adaptive inertia weight\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 48, "feedback": "The algorithm ImprovedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "948b90cf-ebe7-46a7-a063-06744c3cbbbb", "fitness": -Infinity, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with dynamic parameter adaptation and local search to improve convergence and solution quality in diverse search spaces.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += len(self.population)\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def adaptive_parameters(self, iteration, max_iterations):\n        self.inertia_weight = 0.4 + 0.5 * (1 - iteration / max_iterations)\n        self.c1 = 1.5 + 1.0 * (iteration / max_iterations)\n        self.c2 = 1.5 + 1.0 * (iteration / max_iterations)\n\n    def local_search(self, bounds, func):\n        lb, ub = bounds.lb, bounds.ub\n        for i in range(self.population_size):\n            if np.random.rand() < 0.3:\n                perturbation = np.random.normal(0, 0.1, size=self.dim)\n                candidate = self.best_positions[i] + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_fitness = func(candidate)\n                self.eval_count += 1\n                if candidate_fitness < func(self.best_positions[i]):\n                    self.best_positions[i] = candidate\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        iteration = 0\n        while self.eval_count < self.budget:\n            self.adaptive_parameters(iteration, self.budget // self.population_size)\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            self.local_search(func_bounds, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n            iteration += 1\n\n        return self.global_best_position", "configspace": "", "generation": 49, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {}}
{"id": "312793ca-6c19-4a5e-a475-01b78d9abd2d", "fitness": 0.05446272622582239, "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO and DE with Dynamic Parameter Adjustment for improved exploration-exploitation balance and convergence rate.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def dynamic_parameter_adjustment(self):\n        # Linearly decrease inertia weight\n        self.inertia_weight = 0.9 - (0.5 * (self.eval_count / self.budget))\n        # Adjust cognitive and social components\n        self.c1 = 2.5 - (1.5 * (self.eval_count / self.budget))\n        self.c2 = 0.5 + (1.5 * (self.eval_count / self.budget))\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.dynamic_parameter_adjustment()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "51233b75-fcfd-4870-842f-3c5f2a7b3d32", "fitness": 0.05446272622582239, "name": "AdaptiveHybridPSO_DE", "description": "HybridPSO_DE with adaptive parameter tuning and dynamic population size for improved exploration-exploitation balance in black-box optimization.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F = 0.5  # Initial differential evolution scaling factor\n        self.CR = 0.7  # Initial crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.adaptive_step = 0.1  # Step size for parameter adaptation\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def adapt_parameters(self):\n        # Adjust parameters based on the progress of the optimization\n        self.inertia_weight = max(0.4, self.inertia_weight - self.adaptive_step)\n        self.c1 = max(1.5, self.c1 - self.adaptive_step)\n        self.c2 = max(1.5, self.c2 - self.adaptive_step)\n        self.F = min(0.9, self.F + self.adaptive_step / 2)\n        self.CR = min(0.9, self.CR + self.adaptive_step / 2)\n        # Reduce population size as the search progresses\n        if self.eval_count < self.budget / 2:\n            self.population_size = self.initial_population_size\n        else:\n            self.population_size = max(20, int(self.initial_population_size / 2))\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n            self.adapt_parameters()\n\n        return self.global_best_position", "configspace": "", "generation": 51, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "862161e6-408c-45b9-b471-f69703a9b00c", "fitness": -Infinity, "name": "ImprovedHybridPSO_DE", "description": "Improved Hybrid PSO-DE with dynamic parameter adaptation for better convergence and stability across diverse optimization tasks.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_decay = 0.99\n        self.c1_initial = 2.5\n        self.c2_initial = 0.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.F_initial = 0.8\n        self.F_decay = 0.99\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (self.eval_count / self.budget)\n        c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (self.eval_count / self.budget)\n        cognitive_component = c1 * r1 * (self.best_positions - self.population)\n        social_component = c2 * r2 * (self.global_best_position - self.population)\n\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.inertia_weight *= self.inertia_decay\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        F = self.F_initial * self.F_decay ** (self.eval_count / self.budget)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 52, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {}}
{"id": "a7458bbb-85a7-4bb0-8a36-2c8948438580", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive parameter tuning for improved convergence efficiency in continuous search spaces.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.inertia_weight = max(0.1, self.inertia_weight * 0.99)  # Adaptive inertia weight\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 53, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "3728e099-bf1a-433a-9a51-26e09ff415d7", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced with dynamic parameter adjustment for improved balance of exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Dynamic inertia weight adjustment\n        self.inertia_weight = 0.9 - (0.5 * (self.eval_count / self.budget))\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 54, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "4714dcfd-3b63-458d-9a15-83a75fd44bfe", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced Hybridization of Particle Swarm Optimization and Differential Evolution with adaptive parameters for improved convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # updated inertia weight for better exploration\n        self.c1 = 2.0  # increased cognitive coefficient\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Updated velocity calculation with dynamic inertia weight adjustment\n        self.inertia_weight = 0.9 - (self.eval_count / self.budget) * 0.5\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 55, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "f978d936-1a4c-4aab-8aae-e0f19c0d0cbd", "fitness": 0.05446272622582239, "name": "DynamicHybridPSODE", "description": "Dynamic Hybrid PSO-DE with Adaptive Mutation for enhanced diversity and convergence efficiency in solving black-box optimization problems.", "code": "import numpy as np\n\nclass DynamicHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def adaptive_differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            F_adaptive = self.F * (1 - self.eval_count / self.budget)  # Adaptive F\n            mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.adaptive_differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 56, "feedback": "The algorithm DynamicHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "cca0cb1b-3ff7-4fa9-8ca5-9e5b7f7ece6d", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Refinement of Hybrid PSO-DE with adaptive parameters for enhanced convergence speed and improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Changed from 0.5 for better exploration initially\n        self.c1 = 1.2  # Adjusted from 1.5 for better balance\n        self.c2 = 1.7  # Adjusted from 1.5 for stronger global influence\n        self.F = 0.6  # Adjusted from 0.8 for better differential evolution dynamics\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 57, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "c20937be-fb1e-44d9-ad96-ec530c6b3311", "fitness": 0.05446272622582239, "name": "RefinedHybridPSO_DE", "description": "Refined HybridPSO_DE using adaptive inertia weight and dynamic population size for improved exploration and exploitation in continuous search spaces.", "code": "import numpy as np\n\nclass RefinedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (self.eval_count / self.budget)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def adaptive_population_size(self):\n        if self.eval_count < self.budget // 2:\n            self.population_size = self.initial_population_size\n        else:\n            self.population_size = max(10, int(self.initial_population_size * (1 - (self.eval_count - self.budget // 2) / (2 * (self.budget // 2)))))\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.adaptive_population_size()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 58, "feedback": "The algorithm RefinedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "6946680b-5a4c-48cf-89fd-05261d64b8b7", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Introducing adaptive parameter tuning and elitism to enhance convergence and robustness of the Hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Adjusted inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n            elif np.random.rand() < 0.1:  # Introduce elitism\n                new_population[i] = self.best_positions[i].copy()\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 59, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "170eccdc-ef10-422e-9aae-145755020293", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with dynamic inertia weight and adaptive mutation strategies for improved convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Dynamically adjust inertia weight\n        self.inertia_weight = 0.9 - (0.5 * self.eval_count / self.budget)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n\n            # Adaptive mutation strategy\n            if self.eval_count < self.budget / 2:\n                self.F = 0.8\n            else:\n                self.F = 0.5\n\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 60, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "0ac95e6b-d161-4d55-922b-0017e1ccdfcd", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Introduction of adaptive parameters and dynamic inertia weight adjustment in HybridPSO_DE for improved convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Change 1: Increased initial inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Change 2: Adaptive inertia weight based on evaluation count\n        self.inertia_weight = 0.9 - 0.5 * (self.eval_count / self.budget)\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 61, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "2bbc2d20-b155-4008-8555-18f304bddcf8", "fitness": -Infinity, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE with dynamic parameter adjustment and adaptive mutation strategy for improved convergence in high-dimensional search spaces.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Dynamic inertia weight\n        self.inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (self.eval_count / self.budget)\n\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def adaptive_differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            # Adaptive mutation factor\n            adaptive_F = self.F * (1 - self.eval_count / self.budget)\n            mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.adaptive_differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 62, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {}}
{"id": "84c12fe7-ffdd-4a9a-96ef-b333f350460e", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with dynamic parameter adaptation to improve convergence in diverse search landscapes.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n            \n            # Dynamic adaptation of F and CR for better exploration-exploitation balance\n            self.F = 0.5 + 0.5 * (1 - self.eval_count / self.budget)\n            self.CR = 0.9 - 0.5 * (self.eval_count / self.budget)\n\n        return self.global_best_position", "configspace": "", "generation": 63, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "b3fe7053-7ed2-4862-ad96-f998170d2dfe", "fitness": -Infinity, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive parameters and elite selection for improved convergence in complex search spaces.  ", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_parameters(self):\n        # Adaptively adjust inertia weight and learning factors\n        if self.eval_count < self.budget / 3:\n            self.inertia_weight = 0.9\n            self.c1, self.c2 = 2.0, 2.0\n        elif self.eval_count < 2 * self.budget / 3:\n            self.inertia_weight = 0.7\n            self.c1, self.c2 = 1.5, 1.5\n        else:\n            self.inertia_weight = 0.4\n            self.c1, self.c2 = 1.0, 1.0\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        elite_index = np.argmin(fitness)\n        elite_individual = self.population[elite_index]\n        \n        for i in range(self.population_size):\n            if i == elite_index:\n                continue\n            \n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n            elif trial_fitness < func(elite_individual):\n                new_population[i] = elite_individual\n        \n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_parameters()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 64, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {}}
{"id": "11793b68-a3ea-43ec-845e-007a202a75d2", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced diversification and exploitation by adjusting inertia weight dynamically based on evaluation count.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Adjust inertia weight dynamically\n        self.inertia_weight = 0.9 - 0.5 * (self.eval_count / self.budget)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 65, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "02c61933-d4de-49df-9546-9a8ab9876de0", "fitness": 0.05446272622582239, "name": "AdaptiveHybridPSO_DE", "description": "Adaptive Hybrid PSO-DE with feedback-driven parameter tuning to enhance convergence speed and solution quality by dynamically adjusting strategy parameters based on performance trends.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Differential evolution scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.adaptive_factor = 0.95  # Adaptive factor for updating parameters\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def adapt_parameters(self, previous_fitness, current_fitness):\n        if np.mean(current_fitness) < np.mean(previous_fitness):\n            self.inertia_weight *= self.adaptive_factor\n            self.F *= self.adaptive_factor\n            self.CR = min(1.0, self.CR * 1.05)\n        else:\n            self.inertia_weight /= self.adaptive_factor\n            self.F /= self.adaptive_factor\n            self.CR *= self.adaptive_factor\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n        previous_fitness = fitness\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n            self.adapt_parameters(previous_fitness, fitness)\n            previous_fitness = fitness\n\n        return self.global_best_position", "configspace": "", "generation": 66, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "2ddd03ee-98c6-4d79-9e6d-fcdf6521bf03", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive parameters for improved convergence through dynamic adjustment of inertia weight and crossover probability.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Adjusted for exploration initially\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.5  # Reduced initial CR for exploitation\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n\n        # Dynamic adjustment of inertia weight\n        self.inertia_weight = 0.9 - (0.5 * (self.eval_count / self.budget))\n\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            # Ensure at least one dimension crosses\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            # Dynamic adjustment of crossover probability\n            self.CR = 0.5 + (0.4 * (1 - (self.eval_count / self.budget)))\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 67, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "6909886b-3889-41e6-93aa-e25b5aae4e70", "fitness": 0.05446272622582239, "name": "HybridPSO_DE", "description": "Improved exploration of the search space by introducing adaptive inertia weights and mutation factors based on performance feedback.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Adjusted initial inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Adaptive inertia weight\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            F_adaptive = np.random.uniform(0.5, 1.0)  # Adaptive mutation factor\n            mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 68, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05446 with standard deviation 0.00196.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.05567022332318883, 0.051332495018830526, 0.054636049024618494, 0.05704434009401904, 0.05258725840245615, 0.05506825136352678, 0.05749827924110418, 0.05300106577037267]}}
{"id": "52d2d4ca-3c76-4be0-98a7-7cb42002e229", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Enhanced control parameters and adaptive strategy integration for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Changed from 50 to 60\n        self.inertia_weight = 0.7  # Changed from 0.5 to 0.7\n        self.c1 = 1.2  # Changed from 1.5 to 1.2\n        self.c2 = 1.8  # Changed from 1.5 to 1.8\n        self.F = 0.7  # Changed from 0.8 to 0.7\n        self.CR = 0.85  # Changed from 0.9 to 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 69, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["8db3f239-fab4-4eca-8c91-d8cac45eef97"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "bfd348ae-db7e-40e3-8726-3ad0907cdbd4", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight and chaotic mapping to enhance exploration and convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9 for enhanced exploration at start\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Adaptive inertia weight decrease\n        self.inertia_weight *= 0.99  # Decrease inertia weight iteratively\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 70, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "d324b13e-5354-4561-8d76-c6140378da0d", "fitness": 0.055198616311914694, "name": "DynamicHybridPSO_DE", "description": "Integrating dynamic parameter tuning and social learning in the hybrid PSO-DE framework for enhanced convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass DynamicHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n        self.global_best_fitness = float('inf')\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Dynamic inertia weight adjustment\n        self.inertia_weight = 0.9 - 0.5 * (self.eval_count / self.budget)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 71, "feedback": "The algorithm DynamicHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "1323ebdd-256b-4709-b9ee-9846fda4a5f2", "fitness": 0.055198616311914694, "name": "ImprovedHybridPSO_DE", "description": "Introduce dynamic adaptive parameters and a novel mutation strategy to enhance diversity and convergence in a hybrid PSO-DE framework.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.w_max, self.w_min = 0.9, 0.4  # Dynamic inertia weight range\n        self.c1_start, self.c2_start = 1.5, 1.5\n        self.c1_end, self.c2_end = 0.5, 2.0\n        self.F = 0.7\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub - lb), abs(ub - lb), (self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        progress = self.eval_count / self.budget\n        inertia_weight = self.w_max - (self.w_max - self.w_min) * progress\n        c1 = self.c1_start - (self.c1_start - self.c1_end) * progress\n        c2 = self.c2_start + (self.c2_end - self.c2_start) * progress\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = c1 * r1 * (self.best_positions - self.population)\n        social_component = c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            F_adaptive = self.F + np.random.rand() * 0.2 - 0.1  # Adaptive mutation factor\n            mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 72, "feedback": "The algorithm ImprovedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "98ea464c-13d1-4df5-819c-5a257160b8d1", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Incorporate adaptive inertia weight and hybrid mutation strategy for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9 for better exploration\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.6  # Changed from 0.7 to 0.6 for diversity in DE\n        self.CR = 0.9  # Changed from 0.85 to 0.9 for better crossover performance\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n        self.inertia_weight *= 0.99  # Adaptive reduction of inertia weight\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.best_positions[b] - self.best_positions[c])  # Hybrid mutation strategy\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 73, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "4d6eec7c-0da2-481d-b18a-7ef8ebf9499d", "fitness": 0.055198616311914694, "name": "EnhancedHybridPSO_DE", "description": "Introduce dynamic adaptation of parameters and diversity preservation mechanisms for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 0.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def adapt_parameters(self):\n        progress = self.eval_count / self.budget\n        self.inertia_weight = self.initial_inertia_weight - progress * (self.initial_inertia_weight - self.final_inertia_weight)\n        self.c1 = self.c1_initial - progress * (self.c1_initial - 1.5)\n        self.c2 = self.c2_initial + progress * (2.5 - self.c2_initial)\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.adapt_parameters()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "c29c54d1-b92a-4840-a07e-3c61f1f98b5d", "fitness": -Infinity, "name": "AdaptiveHybridPSO_DE", "description": "Integrate adaptive inertia weight and self-adaptive parameter control for enhanced convergence in dynamic environments.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n \n    def get_adaptive_inertia_weight(self):\n        return self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (1 - self.eval_count / self.budget)\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.get_adaptive_inertia_weight()\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 75, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {}}
{"id": "5214b09d-450b-48e7-865c-8e47465d4225", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Fine-tuned cognitive parameter for enhanced individual learning and exploration balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Changed from 50 to 60\n        self.inertia_weight = 0.7  # Changed from 0.5 to 0.7\n        self.c1 = 1.4  # Changed from 1.2 to 1.4\n        self.c2 = 1.8  # Changed from 1.5 to 1.8\n        self.F = 0.7  # Changed from 0.8 to 0.7\n        self.CR = 0.85  # Changed from 0.9 to 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 76, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "754b36cd-1215-4122-a4e1-10a5ba3ca80d", "fitness": 0.055198616311914694, "name": "EnhancedHybridPSO_DE", "description": "Incorporating adaptive inertia weight and differential evolution crossover rate to enhance convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR_max = 0.9\n        self.CR_min = 0.75\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def adaptive_parameters(self):\n        inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * (self.eval_count / self.budget))\n        CR = self.CR_max - ((self.CR_max - self.CR_min) * (self.eval_count / self.budget))\n        return inertia_weight, CR\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        inertia_weight, _ = self.adaptive_parameters()\n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.adaptive_parameters()[1]\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "03969fc0-29cc-43b7-970e-8508360d225a", "fitness": 0.055198616311914694, "name": "EnhancedHybridPSO_DE", "description": "Dynamic inertia and adaptive crossover rates enhance exploration-exploitation balance by adjusting to population diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        diversity = np.std(self.population)\n        self.inertia_weight = 0.4 + (0.5 * (1 - (self.eval_count / self.budget))) * (diversity / (diversity + 1e-9))\n        \n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < (self.CR * (1 - self.eval_count / self.budget))\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "69fd17fc-ecd1-4467-99aa-469b8c897d88", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Introduced dynamic parameter adaptation to balance exploration and exploitation over iterations.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Dynamic inertia weight adaptation\n        self.inertia_weight = 0.9 - (0.5 * (self.eval_count / self.budget))\n\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 79, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "86bd7fbe-2bec-4826-ac89-3024a4fe8f0d", "fitness": -Infinity, "name": "ImprovedHybridPSO_DE", "description": "Introducing dynamic inertia and adaptive crossover rates in a Hybrid PSO-DE framework to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR_initial = 0.9\n        self.CR_final = 0.7\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        inertia_weight = self.inertia_weight_initial - (self.eval_count / self.budget) * (self.inertia_weight_initial - self.inertia_weight_final)\n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        CR = self.CR_initial - (self.eval_count / self.budget) * (self.CR_initial - self.CR_final)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 80, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {}}
{"id": "5137d631-d425-4822-8514-4c4512cfbd37", "fitness": 0.055198616311914694, "name": "EnhancedHybridPSO_DE", "description": "Introduction of adaptive inertia weight and mutation factor adjustments for improved convergence dynamics.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.inertia_weight_min = 0.4  # Minimum inertia weight\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7  # Mutation factor for DE\n        self.CR = 0.85  # Crossover rate for DE\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def adaptive_inertia_weight(self):\n        # Linearly decrease inertia weight from 0.9 to 0.4\n        self.inertia_weight = self.inertia_weight_min + \\\n                              (0.9 - self.inertia_weight_min) * (1 - self.eval_count / self.budget)\n\n    def adaptive_mutation_factor(self):\n        # Adjust mutation factor based on current best fitness\n        fitness_progress = 1 - (self.global_best_fitness / max(1.0, np.abs(self.global_best_fitness)))\n        self.F = 0.5 + 0.3 * fitness_progress\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.adaptive_inertia_weight()\n            self.adaptive_mutation_factor()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "ed7d4030-4f05-4c63-b2f7-74e48c6cb193", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Adaptive velocity update and perturbation strategy for improved diversity and convergence speed.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7\n        self.c1 = 1.4  # Changed from 1.2 to 1.4\n        self.c2 = 1.6  # Changed from 1.8 to 1.6\n        self.F = 0.8  # Changed from 0.7 to 0.8\n        self.CR = 0.9  # Changed from 0.85 to 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Adaptive velocity update\n        self.velocities = (self.inertia_weight * self.velocities + cognitive_component + social_component) * (1 + np.random.normal(0, 0.1, self.velocities.shape))\n        \n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 82, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "f114a4d9-a6b0-4ff0-8074-a044d421137e", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Adaptive learning rate and diversity preservation mechanism for enhanced exploration and exploitation balance in HybridPSO_DE.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        diversity = np.std(self.population, axis=0)\n        adaptive_inertia = 0.9 - 0.5 * (self.eval_count / self.budget) * diversity\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = adaptive_inertia * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 83, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "0affe88d-7c8b-4ca4-86e1-f37b1368ee22", "fitness": 0.055198616311914694, "name": "EnhancedHybridPSO_DE", "description": "Incorporate adaptive inertia weight and local search enhancement for improved convergence dynamics in Hybrid PSO-DE.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_inertia_weight(self):\n        # Adaptive inertia weight calculation\n        alpha = (self.eval_count / self.budget)\n        self.inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (1 - alpha)\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n\n        self.update_inertia_weight()\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def local_search(self, individual, bounds, func):\n        # Simple local perturbation\n        perturbation = np.random.uniform(low=-0.01, high=0.01, size=self.dim)\n        candidate = individual + perturbation\n        candidate = np.clip(candidate, bounds.lb, bounds.ub)\n        candidate_fitness = func(candidate)\n        self.eval_count += 1\n        return candidate, candidate_fitness\n\n    def apply_local_search(self, fitness, func_bounds, func):\n        for i in range(self.population_size):\n            candidate, candidate_fitness = self.local_search(self.population[i], func_bounds, func)\n            if candidate_fitness < fitness[i]:\n                self.population[i] = candidate\n                fitness[i] = candidate_fitness\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            self.apply_local_search(fitness, func_bounds, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "7b036873-8182-4768-8304-2f1c14e73a62", "fitness": 0.055198616311914694, "name": "AdaptiveHybridPSO_DE", "description": "Introduce dynamic control parameters and adaptive mutation strategies to balance exploration-exploitation adaptively over time.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight_init = 0.9\n        self.inertia_weight_final = 0.4\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F_init = 0.9\n        self.F_final = 0.5\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds, iter_fraction):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        inertia_weight = self.inertia_weight_init - iter_fraction * (self.inertia_weight_init - self.inertia_weight_final)\n\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func, iter_fraction):\n        lb, ub = bounds.lb, bounds.ub\n        F = self.F_init - iter_fraction * (self.F_init - self.F_final)\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            iter_fraction = self.eval_count / self.budget\n            self.update_velocities_and_positions(func_bounds, iter_fraction)\n            self.differential_evolution(func_bounds, fitness, func, iter_fraction)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 85, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "c864b371-4ff6-4f93-bff5-2ec243a43402", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Refined HybridPSO_DE with enhanced exploration capabilities and adaptive learning rates for improved optimization.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9\n        self.c1 = 1.0  # Changed from 1.2 to 1.0\n        self.c2 = 2.0  # Changed from 1.8 to 2.0\n        self.F = 0.8  # Changed from 0.7 to 0.8\n        self.CR = 0.9  # Changed from 0.85 to 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 86, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "91239841-cd1d-4686-af9c-03483e9a9023", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Introduced adaptive control parameters and local search for enhanced convergence and diversity maintenance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9\n        self.c1 = 0.8  # Changed from 1.2 to 0.8\n        self.c2 = 2.0  # Changed from 1.8 to 2.0\n        self.F = 0.6  # Changed from 0.7 to 0.6\n        self.CR = 0.9  # Changed from 0.85 to 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def local_search(self, bounds, fitness, func):  # New local search method\n        lb, ub = bounds.lb, bounds.ub\n        for i in range(self.population_size):\n            candidate = self.population[i] + np.random.normal(0, 0.1, self.dim)  # Local perturbation\n            candidate = np.clip(candidate, lb, ub)\n            candidate_fitness = func(candidate)\n            self.eval_count += 1\n            if candidate_fitness < fitness[i]:\n                self.population[i] = candidate\n                fitness[i] = candidate_fitness\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            self.local_search(func_bounds, fitness, func)  # Integrate local search\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 87, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "4f2ce8e2-5527-44c7-8b7a-9136a102c19e", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Introducing a dynamic self-adaptive mechanism for control parameters to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  \n        self.inertia_weight = 0.7  \n        self.c1 = 1.2  \n        self.c2 = 1.8  \n        self.F = 0.7  \n        self.CR = 0.85  \n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        self.c1 = 1.5 - (1.5 - 0.5) * (self.eval_count / self.budget)  # Adaptive c1\n        self.c2 = 0.5 + (1.5 * (self.eval_count / self.budget))  # Adaptive c2\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 88, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "509096ec-d8d5-456a-94dd-9762ae1fa8e1", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Incorporate adaptive velocity scaling and elite retention strategies to enhance convergence speed and solution quality in the HybridPSO_DE algorithm.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.elite_fraction = 0.1  # New: fraction of elite individuals to retain\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # New: Adaptive velocity scaling based on fitness\n        adaptive_inertia = self.inertia_weight * (1 - self.global_best_fitness / np.max(self.global_best_fitness + 1e-8))\n        self.velocities = adaptive_inertia * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        num_elites = int(self.elite_fraction * self.population_size)\n        elites = self.population[np.argsort(fitness)[:num_elites]]  # New: Retain elites\n        for i in range(self.population_size):\n            if i < num_elites:\n                continue  # Preserve elites\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population[:num_elites] = elites  # New: Reinsert elites\n        self.population[num_elites:] = new_population[num_elites:]\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 89, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "983fa30e-7cb1-4427-9949-ca9e87b46839", "fitness": 0.055198616311914694, "name": "AdvancedPSO_DE", "description": "Enhanced PSO-DE algorithm with adaptive mutation scaling and dynamical strategy switching for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdvancedPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.initial_F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def adaptive_differential_evolution(self, bounds, fitness, func, iteration):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        dynamic_F = self.initial_F * (1 - iteration / self.budget)\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                break\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        iteration = 0\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.adaptive_differential_evolution(func_bounds, fitness, func, iteration)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n            iteration += 1\n\n        return self.global_best_position", "configspace": "", "generation": 90, "feedback": "The algorithm AdvancedPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "fcd6f2d0-a593-4c93-bd5e-057931e0880c", "fitness": 0.055198616311914694, "name": "RefinedHybridPSO_DE", "description": "Integrate stochastic ranking for constraint handling and dynamic parameter adjustment to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n        self.rank_probability = 0.45  # Probability for stochastic ranking\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def stochastic_ranking(self, fitness):\n        ranks = np.argsort(fitness)\n        for i in range(self.population_size - 1):\n            for j in range(self.population_size - 1, i, -1):\n                if np.random.rand() < self.rank_probability:\n                    if fitness[ranks[j]] < fitness[ranks[j - 1]]:\n                        ranks[j], ranks[j - 1] = ranks[j - 1], ranks[j]\n                else:\n                    if fitness[ranks[j]] < fitness[ranks[j - 1]]:\n                        ranks[j], ranks[j - 1] = ranks[j - 1], ranks[j]\n        return ranks\n\n    def dynamic_parameter_adjustment(self):\n        self.inertia_weight *= 0.99\n        self.c1 += (np.random.rand() - 0.5) * 0.1\n        self.c2 += (np.random.rand() - 0.5) * 0.1\n        self.F += (np.random.rand() - 0.5) * 0.1\n        self.CR += (np.random.rand() - 0.5) * 0.1\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n            self.stochastic_ranking(fitness)\n            self.dynamic_parameter_adjustment()\n\n        return self.global_best_position", "configspace": "", "generation": 91, "feedback": "The algorithm RefinedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "7e7742ea-9d4e-408d-b39e-ae3ed6d39136", "fitness": -Infinity, "name": "ImprovedHybridPSO_DE", "description": "Adaptive Hybrid PSO-DE with Dynamic Parameter Tuning and Randomness Injection for Enhanced Convergence.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            if fitness[i] < func(self.best_positions[i]):\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        inertia_weight = self.initial_inertia_weight - (\n            (self.initial_inertia_weight - self.final_inertia_weight) * (self.eval_count / self.budget)\n        )\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = inertia_weight * self.velocities + cognitive_component + social_component\n        self.velocities += np.random.normal(0, 0.1, self.velocities.shape)  # Randomness Injection\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 92, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {}}
{"id": "1fb32db9-1ce1-484b-a92b-f0996a7ea5e5", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Introduced adaptive velocity scaling to improve convergence speed and precision.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Adaptive velocity scaling\n        adaptive_scale = 1 - self.eval_count / self.budget\n        \n        self.velocities = adaptive_scale * (self.inertia_weight * self.velocities + cognitive_component + social_component)\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 93, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "83cbaf6c-82ba-42af-ba27-771cff262966", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Balances exploration and exploitation more effectively by introducing adaptive inertia and improved crossover strategies.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7  \n        self.c1 = 1.2  \n        self.c2 = 1.8  \n        self.F = 0.7  \n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n\n        # Adaptive inertia weight\n        inertia_weight_adaptive = self.inertia_weight - ((self.inertia_weight - 0.4) * (self.eval_count / self.budget))\n        self.velocities = inertia_weight_adaptive * self.velocities + cognitive_component + social_component\n        \n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < (self.CR + 0.1 * np.random.rand())  # Improved crossover\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 94, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "793a78ab-d85e-480d-86b7-b5c11271bec2", "fitness": -Infinity, "name": "AdvancedHybridPSO_DE", "description": "Introduced a dynamic adjustment of control parameters and a diversity maintenance mechanism for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdvancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Starts higher for exploration\n        self.c1 = 2.0  # Cognitive component starts higher\n        self.c2 = 2.0  # Social component starts higher\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        fitness = self.evaluate_population(func=lambda x: np.inf)\n        self.update_global_best(fitness)\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n        diversity = np.std(self.population, axis=0)\n        self.inertia_weight = max(0.4, self.inertia_weight - 0.0001)  # Decrease inertia over time\n        self.c1 = max(0.5, self.c1 - 0.001)  # Decrease cognitive component\n        self.c2 = min(2.5, self.c2 + 0.001)  # Increase social component\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 95, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {}}
{"id": "385a21f6-e7b9-428c-891e-1015487cecc3", "fitness": 0.055198616311914694, "name": "EnhancedHybridPSO_DE", "description": "An adaptive multi-phase hybrid algorithm combining enhanced PSO and DE strategies with dynamic parameters for superior convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Adaptive inertia weight starting higher for more exploration\n        self.c1 = 1.5  # Enhanced cognitive component\n        self.c2 = 2.0  # Enhanced social component\n        self.F = 0.8  # Adjusted DE amplification factor\n        self.CR = 0.9  # Adjusted DE crossover rate\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def adaptive_parameters(self):\n        # Gradually reduce inertia weight to focus on exploitation in later stages\n        self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.adaptive_parameters()\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "94e7d934-216e-4389-97bb-21533cb66523", "fitness": 0.055198616311914694, "name": "EnhancedHybridPSO_DE", "description": "Introduce adaptive weight and crossover mechanisms in HybridPSO_DE to dynamically balance exploration and exploitation based on convergence rate.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.7\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR_initial = 0.85\n        self.CR = self.CR_initial\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def adaptive_crossover_rate(self, prev_fitness, current_fitness):\n        improvement_rate = (prev_fitness - current_fitness) / prev_fitness\n        self.CR = max(0.4, self.CR_initial * (1 + improvement_rate))\n    \n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            prev_fitness = self.global_best_fitness\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n            self.adaptive_crossover_rate(prev_fitness, self.global_best_fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "d0b2e051-1ba7-4b7e-8922-8522f8e36649", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Introduced dynamic inertia weight and crossover rate for enhanced diversity and convergence balance in HybridPSO_DE.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        # Dynamic inertia weight adjustment\n        self.inertia_weight = 0.9 - 0.5 * (self.eval_count / self.budget)  # Updated formula\n\n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            \n            # Dynamic crossover rate adjustment\n            dynamic_CR = self.CR - 0.3 * (self.eval_count / self.budget)  # Updated formula\n            crossover = np.random.rand(self.dim) < dynamic_CR\n            \n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 98, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
{"id": "71ed7b6c-f3ac-4913-8573-f49edf176182", "fitness": 0.055198616311914694, "name": "HybridPSO_DE", "description": "Integration of self-adaptive parameter control and local search to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9\n        self.c1 = 1.5  # Changed from 1.2 to 1.5\n        self.c2 = 2.0  # Changed from 1.8 to 2.0\n        self.F = 0.8  # Changed from 0.7 to 0.8\n        self.CR = 0.9  # Changed from 0.85 to 0.9\n        self.population = None\n        self.velocities = None\n        self.best_positions = None\n        self.global_best_position = None\n        self.global_best_fitness = float('inf')\n        self.eval_count = 0\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        self.population = np.random.uniform(low=lb, high=ub, size=(self.population_size, self.dim))\n        self.velocities = np.random.uniform(low=-abs(ub - lb), high=abs(ub - lb), size=(self.population_size, self.dim))\n        self.best_positions = self.population.copy()\n        self.global_best_position = self.population[0].copy()\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        return fitness\n\n    def update_personal_best(self, fitness, func):\n        for i in range(self.population_size):\n            personal_fitness = func(self.best_positions[i])\n            if fitness[i] < personal_fitness:\n                self.best_positions[i] = self.population[i].copy()\n\n    def update_global_best(self, fitness):\n        min_index = np.argmin(fitness)\n        if fitness[min_index] < self.global_best_fitness:\n            self.global_best_fitness = fitness[min_index]\n            self.global_best_position = self.population[min_index].copy()\n\n    def update_velocities_and_positions(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n        cognitive_component = self.c1 * r1 * (self.best_positions - self.population)\n        social_component = self.c2 * r2 * (self.global_best_position - self.population)\n        \n        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n        self.population += self.velocities\n        self.population = np.clip(self.population, lb, ub)\n\n    def differential_evolution(self, bounds, fitness, func):\n        lb, ub = bounds.lb, bounds.ub\n        new_population = self.population.copy()\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, lb, ub)\n            crossover = np.random.rand(self.dim) < self.CR\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.population[i])\n            trial_fitness = func(trial)\n            self.eval_count += 1\n            if trial_fitness < fitness[i]:\n                new_population[i] = trial\n        self.population = new_population\n\n    def __call__(self, func):\n        func_bounds = func.bounds\n        self.initialize_population(func_bounds)\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness, func)\n        self.update_global_best(fitness)\n\n        while self.eval_count < self.budget:\n            self.update_velocities_and_positions(func_bounds)\n            self.differential_evolution(func_bounds, fitness, func)\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness, func)\n            self.update_global_best(fitness)\n\n        return self.global_best_position", "configspace": "", "generation": 99, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05520 with standard deviation 0.00288.", "error": "", "parent_ids": ["52d2d4ca-3c76-4be0-98a7-7cb42002e229"], "operator": null, "metadata": {"aucs": [0.05332657379428485, 0.057828751044597726, 0.051332495018830526, 0.054636049024618494, 0.059265948190392104, 0.05258725840245615, 0.05506825136352678, 0.05974115419815296, 0.05300106577037267]}}
