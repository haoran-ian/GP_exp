{"id": "0c7832dd-db0d-4bcb-bc0f-14081fd2392b", "fitness": 0.07252989834851227, "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization (PSO) with Differential Evolution (DE) for dynamic exploration and exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07253 with standard deviation 0.00664.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.08006110357787766, 0.0736153094418951, 0.06391328202576407]}}
{"id": "1b50a2c0-7765-4fdf-aac9-afae58606a16", "fitness": 0.057456272773811046, "name": "HybridPSODE", "description": "Enhanced HybridPSODE using adaptive parameters for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # PSO Component\n            self.w = 0.4 + 0.5 * (self.budget - evaluations) / self.budget  # adaptive inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05746 with standard deviation 0.00063.", "error": "", "parent_ids": ["0c7832dd-db0d-4bcb-bc0f-14081fd2392b"], "operator": null, "metadata": {"aucs": [0.05780989017533911, 0.05657675125226569, 0.05798217689382834]}}
{"id": "1564d0d1-2096-473a-9dab-0b4b07c4cfe0", "fitness": 0.07192695592242555, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive mutation and crossover rates for improved convergence balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Adaptive mutation and crossover rates\n                self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                self.crossover_rate = 0.6 + 0.4 * np.random.rand()\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07193 with standard deviation 0.00495.", "error": "", "parent_ids": ["0c7832dd-db0d-4bcb-bc0f-14081fd2392b"], "operator": null, "metadata": {"aucs": [0.07525099651234302, 0.06493200351935768, 0.07559786773557597]}}
{"id": "3e60e71d-b3c6-459d-9d22-ac8e13387136", "fitness": 0.06878689549758632, "name": "HybridPSODE", "description": "Enhanced exploration by diversifying DE mutation strategy and increasing population diversity.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.9  # modified mutation factor\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]), lb, ub)  # enhanced mutation\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06879 with standard deviation 0.00246.", "error": "", "parent_ids": ["0c7832dd-db0d-4bcb-bc0f-14081fd2392b"], "operator": null, "metadata": {"aucs": [0.0699411463912828, 0.06536883369366953, 0.07105070640780664]}}
{"id": "3efd479b-ee93-4a4d-a019-8a86fe47bc57", "fitness": -Infinity, "name": "ImprovedHybridPSODE", "description": "Introducing adaptive parameters and chaotic maps to HybridPSODE for enhanced convergence and diversity in black box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w = 0.9  # initial inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 2.0  # initial cognitive component\n        self.c2 = 2.0  # initial social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size * 100)  # Generate a chaotic sequence for randomness\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.7  # Initial value\n        r = 3.9  # Chaotic parameter\n        sequence = []\n        for _ in range(length):\n            x = r * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n        chaotic_index = 0\n\n        while evaluations < self.budget:\n            # Dynamic adaptation of parameters\n            self.w = self.w_min + (0.5 * (self.budget - evaluations) / self.budget)\n            self.c1 = 2 - evaluations / self.budget\n            self.c2 = 2 + evaluations / self.budget\n\n            # PSO Component with chaotic randomness\n            r1 = self.chaotic_sequence[chaotic_index:chaotic_index+self.population_size*self.dim].reshape((self.population_size, self.dim))\n            chaotic_index += self.population_size * self.dim\n            r2 = self.chaotic_sequence[chaotic_index:chaotic_index+self.population_size*self.dim].reshape((self.population_size, self.dim))\n            chaotic_index += self.population_size * self.dim\n\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component with chaotic randomness\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = self.chaotic_sequence[chaotic_index:chaotic_index+self.dim] < self.crossover_rate\n                chaotic_index += self.dim\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 4, "feedback": "An exception occurred: ValueError('cannot reshape array of size 0 into shape (16,10)').", "error": "ValueError('cannot reshape array of size 0 into shape (16,10)')", "parent_ids": ["0c7832dd-db0d-4bcb-bc0f-14081fd2392b"], "operator": null, "metadata": {}}
{"id": "e2517ade-28d2-4963-9112-c470b2538783", "fitness": 0.04301856070367246, "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE utilizing adaptive parameters and a local search mechanism for improved convergence on black box optimization problems.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_initial = 0.9\n        self.w_final = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor_initial = 0.9\n        self.mutation_factor_final = 0.5\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight and mutation factor\n            progress_ratio = evaluations / self.budget\n            w = self.w_initial - (self.w_initial - self.w_final) * progress_ratio\n            mutation_factor = self.mutation_factor_initial - (self.mutation_factor_initial - self.mutation_factor_final) * progress_ratio\n\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component with local search\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                # Local search strategy: perturb the trial solution slightly\n                if evaluations < self.budget:\n                    local_trial = np.clip(trial + np.random.normal(0, 0.01, self.dim), lb, ub)\n                    local_trial_val = func(local_trial)\n                    evaluations += 1\n\n                    if local_trial_val < trial_val:\n                        personal_best_pos[i] = local_trial\n                        personal_best_val[i] = local_trial_val\n\n                        if local_trial_val < personal_best_val[global_best_idx]:\n                            global_best_idx = i\n                            global_best_pos = local_trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04302 with standard deviation 0.00472.", "error": "", "parent_ids": ["0c7832dd-db0d-4bcb-bc0f-14081fd2392b"], "operator": null, "metadata": {"aucs": [0.04757945908777361, 0.03651252542419481, 0.044963697599048946]}}
{"id": "51bc34ab-be82-4965-b8cc-1f8c7d1b8a41", "fitness": 0.057456272773811046, "name": "HybridPSODE", "description": "Enhanced Hybrid PSODE with adaptive inertial weight strategy for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w = 0.9  # Initial inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = self.w_min + (0.9 - self.w_min) * ((self.budget - evaluations) / self.budget)\n\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05746 with standard deviation 0.00063.", "error": "", "parent_ids": ["0c7832dd-db0d-4bcb-bc0f-14081fd2392b"], "operator": null, "metadata": {"aucs": [0.05780989017533911, 0.05657675125226569, 0.05798217689382834]}}
{"id": "f4259380-d8d7-41fd-baf5-a038b201c097", "fitness": 0.0760748861608644, "name": "RefinedHybridPSODE", "description": "A refined hybrid Particle Swarm Optimization (PSO) with Differential Evolution (DE) incorporating adaptive parameters and chaotic initialization to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 7, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07607 with standard deviation 0.01373.", "error": "", "parent_ids": ["0c7832dd-db0d-4bcb-bc0f-14081fd2392b"], "operator": null, "metadata": {"aucs": [0.06778903972029904, 0.06501475700723558, 0.0954208617550586]}}
{"id": "8334d21e-e09e-47f0-bc41-dac196f84a27", "fitness": 0.07792967436290936, "name": "RefinedHybridPSODE", "description": "Enhanced hybrid PSO with DE by tuning mutation factor dynamically based on progress, improving exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.sin(evaluations * np.pi / self.budget)  # Dynamic mutation factor\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 8, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07793 with standard deviation 0.01277.", "error": "", "parent_ids": ["f4259380-d8d7-41fd-baf5-a038b201c097"], "operator": null, "metadata": {"aucs": [0.06527024056612285, 0.07309792076754662, 0.0954208617550586]}}
{"id": "8e77b84c-9aab-4228-9fa1-99bfce511178", "fitness": 0.07643704621739122, "name": "RefinedHybridPSODE", "description": "Enhanced hybrid PSO with DE by adjusting inertia weight non-linearly, improving convergence speed.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.power(evaluations / self.budget, 2)  # Non-linear inertia weight\n            self.mutation_factor = 0.5 + 0.3 * np.sin(evaluations * np.pi / self.budget)  # Dynamic mutation factor\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 9, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07644 with standard deviation 0.01391.", "error": "", "parent_ids": ["8334d21e-e09e-47f0-bc41-dac196f84a27"], "operator": null, "metadata": {"aucs": [0.06247207755645301, 0.07141819934066207, 0.0954208617550586]}}
{"id": "d4b7d699-5d10-4043-b531-88aa7f9caf35", "fitness": -Infinity, "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSO-DE with Lévy Flight and Chaos Enhancement utilizes chaotic map initialization and Lévy flight perturbation to improve exploration, while dynamically adjusting mutation factor and inertia weight for better convergence.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            mutation_factor = 0.5 + 0.3 * np.sin(evaluations * np.pi / self.budget)  # Dynamic mutation factor\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population += velocities + self.levy_flight((self.population_size, self.dim))\n            population = np.clip(population, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 10, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["8334d21e-e09e-47f0-bc41-dac196f84a27"], "operator": null, "metadata": {}}
{"id": "34a0a9ed-fe92-4373-9793-a92b98d938c1", "fitness": 0.07643704621739122, "name": "RefinedHybridPSODE", "description": "Introduced nonlinear damping to inertia weight for adaptive convergence control in RefinedHybridPSODE.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * ((evaluations / self.budget)**2)  # Nonlinear inertia weight\n            self.mutation_factor = 0.5 + 0.3 * np.sin(evaluations * np.pi / self.budget)  # Dynamic mutation factor\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 11, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07644 with standard deviation 0.01391.", "error": "", "parent_ids": ["8334d21e-e09e-47f0-bc41-dac196f84a27"], "operator": null, "metadata": {"aucs": [0.06247207755645301, 0.07141819934066207, 0.0954208617550586]}}
{"id": "4e0a7c2a-a9ff-4d14-8015-c0a25fff351a", "fitness": 0.07685993043450019, "name": "RefinedHybridPSODE", "description": "Introduced adaptive crossover rate oscillating with time to enhance diversification and intensify convergence.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.sin(evaluations * np.pi / self.budget)  # Dynamic mutation factor\n            self.crossover_rate = 0.7 + 0.2 * np.cos(evaluations * np.pi / self.budget)  # Adaptive crossover rate\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 12, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07686 with standard deviation 0.01354.", "error": "", "parent_ids": ["8334d21e-e09e-47f0-bc41-dac196f84a27"], "operator": null, "metadata": {"aucs": [0.06376780650407166, 0.07129755587792508, 0.09551442892150386]}}
{"id": "aebae6c6-ecff-4579-963c-6ae4c3b46988", "fitness": 0.07643704621739122, "name": "RefinedHybridPSODE", "description": "Introduced a non-linear decrement strategy for inertia weight to enhance convergence dynamics.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * ((evaluations / self.budget) ** 2)  # Non-linear decrement\n            self.mutation_factor = 0.5 + 0.3 * np.sin(evaluations * np.pi / self.budget)  # Dynamic mutation factor\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 13, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07644 with standard deviation 0.01391.", "error": "", "parent_ids": ["8334d21e-e09e-47f0-bc41-dac196f84a27"], "operator": null, "metadata": {"aucs": [0.06247207755645301, 0.07141819934066207, 0.0954208617550586]}}
{"id": "87eb73fb-44cb-4740-890f-282738e56def", "fitness": 0.07643704621739122, "name": "RefinedHybridPSODE", "description": "Improved the inertia weight decay to a nonlinear approach to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Nonlinear inertia weight decay for improved balance\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2\n            self.mutation_factor = 0.5 + 0.3 * np.sin(evaluations * np.pi / self.budget)  # Dynamic mutation factor\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 14, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07644 with standard deviation 0.01391.", "error": "", "parent_ids": ["8334d21e-e09e-47f0-bc41-dac196f84a27"], "operator": null, "metadata": {"aucs": [0.06247207755645301, 0.07141819934066207, 0.0954208617550586]}}
{"id": "d4ceb08c-52cf-496e-a322-6b904e8b8629", "fitness": 0.07372062809701933, "name": "EnhancedAdaptiveHybridPSODE", "description": "Introduce adaptive inertia weight and opposition-based learning to enhance convergence speed and diversity in the hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def opposition_based_learning(self, population, lb, ub):\n        opp_population = lb + ub - population\n        return np.clip(opp_population, lb, ub)\n    \n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_min + (self.w_max - self.w_min) * ((self.budget - evaluations) / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.sin(evaluations * np.pi / self.budget)\n            \n            # Apply opposition-based learning\n            opp_population = self.opposition_based_learning(population, lb, ub)\n            opp_values = np.array([func(ind) for ind in opp_population])\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if opp_values[i] < personal_best_val[i]:\n                    personal_best_pos[i] = opp_population[i]\n                    personal_best_val[i] = opp_values[i]\n                    if opp_values[i] < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = opp_population[i]\n\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_pos", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07372 with standard deviation 0.01534.", "error": "", "parent_ids": ["8334d21e-e09e-47f0-bc41-dac196f84a27"], "operator": null, "metadata": {"aucs": [0.06273111718285063, 0.06300990535314877, 0.0954208617550586]}}
{"id": "d5d363ef-dd31-46ec-a3dc-81b26478a730", "fitness": 0.0848156470215851, "name": "RefinedHybridPSODE", "description": "Integrate adaptive velocity scaling in PSO and varied crossover rate in DE to enhance convergence.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.3 * np.sin(evaluations * np.pi / self.budget)  # Dynamic mutation factor\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            velocity_scaling = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            velocities *= velocity_scaling\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 16, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08482 with standard deviation 0.01036.", "error": "", "parent_ids": ["8334d21e-e09e-47f0-bc41-dac196f84a27"], "operator": null, "metadata": {"aucs": [0.07129870077060185, 0.08667423619872883, 0.09647400409542461]}}
{"id": "488b29d1-84bf-4ed7-9316-c257990b37f6", "fitness": 0.0890736996038245, "name": "EnhancedHybridPSODE", "description": "Introduce a dynamic inertia weight decay and adaptive scaling in differential mutation to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)  # Dynamic inertia\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget)  # Adjusted mutation factor for adaptive exploration\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            velocity_scaling = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            velocities *= velocity_scaling\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08907 with standard deviation 0.00620.", "error": "", "parent_ids": ["d5d363ef-dd31-46ec-a3dc-81b26478a730"], "operator": null, "metadata": {"aucs": [0.08121927546630614, 0.08962415530188339, 0.09637766804328396]}}
{"id": "0230427a-9ff7-4f9e-a2c4-bd846e838801", "fitness": 0.08733405918290475, "name": "EnhancedHybridPSODE", "description": "Refining the balance between exploration and exploitation by subtly adjusting the cognitive component for improved convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.6  # cognitive component (slightly increased for better personal learning)\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)  # Dynamic inertia\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget)  # Adjusted mutation factor for adaptive exploration\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            velocity_scaling = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            velocities *= velocity_scaling\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08733 with standard deviation 0.00891.", "error": "", "parent_ids": ["488b29d1-84bf-4ed7-9316-c257990b37f6"], "operator": null, "metadata": {"aucs": [0.0752784332585309, 0.09019827963884974, 0.0965254646513336]}}
{"id": "a6c5bc6e-db38-4351-99cd-e9b357a73a00", "fitness": 0.05778247187357888, "name": "EnhancedHybridPSODE", "description": "Incorporate an adaptive chaotic perturbation mechanism and time-varying cognitive-social coefficients to dynamically enhance search space exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1_start = 2.5\n        self.c1_end = 1.5\n        self.c2_start = 0.5\n        self.c2_end = 2.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def adaptive_chaos(self, x, iteration, max_iterations):\n        beta = 0.5 * (1 + np.cos(np.pi * iteration / max_iterations))\n        return x * (1 - beta) + beta * (4 * x * (1 - x))\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget)\n            c1 = self.c1_start - (self.c1_start - self.c1_end) * (evaluations / self.budget)\n            c2 = self.c2_start + (self.c2_end - self.c2_start) * (evaluations / self.budget)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (personal_best_pos - population)\n                          + c2 * r2 * (global_best_pos - population))\n            velocity_scaling = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            velocities *= velocity_scaling\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial = self.adaptive_chaos(trial, evaluations, self.budget)\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05778 with standard deviation 0.03099.", "error": "", "parent_ids": ["488b29d1-84bf-4ed7-9316-c257990b37f6"], "operator": null, "metadata": {"aucs": [0.019512533367035068, 0.05841402049864297, 0.0954208617550586]}}
{"id": "0aaa85e2-f6ed-469f-a1c9-bb8fe050e569", "fitness": 0.0868097635684862, "name": "EnhancedHybridPSODE", "description": "Refine the crossover rate decay for increased diversity in later stages of optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)  # Dynamic inertia\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget)  # Adjusted mutation factor for adaptive exploration\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            velocity_scaling = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            velocities *= velocity_scaling\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (0.5 + 0.5 * (1 - evaluations / self.budget))  # Adjusted decay\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08681 with standard deviation 0.00886.", "error": "", "parent_ids": ["488b29d1-84bf-4ed7-9316-c257990b37f6"], "operator": null, "metadata": {"aucs": [0.07513179055139008, 0.08871633122901768, 0.09658116892505086]}}
{"id": "23db54f3-04f2-4e6c-8fc5-0589ad4cf788", "fitness": 0.0892365415002813, "name": "EnhancedHybridPSODE", "description": "Introduce velocity deceleration near the budget limit for smoother convergence and improved exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)  # Dynamic inertia\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget)  # Adjusted mutation factor for adaptive exploration\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            velocity_scaling = 0.1 + 0.9 * (1 - evaluations / self.budget)**2  # Modified to decelerate near budget limit\n            velocities *= velocity_scaling\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08924 with standard deviation 0.00632.", "error": "", "parent_ids": ["488b29d1-84bf-4ed7-9316-c257990b37f6"], "operator": null, "metadata": {"aucs": [0.0812784667007912, 0.08968682808174311, 0.0967443297183096]}}
{"id": "267fb132-174c-421c-a6ce-0924165b1885", "fitness": 0.0852040438872697, "name": "EnhancedHybridPSODE", "description": "Introduce adaptive cognitive and social components to balance exploration and exploitation during the optimization process.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)  # Dynamic inertia\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget)  # Adjusted mutation factor for adaptive exploration\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            adaptive_c1 = self.c1 * (1 - evaluations / self.budget)  # Adaptive cognitive component\n            adaptive_c2 = self.c2 * (evaluations / self.budget)  # Adaptive social component\n            velocities = (w * velocities \n                          + adaptive_c1 * r1 * (personal_best_pos - population)\n                          + adaptive_c2 * r2 * (global_best_pos - population))\n            velocity_scaling = 0.1 + 0.9 * (1 - evaluations / self.budget)**2  # Modified to decelerate near budget limit\n            velocities *= velocity_scaling\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08520 with standard deviation 0.01017.", "error": "", "parent_ids": ["23db54f3-04f2-4e6c-8fc5-0589ad4cf788"], "operator": null, "metadata": {"aucs": [0.07165053654421105, 0.087825692001955, 0.09613590311564302]}}
{"id": "4a424217-924c-42e1-8d27-4711d472a907", "fitness": 0.08663061992254568, "name": "EnhancedHybridPSODE", "description": "Refine inertia weight adaptation to better balance exploration and exploitation across the optimization process.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * ((evaluations / self.budget)**2)  # Modified dynamic inertia weight strategy\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget)  # Adjusted mutation factor for adaptive exploration\n            # PSO Component\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            velocity_scaling = 0.1 + 0.9 * (1 - evaluations / self.budget)**2  # Modified to decelerate near budget limit\n            velocities *= velocity_scaling\n            population = np.clip(population + velocities, lb, ub)\n\n            # DE Component\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08663 with standard deviation 0.00864.", "error": "", "parent_ids": ["23db54f3-04f2-4e6c-8fc5-0589ad4cf788"], "operator": null, "metadata": {"aucs": [0.07534107113814459, 0.08821913407169224, 0.09633165455780024]}}
{"id": "3da34ee8-ea79-4a97-b419-b8689b677802", "fitness": 0.0904719282517595, "name": "RefinedHybridPSODE", "description": "Introduce adaptive learning rates and a dynamic mutation factor for enhanced diversity and convergence in optimization.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (personal_best_pos - population)\n                          + self.c2 * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 24, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09047 with standard deviation 0.00466.", "error": "", "parent_ids": ["23db54f3-04f2-4e6c-8fc5-0589ad4cf788"], "operator": null, "metadata": {"aucs": [0.08492970558778679, 0.09015059881780085, 0.09633548034969086]}}
{"id": "fe7f22b7-fc78-4736-aa50-c64c3d5c4b50", "fitness": 0.09101368198637554, "name": "RefinedHybridPSODE", "description": "Introduce a linear damping strategy on the cognitive and social components to enhance convergence stability.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            # Updated line for damping cognitive and social components\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 25, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09101 with standard deviation 0.00487.", "error": "", "parent_ids": ["3da34ee8-ea79-4a97-b419-b8689b677802"], "operator": null, "metadata": {"aucs": [0.08494260019867395, 0.09122383200412676, 0.09687461375632589]}}
{"id": "2e4c9d47-93f1-4075-b270-6d02b65b12d1", "fitness": 0.09018633541999355, "name": "RefinedHybridPSODEV2", "description": "Introduce a dynamically adaptive inertia weight and crossover strategy to further enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridPSODEV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Dynamic inertia weight calculation\n            w = self.w_min + (self.w_max - self.w_min) * np.cos(evaluations * np.pi / (2 * self.budget))\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                # Dynamic crossover strategy\n                crossover_rate_varied = self.crossover_rate * np.sin(evaluations * np.pi / (2 * self.budget))\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 26, "feedback": "The algorithm RefinedHybridPSODEV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09019 with standard deviation 0.00701.", "error": "", "parent_ids": ["fe7f22b7-fc78-4736-aa50-c64c3d5c4b50"], "operator": null, "metadata": {"aucs": [0.08039211728781614, 0.09378391474491832, 0.09638297422724618]}}
{"id": "5c49fc1b-2497-4ce3-8c5e-96bddb871fea", "fitness": 0.08495278655187681, "name": "EnhancedHybridPSODE", "description": "Enhance exploration and exploitation balance using adaptive inertia weight and dynamic crossover rate.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # Max inertia weight\n        self.w_min = 0.2  # Min inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            adaptive_w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget)\n            \n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (adaptive_w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (0.5 + 0.5 * np.cos(evaluations * np.pi / self.budget))\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08495 with standard deviation 0.00789.", "error": "", "parent_ids": ["fe7f22b7-fc78-4736-aa50-c64c3d5c4b50"], "operator": null, "metadata": {"aucs": [0.07772729661798705, 0.08120331979560669, 0.09592774324203668]}}
{"id": "6b1e00fc-4cb0-4ae7-9ac9-6ab597a3b8e9", "fitness": 0.08528104440514887, "name": "RefinedHybridPSODE", "description": "Adjust the chaotic map initialization to use a sinusoidal chaotic map for improved initial distribution of particles.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        # Change: Using sinusoidal chaotic map instead of logistic map.\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = np.sin(np.pi * x)  # updated line\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            # Updated line for damping cognitive and social components\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 28, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08528 with standard deviation 0.01405.", "error": "", "parent_ids": ["fe7f22b7-fc78-4736-aa50-c64c3d5c4b50"], "operator": null, "metadata": {"aucs": [0.09375437881338733, 0.09661121778087411, 0.06547753662118516]}}
{"id": "95c6af95-60d5-4191-a23b-15797ee9bb29", "fitness": 0.08982494731794759, "name": "RefinedHybridPSODE", "description": "Refine the mutation strategy by incorporating a dynamic mutation factor to enhance exploration capabilities as the optimization progresses.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            # Updated line for damping cognitive and social components\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Change mutation strategy to include dynamic factor\n                dynamic_mutation_factor = self.mutation_factor * (1 - 0.5 * evaluations / self.budget)\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 29, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08982 with standard deviation 0.00503.", "error": "", "parent_ids": ["fe7f22b7-fc78-4736-aa50-c64c3d5c4b50"], "operator": null, "metadata": {"aucs": [0.08490966912812437, 0.08782715254721496, 0.09673802027850342]}}
{"id": "e3ff7158-8ed5-45ba-afef-7a91fa614679", "fitness": 0.09101368198637554, "name": "RefinedHybridPSODE", "description": "Introduce a cyclical variation in the inertia weight to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            # Updated line for damping cognitive and social components\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 30, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09101 with standard deviation 0.00487.", "error": "", "parent_ids": ["fe7f22b7-fc78-4736-aa50-c64c3d5c4b50"], "operator": null, "metadata": {"aucs": [0.08494260019867395, 0.09122383200412676, 0.09687461375632589]}}
{"id": "9472e38e-0d10-4eae-837d-2f6ac610c306", "fitness": 0.0915550034964578, "name": "RefinedHybridPSODE", "description": "Enhance mutation strategy with a chaotic scaling factor to improve exploration.  ", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            # Updated line for damping cognitive and social components\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 31, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09156 with standard deviation 0.00572.", "error": "", "parent_ids": ["fe7f22b7-fc78-4736-aa50-c64c3d5c4b50"], "operator": null, "metadata": {"aucs": [0.08354441972568039, 0.09461973493507037, 0.09650085582862267]}}
{"id": "b6eec9ad-5c90-4380-a684-977b51bdd355", "fitness": 0.09134945927534384, "name": "RefinedHybridPSODE", "description": "Introduces adaptive inertia weight to enhance dynamic balancing between exploration and exploitation.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            # Updated line for adaptive inertia weight\n            w = self.w_min + (self.w_max - self.w_min) * np.exp(-5 * (evaluations / self.budget))\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 32, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09135 with standard deviation 0.00655.", "error": "", "parent_ids": ["9472e38e-0d10-4eae-837d-2f6ac610c306"], "operator": null, "metadata": {"aucs": [0.08214234180756497, 0.09505107439318816, 0.0968549616252784]}}
{"id": "b0da071f-b1ae-478f-bef7-b6b160c1c49b", "fitness": 0.09228153396018964, "name": "RefinedHybridPSODE", "description": "Introduce a decay factor in the inertia weight to fine-tune the exploration-exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            # Updated line to add decay factor in inertia weight\n            decay_factor = 0.97  # New decay factor for inertia weight\n            w *= decay_factor\n\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 33, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09228 with standard deviation 0.00522.", "error": "", "parent_ids": ["9472e38e-0d10-4eae-837d-2f6ac610c306"], "operator": null, "metadata": {"aucs": [0.08493857659662885, 0.0953276037499804, 0.09657842153395968]}}
{"id": "d285dcb2-5602-4fb2-a60a-2f8295bee379", "fitness": 0.0923732092804962, "name": "RefinedHybridPSODE", "description": "Introduce an adaptive decay factor in inertia weight based on remaining evaluations for improved balance.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight (reduced from 0.4 for more exploration)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            # Updated line to add adaptive decay factor in inertia weight\n            decay_factor = 0.97 + 0.03 * evaluations / self.budget  # Adaptive decay factor\n\n            w *= decay_factor\n\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 34, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09237 with standard deviation 0.00470.", "error": "", "parent_ids": ["b0da071f-b1ae-478f-bef7-b6b160c1c49b"], "operator": null, "metadata": {"aucs": [0.0857554280176559, 0.09512684276567263, 0.09623735705816006]}}
{"id": "68567a6d-cdba-4cd3-840f-0086f27d5c80", "fitness": 0.09215817361500367, "name": "RefinedDynamicChaosPSODE", "description": "Introduce dynamic chaos-based mutation and crossover rates improving adaptability and diversity throughout iterations.", "code": "import numpy as np\n\nclass RefinedDynamicChaosPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            # Adaptive decay factor in inertia weight\n            decay_factor = 0.97 + 0.03 * evaluations / self.budget\n\n            w *= decay_factor\n\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                dynamic_mutation_factor = self.mutation_factor * (0.5 + 0.5 * np.cos(evaluations * np.pi / self.budget))\n                mutant = np.clip(a + dynamic_mutation_factor * chaos_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget) * np.cos(evaluations * np.pi / (2 * self.budget))\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 35, "feedback": "The algorithm RefinedDynamicChaosPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09216 with standard deviation 0.00483.", "error": "", "parent_ids": ["d285dcb2-5602-4fb2-a60a-2f8295bee379"], "operator": null, "metadata": {"aucs": [0.08543221142245694, 0.09450436992902833, 0.09653793949352574]}}
{"id": "a6027ccd-ba9f-4ca8-855d-755b27a748a1", "fitness": -Infinity, "name": "RefinedHybridPSODes", "description": "Introduce a dynamic population resizing strategy for adaptive exploration-exploitation balance throughout the optimization process.", "code": "import numpy as np\n\nclass RefinedHybridPSODes:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        population_size = self.initial_population_size\n        chaos_population = self.chaotic_map_init(population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = population_size\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n            \n            decay_factor = 0.97 + 0.03 * evaluations / self.budget\n            w *= decay_factor\n\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(population_size, self.dim), np.random.rand(population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (0.1 + 0.9 * (1 - evaluations / self.budget)**2)\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamically adjust population size\n            if evaluations < self.budget / 2:\n                population_size = int(self.initial_population_size * (1 + evaluations / self.budget))\n            else:\n                population_size = max(int(self.initial_population_size * (2 - evaluations / self.budget)), 4)\n            \n            population = population[:population_size]\n            velocities = velocities[:population_size]\n            personal_best_pos = personal_best_pos[:population_size]\n            personal_best_val = personal_best_val[:population_size]\n\n        return global_best_pos", "configspace": "", "generation": 36, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (17,10) (16,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (17,10) (16,10) ')", "parent_ids": ["d285dcb2-5602-4fb2-a60a-2f8295bee379"], "operator": null, "metadata": {}}
{"id": "cba1feef-765a-4be4-8fc5-e2aca4f1cc0c", "fitness": 0.09389170659743067, "name": "RefinedDynamicLearningPSODE", "description": "Integrate a dynamic learning rate that adjusts based on convergence speed to enhance exploration and exploitation in PSO-DE.", "code": "import numpy as np\n\nclass RefinedDynamicLearningPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n        prev_global_best_val = personal_best_val[global_best_idx]\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n            decay_factor = 0.97 + 0.03 * evaluations / self.budget\n            w *= decay_factor\n\n            # Dynamic learning rate adjustment\n            convergence_speed = abs(personal_best_val[global_best_idx] - prev_global_best_val)\n            dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n            prev_global_best_val = personal_best_val[global_best_idx]\n\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 37, "feedback": "The algorithm RefinedDynamicLearningPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09389 with standard deviation 0.00241.", "error": "", "parent_ids": ["d285dcb2-5602-4fb2-a60a-2f8295bee379"], "operator": null, "metadata": {"aucs": [0.09105278680021966, 0.09368547945333705, 0.09693685353873527]}}
{"id": "81f58657-f881-491a-b9b3-e1b7d451654b", "fitness": 0.09389170659743067, "name": "RefinedDynamicLearningPSODE", "description": "Introduced a chaotic mutation factor that varies sinusoidally to enhance diversity and convergence.", "code": "import numpy as np\n\nclass RefinedDynamicLearningPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n        prev_global_best_val = personal_best_val[global_best_idx]\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n            decay_factor = 0.97 + 0.03 * evaluations / self.budget\n            w *= decay_factor\n\n            # Dynamic learning rate adjustment\n            convergence_speed = abs(personal_best_val[global_best_idx] - prev_global_best_val)\n            dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n            prev_global_best_val = personal_best_val[global_best_idx]\n\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 38, "feedback": "The algorithm RefinedDynamicLearningPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09389 with standard deviation 0.00241.", "error": "", "parent_ids": ["cba1feef-765a-4be4-8fc5-e2aca4f1cc0c"], "operator": null, "metadata": {"aucs": [0.09105278680021966, 0.09368547945333705, 0.09693685353873527]}}
{"id": "e7031d1a-fb96-4a1f-9a9c-92fab57a310f", "fitness": 0.0938736269774848, "name": "RefinedDynamicLearningPSODE", "description": "Integrate chaotic velocity initialization with dynamic learning rate adjustment for enhanced convergence in PSO-DE.", "code": "import numpy as np\n\nclass RefinedDynamicLearningPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.2  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n        population = lb + (ub - lb) * chaos_population\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim)) * chaos_population  # Chaotic velocity initialization\n        personal_best_pos = np.copy(population)\n        personal_best_val = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_val)\n        global_best_pos = personal_best_pos[global_best_idx]\n        \n        evaluations = self.population_size\n        prev_global_best_val = personal_best_val[global_best_idx]\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n            adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n            self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n            decay_factor = 0.97 + 0.03 * evaluations / self.budget\n            w *= decay_factor\n\n            # Dynamic learning rate adjustment\n            convergence_speed = abs(personal_best_val[global_best_idx] - prev_global_best_val)\n            dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n            prev_global_best_val = personal_best_val[global_best_idx]\n\n            c_damp = 1 - evaluations / self.budget\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * c_damp * r1 * (personal_best_pos - population)\n                          + self.c2 * c_damp * r2 * (global_best_pos - population))\n            velocities *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n            population = np.clip(population + velocities, lb, ub)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_rate_varied\n                trial = np.where(crossover, mutant, population[i])\n                trial_val = func(trial)\n                evaluations += 1\n\n                if trial_val < personal_best_val[i]:\n                    personal_best_pos[i] = trial\n                    personal_best_val[i] = trial_val\n\n                    if trial_val < personal_best_val[global_best_idx]:\n                        global_best_idx = i\n                        global_best_pos = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best_pos", "configspace": "", "generation": 39, "feedback": "The algorithm RefinedDynamicLearningPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09387 with standard deviation 0.00243.", "error": "", "parent_ids": ["cba1feef-765a-4be4-8fc5-e2aca4f1cc0c"], "operator": null, "metadata": {"aucs": [0.0909822572393294, 0.09370451984680106, 0.09693410384632395]}}
{"id": "de1cf965-9bb6-4c61-b22c-a52ab0105eb8", "fitness": 0.09463524698568464, "name": "EnhancedMultiSwarmPSODE", "description": "Enhance exploration and exploitation by integrating a multi-swarm strategy with adaptive learning rates in PSO-DE.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09464 with standard deviation 0.00130.", "error": "", "parent_ids": ["cba1feef-765a-4be4-8fc5-e2aca4f1cc0c"], "operator": null, "metadata": {"aucs": [0.09469123565869753, 0.09301506181694952, 0.09619944348140685]}}
{"id": "2f7ac9ae-baab-429a-9455-4877667955d0", "fitness": 0.09418641601123352, "name": "EnhancedMultiSwarmPSODE", "description": "Adjust the mutation factor to enhance exploration.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.cos(evaluations * np.pi / self.budget) * adaptive_lr  # Adjusted line\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09419 with standard deviation 0.00138.", "error": "", "parent_ids": ["de1cf965-9bb6-4c61-b22c-a52ab0105eb8"], "operator": null, "metadata": {"aucs": [0.09302183671876318, 0.09341715666078487, 0.09612025465415253]}}
{"id": "ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d", "fitness": 0.0947087299964422, "name": "EnhancedMultiSwarmPSODE", "description": "Enhance exploration by introducing random perturbations in velocities to break local optima traps.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09471 with standard deviation 0.00118.", "error": "", "parent_ids": ["de1cf965-9bb6-4c61-b22c-a52ab0105eb8"], "operator": null, "metadata": {"aucs": [0.09467047467645318, 0.09328653392976649, 0.09616918138310693]}}
{"id": "3b8ccf27-5764-4928-ba8d-f602e976a12a", "fitness": 0.09438738449582713, "name": "EnhancedMultiSwarmPSODE", "description": "Introduce adaptive chaos factor to dynamically adjust search behavior for improved convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget) * (1 - overall_best_val / max(swarm[\"personal_best_val\"]))\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09439 with standard deviation 0.00120.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09364203862590115, 0.09344176908741075, 0.09607834577416952]}}
{"id": "9588840c-edda-4da7-b56a-dd674549fb66", "fitness": 0.090970068433137, "name": "EnhancedMultiSwarmPSODE", "description": "Improve exploration by introducing a new velocity update term based on opposite positions to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + 0.1 * (lb + ub - swarm[\"population\"])) # Opposite position influence\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09097 with standard deviation 0.00339.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.08720534012396164, 0.09028400342039078, 0.0954208617550586]}}
{"id": "b19af98a-42a5-4449-bafa-556ac1e23bf7", "fitness": 0.09437700246579206, "name": "EnhancedMultiSwarmPSODE", "description": "Integrate an adaptive inertia weight and elite learning strategy to boost convergence by focusing on high-potential search areas.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        elite_learning_rate = 0.2\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                # Adaptive inertia weight\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n                # Elite learning strategy\n                elite_indices = np.argsort(swarm[\"personal_best_val\"])[:int(self.population_size * elite_learning_rate)]\n                elite_positions = swarm[\"personal_best_pos\"][elite_indices]\n                for elite_pos in elite_positions:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    elite_trial = np.clip(elite_pos + perturbation, lb, ub)\n                    elite_trial_val = func(elite_trial)\n                    evaluations += 1\n                    if elite_trial_val < swarm[\"global_best_val\"]:\n                        swarm[\"global_best_pos\"] = elite_trial\n                        swarm[\"global_best_val\"] = elite_trial_val\n                        if elite_trial_val < overall_best_val:\n                            overall_best_val = elite_trial_val\n                            overall_best_pos = elite_trial\n\n        return overall_best_pos", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09438 with standard deviation 0.00109.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09433546262936132, 0.0930599333763612, 0.09573561139165365]}}
{"id": "cb819679-5c92-4071-a167-c9825153b641", "fitness": 0.09081749416739875, "name": "AdaptiveAttractionMultiSwarmPSO", "description": "Introduce adaptive attraction forces in multi-swarm dynamics to enhance convergence by dynamically adjusting particle interactions based on performance.", "code": "import numpy as np\n\nclass AdaptiveAttractionMultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": float('inf'),\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        evaluations = 0\n        overall_best_val = float('inf')\n        overall_best_pos = None\n\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n            evaluations += self.population_size\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                global_contribution = 1 if evaluations < self.budget / 2 else 0.5\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + global_contribution * self.c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                # Adaptive attraction based on swarm performance\n                attraction_strength = 1 + np.tanh(1 - swarm[\"global_best_val\"] / (overall_best_val + 1e-10))\n                swarm[\"velocities\"] *= attraction_strength\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    mutant = a + self.mutation_factor * (b - c)\n                    mutant = np.clip(mutant, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.crossover_rate\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 46, "feedback": "The algorithm AdaptiveAttractionMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09082 with standard deviation 0.00327.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.08810443061904905, 0.08892719012808858, 0.0954208617550586]}}
{"id": "7ca2bda0-efe1-449f-8761-17db3d9ae7bb", "fitness": 0.09470163506370566, "name": "EnhancedMultiSwarmPSODE", "description": "Adjust the probability of random perturbations based on convergence progress to enhance exploration.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities with adaptive probability\n                if np.random.rand() < 0.1 * (1 - evaluations / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09470 with standard deviation 0.00103.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09462954709312144, 0.09347676766927804, 0.0959985904287175]}}
{"id": "cedf7d10-3718-4918-ad08-2a9b9f8a5770", "fitness": 0.09347750432842676, "name": "RefinedEnhancedMultiSwarmPSODE", "description": "Enhance exploration and exploitation in multi-swarm PSO using adaptive chaotic maps and dynamic parameter tuning to maintain diversity and convergence efficiency.", "code": "import numpy as np\n\nclass RefinedEnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.cos(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= dynamic_lr\n\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.cos(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 48, "feedback": "The algorithm RefinedEnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09348 with standard deviation 0.00200.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09122188563092704, 0.09312972407796383, 0.0960809032763894]}}
{"id": "03f9c9d8-a6d5-4c95-90db-10836c6fb48a", "fitness": 0.0939125478869181, "name": "EnhancedMultiSwarmPSODE", "description": "Enhance exploration by introducing chaotic initialization in velocities to diversify search directions.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            # Chaotic initialization for velocities\n            swarm[\"velocities\"] = 2 * self.chaotic_map_init(self.population_size, self.dim) - 1\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09391 with standard deviation 0.00141.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09215017648308965, 0.09398083980084682, 0.0956066273768178]}}
{"id": "6e611d87-44bc-4915-9493-1cc8158eac62", "fitness": 0.09339914327253251, "name": "EnhancedMultiSwarmPSODE", "description": "Introduce a chaotic inertia weight and a dynamic crossover rate to enhance global search and convergence precision in EnhancedMultiSwarmPSODE.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                # Chaotic inertia weight\n                chaos_factor = 0.5 * (1 + np.sin(evaluations * np.pi / self.budget))\n                w = self.w_max - (self.w_max - self.w_min) * chaos_factor\n\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget))\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09340 with standard deviation 0.00177.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09128803676158459, 0.09329183640615912, 0.09561755664985383]}}
{"id": "333f48ea-b36a-4f1f-832d-48656119109e", "fitness": 0.0942203521128427, "name": "EnhancedMultiSwarmPSODE", "description": "Improve convergence by adjusting the mutation factor using a cosine function and introducing diverse initial chaotic sequences.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.cos(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09422 with standard deviation 0.00135.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09395008022485818, 0.09272356555336247, 0.09598741056030746]}}
{"id": "064308aa-2825-4621-afd1-980840daeedb", "fitness": 0.09002780698531003, "name": "EnhancedHybridSwarmDE", "description": "Introduce adaptive memory usage and hybridize with differential evolution to enhance convergence and balance exploration-exploitation efficiently.", "code": "import numpy as np\n\nclass EnhancedHybridSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_size = self.population_size // 2\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf'),\n            \"memory\": np.zeros((self.memory_size, self.dim))\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def update_memory(self, swarm):\n        best_indices = np.argsort(swarm[\"personal_best_val\"])[:self.memory_size]\n        swarm[\"memory\"] = swarm[\"personal_best_pos\"][best_indices]\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                self.update_memory(swarm)\n\n                for i in range(self.population_size):\n                    if evaluations >= self.budget:\n                        break\n\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    d = swarm[\"memory\"][np.random.choice(self.memory_size)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c + d - a), lb, ub)\n                    crossover = np.random.rand(self.dim) < self.crossover_rate\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedHybridSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09003 with standard deviation 0.00430.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.08507610794275133, 0.08944056664395617, 0.09556674636922258]}}
{"id": "e8215a1d-67a6-47ae-a8ab-6f67d56d7394", "fitness": 0.09426940545339797, "name": "EnhancedMultiSwarmPSODE", "description": "Introduce adaptive inertia and dynamic grouping to enhance swarm synergy and convergence precision.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusting the minimum inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                # Adaptive inertia weight strategy\n                w = self.w_max - (self.w_max - self.w_min) * ((overall_best_val - swarm[\"global_best_val\"]) / overall_best_val)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09427 with standard deviation 0.00131.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.0942282164163678, 0.09269193123964159, 0.09588806870418454]}}
{"id": "d29b00d7-18c3-48b4-bcc6-6530fa5e3812", "fitness": 0.09260176561828037, "name": "EnhancedAdaptiveMSPSO", "description": "Incorporate adaptive mutation rates and elite preservation to bolster global search capability while maintaining convergence speed.", "code": "import numpy as np\n\nclass EnhancedAdaptiveMSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n        self.elite_fraction = 0.1\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Elite preservation\n                elite_size = max(1, int(self.elite_fraction * self.population_size))\n                elite_indices = np.argsort(swarm[\"personal_best_val\"])[:elite_size]\n                elite_solutions = swarm[\"personal_best_pos\"][elite_indices]\n\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                # Random perturbations and adaptive mutation\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                \n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    if i not in elite_indices:  # Do not mutate elite solutions\n                        idxs = [idx for idx in range(self.population_size) if idx != i]\n                        a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                        chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                        mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                        crossover = np.random.rand(self.dim) < self.crossover_rate\n                        trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                        trial_val = func(trial)\n                        evaluations += 1\n\n                        if trial_val < swarm[\"personal_best_val\"][i]:\n                            swarm[\"personal_best_pos\"][i] = trial\n                            swarm[\"personal_best_val\"][i] = trial_val\n\n                            if trial_val < swarm[\"global_best_val\"]:\n                                swarm[\"global_best_pos\"] = trial\n                                swarm[\"global_best_val\"] = trial_val\n\n                        if evaluations >= self.budget:\n                            break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedAdaptiveMSPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09260 with standard deviation 0.00224.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09002188783086573, 0.09229063578739238, 0.095492773236583]}}
{"id": "d38a8cb2-6f57-48e7-b8ba-4a872c0bce79", "fitness": 0.0889035153969265, "name": "EnhancedMultiSwarmPSODEImproved", "description": "Enhance exploration by integrating dynamic inertia weights and chaotic perturbations to maintain diversity and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                # Introduce chaotic perturbations in velocities\n                chaotic_perturbation = self.chaotic_map_init(self.population_size, self.dim) - 0.5\n                swarm[\"velocities\"] += 0.1 * chaotic_perturbation\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.c1 * (b - c), lb, ub)\n                    crossover = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 55, "feedback": "The algorithm EnhancedMultiSwarmPSODEImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08890 with standard deviation 0.00517.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.08277467230475521, 0.08851501213096569, 0.0954208617550586]}}
{"id": "e7cdb410-c0bb-48c3-bba4-7d7573384335", "fitness": 0.09183447424282913, "name": "EnhancedMultiSwarmSelfAdaptivePSO", "description": "Enhance exploration and exploitation by integrating a self-adaptive parameter control mechanism with chaotic initialization to improve convergence speed and diversity maintenance.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmSelfAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                dynamic_c1 = self.c1 + 0.5 * (np.sin(2 * np.pi * evaluations / self.budget) + 1)\n                dynamic_c2 = self.c2 + 0.5 * (np.cos(2 * np.pi * evaluations / self.budget) + 1)\n\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + dynamic_c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + dynamic_c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                \n                # Introduce random perturbations in velocities\n                random_perturbation_prob = 0.1 - 0.1 * (evaluations / self.budget)\n                if np.random.rand() < random_perturbation_prob:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    trial_val = func(swarm[\"population\"][i])\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = np.copy(swarm[\"population\"][i])\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = np.copy(swarm[\"population\"][i])\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedMultiSwarmSelfAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09183 with standard deviation 0.00282.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.08957122623682612, 0.09011761017966691, 0.09581458631199435]}}
{"id": "c6fbbdb4-2cd5-442c-b3ad-17c79286faec", "fitness": 0.0889035153969265, "name": "EnhancedMultiSwarmPSODE", "description": "Incorporate adaptive velocity scaling based on swarm diversity to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                velocity_scaling = np.std(swarm[\"population\"], axis=0) # Line 1 changed\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2)) * velocity_scaling # Line 2 changed\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08890 with standard deviation 0.00517.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.08277467230475521, 0.08851501213096569, 0.0954208617550586]}}
{"id": "8dee18bc-da68-4562-8da3-a78c15d3262c", "fitness": 0.09452817122548218, "name": "EnhancedMultiSwarmPSODE", "description": "Enhance exploration by incorporating Lévy flight perturbations in velocities for improved global search capability.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce Lévy flight perturbations in velocities\n                if np.random.rand() < 0.1:\n                    levy_steps = np.random.standard_cauchy(swarm[\"velocities\"].shape)\n                    swarm[\"velocities\"] += 0.1 * levy_steps * swarm[\"velocities\"]\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09453 with standard deviation 0.00108.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09472517078095999, 0.09311846049642603, 0.09574088239906053]}}
{"id": "aae3d97c-aed9-45a1-9827-4b2d2fc67f68", "fitness": 0.09528668088894576, "name": "EnhancedMultiSwarmPSODE", "description": "Introduce swarm synergy through adaptive inter-swarm communication, enhancing convergence by sharing and utilizing inter-swarm global best positions dynamically.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09529 with standard deviation 0.00101.", "error": "", "parent_ids": ["ebb9de8a-9b2c-42a1-b9d4-6eb4932c697d"], "operator": null, "metadata": {"aucs": [0.09403684445420335, 0.09531733300951817, 0.09650586520311577]}}
{"id": "6d39a8be-93b3-4f7c-ba14-46288dfebc09", "fitness": -Infinity, "name": "EnhancedMultiSwarmPSODE", "description": "Integrate adaptive learning strategies and chaotic perturbations to dynamically adjust each swarm's search behavior for accelerated convergence. ", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.3  # Adjusted inertia weight\n        self.c1 = 1.7  # Adjusted cognitive component\n        self.c2 = 1.3  # Adjusted social component\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(abs(swarm[\"global_best_val\"] - overall_best_val))\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 60, "feedback": "An exception occurred: AttributeError(\"'EnhancedMultiSwarmPSODE' object has no attribute 'mutation_factor'\").", "error": "AttributeError(\"'EnhancedMultiSwarmPSODE' object has no attribute 'mutation_factor'\")", "parent_ids": ["aae3d97c-aed9-45a1-9827-4b2d2fc67f68"], "operator": null, "metadata": {}}
{"id": "f885cbe0-668d-40e5-b37d-7a4831e4b01d", "fitness": 0.09508569088899214, "name": "HybridSwarmChaosDE", "description": "Leverage hybrid synergy of swarm-based PSO and chaos-enhanced DE with adaptive hybridization, dynamically switching between exploration and exploitation based on convergence progression.", "code": "import numpy as np\n\nclass HybridSwarmChaosDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.6 + 0.4 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                # Dynamic learning rate adjustment\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed*evaluations/self.budget)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                # Introduce random perturbations in velocities\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 61, "feedback": "The algorithm HybridSwarmChaosDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09509 with standard deviation 0.00090.", "error": "", "parent_ids": ["aae3d97c-aed9-45a1-9827-4b2d2fc67f68"], "operator": null, "metadata": {"aucs": [0.09406838793446537, 0.09493551649269949, 0.09625316823981156]}}
{"id": "39224edc-54d8-45e9-b33d-8c8a60c0c645", "fitness": 0.09541124949472198, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Enhance convergence with multi-strategy collaboration, blending chaos-induced diversity and adaptive memory sharing between swarms to balance exploration-exploitation dynamically.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09541 with standard deviation 0.00045.", "error": "", "parent_ids": ["aae3d97c-aed9-45a1-9827-4b2d2fc67f68"], "operator": null, "metadata": {"aucs": [0.09495911672923774, 0.09525036662414632, 0.09602426513078188]}}
{"id": "04f0dfd7-74ef-4356-98ba-6da980bd8179", "fitness": 0.08901776187015036, "name": "EnhancedDynamicSwarmOptimizer", "description": "Leverage dynamic structure with adaptive swarm parameters and chaotic perturbations to enhance global search efficiency and precision.", "code": "import numpy as np\n\nclass EnhancedDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.memory_sharing_probability = 0.1\n        self.mutation_factor = 0.8\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                chaotic_factor = np.sin(5 * np.pi * (evaluations / self.budget))\n\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * r3 * chaotic_factor * (inter_swarm_best_pos - swarm[\"population\"]))\n\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    if np.random.rand() < self.memory_sharing_probability:\n                        idxs = [idx for idx in range(self.population_size) if idx != i]\n                        a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                        mutant = np.clip(a + self.mutation_factor * chaotic_factor * (b - c), lb, ub)\n                        crossover = np.random.rand(self.dim) < (0.5 + 0.5 * chaotic_factor)\n                        trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                        trial_val = func(trial)\n                        evaluations += 1\n\n                        if trial_val < swarm[\"personal_best_val\"][i]:\n                            swarm[\"personal_best_pos\"][i] = trial\n                            swarm[\"personal_best_val\"][i] = trial_val\n\n                            if trial_val < swarm[\"global_best_val\"]:\n                                swarm[\"global_best_pos\"] = trial\n                                swarm[\"global_best_val\"] = trial_val\n\n                        if evaluations >= self.budget:\n                            break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedDynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08902 with standard deviation 0.00504.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.08311741172442677, 0.08851501213096569, 0.0954208617550586]}}
{"id": "425dd6d9-d691-468a-a24d-3253148b7e3e", "fitness": 0.09336836887355209, "name": "RefinedMultiSwarmPSO", "description": "Refine convergence by incorporating adaptive learning rates and hybrid mutation in a multi-swarm framework to enhance dynamic balance between exploration and exploitation.", "code": "import numpy as np\n\nclass RefinedMultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 + int(2.5 * np.sqrt(dim))\n        self.swarm_count = 4\n        self.w_max = 0.8\n        self.w_min = 0.3\n        self.c1 = 1.7\n        self.c2 = 1.7\n        self.adaptive_factor = 0.9\n        self.memory_sharing_probability = 0.1\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                adaptive_lr = self.adaptive_factor * (1 - (evaluations / self.budget))\n                self.c1 += 0.1 * np.sin(evaluations * np.pi / self.budget)\n                self.c2 -= 0.1 * np.cos(evaluations * np.pi / self.budget)\n\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + adaptive_lr * (b - c), lb, ub)\n                    crossover = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 64, "feedback": "The algorithm RefinedMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09337 with standard deviation 0.00149.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.09277849299550367, 0.09190575187009398, 0.0954208617550586]}}
{"id": "d0846e82-5a3a-4404-920c-bf9882089c1d", "fitness": 0.09541124949472198, "name": "AdaptiveChaoticMultiSwarmPSO", "description": "Introduce adaptive chaotic memory sharing and dynamic inertia scaling in multi-swarm PSO to enhance convergence by optimizing the exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveChaoticMultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 65, "feedback": "The algorithm AdaptiveChaoticMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09541 with standard deviation 0.00045.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.09495911672923774, 0.09525036662414632, 0.09602426513078188]}}
{"id": "1cde05e7-d8f5-4710-8d62-210171c6c504", "fitness": 0.09524729439899915, "name": "RefinedMultiSwarmPSODEPlus", "description": "Integrate adaptive multi-parent crossover and Lévy flight-inspired stochastic disturbances into multi-swarm dynamics for enhanced diversity and convergence control.", "code": "import numpy as np\n\nclass RefinedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1/1.5)\n        return 0.01 * step\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    selected_idxs = np.random.choice(idxs, 3, replace=False)\n                    a, b, c = swarm[\"population\"][selected_idxs]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c) + self.levy_flight(self.dim), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 66, "feedback": "The algorithm RefinedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09525 with standard deviation 0.00083.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.09445646135685748, 0.09489430088284079, 0.09639112095729918]}}
{"id": "c9ccdc40-59e4-4b16-9654-b1b2ae50e3c0", "fitness": 0.06457554222495625, "name": "QuantumLevyEnhancedMultiSwarmPSO", "description": "Integrate quantum-inspired superposition states and a Lévy flight mechanism to enhance exploration and escape local optima while maintaining the strengths of multi-swarm dynamics and adaptive parameters for convergence.", "code": "import numpy as np\n\nclass QuantumLevyEnhancedMultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.levy_alpha = 1.5\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def levy_flight(self, size, alpha):\n        num = np.random.normal(0, 1, size)\n        denom = np.abs(np.random.normal(0, 1, size))**(1/alpha)\n        return num / denom\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)\n            swarm[\"population\"] = chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.1:\n                        levy_step = self.levy_flight(self.dim, self.levy_alpha)\n                        swarm[\"population\"][i] = np.clip(swarm[\"population\"][i] + levy_step, lb, ub)\n\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                    crossover = np.random.rand(self.dim) < self.crossover_rate\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 67, "feedback": "The algorithm QuantumLevyEnhancedMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06458 with standard deviation 0.00441.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.058343902214953114, 0.06756619035136824, 0.06781653410854738]}}
{"id": "d40385f0-b6ab-42ad-8a08-076dd7956cb0", "fitness": 0.0954111487688178, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Introduce adaptive inertia weight scaling triggered by the evaluation count milestone, subtly enhancing exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                if evaluations > self.budget * 0.5:  # Adaptive inertia weight scaling at halfway point\n                    w *= 0.9\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09541 with standard deviation 0.00045.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.09495899029109822, 0.09525036493447836, 0.09602409108087684]}}
{"id": "73763a8a-48c2-4211-b805-4432be447082", "fitness": 0.09399926365309696, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Refine adaptive exploration control by introducing sinusoidal modulation and dynamic crossover, enhancing multi-swarm synergy.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * np.sin((inter_swarm_best_pos - swarm[\"population\"])))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - np.sin(evaluations / self.budget))\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09400 with standard deviation 0.00133.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.09260371327249683, 0.09361021243759815, 0.09578386524919591]}}
{"id": "fa3b9cf1-fed7-4ecc-8da9-e83d8a6bb2ab", "fitness": 0.09505451078343312, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Incorporate dynamic swarm topologies and adaptive chaos scaling for enhanced exploitation and exploration balance.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n                \n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                \n                if evaluations % 2 == 0:  # Adjust swarm topology dynamically\n                    topology_factor = 0.7\n                else:\n                    topology_factor = 1.3\n                \n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"])\n                                       * topology_factor)\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget) * 1.1  # Adjust chaos scaling\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09505 with standard deviation 0.00090.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.09420702156579952, 0.09464911550685007, 0.09630739527764975]}}
{"id": "78cc1d56-06c8-418a-b346-8351b86b64e2", "fitness": 0.09509725489623329, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Fine-tune velocity update via chaos-augmented inertia and introduce stochastic crossover adjustments for dynamic adaptability.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                chaos_inertia = 0.3 + 0.1 * np.sin(evaluations * np.pi / self.budget)  # changed line 1\n                swarm[\"velocities\"] = (chaos_inertia * self.w_max * swarm[\"velocities\"]  # changed line 2\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    stochastic_crossover = np.random.uniform() * self.crossover_rate  # changed line 3\n                    crossover = np.random.rand(self.dim) < stochastic_crossover  # changed line 4\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09510 with standard deviation 0.00073.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.09497517112142406, 0.09427052190883423, 0.09604607165844159]}}
{"id": "600825be-60d5-43de-b329-62eb1aa855d7", "fitness": 0.0955407309260801, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Improve convergence by introducing a dynamic chaos sequence adjustment and refined velocity noise addition for enhanced exploration.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09554 with standard deviation 0.00063.", "error": "", "parent_ids": ["39224edc-54d8-45e9-b33d-8c8a60c0c645"], "operator": null, "metadata": {"aucs": [0.09499325671727321, 0.09520437813597171, 0.09642455792499538]}}
{"id": "fb978f1b-5b00-4591-9682-16035e1a5d5c", "fitness": -Infinity, "name": "AdaptiveLevyChaosPSO", "description": "Improve exploration and convergence by using adaptive velocity updates with Levy flights and chaos-enhanced swarm interactions.", "code": "import numpy as np\n\nclass AdaptiveLevyChaosPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 1.4\n        self.c2 = 1.4\n        self.alpha = 0.01  # Levy flight scaling factor\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v) ** (1 / beta)\n        return self.alpha * step\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                if np.random.rand() < 0.1:\n                    swarm[\"velocities\"] += self.levy_flight((self.population_size, self.dim))\n\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    trial_val = func(swarm[\"population\"][i])\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = swarm[\"population\"][i]\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = swarm[\"population\"][i]\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 73, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {}}
{"id": "57c05a0b-c544-44d5-899d-f230479c990d", "fitness": 0.09338965546869837, "name": "EnhancedMultiSwarmPSODENew", "description": "Introduce a non-linear dynamic velocity adaptation and adaptive mutation control to enhance global exploration and local exploitation balance.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODENew:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 1.7\n        self.c2 = 1.7\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.07\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)**2\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.cos(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - (evaluations / self.budget)**2\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.cos(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.cos(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedMultiSwarmPSODENew got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09339 with standard deviation 0.00216.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09069553312168854, 0.09347937862763123, 0.09599405465677535]}}
{"id": "5c3b683f-b46f-4dea-9953-483e00990a09", "fitness": 0.09550884113318552, "name": "RefinedEnhancedMultiSwarmPSODEPlus", "description": "Integrate a multi-layered chaotic dynamic parameter tuning and adaptive exploration enhancement to achieve better convergence precision in high-dimensional spaces.", "code": "import numpy as np\n\nclass RefinedEnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.1  # Increased sharing probability for better inter-swarm communication\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.2:  # Increased noise addition for enhanced exploration\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 75, "feedback": "The algorithm RefinedEnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09551 with standard deviation 0.00064.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.0949506987532257, 0.09516409726137054, 0.09641172738496029]}}
{"id": "cb65926d-2d0c-4f1c-afd8-bfc6363a78f3", "fitness": 0.09551508090956289, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Increase memory sharing probability to enhance swarm communication and improve convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.1  # Increased from 0.05 to 0.1\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09552 with standard deviation 0.00065.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09499325671727321, 0.09512743943795543, 0.09642454657346]}}
{"id": "da93cefb-9313-4e74-a34a-e905d6ddc563", "fitness": 0.08902549100842043, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Introduce adaptive cognitive and social components to improve convergence dynamics and incorporate non-linear inertia weight decay for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 1.5\n        self.c2_final = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n                c2 = self.c2_initial - (self.c2_initial - self.c2_final) * (evaluations / self.budget)\n\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + c2 * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n\n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08903 with standard deviation 0.00514.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.08283800002169195, 0.08881554058415808, 0.09542293241941124]}}
{"id": "40c3dfe9-b5cb-4ba0-9771-d308b5ca754b", "fitness": 0.09522463957337346, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Introduce adaptive velocity scaling through cosine wave modulation for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                # Modify the velocity update with cosine modulation\n                cosine_modulation = 0.5 + 0.5 * np.cos(evaluations * np.pi / self.budget)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + cosine_modulation * swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09522 with standard deviation 0.00084.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09435667583235197, 0.09495962373166011, 0.0963576191561083]}}
{"id": "e2662e08-93ec-43e2-a615-3d15c9c2ea78", "fitness": 0.09511526370810208, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Adjust inertia weight and mutation factor dynamically to enhance exploration and convergence.  ", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Adjust inertia weight\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(2 * evaluations * np.pi / self.budget) * adaptive_lr  # Adjust mutation factor\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09512 with standard deviation 0.00129.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.0937598100730358, 0.0947366366527348, 0.09684934439853565]}}
{"id": "0a467cc3-126d-4586-a1ce-5cda9f655dec", "fitness": 0.0955407309260801, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Introduced adaptive global best enhancement by dynamically adjusting the memory sharing probability for improved convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                adaptive_memory_sharing_prob = self.memory_sharing_probability * (1 - evaluations / self.budget)\n                if np.random.rand() < adaptive_memory_sharing_prob:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09554 with standard deviation 0.00063.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09499325671727321, 0.09520437813597171, 0.09642455792499538]}}
{"id": "2787b06e-118e-4205-ba5b-8f2a439aaad6", "fitness": 0.0955407309260801, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Introduce an adaptive dynamic mutation factor to enhance exploration capabilities in different search stages.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09554 with standard deviation 0.00063.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09499325671727321, 0.09520437813597171, 0.09642455792499538]}}
{"id": "23c4a36a-3867-430e-b878-d74ca748b48c", "fitness": 0.07802939576590746, "name": "AdaptiveSynergyPSO", "description": "Introduce adaptive swarm synergy and dynamic inertia reduction with perturbation control for a balanced exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass AdaptiveSynergyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.c3 = 0.5  # synergy control coefficient\n        self.memory_sharing_probability = 0.1\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        return np.random.rand(N, D)  # Simplified random initialization\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                r1, r2, r3, r4 = (np.random.rand(self.population_size, self.dim) for _ in range(4))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c3 * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                perturbation_chance = 0.1 * (1 - evaluations / self.budget)\n                if np.random.rand() < perturbation_chance:\n                    perturbation = np.random.uniform(-0.1, 0.1, size=swarm[\"velocities\"].shape)\n                    swarm[\"population\"] += perturbation\n                swarm[\"population\"] = np.clip(swarm[\"population\"], lb, ub)\n\n                for i in range(self.population_size):\n                    trial = swarm[\"population\"][i]\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 82, "feedback": "The algorithm AdaptiveSynergyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07803 with standard deviation 0.00416.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.0839100736159285, 0.07500628927421993, 0.07517182440757397]}}
{"id": "6bd3fcb0-ae27-4c93-8547-afdd2208219a", "fitness": 0.09542576490614622, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Integrate adaptive velocity fine-tuning with inter-swarm communication enhancements to boost convergence and exploration balance.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.7  # Slightly adjusted\n        self.c2 = 1.7  # Slightly adjusted\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.08  # Increased probability\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.15 + 0.05 * np.sin(evaluations * np.pi / self.budget):  # Slightly increased base probability\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09543 with standard deviation 0.00065.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09492895227535059, 0.09500383630940401, 0.09634450613368406]}}
{"id": "43b95192-7801-46e0-af32-77ce4560062a", "fitness": 0.09545922967657039, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Enhance exploration by adjusting the sinusoidal noise addition in velocity updates.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.15 + 0.05 * np.sin(evaluations * np.pi / self.budget):  # Adjusted line\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09546 with standard deviation 0.00067.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.0949506987532257, 0.09501526289152518, 0.09641172738496029]}}
{"id": "880227e3-bf12-4581-af52-e67e7e2b8403", "fitness": 0.09551508090956289, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Fine-tune the memory sharing probability to balance exploration and exploitation for better convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.1  # Adjusted for enhanced performance\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09552 with standard deviation 0.00065.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09499325671727321, 0.09512743943795543, 0.09642454657346]}}
{"id": "a0116de1-2de9-4e1a-a5e7-198828c3a7f3", "fitness": 0.0947757078264216, "name": "RefinedMultiSwarmPSODEPlus", "description": "Enhance swarm exploration and convergence by integrating a dynamic inertia weight schedule and adaptive mutation strategies based on convergence feedback.", "code": "import numpy as np\n\nclass RefinedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.1\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                adaptive_lr = 0.2 + 0.8 * np.cos(evaluations * np.pi / (2 * self.budget))\n                self.mutation_factor = 0.6 + 0.4 * np.tanh(evaluations / self.budget)\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed / (1 + evaluations / self.budget))\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.cos(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 86, "feedback": "The algorithm RefinedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09478 with standard deviation 0.00111.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.0934203360770286, 0.09476335511656142, 0.09614343228567479]}}
{"id": "e1660d5c-72d9-421f-9dcf-2997aa9df1f1", "fitness": 0.08896103050447808, "name": "RefinedMultiSwarmPSO", "description": "Introduce a novel adaptive inertia weight mechanism and neighborhood-best adaptive velocity update, aimed at enhancing convergence and robustness.", "code": "import numpy as np\n\nclass RefinedMultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.neigh_size = int(np.sqrt(self.population_size))\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if evaluations % 5 == 0:\n                    neigh_best = self.get_neighborhood_best(swarm)\n                    swarm[\"global_best_pos\"] = neigh_best\n                    \n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                    crossover = np.random.rand(self.dim) < self.crossover_rate\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos\n\n    def get_neighborhood_best(self, swarm):\n        best_val = float('inf')\n        best_pos = None\n        for i in range(self.population_size):\n            neighbors = [j for j in range(self.population_size) if abs(i - j) <= self.neigh_size // 2]\n            for neighbor in neighbors:\n                if swarm[\"personal_best_val\"][neighbor] < best_val:\n                    best_val = swarm[\"personal_best_val\"][neighbor]\n                    best_pos = swarm[\"personal_best_pos\"][neighbor]\n        return best_pos", "configspace": "", "generation": 87, "feedback": "The algorithm RefinedMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08896 with standard deviation 0.00510.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.08294721762740997, 0.08851501213096569, 0.0954208617550586]}}
{"id": "f87a672e-2e1e-4c42-acd3-204848804027", "fitness": 0.09530477595004132, "name": "AdaptiveChaosDifferentialEvolution", "description": "Incorporate adaptive chaos-enhanced differential mutation and cross-swarm learning for improved convergence and exploration.", "code": "import numpy as np\n\nclass AdaptiveChaosDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.1\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.15 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.tanh(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 88, "feedback": "The algorithm AdaptiveChaosDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09530 with standard deviation 0.00081.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09434432816850735, 0.09524481895220671, 0.09632518072940988]}}
{"id": "93574a6f-a287-4cee-811f-af450e7b0d30", "fitness": 0.09476692860198425, "name": "EnhancedMultiSwarmPSODEPlusV2", "description": "Enhance convergence by incorporating adaptive mutation and crossover rates with entropy-based exploration for better diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlusV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                entropy = -np.sum(swarm[\"population\"] * np.log(swarm[\"population\"] + 1e-10)) / self.population_size\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget) * entropy\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n                dynamic_lr = 0.5 + 0.5 * np.tanh(abs(swarm[\"global_best_val\"] - overall_best_val))\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget) * entropy\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlusV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09477 with standard deviation 0.00071.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09441098576162366, 0.09413586634820703, 0.09575393369612206]}}
{"id": "51864ae7-eb44-47d1-a3e6-3d7ee6d9659d", "fitness": 0.09462981325268575, "name": "AdvancedAdaptiveSwarm", "description": "Enhance convergence by incorporating adaptive learning rates and dynamic population restructuring to maintain a balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.1\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)**0.5\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - (evaluations / self.budget)**0.3\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.15 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 90, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09463 with standard deviation 0.00123.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09373095481381344, 0.09378520889740194, 0.09637327604684187]}}
{"id": "78b74d5f-ffe1-4b3c-8260-6b3885d37a0d", "fitness": 0.09553615785815965, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Enhance the algorithm by adjusting the memory sharing probability dynamically based on the convergence speed.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                self.memory_sharing_probability = 0.1 * np.exp(-convergence_speed)  # Dynamic adjustment line\n\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09554 with standard deviation 0.00063.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09498153511693441, 0.09520216107333646, 0.09642477738420807]}}
{"id": "a41d1234-3d7f-4168-a570-0a9421ae73b8", "fitness": 0.092233299082213, "name": "AdaptiveChaosSwarmOptimizer", "description": "Introduce adaptive mutation with chaotic subpopulation dynamics and diversity-driven exploration to enhance convergence efficiency.", "code": "import numpy as np\n\nclass AdaptiveChaosSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.1\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n                c_damp = 1 - evaluations / self.budget\n                diversity_factor = np.var(np.array([s[\"global_best_val\"] for s in self.swarms]))\n                exploration_factor = 0.5 + 0.5 * np.tanh(diversity_factor)\n\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * exploration_factor * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (exploration_factor * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 92, "feedback": "The algorithm AdaptiveChaosSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09223 with standard deviation 0.00255.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.08960369507425014, 0.09140757896308882, 0.09568862320930005]}}
{"id": "4b7008c2-7b58-43f7-b7d1-c8ccf0d3e68d", "fitness": 0.09505229824576737, "name": "RefinedEnhancedMultiSwarmPSODEPlus", "description": "Enhance swarm interactions and adaptive learning rates using entropy-based velocity adjustments to improve exploration efficiency.", "code": "import numpy as np\n\nclass RefinedEnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.entropy_weighting_factor = 0.1\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def compute_entropy(self, values):\n        probabilities = np.histogram(values, bins=10, range=(0, 1), density=True)[0] + 1e-10\n        probabilities /= probabilities.sum()\n        entropy = -np.sum(probabilities * np.log2(probabilities))\n        return entropy\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n                \n                swarm_entropy = self.compute_entropy(swarm[\"personal_best_val\"])\n                entropy_based_adjustment = 1 + self.entropy_weighting_factor * (swarm_entropy - 0.5)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * entropy_based_adjustment * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 93, "feedback": "The algorithm RefinedEnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09505 with standard deviation 0.00105.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09381826772173563, 0.0949454914350264, 0.09639313558054008]}}
{"id": "3f7670cc-413e-4c80-bf30-f81767a00df0", "fitness": 0.09553846359305022, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Introduced adaptive velocity scaling dependent on budget usage and swarm performance to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1 * (1 - evaluations / self.budget), swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09554 with standard deviation 0.00063.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09499349354062026, 0.09519733781051432, 0.09642455942801609]}}
{"id": "2064e2c6-22f1-47ef-86d9-d45c25ef0c46", "fitness": 0.09549971211272668, "name": "AdvancedSwarmOptimization", "description": "Introduce adaptive chaotic inertia weights and swarm-level multi-velocity scaling to enhance exploration and exploitation balance dynamically.", "code": "import numpy as np\n\nclass AdvancedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * np.sin(np.pi * evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget)\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 95, "feedback": "The algorithm AdvancedSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09550 with standard deviation 0.00054.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09504186608001663, 0.09520245158040341, 0.09625481867775998]}}
{"id": "22591ff0-1ac6-4c63-b469-0f89ab323424", "fitness": 0.09553659105783381, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Improve convergence by tuning adaptive parameters and introducing a Gaussian noise factor, maintaining dynamic chaos and velocity adjustments.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.memory_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.05, swarm[\"velocities\"].shape)  # Reduced noise factor\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09554 with standard deviation 0.00063.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09499377337157355, 0.09519263450891502, 0.09642336529301287]}}
{"id": "a2dffb61-8e19-4171-94e4-aa917a86c13a", "fitness": 0.09393623314869637, "name": "EnhancedMultiSwarmPSODEPlusV2", "description": "Integrate adaptive memory-sharing strategy and convergence-dependent mutation for enhanced swarm adaptability and precision.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlusV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < 0.1 + 0.1 * (1 - evaluations / self.budget):\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + 0.8 * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = 0.9 * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlusV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09394 with standard deviation 0.00134.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09261304223352351, 0.09342315399734513, 0.09577250321522046]}}
{"id": "69697e70-d910-4c05-9c15-6e96c0ea6dbd", "fitness": 0.09475292598580654, "name": "EnhancedMultiSwarmPSODEPlus", "description": "Enhance exploration by introducing adaptive chaotic sequences and dynamically adjusting memory sharing to improve convergence.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory_sharing_probability = 0.05\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                # Line changed for adaptive memory sharing probability\n                if np.random.rand() < self.memory_sharing_probability * (1 - evaluations / self.budget):\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.9 * (1 - evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * np.sin(evaluations * np.pi / self.budget) * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                # Line changed for adaptive chaotic sequences\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) * (0.5 + 0.5 * convergence_speed) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.sin(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.sin(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09475 with standard deviation 0.00085.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.0937536234503672, 0.09467209616484584, 0.09583305834220657]}}
{"id": "7d8875b7-a63a-4c91-8a31-3df0f2b4e474", "fitness": 0.094213052539086, "name": "EnhancedMultiSwarmPSODEPlusRefined", "description": "Introduce adaptive multi-oscillatory learning rates and elitist memory sharing to refine exploration and convergence dynamics.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSODEPlusRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(dim))\n        self.swarm_count = 3\n        self.w_max = 0.9\n        self.w_min = 0.2\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.elite_sharing_probability = 0.1\n        self.swarms = [self.initialize_swarm() for _ in range(self.swarm_count)]\n\n    def initialize_swarm(self):\n        return {\n            \"population\": None,\n            \"velocities\": None,\n            \"personal_best_pos\": None,\n            \"personal_best_val\": None,\n            \"global_best_pos\": None,\n            \"global_best_val\": float('inf')\n        }\n\n    def chaotic_map_init(self, N, D):\n        chaos_seq = np.zeros((N, D))\n        x0 = np.random.rand()\n        for d in range(D):\n            x = x0\n            for n in range(N):\n                x = 4 * x * (1 - x)\n                chaos_seq[n, d] = x\n        return chaos_seq\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        for swarm in self.swarms:\n            chaos_population = self.chaotic_map_init(self.population_size, self.dim)\n            swarm[\"population\"] = lb + (ub - lb) * chaos_population\n            swarm[\"velocities\"] = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            swarm[\"personal_best_pos\"] = np.copy(swarm[\"population\"])\n            swarm[\"personal_best_val\"] = np.array([func(ind) for ind in swarm[\"population\"]])\n            best_idx = np.argmin(swarm[\"personal_best_val\"])\n            swarm[\"global_best_pos\"] = swarm[\"personal_best_pos\"][best_idx]\n            swarm[\"global_best_val\"] = swarm[\"personal_best_val\"][best_idx]\n\n        evaluations = self.swarm_count * self.population_size\n        overall_best_val = min(swarm[\"global_best_val\"] for swarm in self.swarms)\n        overall_best_pos = None\n\n        while evaluations < self.budget:\n            inter_swarm_best_pos = min(self.swarms, key=lambda s: s[\"global_best_val\"])[\"global_best_pos\"]\n            for swarm in self.swarms:\n                if np.random.rand() < self.elite_sharing_probability:\n                    swarm[\"global_best_pos\"] = inter_swarm_best_pos\n                    swarm[\"global_best_val\"] = min(swarm[\"global_best_val\"], min(s[\"global_best_val\"] for s in self.swarms))\n\n                w = self.w_max - (self.w_max - self.w_min) * (evaluations**0.5 / self.budget**0.5)\n                adaptive_lr = 0.1 + 0.8 * np.sin(evaluations * 2 * np.pi / self.budget)\n                self.mutation_factor = 0.5 + 0.5 * adaptive_lr\n\n                convergence_speed = abs(swarm[\"global_best_val\"] - overall_best_val)\n                dynamic_lr = 0.5 + 0.5 * np.tanh(convergence_speed)\n\n                c_damp = 1 - evaluations / self.budget\n                r1, r2, r3 = (np.random.rand(self.population_size, self.dim) for _ in range(3))\n                swarm[\"velocities\"] = (w * swarm[\"velocities\"]\n                                       + self.c1 * c_damp * r1 * (swarm[\"personal_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r2 * (swarm[\"global_best_pos\"] - swarm[\"population\"])\n                                       + self.c2 * c_damp * r3 * (inter_swarm_best_pos - swarm[\"population\"]))\n                swarm[\"velocities\"] *= (dynamic_lr * (0.1 + 0.9 * (1 - evaluations / self.budget)**2))\n                \n                if np.random.rand() < 0.1 + 0.05 * np.cos(evaluations * np.pi / self.budget):\n                    swarm[\"velocities\"] += np.random.normal(0, 0.1, swarm[\"velocities\"].shape)\n                swarm[\"population\"] = np.clip(swarm[\"population\"] + swarm[\"velocities\"], lb, ub)\n\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = swarm[\"population\"][np.random.choice(idxs, 3, replace=False)]\n                    chaos_factor = np.cos(evaluations * np.pi / self.budget)\n                    mutant = np.clip(a + self.mutation_factor * chaos_factor * (b - c), lb, ub)\n                    crossover_rate_varied = self.crossover_rate * (1 - evaluations / self.budget)\n                    crossover = np.random.rand(self.dim) < crossover_rate_varied\n                    trial = np.where(crossover, mutant, swarm[\"population\"][i])\n                    trial_val = func(trial)\n                    evaluations += 1\n\n                    if trial_val < swarm[\"personal_best_val\"][i]:\n                        swarm[\"personal_best_pos\"][i] = trial\n                        swarm[\"personal_best_val\"][i] = trial_val\n\n                        if trial_val < swarm[\"global_best_val\"]:\n                            swarm[\"global_best_pos\"] = trial\n                            swarm[\"global_best_val\"] = trial_val\n\n                    if evaluations >= self.budget:\n                        break\n\n                if swarm[\"global_best_val\"] < overall_best_val:\n                    overall_best_val = swarm[\"global_best_val\"]\n                    overall_best_pos = swarm[\"global_best_pos\"]\n\n        return overall_best_pos", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedMultiSwarmPSODEPlusRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09421 with standard deviation 0.00132.", "error": "", "parent_ids": ["600825be-60d5-43de-b329-62eb1aa855d7"], "operator": null, "metadata": {"aucs": [0.09266227568310414, 0.0940824884358995, 0.09589439349825435]}}
