{"id": "5eb1a5b6-e0ac-409c-a257-52026a748080", "fitness": 0.38482636162009376, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization combined with Differential Evolution to balance exploration and exploitation in optimizing black-box functions.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.35.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.17054391383820366, 0.8200389795746772, 0.16842139304002302, 0.12975046621438646, 0.18479281605283826, 0.15270495278301366, 0.09658530001114507, 0.95448506300738, 0.7752016657877099, 0.8553726484723091, 0.8653112181100672, 0.1387615451304114, 0.7952417792404175, 0.7044223824483185, 0.7170942138165082]}}
{"id": "98f69797-4a55-4d43-9913-338e5f6d0856", "fitness": 0.09925721070891465, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization combined with Differential Evolution using adaptive inertia weight for enhanced convergence in optimizing black-box functions.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9  # Adaptive inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.04.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.13553858894925108, 0.12167008191030948, 0.2026828864252691, 0.1374330329052642, 0.1336674122676319, 0.1226145150049448, 0.08703469798432584, 0.12613280214460842, 0.09943792403408114, 0.08333333933968523, 0.11099021123998098, 0.12097079898877583, 0.13278696883524976, 0.10365595945511152, 0.09939609981933739]}}
{"id": "2f05aaf1-cd16-482b-9987-949322f84802", "fitness": 0.32426632105219055, "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight to improve convergence speed in HybridPSO_DE.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            w = 0.9 - 0.8 * (self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.49521699871287983, 0.11879361873611194, 0.49604095185420805, 0.12195269847874413, 0.17472297678452298, 0.6456289881274321, 0.7061482399332413, 0.7428597342759307, 0.5509622305982953, 0.08333333933968523, 0.7263249392269786, 0.08143849371195155, 0.14145664357324916, 0.635006985560624, 0.5976406872554891]}}
{"id": "f156d3ed-65b3-43e4-bef1-726ee49d1d20", "fitness": 0.23801726600765064, "name": "HybridPSO_DE", "description": "Introducing adaptive inertia weight to enhance the exploration-exploitation balance in the hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            w = 0.9 - 0.7 * (self.evaluations / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.12140400356132519, 0.15085004434762694, 0.1270336338602538, 0.13975849413926478, 0.1524253471960001, 0.14767749012501974, 0.46683927537193326, 0.47579540790880026, 0.17263823124251987, 0.08333333933968523, 0.7163488530057563, 0.6362886253329886, 0.7248212443584776, 0.3468863933435373, 0.1304460421453565]}}
{"id": "89572ecd-9213-4341-8731-4feb5e9cb55a", "fitness": 0.24485935656629962, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization combined with Differential Evolution with adaptively tuned inertia weight to enhance convergence speed and solution precision.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w_max = 0.9  # Maximum inertia weight\n        w_min = 0.4  # Minimum inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            w = w_max - ((w_max - w_min) * (self.evaluations / self.budget))  # Adaptively tuned inertia weight\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.14036987951502333, 0.3544902135465806, 0.3905051530765068, 0.5780836128892267, 0.3336636181427468, 0.2163096569521249, 0.6397387309054013, 0.3741464242294651, 0.4983582088208217, 0.08333333933968523, 0.12971913356043818, 0.0874488808631333, 0.14994134679277216, 0.126328460415416, 0.6269515774021834]}}
{"id": "b3dcbdad-1957-4e86-9e00-06672bed1bb8", "fitness": 0.19745305907821367, "name": "HybridPSO_DE", "description": "An improved hybrid algorithm with an adaptive inertia weight in PSO combined with Differential Evolution for dynamic exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w_max = 0.9  # Maximum inertia weight\n        w_min = 0.4  # Minimum inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Calculate dynamic inertia weight\n            w = w_max - ((w_max - w_min) * (self.evaluations / self.budget))\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1284142694948872, 0.3770109925807965, 0.14488420143964176, 0.13170432523567055, 0.13884835942009643, 0.13145731826114915, 0.4707044001263775, 0.13306663660512497, 0.23825781319798678, 0.08336071801584144, 0.6880306634090526, 0.08508632407065275, 0.4043870084148208, 0.19310482805235385, 0.43294442836535496]}}
{"id": "31a640ed-33d2-42ea-a8df-03012f133a89", "fitness": 0.143450976504992, "name": "HybridPSO_DE", "description": "Slightly increased the inertia weight and cognitive component to enhance exploration in the initial stages.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.8  # Inertia weight (changed from 0.7)\n        c1 = 1.6  # Cognitive component (changed from 1.5)\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.16.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.11401246085622962, 0.1479934613627124, 0.17244979089115975, 0.13061814965682705, 0.2925250465587569, 0.15138499087848778, 0.08452439503343212, 0.7971423458055824, 0.10673978613483381, 0.0849343445242553, 0.12740784943791417, 0.12619896699502176, 0.18921557368402464, 0.09805545861587672, 0.0780180147902596]}}
{"id": "bfc2d099-a888-4bac-a528-f0c5badd606b", "fitness": 0.09925721070891465, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization combined with Differential Evolution, enhanced with dynamic inertia weight adjustment for better convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9  # Adjusted dynamic inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.04.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.13553858894925108, 0.12167008191030948, 0.2026828864252691, 0.1374330329052642, 0.1336674122676319, 0.1226145150049448, 0.08703469798432584, 0.12613280214460842, 0.09943792403408114, 0.08333333933968523, 0.11099021123998098, 0.12097079898877583, 0.13278696883524976, 0.10365595945511152, 0.09939609981933739]}}
{"id": "40c24e6c-a639-4569-bd1d-cf42b35d7627", "fitness": 0.6461264237100651, "name": "HybridPSO_DE", "description": "Introducing a decay factor to the inertia weight for better balance between exploration and exploitation over time.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= decay_rate  # Decay the inertia weight\n        return self.global_best_position", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.37.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8402941861369297, 0.8763037290398475, 0.834518574513228, 0.3907375955483815, 0.7847512455289423, 0.9643973461770781, 0.9323157428828519, 0.9579878479912951, 0.829584676772781, 0.9129858454483634, 0.9273058614456796, 0.8507132406858546, 0.9153195389522873, 0.8567879039451668, 0.8807262442581483]}}
{"id": "ba81691a-f510-4c97-937b-2a2138b4179b", "fitness": 0.6211674311263954, "name": "HybridPSO_DE", "description": "Enhance the exploration phase by adjusting the differential weight (F) slightly to improve convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.85  # Differential weight adjusted for better exploration\n        CR = 0.9  # Crossover probability\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= decay_rate  # Decay the inertia weight\n        return self.global_best_position", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.37.", "error": "", "parent_ids": ["40c24e6c-a639-4569-bd1d-cf42b35d7627"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.20616558413543729, 0.7838115085494882, 0.6805597523360389, 0.7628351512882405, 0.8464018161388278, 0.9035684121921033, 0.8721327479278982, 0.9579878479912951, 0.9628033676401432, 0.7593242595445583, 0.8892822825029532, 0.8953668088559937, 0.9255231188606784, 0.9163856666526595, 0.8934014030371269]}}
{"id": "1dda1314-fafb-47ef-903e-0863fdfa4663", "fitness": 0.6591783635881625, "name": "HybridPSO_DE", "description": "Integrate a dynamic population size strategy for better adaptability to problem landscapes.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= decay_rate  # Decay the inertia weight\n        return self.global_best_position", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.37.", "error": "", "parent_ids": ["40c24e6c-a639-4569-bd1d-cf42b35d7627"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7359543100170622, 0.8641021643677992, 0.9005656073423755, 0.7728166309501792, 0.8724846501354198, 0.965234797136052, 0.9470169389877963, 0.7145967107134389, 0.9163430927688443, 0.8911112270280859, 0.9255919212679004, 0.9062486412582762, 0.9179063238443476, 0.870891965957916, 0.8149033951132901]}}
{"id": "42d350aa-9cd0-4141-afeb-58d0c32a6e68", "fitness": 0.6585312928363761, "name": "HybridPSO_DE", "description": "Enhance adaptability by fine-tuning velocity and crossover strategies.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7\n        c1 = 1.5\n        c2 = 1.5\n        F = 0.8\n        CR = 0.9\n        decay_rate = 0.99\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR * (1 - self.evaluations / self.budget):  # Adjust crossover prob\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= decay_rate\n        return self.global_best_position", "configspace": "", "generation": 11, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.37.", "error": "", "parent_ids": ["1dda1314-fafb-47ef-903e-0863fdfa4663"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7805576160627617, 0.7908911709810337, 0.9166935744477712, 0.7354382467748075, 0.814432106029275, 0.965234797136052, 0.9471676970964296, 0.9081832740048471, 0.8756585282206306, 0.8785832281936574, 0.7954628819373216, 0.9214071938754886, 0.8839925920759943, 0.9024894912460051, 0.8866345637709794]}}
{"id": "61f23575-8430-412e-bf88-0b5eea17be51", "fitness": 0.6179090064149853, "name": "HybridPSO_DE", "description": "Enhance global search by periodically resetting a portion of the population to improve exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7\n        c1 = 1.5\n        c2 = 1.5\n        F = 0.8\n        CR = 0.9\n        decay_rate = 0.99\n\n        reset_interval = 100\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            if self.evaluations % reset_interval == 0:\n                indices_to_reset = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in indices_to_reset:\n                    self.particles[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= decay_rate\n        return self.global_best_position", "configspace": "", "generation": 12, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["1dda1314-fafb-47ef-903e-0863fdfa4663"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.595666991408906, 0.8371352868159567, 0.7410493081602634, 0.8913112844372308, 0.5381524382568514, 0.8801002473033663, 0.9391914552937256, 0.9382799620283021, 0.925147211429272, 0.7566651924826188, 0.9160909732518836, 0.918660117795, 0.6531266575330741, 0.848708941420669, 0.8110951658081211]}}
{"id": "c0c836a9-a8b8-4df8-b81e-9cb6e1581fbc", "fitness": 0.6562696428959154, "name": "HybridPSO_DE", "description": "Incorporate adaptive parameter tuning and exploration-exploitation balance to enhance performance over diverse landscapes.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8\n        CR = 0.9\n        decay_rate = 0.99\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Adaptive parameter tuning: inertia weight and differential weight\n            w *= decay_rate\n            F = 0.5 + 0.3 * np.random.rand()\n\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Dynamic adjustment of cognitive and social components\n            if self.evaluations < self.budget / 2:\n                c1, c2 = 2.0, 1.0\n            else:\n                c1, c2 = 1.0, 2.0\n                \n        return self.global_best_position", "configspace": "", "generation": 13, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.37.", "error": "", "parent_ids": ["1dda1314-fafb-47ef-903e-0863fdfa4663"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8060436682799696, 0.8271390776575622, 0.5310065344467988, 0.8349954033944552, 0.760353790922631, 0.9192178341535178, 0.9428236670193468, 0.9412725222712462, 0.9269965501816383, 0.8998504266868436, 0.9453311350726826, 0.8556272057983779, 0.9035645154541458, 0.9286442126640558, 0.9347274190405693]}}
{"id": "b240c854-f583-4e32-9eb1-d620dc6f95cd", "fitness": 0.47683068037109455, "name": "HybridPSO_DE", "description": "Enhance the dynamic population strategy with adaptive learning rate scheduling and selection pressure to improve convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7\n        c1 = 1.5\n        c2 = 1.5\n        F = 0.8\n        CR = 0.9\n        decay_rate = 0.99\n        learning_rate = 1.0  # Adaptive learning rate\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            adaptive_rate = learning_rate / (1 + 0.1 * self.evaluations / self.budget)  # New adaptive component\n            self.particles += adaptive_rate * self.velocities  # Modify velocity update with adaptive rate\n\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= decay_rate\n            learning_rate *= 0.98  # Learning rate decay\n        return self.global_best_position", "configspace": "", "generation": 14, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.36.", "error": "", "parent_ids": ["1dda1314-fafb-47ef-903e-0863fdfa4663"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.23544487081270582, 0.4933430470165957, 0.1662060102173304, 0.1768301609732592, 0.2256558244936897, 0.9422523506100107, 0.9082513896233816, 0.9081443484487827, 0.8990763422308086, 0.8127713963277521, 0.9431285263315552, 0.757024937830558, 0.7979723867364167, 0.7005400912263529, 0.4021730296682253]}}
{"id": "5c58cc26-5649-4aa8-829c-03b694c662bb", "fitness": 0.6624541147687727, "name": "HybridPSO_DE", "description": "Introduce adaptive differential weight and crossover rate to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= decay_rate  # Decay the inertia weight\n        return self.global_best_position", "configspace": "", "generation": 15, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.37.", "error": "", "parent_ids": ["1dda1314-fafb-47ef-903e-0863fdfa4663"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8191199045746648, 0.8511625559611387, 0.8699969805594652, 0.5295481298368522, 0.9352258629161833, 0.9529924343861108, 0.9630540488777053, 0.8928919870181042, 0.8288972326320043, 0.8928724158879446, 0.947141184179143, 0.9212993770054192, 0.9129981958191832, 0.8729556034577471, 0.8911274873893231]}}
{"id": "52d6352d-2704-49c9-bc2e-f48ea0515274", "fitness": 0.6768255275406434, "name": "HybridPSO_DE", "description": "Introduce a dynamic decay rate for inertia weight that decreases more rapidly as evaluations increase.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.01 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 16, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.37.", "error": "", "parent_ids": ["5c58cc26-5649-4aa8-829c-03b694c662bb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8638410242957599, 0.783757113151333, 0.8699956594882401, 0.8392807966241561, 0.9352276576365522, 0.9529923891529185, 0.9630545951691066, 0.8870236143758377, 0.8401384515900233, 0.8928752377210438, 0.9471412146811751, 0.9213013131459832, 0.9130020458760313, 0.8679468024825399, 0.8911337405477031]}}
{"id": "aef56955-09bf-42b8-a982-78f8ce63487b", "fitness": 0.6507417757744496, "name": "HybridPSO_DE", "description": "Introduce a dynamic adjustment to the cognitive component (c1) based on evaluations to enhance exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            c1_dynamic = c1 * (1 + 0.01 * (self.evaluations / self.budget))  # Dynamic adjustment to cognitive component\n            cognitive_velocity = c1_dynamic * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.01 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 17, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.37.", "error": "", "parent_ids": ["52d6352d-2704-49c9-bc2e-f48ea0515274"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.39837157490205777, 0.8568466979626992, 0.8529522733498393, 0.8315000523087422, 0.8596602755235854, 0.9529927947271398, 0.9697890893448039, 0.8917834171982637, 0.9080960330948531, 0.8840874201886416, 0.9455645198602943, 0.87557989041145, 0.9092133136110182, 0.8217813728157033, 0.8888178953154353]}}
{"id": "84a2d4b2-e2f3-4014-9eed-99f8f4e0439a", "fitness": 0.5992701099602328, "name": "HybridPSO_DE", "description": "Introduce a dynamic mutation scaling factor in the DE mutation operator.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.5 * np.random.rand() * (self.evaluations / self.budget)  # Dynamic mutation scaling factor\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.01 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 18, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.38.", "error": "", "parent_ids": ["52d6352d-2704-49c9-bc2e-f48ea0515274"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.19190353466704535, 0.8392220984966579, 0.5902079118628553, 0.8802496789721994, 0.8706493165527209, 0.9556161394605087, 0.6163923346233708, 0.9541319142643854, 0.9021634665135958, 0.8766533293881218, 0.9530466819427553, 0.9249422192348913, 0.8819637481564375, 0.4381609013333664, 0.9423000288612775]}}
{"id": "99bee530-aedc-4fcb-87d5-d7843eb0c437", "fitness": 0.10939006687290458, "name": "HybridPSO_DE", "description": "Improve local exploration by introducing a velocity component based on the personal best's influence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            # Modification line: add an additional personal best influence component\n            personal_best_influence = c1 * r1 * (self.personal_best_positions - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity + personal_best_influence\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.01 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 19, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.06.", "error": "", "parent_ids": ["52d6352d-2704-49c9-bc2e-f48ea0515274"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1395398413973703, 0.2691423234097885, 0.12277838051185952, 0.13658033241189171, 0.17771604654790008, 0.18303002950096336, 0.09207221528881693, 0.1110291652140295, 0.12856116141166596, 0.11735845294273073, 0.10977760029901318, 0.09530856063726112, 0.12026646245539985, 0.11410641684807266, 0.10273545370686188]}}
{"id": "f1fd03a1-d82a-41f3-bc2d-c1d50a8eb9f4", "fitness": 0.6705161439910172, "name": "HybridPSO_DE", "description": "Refine hybrid strategy by dynamically adjusting crossover probability based on evaluations.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.01 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 20, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["52d6352d-2704-49c9-bc2e-f48ea0515274"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7502574994745178, 0.8567406929840542, 0.8405138215326093, 0.7362882979719576, 0.9352276576365522, 0.9455785211104468, 0.9630545951691066, 0.9436480651625324, 0.8381128433169824, 0.8928752377210438, 0.9471412146811751, 0.9213013131459832, 0.9129184383984685, 0.8677320460927442, 0.8911337405477031]}}
{"id": "c5442edc-897b-4d4a-a688-8e1413467e83", "fitness": 0.6103305544387885, "name": "HybridPSO_DE", "description": "Adjust dynamic decay rate to improve convergence by updating the initial inertia weight.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.8  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.01 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 21, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.36.", "error": "", "parent_ids": ["52d6352d-2704-49c9-bc2e-f48ea0515274"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8644122229077145, 0.8501940083372383, 0.7753114805990715, 0.6106970979221682, 0.29792741463749206, 0.9163605857436199, 0.8984385386656923, 0.929197409658348, 0.9143589207039704, 0.6006706794855123, 0.8812580753879654, 0.899751656736532, 0.9111646839676054, 0.8875735606150061, 0.8014958585333656]}}
{"id": "c0de436a-b953-48b9-8c61-3c8d54412fa2", "fitness": 0.6762857991971033, "name": "HybridPSO_DE", "description": "Introduce a further adaptive decay element to the inertia weight, influenced by the global best score.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.01 * (self.evaluations / self.budget) + 0.001 * self.global_best_score))  # Dynamic decay rate with global best score influence\n        return self.global_best_position", "configspace": "", "generation": 22, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.37.", "error": "", "parent_ids": ["52d6352d-2704-49c9-bc2e-f48ea0515274"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8638374209784283, 0.7878683494435866, 0.8699946557085632, 0.8312687609946527, 0.9352238024842028, 0.9529923228035353, 0.9630566812448016, 0.8870198309614405, 0.8175444490246407, 0.8928781409440314, 0.9471412535383313, 0.9213069333017244, 0.9130024149852286, 0.8836460326843513, 0.8911360399700787]}}
{"id": "b8a2af4e-b2fb-49ee-ae09-540149d1d2ea", "fitness": 0.6031313088319523, "name": "HybridPSO_DE", "description": "Enhance convergence by reducing the inertia weight's decay rate for more stable exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.995  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.01 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 23, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.37.", "error": "", "parent_ids": ["52d6352d-2704-49c9-bc2e-f48ea0515274"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.5432832882345993, 0.8575516963944614, 0.4068525586785555, 0.7669101998890272, 0.355264105302013, 0.9459646296213771, 0.8687142663439685, 0.9150668029765613, 0.8876575610119887, 0.8670965977238813, 0.9537385501383132, 0.9194078315076455, 0.8240492681151836, 0.9176057461740722, 0.8656641796529327]}}
{"id": "a6b9516c-a289-4e23-b27a-1d7854dc099b", "fitness": 0.6787405710663829, "name": "HybridPSO_DE", "description": "Introduce a more adaptive inertia weight decay strategy that adjusts based on the evaluations ratio more sensitively. ", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.03 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 24, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.37.", "error": "", "parent_ids": ["52d6352d-2704-49c9-bc2e-f48ea0515274"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8638328272512867, 0.8516926614055683, 0.8255298744582773, 0.8312701011110694, 0.9352311438165154, 0.9529922980926799, 0.9630556886853429, 0.8870220436748223, 0.8495587605860095, 0.8928808404067131, 0.9471412682022771, 0.9213050795046704, 0.9130098390465616, 0.8836510567085037, 0.8888390435028959]}}
{"id": "0adcf592-f71d-4cae-9ae4-e4922b92fa95", "fitness": 0.676826222129684, "name": "HybridPSO_DE", "description": "Introduce a more dynamic adaptation of the inertia weight by making it dependent on both the evaluation ratio and the function dimension, enhancing convergence speed.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.03 * (self.evaluations / self.budget) * (0.1 + 0.9 * self.dim / 100)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 25, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.37.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8638413287594616, 0.783759869001835, 0.8699957774505643, 0.8392820032199836, 0.9352275170988558, 0.9529923927335412, 0.9630545520007794, 0.8870236755467111, 0.8401487391326894, 0.8928750152448239, 0.947141212362199, 0.9213011614730917, 0.9130017406024801, 0.8679473112767919, 0.891133251815405]}}
{"id": "00810d04-3d72-4d87-adcc-9db70fe5b610", "fitness": 0.6776808068013696, "name": "HybridPSO_DE", "description": "Enhance PSO-DE by fine-tuning the decay rate formula for the inertia weight to improve convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.02 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 26, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.37.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8638370418450646, 0.7837365155115886, 0.8699939660154503, 0.8312854694455915, 0.9352294180288062, 0.9529923437217979, 0.9630551417714773, 0.8870228343397819, 0.8495521835585396, 0.8928780467433078, 0.9471412426896261, 0.9213032140084919, 0.9130059268269504, 0.8836440070868806, 0.8911398895595672]}}
{"id": "89aa5abf-bfeb-4c57-9fb9-ef1c4dc89777", "fitness": 0.6787405710663829, "name": "HybridPSO_DE", "description": "Enhance particle position reset mechanism to prevent premature convergence in HybridPSO_DE.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.03 * (self.evaluations / self.budget)))  # Dynamic decay rate\n\n            # Reset particles if no improvement\n            if self.evaluations % (self.budget // 10) == 0:\n                self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        \n        return self.global_best_position", "configspace": "", "generation": 27, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.37.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8638328272512867, 0.8516926614055683, 0.8255298744582773, 0.8312701011110694, 0.9352311438165154, 0.9529922980926799, 0.9630556886853429, 0.8870220436748223, 0.8495587605860095, 0.8928808404067131, 0.9471412682022771, 0.9213050795046704, 0.9130098390465616, 0.8836510567085037, 0.8888390435028959]}}
{"id": "e2f61e05-efe4-4c32-9a49-cebe79cee6bc", "fitness": 0.6354887086393876, "name": "HybridPSO_DE", "description": "Introduce a dynamic social component in PSO to enhance convergence adaptability.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            social_factor = c2 * (1 + 0.5 * (self.evaluations / self.budget))  # Dynamic social component\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = social_factor * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.03 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 28, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.37.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8957920613580134, 0.9396393303784208, 0.8457126257516431, 0.8002227612253412, 0.8477267207046633, 0.9273645627159702, 0.8464691470796684, 0.7755390389360441, 0.2971808361023647, 0.9143049785853624, 0.9589760625881611, 0.7285284358454934, 0.9443178045768804, 0.9246162383161826, 0.8955846737490759]}}
{"id": "1530cf6f-f41b-496b-9d04-88c4b8b13dcd", "fitness": 0.6777881541352778, "name": "HybridPSO_DE", "description": "Introduce a more adaptive inertia weight decay strategy that adjusts based on the evaluations ratio slightly more sensitively and adaptively.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.035 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 29, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.37.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8626759826669034, 0.8359963192908105, 0.8315212833426632, 0.8312620080721879, 0.9352319936477489, 0.9529922752038541, 0.9630559622592506, 0.8870216443456728, 0.8495620337472896, 0.8846927575682518, 0.9471412800219903, 0.9213059989639634, 0.9130118070014139, 0.883654570585171, 0.8888382711139189]}}
{"id": "b00c9dff-2eb1-4d2b-a90a-3f80d31847ee", "fitness": 0.5670949163503914, "name": "HybridPSO_DE", "description": "Adjust the inertia weight decay rate to a more gradual decrease for better exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.995  # Adjusted decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.03 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 30, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.37.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.37853173484637304, 0.41685397864692075, 0.22154821720791396, 0.8016385599230151, 0.39067410195970553, 0.9459614779043859, 0.867070688621487, 0.9150669031505855, 0.8876893278636331, 0.8685951191489041, 0.9537377778560706, 0.9194046340359192, 0.8240623841938249, 0.9176028056882599, 0.8656617210863657]}}
{"id": "8cbec355-9ed6-4e69-b1d6-fe328c229ea8", "fitness": 0.6003139263412984, "name": "HybridPSO_DE", "description": "Introduce a variable learning factor based on evaluations to improve exploration and convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7\n        c1 = 1.5\n        c2 = 1.5\n        decay_rate = 0.99\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()\n                CR = 0.8 + 0.1 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.03 * (self.evaluations / self.budget)))\n            c1 = 1.5 * (1 - self.evaluations / self.budget)  # Change introduced here\n        return self.global_best_position", "configspace": "", "generation": 31, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.37.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7996347094489964, 0.7835344505874102, 0.8755067003646099, 0.61389079202829, 0.8679585086020005, 0.9626324183577497, 0.8646022714484601, 0.9287445108317821, 0.1175653042496333, 0.8426796163549335, 0.8967787339254396, 0.8851849684640167, 0.9404611121013469, 0.6206145367154852, 0.8386909984713441]}}
{"id": "594b5bb8-78f4-4f4f-842b-82a9fbd1120b", "fitness": 0.5134195968268361, "name": "HybridPSO_DE", "description": "Integrate a random exploration factor in the PSO velocity update to enhance global exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            random_explore_factor = 0.1 * np.random.uniform(-1.0, 1.0, self.velocities.shape)  # Added random exploration factor\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity + random_explore_factor\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.03 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 32, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.38.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.14558707415331584, 0.15463601293725993, 0.5172426921986046, 0.14924894077844197, 0.37407143968416734, 0.905107235284242, 0.8962522215755457, 0.8622713982524562, 0.8772817928193508, 0.9458021110204493, 0.8046561190744062, 0.7847712391185944, 0.9046865486151825, 0.9164105769171134, 0.8625676392331256]}}
{"id": "6c69af5f-bbe0-4720-ad00-bef2ac8325c7", "fitness": 0.6480512572225537, "name": "HybridPSO_DE", "description": "Leverage a dynamic inertia weight that adapts more aggressively to the evaluations ratio, enhancing convergence speed.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9  # Increased initial inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.93  # More aggressive decay rate\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.03 * (self.evaluations / self.budget)))  # Dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 33, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.39.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8839767356589139, 0.9114161073597865, 0.8705458802388123, 0.8097465822390923, 0.19765513739739027, 0.9506724307243308, 0.9016221844530212, 0.9590451818775089, 0.6653180541338214, 0.94474356646666, 0.9649982080529457, 0.8505718299293749, 0.9637390273423608, 0.9542885090347022, 0.9648868146678851]}}
{"id": "9451855d-f543-4554-a49f-08c295d4114f", "fitness": 0.6814263803039722, "name": "HybridPSO_DE", "description": "Introduce a more aggressive dynamic decay rate to further adapt inertia weight based on evaluations ratio.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 34, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.38.", "error": "", "parent_ids": ["a6b9516c-a289-4e23-b27a-1d7854dc099b"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8640135787486689, 0.8411355878841198, 0.8433264718689664, 0.8312828787219194, 0.9352361108145766, 0.9529921600166988, 0.9630573313011941, 0.8870196075615289, 0.8495864420833853, 0.8860369918471813, 0.9471413297435876, 0.9213104629764379, 0.9130217671858484, 0.9367338965026121, 0.8888340939482507]}}
{"id": "2f899d80-fe3e-4ce2-9044-6fa53fcb0aec", "fitness": 0.6652853973543567, "name": "HybridPSO_DE", "description": "Fine-tuned the weighting of the cognitive component to enhance convergence stability.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.6  # Cognitive component (modified slightly to improve convergence)\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 35, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6946068082126557, 0.8268253630565391, 0.8345556582433848, 0.927572135149819, 0.7088260094538598, 0.9577032921551565, 0.8810298623533112, 0.9225454084114457, 0.9163640314083878, 0.939279986787755, 0.9352123687169298, 0.8345916366649295, 0.9494786372944325, 0.9079072281453235, 0.9014106261587371]}}
{"id": "1e76e8b1-c8b5-43f9-b5bf-067f3b75083a", "fitness": 0.49288265559505196, "name": "HybridPSO_DE", "description": "Introduce a more adaptive mutation strategy by varying the differential weight F based on the global best score.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand() + (0.1 * (1 - self.global_best_score / np.finfo(float).eps))  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 36, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.41520213120000504, 0.505215823621104, 0.17098467972781084, 0.12191396100655516, 0.7738874274975575, 0.9669679822945816, 0.9551927715903468, 0.9324589343333785, 0.882087167419723, 0.43568998419073746, 0.13871812831441832, 0.9063278335214102, 0.8174394519864396, 0.7812316612932642, 0.8865362790292407]}}
{"id": "e1ffb78d-b70c-4d49-bf21-127752768552", "fitness": 0.6669686595450475, "name": "HybridPSO_DE", "description": "Introduce an adaptive cognitive component to the PSO velocity update to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = (c1 + 0.5 * (self.evaluations / self.budget)) * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 37, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6290413020894592, 0.9245162516438055, 0.8877564443325975, 0.8843358689612938, 0.7326663697870288, 0.9554841439214677, 0.8905742403298078, 0.9557650361495761, 0.8764239795774627, 0.7987256746975703, 0.9507831700607982, 0.9028384323152692, 0.9437850175624207, 0.9169719997785367, 0.921906364819387]}}
{"id": "d0c688c2-3332-4fc8-82d8-965aaa976919", "fitness": 0.6814263803039722, "name": "HybridPSO_DE", "description": "Introduce a diversity mechanism by randomizing velocities to prevent premature convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n            # Introduce diversity by randomizing velocities occasionally\n            if self.evaluations % (self.budget // 10) == 0: \n                self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        return self.global_best_position", "configspace": "", "generation": 38, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.38.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8640135787486689, 0.8411355878841198, 0.8433264718689664, 0.8312828787219194, 0.9352361108145766, 0.9529921600166988, 0.9630573313011941, 0.8870196075615289, 0.8495864420833853, 0.8860369918471813, 0.9471413297435876, 0.9213104629764379, 0.9130217671858484, 0.9367338965026121, 0.8888340939482507]}}
{"id": "61ff5701-ba51-4b5c-9702-d14f7717a97a", "fitness": 0.6094700524027256, "name": "HybridPSO_DE", "description": "Enhance the PSO-DE hybrid by introducing a more adaptive cognitive and social component scaling.  ", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            c1 = 1.5 + 0.5 * (self.evaluations / self.budget)  # Adaptive cognitive component\n            c2 = 1.5 + 0.5 * (self.evaluations / self.budget)  # Adaptive social component\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 39, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.35.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7715500757017103, 0.7107126351436602, 0.4241114865283033, 0.7860671964689487, 0.6252246647561248, 0.6799865330974942, 0.8517412129208344, 0.9358626231616789, 0.8613485190611708, 0.8873130319900855, 0.9551635036976815, 0.8646984504429529, 0.9363410843011336, 0.8030153504744484, 0.9284657854338172]}}
{"id": "e3a8e45d-2a33-4440-8827-03e36bd76342", "fitness": 0.6440529945503723, "name": "HybridPSO_DE", "description": "Adjust the adaptive differential weight `F` to dynamically depend on the remaining budget to enhance exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * (1 - self.evaluations / self.budget)  # Changed adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 40, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8510899380288854, 0.8989924266562856, 0.8048640429537272, 0.8653276437149752, 0.8697267851358432, 0.9697548410666307, 0.9536257145598217, 0.6739179217213075, 0.914069023019574, 0.8941197295046404, 0.9694707781283585, 0.7749703228687335, 0.9510247296950045, 0.8899602399383195, 0.432346859140872]}}
{"id": "bd572f20-6304-444a-89d9-8bd45fdbb533", "fitness": 0.6563343970701292, "name": "HybridPSO_DE", "description": "Improve convergence by incorporating non-linear decay rate and enhancing mutation strategy.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.98  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 41, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9218046438846975, 0.7635904804725953, 0.7856866878762523, 0.8076420620031209, 0.48493932166951814, 0.932534682436486, 0.9128476685173846, 0.9085155314500857, 0.8999180385739937, 0.9322651672821453, 0.9483976479893982, 0.8480631906048162, 0.9356759567597239, 0.9271386773622412, 0.9498692896456589]}}
{"id": "bffe0207-aa74-46dc-9eb6-2581220280ea", "fitness": 0.6652853973543567, "name": "HybridPSO_DE", "description": "Fine-tune the balance between exploration and exploitation by slightly increasing the cognitive component.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.6  # Cognitive component slightly increased\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 42, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6946068082126557, 0.8268253630565391, 0.8345556582433848, 0.927572135149819, 0.7088260094538598, 0.9577032921551565, 0.8810298623533112, 0.9225454084114457, 0.9163640314083878, 0.939279986787755, 0.9352123687169298, 0.8345916366649295, 0.9494786372944325, 0.9079072281453235, 0.9014106261587371]}}
{"id": "3559803c-16e8-4927-a1e0-233e92af3cb7", "fitness": 0.6619572265653515, "name": "HybridPSO_DE", "description": "Introduce an adaptive mutation factor for better exploration in the Differential Evolution step.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.4 * np.random.rand() * (self.evaluations / self.budget)  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 43, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8233989204513696, 0.8721059195302283, 0.8934322633454055, 0.8809099075022303, 0.7790934504973167, 0.9556170882377721, 0.8392574679766028, 0.9541788211857233, 0.9304299328240964, 0.8998189064851617, 0.9552365188086319, 0.8296065610696779, 0.9068330496546377, 0.6227975629376825, 0.9286292659260262]}}
{"id": "83709b3d-fb65-417b-86dc-dda12b2258a9", "fitness": 0.6778580219475743, "name": "HybridPSO_DE", "description": "Enhance the dynamic population size function to adapt the initial particle count based on remaining evaluations.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / (self.budget * 0.9))))  # Adjust population size adaptation\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 44, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8079864992369779, 0.8418458084647638, 0.8237287696233143, 0.8322449708186842, 0.9353480966904342, 0.9531012516395337, 0.9630573313011941, 0.8873516374423756, 0.8502871108342431, 0.8863799595790156, 0.9472493819097769, 0.9214291698210957, 0.9133176714866266, 0.9368500271301042, 0.8891838580988785]}}
{"id": "ca717050-f559-4ceb-8fa2-365aca8d480a", "fitness": 0.6622967695691546, "name": "HybridPSO_DE", "description": "Introduce a non-linear dynamic decay rate for further adaptation of inertia weight based on the evaluations ratio.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * np.sqrt(self.evaluations / self.budget)))  # Non-linear dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 45, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7244649265504577, 0.8745321137415207, 0.8003233715835819, 0.8653304729913707, 0.774514193420671, 0.9529896385999098, 0.9698028024014969, 0.8826699104265782, 0.8247474152136818, 0.924632648951472, 0.9471395971948561, 0.9213793891766893, 0.8918555154367965, 0.8430967261851641, 0.8806577746343782]}}
{"id": "7c496a6d-ba86-483b-80da-ce29c56e7d76", "fitness": 0.6701810796714144, "name": "HybridPSO_DE", "description": "Introduce a slightly adaptive crossover probability based on evaluations ratio to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand() * (1 - self.evaluations / self.budget)  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 46, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8058438391306355, 0.8293579317713169, 0.8334184228760726, 0.6256545190981369, 0.9352361108145766, 0.9530364393079183, 0.9630573313011941, 0.9436518463540075, 0.8467421921630097, 0.8928891484960182, 0.9471413297435876, 0.9213104629764379, 0.9129151340700465, 0.9367338965026121, 0.8888340939482507]}}
{"id": "5a363c68-6a1d-4601-8404-9487af18bf22", "fitness": 0.6814263803039722, "name": "HybridPSO_DE", "description": "Introduce a random restart mechanism to improve exploration and escape local optima.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            if self.evaluations / self.budget > 0.8 and np.random.rand() < 0.1:  # Random restart\n                self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 47, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.38.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8640135787486689, 0.8411355878841198, 0.8433264718689664, 0.8312828787219194, 0.9352361108145766, 0.9529921600166988, 0.9630573313011941, 0.8870196075615289, 0.8495864420833853, 0.8860369918471813, 0.9471413297435876, 0.9213104629764379, 0.9130217671858484, 0.9367338965026121, 0.8888340939482507]}}
{"id": "133747c4-2543-4250-95fe-0300d8e65228", "fitness": 0.6674104910726053, "name": "HybridPSO_DE", "description": "Introduce a dynamic cognitive and social component adaptation to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            # Introducing dynamic cognitive and social coefficients based on evaluations\n            dynamic_c1 = c1 * (1 + 0.1 * (self.evaluations / self.budget))\n            dynamic_c2 = c2 * (1 - 0.1 * (self.evaluations / self.budget))\n            cognitive_velocity = dynamic_c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = dynamic_c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 48, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6931112089829539, 0.8982274238236696, 0.8954757972311521, 0.70517547856249, 0.8665135284209255, 0.8978710349599139, 0.9124748938776985, 0.9538546425632798, 0.9411992501145554, 0.8830123957405241, 0.9471674482973512, 0.8701119880733871, 0.8958056670356747, 0.9179237995694207, 0.9024863693246459]}}
{"id": "97206e9e-0dcd-483e-bafb-116bc4f80264", "fitness": 0.6225049955181288, "name": "HybridPSO_DE", "description": "Introduce a more randomized component in the dynamic population size to enhance solution diversity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - (evaluations / self.budget) * (0.9 + 0.2 * np.random.rand()))))  # Dynamic population size with randomness\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 49, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8601938183494, 0.8479973871206798, 0.7264419025193111, 0.8609604349218035, 0.7885672183193418, 0.8760151411820308, 0.9252038846329826, 0.2149893671445613, 0.8291574981698046, 0.9095498413062215, 0.9202384517190051, 0.8830263361019418, 0.9493854578072423, 0.7760844078849761, 0.914489868308808]}}
{"id": "0ae1147c-d689-4bb2-bd2d-ce2f9ff23473", "fitness": 0.6017997652502075, "name": "HybridPSO_DE", "description": "Enhance the balance between exploration and exploitation by modulating cognitive and social factors based on evaluation ratio.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n            c1 = 2.0 - 1.5 * (self.evaluations / self.budget)  # Modulated cognitive component\n            c2 = 1.5 + 0.5 * (self.evaluations / self.budget)  # Modulated social component\n        return self.global_best_position", "configspace": "", "generation": 50, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.35.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6662540188834829, 0.7295551556191305, 0.8004150474544267, 0.8631284453482415, 0.7964579246567391, 0.9222089305570214, 0.905836192279162, 0.8327120521309008, 0.9057830672739602, 0.6534025593909829, 0.8968481272798392, 0.8812042113422642, 0.4100280371327836, 0.931696013795447, 0.6726666269853021]}}
{"id": "00d3b9db-9cbc-44b5-af41-72b210d80381", "fitness": 0.6411981334108685, "name": "HybridPSO_DE", "description": "Slightly increase the cognitive component to enhance local exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.55  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 51, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7244486024977296, 0.47566301534508726, 0.9447718495263406, 0.9287506165993611, 0.7328424007275349, 0.9333532852577978, 0.9384268255778205, 0.9550712821996472, 0.584284229508744, 0.8798499756711612, 0.9476637194939563, 0.9236364681499332, 0.8945502203975502, 0.8745115883431895, 0.9183396940470518]}}
{"id": "30b307b2-d16a-4247-bb32-a3831e053bc7", "fitness": 0.6536271144068803, "name": "HybridPSO_DE", "description": "Slightly adjust the cognitive component to enhance the exploitation capability of the particles.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.7  # Cognitive component adjusted\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 52, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8409548177627796, 0.8172544798923631, 0.9342655416355454, 0.7605471823309824, 0.8671657576130831, 0.9432744329234559, 0.9067070037824516, 0.881571712896112, 0.9174405754602006, 0.9357580988367012, 0.949914284436664, 0.8329089611442584, 0.8910743546634071, 0.9244657259185357, 0.5014404639665975]}}
{"id": "a454006c-9f6a-4b85-a103-e7b562f36783", "fitness": 0.678737525560724, "name": "HybridPSO_DE", "description": "Implemented variable decay rate for inertia weight based on current evaluations to improve convergence dynamics.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # More aggressive dynamic decay rate\n            w *= (decay_rate ** (1 + 0.08 * (self.evaluations / self.budget)))  \n        return self.global_best_position", "configspace": "", "generation": 53, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8149662265357278, 0.8632323233472621, 0.8433216370177171, 0.8312426222852145, 0.9352392441392179, 0.9529920669748589, 0.9630584279456176, 0.8870179297134388, 0.8227873114476001, 0.8860434192862929, 0.9471413582524774, 0.9213138736999689, 0.9130298828600031, 0.9367349075106377, 0.888830385323977]}}
{"id": "b5e37bb7-934a-4b58-9ff5-3927e0287e79", "fitness": 0.6652853973543567, "name": "HybridPSO_DE", "description": "Slightly increase the cognitive component to enhance exploration in the optimization process.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.6  # Cognitive component (changed from 1.5 to 1.6)\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 54, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6946068082126557, 0.8268253630565391, 0.8345556582433848, 0.927572135149819, 0.7088260094538598, 0.9577032921551565, 0.8810298623533112, 0.9225454084114457, 0.9163640314083878, 0.939279986787755, 0.9352123687169298, 0.8345916366649295, 0.9494786372944325, 0.9079072281453235, 0.9014106261587371]}}
{"id": "00f98ea7-ca0d-41ac-a641-4223dfb6dfaa", "fitness": 0.6373896443077548, "name": "HybridPSO_DE", "description": "Introduce a minor increase in cognitive and social components to enhance convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.55  # Cognitive component\n        c2 = 1.55  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 55, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.5058644388262616, 0.7984888297182504, 0.8544168728866234, 0.7007310039314545, 0.8488647955134307, 0.929722595187374, 0.9077597756650738, 0.9030970412076348, 0.7336765264850286, 0.9439891970381786, 0.9331486588530487, 0.8293047585652784, 0.9122514807435406, 0.8494649624021948, 0.9292130542572578]}}
{"id": "19275a6c-db20-4d63-932a-91322836249b", "fitness": 0.6375758796342176, "name": "HybridPSO_DE", "description": "Introduce a more adaptive social component scaling based on the remaining budget.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = (c2 * (1 - self.evaluations / self.budget)) * r2 * (self.global_best_position - self.particles)  # Adjusted social component\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 56, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.546061236164468, 0.7899213378732076, 0.5446164406505569, 0.8418221818962744, 0.9170064324024733, 0.9556642703479885, 0.8724415761971166, 0.8969074981326487, 0.8844517312152673, 0.9109991206088982, 0.912713505517172, 0.8221146801121462, 0.9434635317306399, 0.9119952375943395, 0.8335399173666852]}}
{"id": "c933531a-6f3c-4db0-96b2-5a686923dfc3", "fitness": 0.6737913843878405, "name": "HybridPSO_DE", "description": "Fine-tune cognitive and social factors to enhance convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.6  # Cognitive component\n        c2 = 1.4  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 57, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.815646980945447, 0.8666610896092074, 0.8117354560755696, 0.7817180235258248, 0.8219348261420423, 0.9484910303201637, 0.9156339606739692, 0.9505149990192812, 0.8680493479068776, 0.9021370359808984, 0.9531365694697563, 0.9202624568672343, 0.9424377951750285, 0.87253705094106, 0.9371321702299804]}}
{"id": "483a1aa4-0fbb-4104-9521-4e85db638a8a", "fitness": 0.6411981334108685, "name": "HybridPSO_DE", "description": "Slightly increase the cognitive component in the PSO for a better personal exploration balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.55  # Cognitive component (slightly increased)\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 58, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7244486024977296, 0.47566301534508726, 0.9447718495263406, 0.9287506165993611, 0.7328424007275349, 0.9333532852577978, 0.9384268255778205, 0.9550712821996472, 0.584284229508744, 0.8798499756711612, 0.9476637194939563, 0.9236364681499332, 0.8945502203975502, 0.8745115883431895, 0.9183396940470518]}}
{"id": "1e0da379-70b1-49dc-afa1-7f1e3ac96336", "fitness": 0.49101943181120317, "name": "HybridPSO_DE", "description": "Introduce mutation-based learning rate to enhance exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget + np.sum(self.velocities))))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 59, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.43.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8734785957267619, 0.08800362723918553, 0.8531129730287399, 0.10842471925945862, 0.8203601711247148, 0.1204756587770126, 0.9538604453564871, 0.9298959459185189, 0.08587078813305526, 0.9505468192984426, 0.1018108711332002, 0.9087712196705474, 0.9359423472774802, 0.958914236224187, 0.9631213231818048]}}
{"id": "3fdd20eb-a565-4af0-8e0e-d86b038fceb6", "fitness": 0.6385669358052819, "name": "HybridPSO_DE", "description": "Incorporate a stochastic component to the inertia weight decay for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * np.random.rand()))  # Change: Added stochastic component to decay rate\n        return self.global_best_position", "configspace": "", "generation": 60, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8819304394630426, 0.3148539312230101, 0.8755793992491581, 0.8579736399431062, 0.8224299621504615, 0.9153316582987586, 0.8899333650995573, 0.8822529462554968, 0.8383247658479971, 0.8472094208012488, 0.9323277346767327, 0.9145665637363668, 0.8547790901548288, 0.8865708747685959, 0.8894760295628112]}}
{"id": "174ca3c7-6747-450d-b6aa-f907dd98fca7", "fitness": 0.6782288669044417, "name": "EnhancedHybridPSO_DE", "description": "Implement a novel adaptive mechanism in the inertia weight and a refined mutation strategy to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.8  # Updated initial inertia weight\n        c1 = 1.5\n        c2 = 1.5\n        decay_rate = 0.98  # Slightly refined decay rate\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.2 * np.random.rand()  # Refined differential weight\n                CR = 0.8 + 0.05 * np.random.rand()  # Adjusted crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.05 * (self.evaluations / self.budget)))  # Adjusted dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.38.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9244503462460842, 0.6521547117492161, 0.9130898674924718, 0.8959371512909143, 0.9001143381630634, 0.9531928529221462, 0.8575126905477766, 0.8430727034572745, 0.9399985648096006, 0.8880671603715182, 0.9616252325352884, 0.9189752135374724, 0.9463120809787706, 0.9119515391139505, 0.8903239899988218]}}
{"id": "29073e6c-61b8-4ca0-b03e-65192da2888b", "fitness": 0.32844169787772703, "name": "HybridPSO_DE", "description": "Adjust cognitive and social components dynamically based on the evaluations ratio.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n            c1, c2 = 1.5 * (1 - self.evaluations / self.budget), 1.5 * (self.evaluations / self.budget)  # Dynamic adjustment\n        return self.global_best_position", "configspace": "", "generation": 62, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.21.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.2714825821559236, 0.30300753030131244, 0.2837798533425788, 0.29920812899075155, 0.2856545855097734, 0.48976588724867687, 0.4401098416831567, 0.44038718878431027, 0.8546491972446716, 0.4821022078793227, 0.4698402515589989, 0.46304528467834827, 0.48126684735547687, 0.41807317904259367, 0.41866249690417723]}}
{"id": "cf33c3df-6a3f-481e-8072-9e2a37118eef", "fitness": 0.6652853973543567, "name": "HybridPSO_DE", "description": "Enhance exploration by increasing cognitive component in the velocity update equation for improved convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.6  # Increased Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 63, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6946068082126557, 0.8268253630565391, 0.8345556582433848, 0.927572135149819, 0.7088260094538598, 0.9577032921551565, 0.8810298623533112, 0.9225454084114457, 0.9163640314083878, 0.939279986787755, 0.9352123687169298, 0.8345916366649295, 0.9494786372944325, 0.9079072281453235, 0.9014106261587371]}}
{"id": "281916ff-8729-45b5-bfa2-eea3bf3955a6", "fitness": 0.6524917796695213, "name": "HybridPSO_DE", "description": "Introduce an adaptively changing social component based on the ratio of evaluations to improve global exploration dynamically.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = (1.5 + 0.5 * (self.evaluations / self.budget)) * r2 * (self.global_best_position - self.particles)  # Adaptive social component\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 64, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8919488145196471, 0.6263705466043277, 0.7273424858625402, 0.8342242560357521, 0.9217446820004503, 0.9417113507600912, 0.9341791929043922, 0.9583168370984236, 0.8044392087014322, 0.9120643006790038, 0.9459347015305867, 0.7003017825653628, 0.9205256376827922, 0.8903765144259871, 0.8725563871451704]}}
{"id": "c8d444bd-7923-4de1-8284-5731ff9b1098", "fitness": 0.6652853973543567, "name": "HybridPSO_DE", "description": "Introduce a slightly more aggressive cognitive component to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.6  # Cognitive component updated\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 65, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6946068082126557, 0.8268253630565391, 0.8345556582433848, 0.927572135149819, 0.7088260094538598, 0.9577032921551565, 0.8810298623533112, 0.9225454084114457, 0.9163640314083878, 0.939279986787755, 0.9352123687169298, 0.8345916366649295, 0.9494786372944325, 0.9079072281453235, 0.9014106261587371]}}
{"id": "85c1c97c-9d59-4880-9654-66541d0d0ea1", "fitness": 0.6194012511366054, "name": "HybridPSO_DE", "description": "Introduce a dynamic strategy for the cognitive component to enhance local search adaptivity.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            c1_dynamic = c1 + 0.5 * (1 - self.evaluations / self.budget)  # Dynamic cognitive component\n            cognitive_velocity = c1_dynamic * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 66, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8989963387779625, 0.7698748889111113, 0.8138343592391469, 0.6999169679699746, 0.6311589322199459, 0.9330127977258484, 0.7637958617340939, 0.9096397655933808, 0.9409025416397282, 0.8885866874465483, 0.9066018378072032, 0.49604326357147743, 0.8316276494415655, 0.8800648441032224, 0.8561693916764328]}}
{"id": "069dfd18-5d4a-407e-8851-eef79808b3b4", "fitness": 0.6411981334108685, "name": "HybridPSO_DE", "description": "Improve exploration by slightly increasing the cognitive component.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.55  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 67, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7244486024977296, 0.47566301534508726, 0.9447718495263406, 0.9287506165993611, 0.7328424007275349, 0.9333532852577978, 0.9384268255778205, 0.9550712821996472, 0.584284229508744, 0.8798499756711612, 0.9476637194939563, 0.9236364681499332, 0.8945502203975502, 0.8745115883431895, 0.9183396940470518]}}
{"id": "9b1a8e55-5306-46cc-b607-e1e951a5c2fb", "fitness": 0.6411981334108685, "name": "HybridPSO_DE", "description": "Increase cognitive component \\(c1\\) slightly to enhance individual particle exploration.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.55  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)))  # More aggressive dynamic decay rate\n        return self.global_best_position", "configspace": "", "generation": 68, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.37.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7244486024977296, 0.47566301534508726, 0.9447718495263406, 0.9287506165993611, 0.7328424007275349, 0.9333532852577978, 0.9384268255778205, 0.9550712821996472, 0.584284229508744, 0.8798499756711612, 0.9476637194939563, 0.9236364681499332, 0.8945502203975502, 0.8745115883431895, 0.9183396940470518]}}
{"id": "7e8bf6bf-ae2a-4cb1-b0c0-68fc7344a36f", "fitness": 0.5859324861574833, "name": "HybridPSO_DE", "description": "Add randomness to inertia weight decay to improve exploration without altering the overall structure.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the initial population\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))  # Dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)  # Update population size\n            for i in range(current_population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply adaptive differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.06 * (self.evaluations / self.budget)) + 0.01 * np.random.rand())  # More aggressive dynamic decay rate with randomness\n        return self.global_best_position", "configspace": "", "generation": 69, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.38.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8327064879594429, 0.8626657181571792, 0.1331072915991578, 0.7965327280924167, 0.19605652727159295, 0.8844468075965423, 0.8299322238428931, 0.9650823840260637, 0.8484267421139396, 0.7231459761409613, 0.886048984708071, 0.8967256369215132, 0.9017915137160751, 0.9058685426913253, 0.8883132634380254]}}
{"id": "a92a3351-a23f-4d24-8e5e-7a6169ad2d27", "fitness": 0.7001628737360742, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive inertia and mutation strategies to efficiently explore the search space.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9  # Increased initial inertia weight\n        c1 = 1.3  # Adjusted cognitive component\n        c2 = 1.7  # Adjusted social component\n        decay_rate = 0.95  # Modified decay rate for inertia\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()  # Adjusted differential weight\n                CR = 0.9 + 0.05 * np.random.rand()  # Adjusted crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))  # Modified decay computation\n        return self.global_best_position", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.39.", "error": "", "parent_ids": ["9451855d-f543-4554-a49f-08c295d4114f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8622747650423765, 0.9078640598441811, 0.9047480747097744, 0.9009535367275829, 0.8996614467364011, 0.9119155524755398, 0.9444523710958126, 0.9046738001759591, 0.9582992089944022, 0.8664822879469838, 0.95772372826858, 0.9536738050742728, 0.9405542899953548, 0.9610495634696943, 0.9611320892901026]}}
{"id": "364315e7-dcdc-408e-a4e6-287fc2e54a20", "fitness": 0.6463883228154929, "name": "EnhancedHybridPSO_DE", "description": "Improved velocity update by slightly increasing the cognitive component to enhance individual exploration.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9  # Increased initial inertia weight\n        c1 = 1.35  # Slightly increased cognitive component for better individual exploration\n        c2 = 1.7  # Adjusted social component\n        decay_rate = 0.95  # Modified decay rate for inertia\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()  # Adjusted differential weight\n                CR = 0.9 + 0.05 * np.random.rand()  # Adjusted crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))  # Modified decay computation\n        return self.global_best_position", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.39.", "error": "", "parent_ids": ["a92a3351-a23f-4d24-8e5e-7a6169ad2d27"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9046578245440428, 0.20079517633872934, 0.8373945897207564, 0.815636826164312, 0.8747853032190852, 0.9412226364286714, 0.9346883980047508, 0.9519742326909602, 0.9305289169801254, 0.7761749924333584, 0.9305351138373785, 0.9069946698701941, 0.882758567296758, 0.9187893910366072, 0.9530309228696615]}}
{"id": "8e089ba0-0e52-44ee-aa16-47dbba47fe88", "fitness": 0.658971298009447, "name": "EnhancedHybridPSO_DE", "description": "EnhancedHybridPSO_DE with dynamically adapting crossover probability to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9  # Increased initial inertia weight\n        c1 = 1.3  # Adjusted cognitive component\n        c2 = 1.7  # Adjusted social component\n        decay_rate = 0.95  # Modified decay rate for inertia\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()  # Adjusted differential weight\n                CR = 0.9 + 0.1 * (1 - self.evaluations / self.budget)  # Dynamically adapting crossover probability\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))  # Modified decay computation\n        return self.global_best_position", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.40.", "error": "", "parent_ids": ["a92a3351-a23f-4d24-8e5e-7a6169ad2d27"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8232291210349951, 0.9347105360639381, 0.9213057256371576, 0.9079718948539077, 0.10282557328607678, 0.932419935612538, 0.9372275697573973, 0.9601208525157299, 0.9214852154991844, 0.9090806550177007, 0.9471907125989106, 0.9157421338594862, 0.931222655102572, 0.9321545984645272, 0.9349398860103523]}}
{"id": "251bb0f6-2941-4335-8bfe-7d78637cee2e", "fitness": 0.6201128640759351, "name": "EnhancedHybridPSO_DE", "description": "Enhanced HybridPSO_DE with dynamic crossover probability and adaptive decay rate for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9  # Increased initial inertia weight\n        c1 = 1.3  # Adjusted cognitive component\n        c2 = 1.7  # Adjusted social component\n        decay_rate = 0.95  # Modified decay rate for inertia\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()  # Adjusted differential weight\n                # Changed: Dynamic crossover probability based on evaluations\n                CR = 0.9 + 0.1 * (self.evaluations / self.budget)  \n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            # Changed: Adaptive decay computation\n            w *= (decay_rate ** (1 + 0.05 * (self.evaluations / self.budget)))  \n        return self.global_best_position", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.41.", "error": "", "parent_ids": ["a92a3351-a23f-4d24-8e5e-7a6169ad2d27"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.914725767941609, 0.8649860745100852, 0.8762092041583078, 0.880272138538365, 0.1298909754554789, 0.9612077984433369, 0.9569845827087958, 0.9433896047680127, 0.9341097524322892, 0.12884293502389277, 0.9405329664683354, 0.938012307067926, 0.9404035648243528, 0.8844841380094939, 0.9404065762939562]}}
{"id": "def67992-3aef-4acb-9b46-d989dc22a4bb", "fitness": 0.7101371158392965, "name": "EnhancedHybridPSO_DE", "description": "EnhancedHybridPSO_DE with adaptive exploration-exploitation balance by modifying particle initialization and velocity update.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = 0.5 * (self.velocities + cognitive_velocity + social_velocity)  # Change: Averaging update to smoothen velocity changes\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n        return self.global_best_position", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.39.", "error": "", "parent_ids": ["a92a3351-a23f-4d24-8e5e-7a6169ad2d27"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9119478928885094, 0.920232732217791, 0.932240061972498, 0.9629924576826197, 0.891603682729916, 0.9748097509898443, 0.8012461206083645, 0.8959372027543961, 0.9757748687349732, 0.9613833958567521, 0.9776443452190257, 0.9715291768950574, 0.9744766398559297, 0.9088620812323437, 0.9742630122734427]}}
{"id": "0e83469e-43c1-4f73-831c-c716d3c3f150", "fitness": 0.5968331346338231, "name": "EnhancedHybridPSO_DE", "description": "Modified the velocity update factor to introduce dynamic inertia weight for better convergence in the EnhancedHybridPSO_DE algorithm.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * (self.velocities + cognitive_velocity + social_velocity)  # Change: Introduced dynamic inertia weight\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n        return self.global_best_position", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.38.", "error": "", "parent_ids": ["def67992-3aef-4acb-9b46-d989dc22a4bb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.4979450819052256, 0.7940557107886516, 0.8769588686309615, 0.1417705404468157, 0.49885353706222946, 0.9563288900238341, 0.9472812797130943, 0.9395971133122245, 0.943772733175007, 0.9098437155270004, 0.9630813242206365, 0.6304839156441939, 0.9253654408453829, 0.7832166128015338, 0.960309033705207]}}
{"id": "60c6bd03-c2fd-41f5-9500-8dfe7eca4dd3", "fitness": 0.6964075787771561, "name": "EnhancedHybridPSO_DE", "description": "EnhancedHybridPSO_DE with improved exploration using time-varying acceleration coefficients.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = 0.5 * (self.velocities + cognitive_velocity + social_velocity)  # Change: Averaging update to smoothen velocity changes\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1, c2 = 1.3 * (1 - self.evaluations / self.budget), 1.7 * (1 - self.evaluations / self.budget)  # Change: Time-varying acceleration coefficients for exploration\n        return self.global_best_position", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.39.", "error": "", "parent_ids": ["def67992-3aef-4acb-9b46-d989dc22a4bb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7308881347916403, 0.892688369277309, 0.7340945924222769, 0.9491992064423098, 0.7891032744823498, 0.9742896637090057, 0.9448536554058584, 0.9620364055983958, 0.9597335552728501, 0.9844925359457999, 0.9735487727084979, 0.9670448800628868, 0.9746049652865686, 0.9740536948691165, 0.949720974393792]}}
{"id": "1bc8d824-a471-4b5c-bae6-871f0d7669bb", "fitness": 0.704797866673305, "name": "EnhancedHybridPSO_DE", "description": "EnhancedHybridPSO_DE with increased cognitive coefficient for improved local search capability.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.5  # Change: Increased cognitive coefficient for improved local search capability\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = 0.5 * (self.velocities + cognitive_velocity + social_velocity)  # Change: Averaging update to smoothen velocity changes\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n        return self.global_best_position", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.39.", "error": "", "parent_ids": ["def67992-3aef-4acb-9b46-d989dc22a4bb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8835393038955064, 0.9007720864422025, 0.9532301034768191, 0.7387098807060081, 0.8741669171205705, 0.9760341343229867, 0.956423875647511, 0.958418054845301, 0.9702556469777772, 0.858219606727615, 0.9821382309034921, 0.9758840595238719, 0.969004485157369, 0.9591471024069445, 0.9722149504376579]}}
{"id": "33d43766-335b-4bac-8416-2c3596fe0536", "fitness": 0.669647678817306, "name": "EnhancedHybridPSO_DE", "description": "Introduce adaptive inertia weight decay to improve convergence by dynamically adjusting the influence of previous velocities.  ", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity  # Change: Adaptive inertia weight decay\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n        return self.global_best_position", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.40.", "error": "", "parent_ids": ["def67992-3aef-4acb-9b46-d989dc22a4bb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8873258184609883, 0.8747896428343453, 0.19609036830591375, 0.9370582525672496, 0.9110898999582477, 0.9602267757973547, 0.9394746374626941, 0.9422941150868266, 0.9611191046600355, 0.9421221685938416, 0.9298519343683802, 0.925652486610471, 0.9163049123752809, 0.9543125661276579, 0.9474419982623671]}}
{"id": "df33fbe1-266e-4ff7-a66a-420bf5c2a759", "fitness": 0.7101371158392965, "name": "EnhancedHybridPSO_DE", "description": "Improved EnhancedHybridPSO_DE by adjusting the inertial weight decay for better convergence.  ", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.98  # Change: Adjusted decay rate to improve convergence\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = 0.5 * (self.velocities + cognitive_velocity + social_velocity)  # Change: Averaging update to smoothen velocity changes\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n        return self.global_best_position", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.39.", "error": "", "parent_ids": ["def67992-3aef-4acb-9b46-d989dc22a4bb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9119478928885094, 0.920232732217791, 0.932240061972498, 0.9629924576826197, 0.891603682729916, 0.9748097509898443, 0.8012461206083645, 0.8959372027543961, 0.9757748687349732, 0.9613833958567521, 0.9776443452190257, 0.9715291768950574, 0.9744766398559297, 0.9088620812323437, 0.9742630122734427]}}
{"id": "fa2051c1-99c3-433b-b084-475b1b49b04a", "fitness": 0.5968331346338231, "name": "EnhancedHybridPSO_DE", "description": "Introduced adaptive inertia weight adjustment to improve convergence by modifying the velocity update strategy.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * (self.velocities + cognitive_velocity + social_velocity)  # Change: Introduced adaptive inertia weight adjustment\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n        return self.global_best_position", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.38.", "error": "", "parent_ids": ["def67992-3aef-4acb-9b46-d989dc22a4bb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.4979450819052256, 0.7940557107886516, 0.8769588686309615, 0.1417705404468157, 0.49885353706222946, 0.9563288900238341, 0.9472812797130943, 0.9395971133122245, 0.943772733175007, 0.9098437155270004, 0.9630813242206365, 0.6304839156441939, 0.9253654408453829, 0.7832166128015338, 0.960309033705207]}}
{"id": "2ffc2495-1da9-40e8-a7e1-474518e74678", "fitness": 0.7140126253392681, "name": "EnhancedHybridPSO_DE", "description": "Improved convergence by dynamically adapting velocity influence based on evaluation progress.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n        return self.global_best_position", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.40.", "error": "", "parent_ids": ["def67992-3aef-4acb-9b46-d989dc22a4bb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.867137543055799, 0.9086095545829684, 0.9615802727155284, 0.9607178243590196, 0.7967537577409983, 0.9791745845320201, 0.9304034356167132, 0.9533590266059511, 0.9655086260694419, 0.9513043596836753, 0.9794244799623146, 0.9743833397733119, 0.9694318010351761, 0.9447304672317016, 0.9699345389462756]}}
{"id": "54dd6ebe-a921-4f08-b557-f938793cd241", "fitness": 0.7152374968262547, "name": "EnhancedHybridPSO_DE", "description": "Introduced adaptive crossover rate to enhance exploration-exploitation balance in evolutionary steps.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n        return self.global_best_position", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["2ffc2495-1da9-40e8-a7e1-474518e74678"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8814361763397496, 0.9301597829114328, 0.9615802727155284, 0.9607178243590196, 0.7824716065966083, 0.9791745845320201, 0.9304034356167132, 0.9533590266059511, 0.9655086260694419, 0.9641391579302204, 0.9794244799623146, 0.9743833397733119, 0.9694318010351761, 0.9348263882568647, 0.9699345389462756]}}
{"id": "e511f19f-3e68-4e55-9bb6-c9cb17c5a833", "fitness": 0.7152374968262547, "name": "EnhancedHybridPSO_DE", "description": "Introduced nonlinear decay in the inertia weight to boost convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget))**1.5)  # Change: Nonlinear decay in inertia weight\n        return self.global_best_position", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["54dd6ebe-a921-4f08-b557-f938793cd241"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8814361763397496, 0.9301597829114328, 0.9615802727155284, 0.9607178243590196, 0.7824716065966083, 0.9791745845320201, 0.9304034356167132, 0.9533590266059511, 0.9655086260694419, 0.9641391579302204, 0.9794244799623146, 0.9743833397733119, 0.9694318010351761, 0.9348263882568647, 0.9699345389462756]}}
{"id": "3a62705d-7489-4588-9fdb-bbe95be91c94", "fitness": 0.6657460371885338, "name": "EnhancedHybridPSO_DE", "description": "Introduced velocity clamping to prevent excessive particle movement and enhance global convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.velocities = np.clip(self.velocities, -0.5, 0.5)  # Change: Velocity clamping for enhanced convergence\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n        return self.global_best_position", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.41.", "error": "", "parent_ids": ["54dd6ebe-a921-4f08-b557-f938793cd241"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.13485435525904577, 0.8135429213687018, 0.789815554181936, 0.9206346940790943, 0.9539843614269841, 0.9510295050315768, 0.9562725474365089, 0.9525005043726058, 0.9373885449241703, 0.9505443697192374, 0.9627086449448508, 0.9433411569241859, 0.9534638444278646, 0.9681062689436483, 0.9589345758557988]}}
{"id": "9b5a4ff9-7e30-42ba-9543-fc6cf730d20c", "fitness": 0.7220436289604646, "name": "EnhancedHybridPSO_DE", "description": "Introduced a dynamic learning factor adjustment to improve convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))  # Change: Dynamic adjustment of the cognitive learning factor\n        return self.global_best_position", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["54dd6ebe-a921-4f08-b557-f938793cd241"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8809173386717085, 0.9264470805452575, 0.9615666169858624, 0.9607163266462493, 0.921112833971697, 0.9791754171278829, 0.9283447092298943, 0.9534020090048101, 0.965505795332916, 0.9641399149235054, 0.9794251279448886, 0.9743811233933846, 0.9694280190701758, 0.9385770209763781, 0.9699343505102153]}}
{"id": "94f97597-091d-4c5b-a437-e916690b9fb2", "fitness": 0.686300531739087, "name": "EnhancedHybridPSO_DE", "description": "Improved exploration by adding randomness to particle initialization.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        # Change: Added randomness to particle initialization for better exploration\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        ) + np.random.normal(0, 0.1, (self.population_size, self.dim))  # Change: Adding small Gaussian noise\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))\n        return self.global_best_position", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.38.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7865983170143176, 0.8286830506387715, 0.8611128685863446, 0.8408458505091388, 0.8133169037101478, 0.9426748955411762, 0.9439454929344334, 0.9687656832398149, 0.958802324168154, 0.9692723448086863, 0.7898963580944508, 0.9511864552332017, 0.9553264825382399, 0.9714464809100887, 0.9763382319803073]}}
{"id": "5a5dae9a-53fd-43cf-9b2a-653c1bb2a59d", "fitness": 0.6694871033042127, "name": "EnhancedHybridPSO_DE", "description": "EnhancedHybridPSO_DE: Improved global learning through adaptive velocity and crossover adjustments.  ", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.95 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Slightly increased base crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c2 *= (1 + 0.01 * (self.evaluations / self.budget))  # Change: Dynamic adjustment of the social learning factor\n        return self.global_best_position", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.41.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8806031205603706, 0.918324787066173, 0.9357691315365271, 0.15018866883812865, 0.9345275225128518, 0.9441408969415329, 0.9568218467034608, 0.9711019176882938, 0.9651468087988733, 0.9468189051884824, 0.8296812197148853, 0.9444491551026238, 0.9606775392550727, 0.9113270144965031, 0.9723646368060073]}}
{"id": "40c8b76f-33c9-4d35-b3b6-e5e3f139b272", "fitness": 0.7220436289604646, "name": "EnhancedHybridPSO_DE", "description": "Introduced dynamic inertia weight adjustment to further balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))  # Change: Dynamic adjustment of the cognitive learning factor\n            w = 0.4 + 0.5 * ((self.budget - self.evaluations) / self.budget)  # Dynamic inertia weight adjustment\n        return self.global_best_position", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8809173386717085, 0.9264470805452575, 0.9615666169858624, 0.9607163266462493, 0.921112833971697, 0.9791754171278829, 0.9283447092298943, 0.9534020090048101, 0.965505795332916, 0.9641399149235054, 0.9794251279448886, 0.9743811233933846, 0.9694280190701758, 0.9385770209763781, 0.9699343505102153]}}
{"id": "653f1510-acc4-4b20-bd67-8f250297fb77", "fitness": 0.714842980862024, "name": "EnhancedHybridPSO_DE", "description": "Enhanced learning rate decay for improved convergence precision.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.005 * (self.evaluations / self.budget))  # Change: Dynamic adjustment of the cognitive learning factor\n        return self.global_best_position", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.40.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8544649656580524, 0.9288174953223368, 0.9615734795526485, 0.9607171229493718, 0.7971259777746953, 0.9791750015362988, 0.9295859441457478, 0.9533776396588156, 0.9655072266889361, 0.9641395416240667, 0.9794248054474164, 0.9743822289088347, 0.9694299107127472, 0.9414049166294215, 0.9699344657566245]}}
{"id": "5cc76f09-72fe-40f2-af64-157a78bfefad", "fitness": 0.7220429879313696, "name": "EnhancedHybridPSO_DE", "description": "EnhancedHybridPSO_DE with improved velocity decay for adaptive exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * np.tanh(self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Improved velocity decay\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))\n        return self.global_best_position", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8809134565291052, 0.9264478300767728, 0.9615665644902913, 0.9607163156544689, 0.9211131149516044, 0.9791754271703048, 0.9283424210741218, 0.9534023384241803, 0.9655057742560498, 0.9641399166419232, 0.9794251367306239, 0.9743811256884825, 0.9694280451694307, 0.9385690885165722, 0.9699343083789915]}}
{"id": "b2a66394-115a-4528-92da-8e6d9b070cb3", "fitness": 0.7217276580086809, "name": "EnhancedHybridPSO_DE", "description": "Enhanced particle exploration with adaptive inertia weight adjustment for improved convergence.  ", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget) + 0.1 * np.random.rand()))  # Change: Added randomness to inertia weight adjustment\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))  # Change: Dynamic adjustment of the cognitive learning factor\n        return self.global_best_position", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9299414508323361, 0.9471817446675134, 0.826959124737046, 0.9185884269831686, 0.9312291691286602, 0.9839503275615356, 0.9767614223460341, 0.9653666964059943, 0.9786927733563886, 0.9658697249183391, 0.9660396657349251, 0.9660430280168786, 0.9767627400013563, 0.9685214360738792, 0.9648465345350958]}}
{"id": "88fc6263-4578-448a-bf26-681fe7f89a35", "fitness": 0.19255365298501537, "name": "EnhancedHybridPSO_DE", "description": "Introduced adaptive inertia weight and differential mutation strategy for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w_max, w_min = 0.9, 0.4\n        c1 = 1.5\n        c2 = 1.5\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            w = w_max - ((w_max - w_min) * (self.evaluations / self.budget))\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.5 * np.random.rand()  # Adjusted mutation factor for diversity\n                CR = 0.8 + 0.2 * np.random.rand() * (self.budget - self.evaluations) / self.budget\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.16831925961341954, 0.2108734254661867, 0.18813885372170513, 0.41532052629196814, 0.10959644719658335, 0.1847021994540612, 0.4250303603849641, 0.31340255393947325, 0.1281031748887459, 0.09432987606254895, 0.120981375891001, 0.4446234258256463, 0.6361521178504154, 0.12126011430620054, 0.12244045393292158]}}
{"id": "2b4cf8ef-4447-43d0-97eb-c37d729ce6c7", "fitness": 0.7220436289604646, "name": "EnhancedHybridPSO_DE", "description": "Introduced adaptive inertia weight decay for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))  # Change: Dynamic adjustment of the cognitive learning factor\n        return self.global_best_position", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8809173386717085, 0.9264470805452575, 0.9615666169858624, 0.9607163266462493, 0.921112833971697, 0.9791754171278829, 0.9283447092298943, 0.9534020090048101, 0.965505795332916, 0.9641399149235054, 0.9794251279448886, 0.9743811233933846, 0.9694280190701758, 0.9385770209763781, 0.9699343505102153]}}
{"id": "b8aca1e4-fff8-4f4b-b450-3de14cfadd8b", "fitness": 0.7220436289604646, "name": "EnhancedHybridPSO_DE", "description": "Incorporated adaptive inertia weight decay to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))  # Change: Dynamic adjustment of the cognitive learning factor\n        return self.global_best_position", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8809173386717085, 0.9264470805452575, 0.9615666169858624, 0.9607163266462493, 0.921112833971697, 0.9791754171278829, 0.9283447092298943, 0.9534020090048101, 0.965505795332916, 0.9641399149235054, 0.9794251279448886, 0.9743811233933846, 0.9694280190701758, 0.9385770209763781, 0.9699343505102153]}}
{"id": "747f5415-3073-4dae-8c74-b5166184b0f1", "fitness": 0.7218094751281258, "name": "EnhancedHybridPSO_DE", "description": "Introduced a dynamic population decay rate to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - (evaluations / self.budget) ** 1.2)))  # Change: Modified decay rate for dynamic population size\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))\n        return self.global_best_position", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.40.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8787755630295948, 0.9256822961748349, 0.9615666169858624, 0.9607163266462493, 0.9204310211306514, 0.9791754171278829, 0.9276571466136404, 0.9533751253309327, 0.965505795332916, 0.9641399149235054, 0.9794251279448886, 0.9743811233933846, 0.9694280190701758, 0.9381967634733169, 0.9699343505102153]}}
{"id": "52e1e777-1f85-4d3e-ae9d-af71896383ce", "fitness": 0.38912440414183475, "name": "EnhancedHybridPSO_DE", "description": "Introduced enhanced adaptive inertia weight to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (w) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Enhanced adaptive inertia weight\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Adaptive crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w = 0.4 + 0.5 * ((self.budget - self.evaluations) / self.budget)  # Change: Dynamic inertia weight adjustment for exploration-exploitation balance\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))  # Change: Dynamic adjustment of the cognitive learning factor\n        return self.global_best_position", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.29.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6520529619401386, 0.5348726503054159, 0.5830299381743311, 0.6399062993312346, 0.40647263167060876, 0.7679338016371021, 0.7280159827542229, 0.6441970424485444, 0.1348514391343224, 0.1139654436467834, 0.7427522207387312, 0.10562354299272902, 0.6485795022403683, 0.18261320689794447, 0.729822524049752]}}
{"id": "4d4836b2-b9c0-4cad-97e0-fd1b9adc3cf3", "fitness": 0.7023190858520512, "name": "EnhancedHybridPSO_DE", "description": "Refined mutation scaling factor to improve exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.5 + 0.5 * np.random.rand()  # Change: Adjusted mutation scaling factor for better exploration-exploitation balance\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))\n        return self.global_best_position", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.39.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9164847149973216, 0.9252795998529433, 0.8900584122252186, 0.9606906549651653, 0.9560791876597102, 0.6472757336212841, 0.964642472998459, 0.9724216666195796, 0.9519324085125556, 0.9563995204731864, 0.8806217567295519, 0.9657236835281351, 0.9592494148202964, 0.9691603933594577, 0.9625632018036904]}}
{"id": "ed3aab2d-f361-4e45-aea9-7860b4cdf4cf", "fitness": 0.6783032293780717, "name": "EnhancedHybridPSO_DE", "description": "Introduced a small, adaptive perturbation in the mutation strategy to enhance exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.9 + 0.05 * np.random.rand() * (self.budget - self.evaluations) / self.budget\n                mutant = np.clip(a + F * (b - c) + 0.05 * np.random.randn(self.dim), self.lower_bound, self.upper_bound)  # Change: Added small perturbation to mutant\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))\n        return self.global_best_position", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.39.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.85835736661607, 0.7500615753920892, 0.664402021131656, 0.5651227468490947, 0.8452647422710916, 0.9770007330805962, 0.9739249477613798, 0.9774203353221647, 0.978277013178239, 0.968399830629431, 0.9599524956637052, 0.9763212320412747, 0.9844588899288426, 0.9659720215853502, 0.953329741235983]}}
{"id": "02959d1b-b951-4084-9bf4-579cd26ca20d", "fitness": 0.7322441179159571, "name": "EnhancedHybridPSO_DE", "description": "Enhanced dynamic crossover to balance exploration-exploitation in search space.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.dynamic_population_size = lambda evaluations: max(5, int(self.population_size * (1 - evaluations / self.budget)))\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)  # Change: Adjusted velocity initialization range for better convergence\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9\n        c1 = 1.3\n        c2 = 1.7\n        decay_rate = 0.95\n\n        while self.evaluations < self.budget:\n            current_population_size = self.dynamic_population_size(self.evaluations)\n            for i in range(current_population_size):\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = (0.5 + 0.5 * (self.evaluations / self.budget)) * (self.velocities + cognitive_velocity + social_velocity)  # Change: Dynamic velocity influence for better adaptation\n            self.particles += self.velocities\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                F = 0.6 + 0.4 * np.random.rand()\n                CR = 0.95 * np.random.rand() * (self.budget - self.evaluations) / self.budget  # Change: Enhanced dynamic crossover rate\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= (decay_rate ** (1 + 0.04 * (self.evaluations / self.budget)))\n            c1 *= (1 - 0.01 * (self.evaluations / self.budget))  # Change: Dynamic adjustment of the cognitive learning factor\n        return self.global_best_position", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.40.", "error": "", "parent_ids": ["9b5a4ff9-7e30-42ba-9543-fc6cf730d20c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9694641016661708, 0.9377404478678109, 0.902768274795074, 0.9721984700627733, 0.9544670437404623, 0.9826125290932475, 0.980313784669484, 0.9756256635574219, 0.9576858979753753, 0.9659660787271591, 0.9740001803816897, 0.9757396324398155, 0.9792037790629151, 0.9734486198174845, 0.9758489595877915]}}
