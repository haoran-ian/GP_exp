{"id": "44005e8e-3efe-44a7-8e47-32b3cf213545", "fitness": 0.18822181766803295, "name": "AdaptiveHybridPSO", "description": "Adaptive Hybrid Particle Swarm Optimization with Differential Mutation and Local Search for Efficient Black Box Optimization.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight = 0.7\n        cognitive_weight = 1.5\n        social_weight = 1.5\n        mutation_factor = 0.5\n\n        while self.func_evals < self.budget:\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                # Evaluate the current position\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                # Update personal best\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Update position\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                # Apply differential mutation if a better global best is found\n                if np.random.rand() < mutation_factor:\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.05 on similar problems with similar landscape features.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.24571067191208706, 0.12436644548324316, 0.19458833560876865]}}
{"id": "b7d1b051-49d7-418e-8d14-dbbc44fe114a", "fitness": 0.6776803594476365, "name": "AdaptiveHybridPSO", "description": "Enhanced Adaptive Hybrid PSO by dynamically updating inertia weight for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight_start = 0.9  # Changed from 0.7 to start with a higher inertia weight\n        inertia_weight_end = 0.4  # New line: Added an end inertia weight to dynamically adjust inertia\n        cognitive_weight = 1.5\n        social_weight = 1.5\n        mutation_factor = 0.5\n\n        while self.func_evals < self.budget:\n            inertia_weight = inertia_weight_start - (inertia_weight_start - inertia_weight_end) * (self.func_evals / self.budget)  # Dynamically adjust inertia weight\n\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                # Evaluate the current position\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                # Update personal best\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Update position\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                # Apply differential mutation if a better global best is found\n                if np.random.rand() < mutation_factor:\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68 with standard deviation 0.42 on similar problems with similar landscape features.", "error": "", "parent_ids": ["44005e8e-3efe-44a7-8e47-32b3cf213545"], "operator": null, "metadata": {"aucs": [0.9791645138245243, 0.9706193804024383, 0.08325718411594663]}}
{"id": "585c411c-3fb4-4fcc-a7ee-ac0a61fc0f39", "fitness": 0.9743838874621004, "name": "AdaptiveHybridPSO", "description": "Introduced velocity clamping and adaptive mutation factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight_start = 0.9\n        inertia_weight_end = 0.4\n        cognitive_weight = 1.5\n        social_weight = 1.5\n        mutation_factor = 0.5\n\n        while self.func_evals < self.budget:\n            inertia_weight = inertia_weight_start - (inertia_weight_start - inertia_weight_end) * (self.func_evals / self.budget)\n\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Velocity clamping to prevent excessive exploration\n                vel_max = 0.1 * (self.upper_bound - self.lower_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -vel_max, vel_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < (mutation_factor + 0.1 * np.sin(self.func_evals)):\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.02 on similar problems with similar landscape features.", "error": "", "parent_ids": ["b7d1b051-49d7-418e-8d14-dbbc44fe114a"], "operator": null, "metadata": {"aucs": [0.980866081578367, 0.9981816780469105, 0.9441039027610236]}}
{"id": "2e754d5f-0744-441e-ad85-137377be1959", "fitness": 0.7086377731859764, "name": "AdaptiveHybridPSO", "description": "Enhanced velocity update with local perturbation for better fine-tuning in later stages.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight_start = 0.9\n        inertia_weight_end = 0.4\n        cognitive_weight = 1.5\n        social_weight = 1.5\n        mutation_factor = 0.5\n\n        while self.func_evals < self.budget:\n            inertia_weight = inertia_weight_start - (inertia_weight_start - inertia_weight_end) * (self.func_evals / self.budget)\n\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Enhanced velocity update with local perturbation\n                if self.func_evals > 0.7 * self.budget:\n                    local_perturbation = 0.05 * np.random.randn(self.dim)\n                    self.velocities[i] += local_perturbation\n\n                # Velocity clamping to prevent excessive exploration\n                vel_max = 0.1 * (self.upper_bound - self.lower_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -vel_max, vel_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < (mutation_factor + 0.1 * np.sin(self.func_evals)):\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.40 on similar problems with similar landscape features.", "error": "", "parent_ids": ["585c411c-3fb4-4fcc-a7ee-ac0a61fc0f39"], "operator": null, "metadata": {"aucs": [0.9896304602687207, 0.9904925930257984, 0.14579026626341018]}}
{"id": "336cc332-e932-4527-bc2e-eeb61d025969", "fitness": 0.9900613348526276, "name": "AdaptiveHybridPSO", "description": "Introduced dynamic social and cognitive weights for improved adaptability and convergence speed.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight_start = 0.9\n        inertia_weight_end = 0.4\n        cognitive_weight_start = 2.0\n        cognitive_weight_end = 1.0\n        social_weight_start = 1.0\n        social_weight_end = 2.0\n        mutation_factor = 0.5\n\n        while self.func_evals < self.budget:\n            inertia_weight = inertia_weight_start - (inertia_weight_start - inertia_weight_end) * (self.func_evals / self.budget)\n            cognitive_weight = cognitive_weight_start - (cognitive_weight_start - cognitive_weight_end) * (self.func_evals / self.budget)\n            social_weight = social_weight_start + (social_weight_end - social_weight_start) * (self.func_evals / self.budget)\n\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Velocity clamping to prevent excessive exploration\n                vel_max = 0.1 * (self.upper_bound - self.lower_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -vel_max, vel_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < (mutation_factor + 0.1 * np.sin(self.func_evals)):\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.99 with standard deviation 0.00 on similar problems with similar landscape features.", "error": "", "parent_ids": ["585c411c-3fb4-4fcc-a7ee-ac0a61fc0f39"], "operator": null, "metadata": {"aucs": [0.9856818333998372, 0.9875496956333494, 0.9969524755246962]}}
{"id": "d95325a9-ffb0-4617-9917-4b6af7d12424", "fitness": 0.9872390608667968, "name": "AdaptiveHybridPSO", "description": "Enhanced convergence by introducing a non-linear inertia decay and stochastic influence in the mutation mechanism.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight_start = 0.9\n        inertia_weight_end = 0.4\n        cognitive_weight_start = 2.0\n        cognitive_weight_end = 1.0\n        social_weight_start = 1.0\n        social_weight_end = 2.0\n        mutation_factor = 0.5\n\n        while self.func_evals < self.budget:\n            # Non-linear decay for inertia weight\n            inertia_weight = inertia_weight_start - (inertia_weight_start - inertia_weight_end) * ((self.func_evals / self.budget) ** 2)\n            cognitive_weight = cognitive_weight_start - (cognitive_weight_start - cognitive_weight_end) * (self.func_evals / self.budget)\n            social_weight = social_weight_start + (social_weight_end - social_weight_start) * (self.func_evals / self.budget)\n\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Velocity clamping to prevent excessive exploration\n                vel_max = 0.1 * (self.upper_bound - self.lower_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -vel_max, vel_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                # Stochastic influence in the mutation mechanism\n                if np.random.rand() < (mutation_factor + 0.1 * np.sin(self.func_evals + np.random.rand())):\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.99 with standard deviation 0.01 on similar problems with similar landscape features.", "error": "", "parent_ids": ["336cc332-e932-4527-bc2e-eeb61d025969"], "operator": null, "metadata": {"aucs": [0.978975586903365, 0.9937792129678936, 0.9889623827291317]}}
{"id": "69ea4a04-aa78-4684-8e68-1c768c5cf974", "fitness": 0.7028561359513548, "name": "AdaptiveHybridPSO", "description": "Enhanced exploration by dynamically adjusting mutation_factor using a cosine function for improved global search.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight_start = 0.9\n        inertia_weight_end = 0.4\n        cognitive_weight_start = 2.0\n        cognitive_weight_end = 1.0\n        social_weight_start = 1.0\n        social_weight_end = 2.0\n        mutation_factor = 0.5\n\n        while self.func_evals < self.budget:\n            inertia_weight = inertia_weight_start - (inertia_weight_start - inertia_weight_end) * (self.func_evals / self.budget)\n            cognitive_weight = cognitive_weight_start - (cognitive_weight_start - cognitive_weight_end) * (self.func_evals / self.budget)\n            social_weight = social_weight_start + (social_weight_end - social_weight_start) * (self.func_evals / self.budget)\n\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Velocity clamping to prevent excessive exploration\n                vel_max = 0.1 * (self.upper_bound - self.lower_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -vel_max, vel_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < (mutation_factor + 0.1 * np.cos(self.func_evals)):  # Change here\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.41 on similar problems with similar landscape features.", "error": "", "parent_ids": ["336cc332-e932-4527-bc2e-eeb61d025969"], "operator": null, "metadata": {"aucs": [0.9871292015088254, 0.12885973251058025, 0.9925794738346586]}}
{"id": "2deee3e1-4442-4836-b979-f24c1602a23e", "fitness": 0.9809173860925514, "name": "AdaptiveHybridPSO", "description": "Introduced local search phase with simulated annealing for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight_start = 0.9\n        inertia_weight_end = 0.4\n        cognitive_weight_start = 2.0\n        cognitive_weight_end = 1.0\n        social_weight_start = 1.0\n        social_weight_end = 2.0\n        mutation_factor = 0.5\n        initial_temp = 100\n\n        while self.func_evals < self.budget:\n            inertia_weight = inertia_weight_start - (inertia_weight_start - inertia_weight_end) * (self.func_evals / self.budget)\n            cognitive_weight = cognitive_weight_start - (cognitive_weight_start - cognitive_weight_end) * (self.func_evals / self.budget)\n            social_weight = social_weight_start + (social_weight_end - social_weight_start) * (self.func_evals / self.budget)\n\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Velocity clamping to prevent excessive exploration\n                vel_max = 0.1 * (self.upper_bound - self.lower_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -vel_max, vel_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < (mutation_factor + 0.1 * np.sin(self.func_evals)):\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n            # Local search with simulated annealing\n            temp = initial_temp * (1 - self.func_evals / self.budget)\n            new_position = self.gbest + np.random.normal(0, 1, self.dim)\n            new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n            new_score = func(new_position)\n            self.func_evals += 1\n\n            if new_score < self.gbest_score or np.exp((self.gbest_score - new_score) / temp) > np.random.rand():\n                self.gbest_score = new_score\n                self.gbest = new_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.98 with standard deviation 0.01 on similar problems with similar landscape features.", "error": "", "parent_ids": ["336cc332-e932-4527-bc2e-eeb61d025969"], "operator": null, "metadata": {"aucs": [0.9951292807748624, 0.9694738426570381, 0.9781490348457534]}}
{"id": "4fe66d47-a968-43a8-915c-953a06806ae0", "fitness": 0.7540366001642314, "name": "AdaptiveHybridPSO", "description": "Enhanced exploration and exploitation balance through adaptive mutation and multi-best guidance.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight_start = 0.9\n        inertia_weight_end = 0.4\n        cognitive_weight_start = 2.0\n        cognitive_weight_end = 1.0\n        social_weight_start = 1.0\n        social_weight_end = 2.0\n        mutation_factor = 0.5\n\n        while self.func_evals < self.budget:\n            inertia_weight = inertia_weight_start - (inertia_weight_start - inertia_weight_end) * (self.func_evals / self.budget)\n            cognitive_weight = cognitive_weight_start - (cognitive_weight_start - cognitive_weight_end) * (self.func_evals / self.budget)\n            social_weight = social_weight_start + (social_weight_end - social_weight_start) * (self.func_evals / self.budget)\n\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                additional_social_velocity = 0.5 * social_weight * r2 * (self.pbest[np.argmin(self.pbest_scores)] - self.positions[i])  # New line for multi-best\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + additional_social_velocity\n\n                vel_max = 0.1 * (self.upper_bound - self.lower_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -vel_max, vel_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < (mutation_factor + 0.1 * np.sin(self.func_evals)):\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.33 on similar problems with similar landscape features.", "error": "", "parent_ids": ["336cc332-e932-4527-bc2e-eeb61d025969"], "operator": null, "metadata": {"aucs": [0.28641702020815596, 0.986052666114826, 0.9896401141697118]}}
{"id": "af1e0904-ab01-421a-960a-6a6b7d2c67d4", "fitness": 0.7479459933546679, "name": "AdaptiveHybridPSO", "description": "Introduced adaptive mutation and elite selection for enhanced convergence and solution quality.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = swarm_size\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.pbest = self.positions.copy()\n        self.pbest_scores = np.full(self.swarm_size, np.inf)\n        self.gbest = self.positions[0].copy()\n        self.gbest_score = np.inf\n        self.func_evals = 0\n\n    def optimize(self, func):\n        inertia_weight_start = 0.9\n        inertia_weight_end = 0.4\n        cognitive_weight_start = 2.0\n        cognitive_weight_end = 1.0\n        social_weight_start = 1.0\n        social_weight_end = 2.0\n        mutation_factor = 0.5\n\n        while self.func_evals < self.budget:\n            inertia_weight = inertia_weight_start - (inertia_weight_start - inertia_weight_end) * (self.func_evals / self.budget)\n            cognitive_weight = cognitive_weight_start - (cognitive_weight_start - cognitive_weight_end) * (self.func_evals / self.budget)\n            social_weight = social_weight_start + (social_weight_end - social_weight_start) * (self.func_evals / self.budget)\n\n            for i in range(self.swarm_size):\n                if self.func_evals >= self.budget:\n                    break\n\n                score = func(self.positions[i])\n                self.func_evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest[i] = self.positions[i].copy()\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest = self.positions[i].copy()\n\n            # Introduced elite selection\n            elite_threshold = int(0.1 * self.swarm_size)\n            elite_indices = np.argsort(self.pbest_scores)[:elite_threshold]\n\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_velocity = cognitive_weight * r1 * (self.pbest[i] - self.positions[i])\n                social_velocity = social_weight * r2 * (self.gbest - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Velocity clamping to prevent excessive exploration\n                vel_max = 0.1 * (self.upper_bound - self.lower_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -vel_max, vel_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation based on elite selection\n                if np.random.rand() < (mutation_factor + 0.1 * np.sin(self.func_evals)) * (i in elite_indices):\n                    idxs = np.random.choice(self.swarm_size, 3, replace=False)\n                    mutated_position = self.positions[idxs[0]] + mutation_factor * (self.positions[idxs[1]] - self.positions[idxs[2]])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n\n                    mutated_score = func(mutated_position)\n                    self.func_evals += 1\n\n                    if mutated_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = mutated_score\n                        self.pbest[i] = mutated_position.copy()\n\n                    if mutated_score < self.gbest_score:\n                        self.gbest_score = mutated_score\n                        self.gbest = mutated_position.copy()\n\n        return self.gbest, self.gbest_score\n\n    def __call__(self, func):\n        return self.optimize(func)", "configspace": "", "generation": 9, "feedback": "The algorithm AdaptiveHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.28 on the real problem.", "error": "", "parent_ids": ["336cc332-e932-4527-bc2e-eeb61d025969"], "operator": null, "metadata": {"aucs": [0.9066152419022112, 0.9834006720162565, 0.35382206614553613]}}
