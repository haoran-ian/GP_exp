{"id": "250a2364-0e1f-4ec6-8e16-7635a96a8c05", "fitness": 0.019866244651714816, "name": "HADE_RLS", "description": "Hybrid Adaptive Differential Evolution with Randomized Local Search (HADE-RLS) that combines global exploration with adaptive parameters and local search intensification.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 0, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.0018098191856917856, 0.0008831173767835931, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04512807238336203, 0.04392610406975983, 0.03793036932481475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05320689337552009, 0.058525534852800654, 0.04818444404698208, 0.08326164718343754, 0.0900535661622962, 0.09127444630238568, 0.032302657171573546, 0.036513065157004476, 0.0475984745011927, 0.07137085999609538, 0.07988615668784982, 0.07410158158969271, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013877314893317005, 0.012861928599651962, 0.0120343885030052, 0.010275298926366583, 0.011226232461463037, 0.013136907325358105, 0.14124775749224994, 0.1557383253704251, 0.14401465198438612, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6471c765-8cbe-44bc-abc1-2229726a01b9", "fitness": 0.019307380404846943, "name": "HADE_RLS", "description": "Improved Hybrid Adaptive Differential Evolution with enhanced mutation and dynamic crossover for better exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7  # Mutation factor (modified)\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < (self.CR * np.random.rand())  # Modified crossover\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 1, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.003977503107323921, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03384092529677174, 0.03836206041599388, 0.03330960972856167, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05803144795869786, 0.06031264789387025, 0.05295531548668686, 0.09509057762713091, 0.09076277731405435, 0.08711508778642763, 0.03463552302098061, 0.033020338586975395, 0.038354483336664136, 0.06302531015901403, 0.06726911132518876, 0.07488378194906797, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013709642830094126, 0.011607956987927714, 0.01216075435976638, 0.009460461610583226, 0.016305860088645097, 0.010679524360820092, 0.14254593192946552, 0.1513870225493421, 0.13689295083022912, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a7aafb56-3ee5-4617-a60a-1658f9002eda", "fitness": 0.019294776560570517, "name": "HADE_RLS", "description": "Enhanced HADE-RLS with adaptive mutation factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor change\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 2, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04494556138045047, 0.042512661058457635, 0.04337545462859549, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05463609180388951, 0.058525534852800654, 0.05011386035160004, 0.08384998354452244, 0.08558045631937183, 0.0882588976120221, 0.03154216468136162, 0.03330976134029218, 0.038354483336664136, 0.06675593105234023, 0.071026329347889, 0.07453030559526663, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013709642830094126, 0.011812649625174365, 0.012655021500468155, 0.010479813139072203, 0.011683563191306923, 0.010550992219453548, 0.14584305158918454, 0.1475173800428523, 0.13678475610055474, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "03096bdb-a889-411f-be47-a9ef4b21c261", "fitness": 0.018667311585612596, "name": "HADE_RLS", "description": "Enhanced HADE-RLS with adaptive mutation strategy based on fitness variance for improved exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                fitness_variance = np.var(fitness)  # Changed line: compute fitness variance\n                adaptive_F = self.F + 0.5 * fitness_variance  # Adaptive mutation factor\n                mutant = np.clip(x1 + adaptive_F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 3, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005045652551084467, 0.0012546537195762264, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03248724604145237, 0.038841099384228084, 0.029091184151828098, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051041661018763174, 0.05869448100266872, 0.067339774576199, 0.07890209694009032, 0.08359915114846628, 0.08510788298664607, 0.02910454259449935, 0.032760997119857915, 0.03443121945774574, 0.06417271164141236, 0.0645584539602525, 0.07410158158969271, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013863143014809398, 0.011641297621757474, 0.011699019549170186, 0.00986629590626431, 0.011434027308433237, 0.010240127383775999, 0.14192875108585412, 0.14535660659766603, 0.14202386310788795, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "73269b9a-f883-4915-8851-0f07e9aef1d2", "fitness": 0.01968357955661489, "name": "HADE_RLS", "description": "Enhanced HADE-RLS with adaptive crossover rate to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Initial Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover with adaptive CR\n                trial = np.copy(population[i])\n                self.CR = (self.budget - eval_count) / self.budget  # Adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 4, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.0011128537928672966, 0.00045462036821375396, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05036172095976976, 0.04331309055208177, 0.04167669262914364, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05141288942845257, 0.058525534852800654, 0.05442163157696556, 0.08701771256938073, 0.087011235550991, 0.09252922466865965, 0.032076358997830345, 0.034595915511167696, 0.047635466004540716, 0.07133825589036646, 0.0745385138161474, 0.07410158158969271, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013863143014809398, 0.012073653774545723, 0.011719785171072084, 0.010434185801184936, 0.010335113227512682, 0.01127918519742388, 0.1413885423086616, 0.1557383253704251, 0.1282624954515641, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0f3ceb1a-41b3-4c7c-a1b5-3138bf9561a8", "fitness": 0.019504455519723508, "name": "HADE_RLS", "description": "Enhanced HADE-RLS with adaptive mutation factor and local search noise reduction for improved convergence.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                adaptive_F = 0.5 + 0.2 * np.random.rand()  # Adjusted mutation factor\n                mutant = np.clip(x1 + adaptive_F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.05, self.dim)  # Reduced noise in local search\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 5, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.000581048903619874, 0.002156761636994964, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04542428217104588, 0.04271248450853182, 0.04351407985158762, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056207552714230946, 0.05964254228686572, 0.049585397883455395, 0.09048798334172103, 0.09128098342426527, 0.08727812666601575, 0.03507685595326815, 0.037286473879482585, 0.03583365937873806, 0.0669082287973859, 0.06890447169925462, 0.07387258953320541, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013692870414212632, 0.011672743074418013, 0.01224206506696246, 0.010506959763149859, 0.013131672845392628, 0.01036516713551583, 0.14124775749224994, 0.14076381325708143, 0.14394422574143995, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4a77876f-5bc4-422f-8f17-d2589eb5c881", "fitness": 0.019107207205274746, "name": "HADE_RLS", "description": "Enhanced Hybrid Adaptive Differential Evolution with Randomized Local Search (HADE-RLS) by dynamic mutation factor tuning for improved convergence.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                # Alteration made here: dynamic adjustment of the mutation factor F based on evaluations\n                self.F = 0.5 + 0.5 * (eval_count / self.budget)\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 6, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04340682026233067, 0.041678782584473995, 0.034769067060598124, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052984368916183855, 0.058525534852800654, 0.0542015159558763, 0.0806934594026979, 0.08735375151430713, 0.0905790115074816, 0.030586348585629475, 0.03626243117122596, 0.037090399157519105, 0.06417271164141236, 0.07224360737024826, 0.07410158158969271, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013863143014809398, 0.011495162299962947, 0.011933212394336756, 0.009669000318724641, 0.012328498662940612, 0.010928635164151768, 0.14124775749224994, 0.1428163335083179, 0.1419182191344175, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b7fb8c80-2354-40d8-92a8-dcf7a93dbb9b", "fitness": 0.019049136827490203, "name": "HADE_RLS", "description": "Improved HADE-RLS with adaptive mutation factor to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                self.F = 0.1 + 0.9 * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 7, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.0016017079266861245, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0371583394558731, 0.04276682307517721, 0.03725948126843792, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05720521542700063, 0.05860994808707509, 0.051725537083762596, 0.08412673493429734, 0.08634425782865351, 0.08651798005404365, 0.03172942185654648, 0.03305832724986979, 0.03478788769241303, 0.0666404728035822, 0.06885287874491264, 0.07410158158969271, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013972965496396816, 0.012553843580743407, 0.012144036711393191, 0.009001076946611675, 0.011549544530881417, 0.010782813089480592, 0.14192875108585412, 0.1439208434567355, 0.1427625989944774, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a5b14b95-d0d9-4641-9d7a-7b7c5b6e9e99", "fitness": 0.01901925588933138, "name": "HADE_RLS", "description": "Enhanced Hybrid Adaptive Differential Evolution with Local Search (E-HADE-RLS) that improves exploration with adaptive mutation factor based on population diversity.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Adapt F based on population diversity\n            self.F = 0.5 + 0.5 * np.std(population) / (self.upper_bound - self.lower_bound)\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 8, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04018960273470917, 0.038841099384228084, 0.03418186934880196, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051071987936610164, 0.06189966413562353, 0.04791524758049448, 0.08304812390294203, 0.08878485754428178, 0.08852598678708412, 0.033664022769624546, 0.033215099442751805, 0.03517057443204363, 0.06417271164141236, 0.07146356121931385, 0.07410158158969271, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013863143014809398, 0.011629866005857359, 0.012488312834112225, 0.00934306845439925, 0.011674444765376824, 0.010756321707020566, 0.1428201995661622, 0.1408203867617711, 0.14887512525534408, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "479ff01c-51aa-4b3a-b11d-3ca497e9b84a", "fitness": 0.019120905095128406, "name": "HADE_RLS", "description": "Enhanced HADE-RLS by introducing an adaptive mutation factor and adaptive crossover rate to improve convergence efficiency.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                self.CR = 0.8 + 0.2 * np.random.rand()  # Adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 9, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.001509721205600556, 0.0008310444182706433, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04667852991076715, 0.0416773757951403, 0.03653454524148658, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050475941752204045, 0.058525534852800654, 0.0514879570047736, 0.0843681401281996, 0.08626758865310225, 0.08874377921306686, 0.028437474807170404, 0.03307103704851533, 0.035469235351665684, 0.06973318024204767, 0.07102743664478073, 0.07516281977174577, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013758117824844596, 0.015410902883878141, 0.012345607650695478, 0.009926807687590355, 0.009761242689659722, 0.010424267567625267, 0.14174078913461718, 0.1440885196574575, 0.13924756971153818, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f3fac2ea-dfaa-4ab7-9f28-47358e344d6b", "fitness": 0.0194815376552391, "name": "HADE_RLS", "description": "Hybrid Adaptive Differential Evolution with Randomized Local Search (HADE-RLS) with an increased population size for enhanced exploration capabilities.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 * dim  # Increase population size\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 10, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0421446103510571, 0.05212694555349984, 0.04051770334935456, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049605431415993384, 0.0617074822803354, 0.05337984409997454, 0.08926945045464219, 0.0928114861132785, 0.08852311098881072, 0.02960744673160942, 0.03700659437084597, 0.03739325255843062, 0.0686879137169557, 0.07031371629706307, 0.07410785010950782, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013673127063341006, 0.011551648261335812, 0.013974339612499831, 0.008886957121702732, 0.01045547417596615, 0.010284103281333445, 0.14124775749224994, 0.14107449986867826, 0.14345040069135695, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "99ec2daf-e36c-4034-bd6f-2bea4c24f680", "fitness": 0.01964241415670282, "name": "HADE_RLS", "description": "Improved Hybrid Adaptive Differential Evolution with Randomized Local Search (HADE-RLS) using self-adaptive F and CR to enhance both exploration and exploitation.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n        \n        while eval_count < self.budget:\n            # Dynamic adjustment of F and CR\n            self.F = 0.1 + np.random.rand() * 0.9  # Change 1\n            self.CR = np.random.rand()  # Change 2\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 11, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.0006836496448929807, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06315564525370576, 0.04233838620307051, 0.03534333034255799, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05143860189458693, 0.058525534852800654, 0.05159455542406699, 0.08775349932285414, 0.09065683404563829, 0.08574440640621561, 0.03235839780296734, 0.034753487777308245, 0.03443121945774574, 0.08249330160953139, 0.07806241709032868, 0.07428146917725109, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01458285279965188, 0.012010923762560077, 0.01196763807697232, 0.010809551211355184, 0.013569471392775312, 0.010361032635512135, 0.14192875108585412, 0.14076381325708143, 0.13421026614662168, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f016cd95-ce7f-47b3-a291-cb7a0c88ad86", "fitness": 0.019638881388284346, "name": "HADE_RLS", "description": "Enhanced HADE-RLS with adaptive crossover rate adjustment to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover with adaptive CR\n                trial = np.copy(population[i])\n                self.CR = 0.1 + 0.8 * (1 - eval_count / self.budget)  # Update crossover rate\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 12, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.0017548849525776955, 0.001636951455459168, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04694509266842428, 0.047555444934514135, 0.04833968250611498, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05153976038855057, 0.058525534852800654, 0.04849763332618273, 0.08583682136867299, 0.08956295505584877, 0.09296033318735664, 0.030593056758391746, 0.034284963915398925, 0.0403756379934096, 0.0715205451121056, 0.0717979424132642, 0.07498090568142857, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013863143014809398, 0.01320477454627611, 0.01398121415438569, 0.010010044938657647, 0.01051978711796897, 0.010283269708473597, 0.14192875108585412, 0.14108228141407197, 0.14241804740547315, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e9420361-a4b1-4674-8386-fb45beac2270", "fitness": 0.01882521849650735, "name": "HADE_RLS", "description": "Improved Hybrid Adaptive Differential Evolution with Randomized Local Search (HADE-RLS) by introducing adaptive mutation and crossover rates based on fitness diversity.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Calculate diversity\n            fitness_std = np.std(fitness)\n            self.F = 0.5 + fitness_std / (fitness_std + 1) * 0.4\n            self.CR = 0.9 * (1 - fitness_std / (fitness_std + 1))\n            \n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 13, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03248724604145237, 0.038841099384228084, 0.029411626399077795, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052018898575510675, 0.058525534852800654, 0.07032915031240983, 0.08078798787810304, 0.08614693584304267, 0.08548355978735933, 0.02910454259449935, 0.032760997119857915, 0.03443121945774574, 0.06600773408248584, 0.06752982245019434, 0.07870005899433752, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013863143014809398, 0.014980343483892322, 0.011893797229937775, 0.00904519868774023, 0.010090255757550404, 0.010224938788649385, 0.14124775749224994, 0.14175392031379408, 0.1388803979894081, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d3a8ecb4-b654-4eee-87b6-aafe9678a378", "fitness": 0.019120905095128406, "name": "HADE_RLS", "description": "HADE_RLS with adaptive mutation and crossover rates for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                self.CR = 0.8 + 0.2 * np.random.rand()  # Adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 14, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.001509721205600556, 0.0008310444182706433, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04667852991076715, 0.0416773757951403, 0.03653454524148658, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050475941752204045, 0.058525534852800654, 0.0514879570047736, 0.0843681401281996, 0.08626758865310225, 0.08874377921306686, 0.028437474807170404, 0.03307103704851533, 0.035469235351665684, 0.06973318024204767, 0.07102743664478073, 0.07516281977174577, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013758117824844596, 0.015410902883878141, 0.012345607650695478, 0.009926807687590355, 0.009761242689659722, 0.010424267567625267, 0.14174078913461718, 0.1440885196574575, 0.13924756971153818, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "44fc3775-8ce4-45cf-b1eb-79e1395d71f3", "fitness": 0.019107207205274746, "name": "HADE_RLS", "description": "Enhanced HADE-RLS with adaptive mutation factor for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.5 * (eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 15, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04340682026233067, 0.041678782584473995, 0.034769067060598124, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052984368916183855, 0.058525534852800654, 0.0542015159558763, 0.0806934594026979, 0.08735375151430713, 0.0905790115074816, 0.030586348585629475, 0.03626243117122596, 0.037090399157519105, 0.06417271164141236, 0.07224360737024826, 0.07410158158969271, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013863143014809398, 0.011495162299962947, 0.011933212394336756, 0.009669000318724641, 0.012328498662940612, 0.010928635164151768, 0.14124775749224994, 0.1428163335083179, 0.1419182191344175, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5592cec0-c2e6-452f-a4f0-e8a21757597a", "fitness": 0.01904417263479401, "name": "HADE_RLS", "description": "Refined HADE-RLS with adaptive crossover rate and improved local search for enhanced convergence efficiency.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                adaptive_CR = self.CR * (1 - eval_count / self.budget)  # Adaptive Crossover Rate\n                crossover_points = np.random.rand(self.dim) < adaptive_CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.05, self.dim)  # Reduced perturbation scale\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 16, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044418958824071764, 0.04437399601362935, 0.036414527591079326, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04921652914772212, 0.05862908856893778, 0.05674414773741854, 0.08274777793989019, 0.08495047367886444, 0.09099108741240303, 0.027838378744753478, 0.03440766227481662, 0.04215256746710205, 0.07122611695650427, 0.06645296161292524, 0.07490461913331314, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014235377409351435, 0.0115634227590371, 0.012594524474312974, 0.009937494267855396, 0.010517319179513818, 0.010423395518102674, 0.1432392333646587, 0.14111125398042812, 0.13121995043108503, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "63fa6a8c-d198-4e81-8ede-5e53ad2fd12f", "fitness": 0.02006163715828565, "name": "HADE_RLS", "description": "Improved HADE_RLS with adaptive mutation strategy to enhance convergence speed.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 17, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["250a2364-0e1f-4ec6-8e16-7635a96a8c05"], "operator": null, "metadata": {"aucs": [0.003386901447594459, 0.004939821426965585, 0.0077057758385278285, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04692649984212416, 0.04048727640489802, 0.04313997144629411, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051379016637062125, 0.06419677612300745, 0.04728827680313963, 0.08589894991711688, 0.09689687748711506, 0.08852838176544997, 0.036943884478816025, 0.035951472230657755, 0.04191832902888404, 0.07520753259433333, 0.07639892308468144, 0.07623943568920066, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014159762266145126, 0.012742216927098093, 0.012405449148220615, 0.010527130629346959, 0.010627598274246197, 0.012929948524985524, 0.14126671375105782, 0.14079271238862712, 0.14598702384966555, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2aa723e6-f6d5-466b-951b-80435805021b", "fitness": 0.019819845102621955, "name": "HADE_RLS", "description": "Enhanced HADE_RLS with a dynamic crossover rate and adaptive perturbation for improved exploration and exploitation balance. ", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                self.CR = 0.9 * (1 - eval_count / self.budget)  # Dynamic crossover rate\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1 * (1 - eval_count / self.budget), self.dim)  # Adaptive perturbation\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 18, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0006474146836653594, 0.003474009798974942, 0.002355863547645387, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03937812700781507, 0.048322257343529795, 0.04126983756630753, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05083848905407773, 0.06148287467237934, 0.05237730499570481, 0.0877948651847984, 0.08911073590032847, 0.09573300350099723, 0.030559693055371207, 0.04006377785691273, 0.03954239642420021, 0.07247319583131095, 0.07110664589254967, 0.07943612201554873, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014090742393212397, 0.012968177019039184, 0.014406162947820489, 0.010138409968704076, 0.010620668299615832, 0.010926015754292195, 0.1422910840806917, 0.14533832421794612, 0.14071743098403589, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "42300473-c2e9-4187-bdbf-fce63b76ee32", "fitness": 0.019595002079614947, "name": "HADE_RLS", "description": "Enhanced HADE_RLS with dynamic crossover rate for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                CR_dynamic = self.CR * (1 - eval_count / self.budget) + 0.1  # Dynamic crossover rate\n                crossover_points = np.random.rand(self.dim) < CR_dynamic\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 19, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0030873172451637565, 0.002269609546535656, 0.002053766123023326, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.046458549298676655, 0.045669804419623095, 0.04177929191390417, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05199146642776964, 0.058525534852800654, 0.04781576935717802, 0.08404370863281474, 0.08825258992378737, 0.08918851661299987, 0.03316431063755498, 0.036948988434667096, 0.04191832902888404, 0.07032895905210279, 0.07358755634604497, 0.07589939855627681, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014082454587579285, 0.014072722260521808, 0.012401711885324018, 0.010563324967855947, 0.010693143570019048, 0.01119585218410446, 0.1434979197418239, 0.14180003035734112, 0.13998430637659376, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f307dc34-ef53-415a-b663-61ed506ad0fd", "fitness": 0.019972520709348685, "name": "HADE_RLS", "description": "Enhanced HADE_RLS by introducing adaptive crossover for better exploration and convergence.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR * (1 - eval_count / self.budget)  # Adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 20, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0006686858452918942, 0.0032537568778642223, 0.0023872457340655684, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03944311667502898, 0.048840612241747516, 0.042133922023289694, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05104629515679948, 0.058525534852800654, 0.056504333666532514, 0.08765265401717404, 0.09017141314942478, 0.09725920594280679, 0.0313208198109558, 0.03862033795160913, 0.0407428067749418, 0.07707482794144294, 0.07112645516174565, 0.08109579272969192, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014197422140503568, 0.013114384489292918, 0.014498163273833242, 0.010168260590604716, 0.010620454401756074, 0.01101751216610869, 0.14124775749224994, 0.14500707159020154, 0.14071743098403589, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "60e7d4e1-bc2f-4074-abda-b5d700a627d5", "fitness": 0.019771464720455798, "name": "HADE_RLS", "description": "Enhanced HADE_RLS with an adaptive crossover rate for improved exploration and convergence.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR * (0.5 + 0.5 * np.random.rand())  # Adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 21, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0005944655967592416, 0.0012541133521909442, 0.0032578531649261055, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04149695730595837, 0.04724379622504038, 0.03920730658507199, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05390559456970745, 0.058525534852800654, 0.050708643292335265, 0.0876943109375925, 0.09354835958419061, 0.0885561505371375, 0.0333081324305915, 0.03588206380628667, 0.038354483336664136, 0.07440445717968314, 0.07445035841828862, 0.079337964110194, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013709642830094126, 0.012019023518254568, 0.012215563130057672, 0.011285313751221548, 0.012719179144385251, 0.010852949888052299, 0.14279379065662, 0.1475173800428523, 0.13913685423455524, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b9a645be-7ec0-43a6-8da4-52908256f8cd", "fitness": 0.019935738311838473, "name": "HADE_RLS", "description": "Enhanced HADE_RLS by modifying the mutation factor calculation to improve exploration capability.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - (eval_count / self.budget) ** 2)  # Adaptive mutation factor with squared decay\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 22, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0025229205226141582, 0.0032366682056342855, 0.005341890913690084, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.045473012373744015, 0.04232860729967225, 0.04097597660854979, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.054728073853423265, 0.058525534852800654, 0.052231818653886375, 0.08656124110172325, 0.09299692540262783, 0.09145992119280599, 0.03269241816597457, 0.036799800787279624, 0.0480789925401921, 0.07324446588925815, 0.07434108173337473, 0.07410158158969271, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013863712352222723, 0.012484683417040676, 0.012400554740159997, 0.010928836437997247, 0.010833946484006485, 0.014209186827719655, 0.14124775749224994, 0.14076381325708143, 0.14343451836564303, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "79f86aa7-ea17-4fdb-be79-5f1944c6252c", "fitness": 0.02006163715828565, "name": "HADE_RLS", "description": "Introduced scaling factor adaptation based on fitness improvement to enhance convergence.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n        best_fitness = np.min(fitness)  # Track best fitness\n        \n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget) + 0.1 * (best_fitness - np.min(fitness))  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness  # Update best fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n                    if local_fitness < best_fitness:\n                        best_fitness = local_fitness  # Update best fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 23, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.003386901447594459, 0.004939821426965585, 0.0077057758385278285, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04692649984212416, 0.04048727640489802, 0.04313997144629411, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051379016637062125, 0.06419677612300745, 0.04728827680313963, 0.08589894991711688, 0.09689687748711506, 0.08852838176544997, 0.036943884478816025, 0.035951472230657755, 0.04191832902888404, 0.07520753259433333, 0.07639892308468144, 0.07623943568920066, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014159762266145126, 0.012742216927098093, 0.012405449148220615, 0.010527130629346959, 0.010627598274246197, 0.012929948524985524, 0.14126671375105782, 0.14079271238862712, 0.14598702384966555, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c6a2974a-18fe-423d-8677-b839395d6b99", "fitness": 0.019972520709348685, "name": "HADE_RLS", "description": "Improved HADE_RLS with adaptive crossover strategy to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR * (1 - eval_count / self.budget)  # Adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 24, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0006686858452918942, 0.0032537568778642223, 0.0023872457340655684, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03944311667502898, 0.048840612241747516, 0.042133922023289694, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05104629515679948, 0.058525534852800654, 0.056504333666532514, 0.08765265401717404, 0.09017141314942478, 0.09725920594280679, 0.0313208198109558, 0.03862033795160913, 0.0407428067749418, 0.07707482794144294, 0.07112645516174565, 0.08109579272969192, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014197422140503568, 0.013114384489292918, 0.014498163273833242, 0.010168260590604716, 0.010620454401756074, 0.01101751216610869, 0.14124775749224994, 0.14500707159020154, 0.14071743098403589, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9deee3f0-cc6c-49a7-80be-c3e84dad8393", "fitness": 0.019060953075523777, "name": "HADE_RLS", "description": "Enhanced HADE_RLS by refining the adaptive mutation factor and local search perturbation to improve robustness and exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1.5 - eval_count / self.budget)  # Adjusted adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.05, self.dim)  # Adjusted perturbation scale\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 25, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.0007470145307295617, 0.00255170235989699, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.039869405597722785, 0.04380395166387585, 0.03760411779994821, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04785495927003036, 0.05862908856893778, 0.05249068784475286, 0.08291028748643581, 0.08849659900839113, 0.09486264825130553, 0.029390424391625203, 0.03629379318852466, 0.03315885292032006, 0.06698694352257184, 0.07760251829949338, 0.07228864326497997, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014481599142542767, 0.011878853942889345, 0.012482777442494042, 0.009737123730532149, 0.011835379660374623, 0.010838498545399311, 0.14152308594273444, 0.14241089186863498, 0.13165877319256736, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "25971bcf-1218-42f6-a4ca-ecb9b3ab52b7", "fitness": 0.019771464720455798, "name": "HADE_RLS", "description": "Enhanced HADE_RLS with self-adaptive crossover strategy for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR * (0.5 + 0.5 * np.random.rand())  # Self-adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 26, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0005944655967592416, 0.0012541133521909442, 0.0032578531649261055, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04149695730595837, 0.04724379622504038, 0.03920730658507199, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05390559456970745, 0.058525534852800654, 0.050708643292335265, 0.0876943109375925, 0.09354835958419061, 0.0885561505371375, 0.0333081324305915, 0.03588206380628667, 0.038354483336664136, 0.07440445717968314, 0.07445035841828862, 0.079337964110194, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013709642830094126, 0.012019023518254568, 0.012215563130057672, 0.011285313751221548, 0.012719179144385251, 0.010852949888052299, 0.14279379065662, 0.1475173800428523, 0.13913685423455524, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "582fc224-33a8-4075-aa86-9ee9b481f0ae", "fitness": 0.01954274719937264, "name": "HADE_RLS", "description": "Enhanced HADE_RLS by adjusting the mutation strategy for better exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget) + 0.1  # Adaptive mutation factor with slight increase\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 27, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0026067319884875984, 0.0030132595677231366, 0.005763581788524874, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04538768011152783, 0.04018784079003024, 0.040053505033900594, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05090731172724272, 0.058981009452596767, 0.046830579610155576, 0.08695258673743644, 0.09015384629207923, 0.08973494174636232, 0.03087553446148439, 0.034481460829659416, 0.041223494688517714, 0.07126691010579045, 0.07567607245390406, 0.07426111684066561, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014122533724507336, 0.012621102480583124, 0.013161110173496526, 0.0100240199711783, 0.011353467751614943, 0.013987751591450603, 0.14124775749224994, 0.14076381325708143, 0.14187356029527365, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "afb4b311-1378-4ac5-9fe2-71786dc648a4", "fitness": 0.019230147916121418, "name": "HADE_RLS", "description": "Enhanced HADE_RLS by incorporating a dynamic crossover rate and an early stopping mechanism.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        best_fitness = np.min(fitness)\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                self.CR = 0.9 * (1 - eval_count / self.budget)  # Dynamic crossover rate\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n            # Early stopping if no improvement\n            current_best_fitness = np.min(fitness)\n            if current_best_fitness == best_fitness:\n                break\n            best_fitness = current_best_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 28, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.00043478260869567187, 0.00043478260869567187, 0.0, 0.0, 0.0, 0.0, 0.00043478260869567187, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00043478260869567187, 0.0, 0.00043478260869567187, 0.00043478260869567187, 0.0, 0.0, 0.00043478260869567187, 0.0, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00043478260869567187, 0.0, 0.0, 0.00043478260869567187, 0.03840306748469824, 0.04605554726036687, 0.042133922023289694, 0.00043478260869567187, 0.0, 0.0, 0.04459913488737666, 0.058116548362181275, 0.05609575034449377, 0.08700264858594631, 0.08284795299965009, 0.09686874976854754, 0.0313208198109558, 0.03234057811678415, 0.040326942597448956, 0.07667930524934574, 0.07112645516174565, 0.08007250824810086, 0.0, 0.00043478260869567187, 0.00043478260869567187, 0.014197422140503568, 0.011057889805913712, 0.0111363332353549, 0.010168260590604716, 0.010620454401756074, 0.010587621847194195, 0.14087512050629525, 0.14463578563350576, 0.1403453091595518, 0.0, 0.0, 0.00043478260869567187]}}
{"id": "276cc09a-aa56-4ada-8a02-0e45efc11d16", "fitness": 0.019728148762508994, "name": "HADE_RLS", "description": "Introduced adaptive crossover rate to enhance exploration in the initial stages and exploitation in later stages.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR * (eval_count / self.budget)  # Adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 29, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0013024103072666326, 0.00718337485938636, 0.002711745724858994, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04691382030063951, 0.04506639041194216, 0.04739495164700713, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05152738346270047, 0.058525534852800654, 0.055004851348170014, 0.08849874032238547, 0.09393312687623911, 0.08918279025727216, 0.03116318286872588, 0.03916706907323442, 0.0346873257617738, 0.06891938371931305, 0.07317231821511838, 0.07438091310802286, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014044131994653042, 0.0128377782316218, 0.01272600303073812, 0.010918152070462206, 0.011464486979231858, 0.01130519584854106, 0.1436535038962672, 0.1413338225548323, 0.1338431057861379, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "82dfb087-d95e-49a1-adaa-318c18536a5b", "fitness": -Infinity, "name": "HADE_RLS", "description": "Enhanced HADE_RLS with modified crossover and perturbation dynamics for improved exploration and exploitation.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < (self.CR + 0.1 * np.sin(np.pi * eval_count / self.budget))\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1 + 0.05 * (1 - fitness[i]/max(fitness)), self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 30, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {}}
{"id": "69f2a1f3-af54-4953-8080-a5874d58f749", "fitness": 0.019728148762508994, "name": "HADE_RLS", "description": "Enhanced HADE_RLS using adaptive crossover rate to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR * (eval_count / self.budget)  # Adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < CR_adaptive  # Use CR_adaptive instead of self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 31, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0013024103072666326, 0.00718337485938636, 0.002711745724858994, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04691382030063951, 0.04506639041194216, 0.04739495164700713, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05152738346270047, 0.058525534852800654, 0.055004851348170014, 0.08849874032238547, 0.09393312687623911, 0.08918279025727216, 0.03116318286872588, 0.03916706907323442, 0.0346873257617738, 0.06891938371931305, 0.07317231821511838, 0.07438091310802286, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014044131994653042, 0.0128377782316218, 0.01272600303073812, 0.010918152070462206, 0.011464486979231858, 0.01130519584854106, 0.1436535038962672, 0.1413338225548323, 0.1338431057861379, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "425c666a-0626-408c-ad9e-38454c18797f", "fitness": 0.02003178890228148, "name": "HADE_RLS", "description": "Enhanced HADE_RLS with dynamic population size adjustment based on evaluation count to improve exploitation.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Adjust population size dynamically\n            current_population_size = max(2, int(self.population_size * (1 - eval_count / self.budget)))\n\n            # Differential Evolution\n            for i in range(current_population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(current_population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 32, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.0032950758144562053, 0.0011126330255945005, 0.0021428905070886017, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04688822325048159, 0.043463266252068866, 0.04007676054956366, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05431015254136562, 0.06419677612300745, 0.05242698081103059, 0.08818069925846761, 0.09154489579296454, 0.09464397269246627, 0.035352819729711826, 0.036129881533275565, 0.04406359077578126, 0.0729036751813158, 0.07463881221572488, 0.07725094972278168, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015642841687219855, 0.013599092416272218, 0.012428212060256238, 0.010904785456094412, 0.010349716641249507, 0.010812129331745912, 0.14124775749224994, 0.14304051272893326, 0.1420764799817935, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0c73325d-7f7d-4014-9d93-faaa2c4c33ce", "fitness": 0.020107379850691894, "name": "HADE_RLS", "description": "Introduced a dynamic crossover rate to balance exploration and exploitation during optimization.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 33, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["63fa6a8c-d198-4e81-8ede-5e53ad2fd12f"], "operator": null, "metadata": {"aucs": [0.004860674179275493, 0.0008136906307671943, 0.005028165162093479, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04768462170451904, 0.0498308514384167, 0.052094720560091234, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051201381272201085, 0.058525534852800654, 0.056504333666532514, 0.08632972424508967, 0.08932542941642607, 0.09160978739384973, 0.03193475638358889, 0.03407191645865559, 0.03720254442936943, 0.07547382469890462, 0.0710746171079113, 0.0753667327474764, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013867503474834453, 0.012726974423018622, 0.012821639584343236, 0.01086631053248921, 0.012080748443517142, 0.011089818946139252, 0.14193185692285903, 0.1561375857253482, 0.1377103874579927, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7f3c7205-33f5-4200-89bd-10b9f4ebad86", "fitness": 0.019663237110189302, "name": "HADE_RLS", "description": "Enhanced local search by introducing adaptive perturbation to boost convergence.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                adaptive_perturbation = 0.1 * (1 - eval_count / self.budget)  # Adaptive perturbation\n                perturbation = np.random.normal(0, adaptive_perturbation, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 34, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["0c73325d-7f7d-4014-9d93-faaa2c4c33ce"], "operator": null, "metadata": {"aucs": [0.004561159438501661, 0.00076677188662988, 0.005089777515256522, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04664927078389647, 0.04951655786628084, 0.051984578409559945, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04788496835033362, 0.05868773633468383, 0.05237730499570481, 0.08453154146031072, 0.08856158733861397, 0.0913448931678803, 0.0324584106974346, 0.034500196462124766, 0.03423641620514628, 0.07513863501339269, 0.07177789213114782, 0.07348082656903598, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013821562355891603, 0.01264544932940248, 0.012818549531762313, 0.010836456958860485, 0.012019089999857457, 0.011243245280410097, 0.14150651201960285, 0.14500707159020154, 0.13274139285040099, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "11d2eb77-1943-405e-b859-dab86fa9367e", "fitness": 0.020208207902944655, "name": "HADE_RLS", "description": "Enhanced mutation strategy by incorporating dimension-wise scaling and introduced diversity control for improved exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 35, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["0c73325d-7f7d-4014-9d93-faaa2c4c33ce"], "operator": null, "metadata": {"aucs": [0.007182331025710531, 0.004414655981048732, 0.0035467717235625473, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04723881287089149, 0.04295428194482531, 0.04611211087137135, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056790948337215874, 0.058525534852800654, 0.05191497015790225, 0.0855743101202261, 0.09472612321000429, 0.09250010788439078, 0.03299791031555799, 0.036879822780878646, 0.03676227181483527, 0.08321665905248032, 0.07672413915408216, 0.07958190761755646, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014487771322077903, 0.01508183936243257, 0.013322632111629429, 0.011067318010875127, 0.010478410828561158, 0.011210476813917625, 0.1423298973684125, 0.1425940717407984, 0.13720966434666448, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "be4ed1b1-1284-4696-acdf-6a38bd093a33", "fitness": 0.019934783237546105, "name": "HADE_RLS", "description": "Improved adaptive strategy by refining crossover rate adaptation for enhanced convergence.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init * (self.CR_final / self.CR_init) ** (eval_count / self.budget)  # Adjusted crossover adaptation\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 36, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["11d2eb77-1943-405e-b859-dab86fa9367e"], "operator": null, "metadata": {"aucs": [0.004867999334296047, 0.001342660748636204, 0.0034620951805127698, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04396997894007837, 0.04073248090178627, 0.0434295671318381, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056790948337215874, 0.060975944405391114, 0.05437025444611965, 0.08541983908055739, 0.09592108345527772, 0.09332358092653881, 0.03263492703788973, 0.03892782210382195, 0.035947006543714966, 0.07914570615506222, 0.07269627751131691, 0.0771526598654999, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013752841362785428, 0.01567975412665701, 0.012189818565632171, 0.011851754620457067, 0.011054048041660436, 0.010993166276054178, 0.14177116441172555, 0.14076381325708143, 0.13657198294440698, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "638dbb36-ddde-41dc-a637-dd523f136266", "fitness": 0.020068934507580335, "name": "HADE_RLS", "description": "Improved exploration by introducing a dynamic perturbation factor in the Randomized Local Search phase.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                dynamic_perturbation = 0.1 * (1 - eval_count / self.budget)  # Dynamic perturbation factor\n                perturbation = np.random.normal(0, dynamic_perturbation, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 37, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["11d2eb77-1943-405e-b859-dab86fa9367e"], "operator": null, "metadata": {"aucs": [0.006595012547908952, 0.00418866608827928, 0.004047084955276725, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04628057219802073, 0.04242576808016785, 0.045723893557955586, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.057478892329713926, 0.058525534852800654, 0.054460774187644945, 0.08474390779164165, 0.09228433478969233, 0.09059058218733596, 0.030485898634431186, 0.03567655236513256, 0.03710506258285362, 0.08354622775823117, 0.07169003429346033, 0.07844218546453074, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01431122704754062, 0.014722595551665996, 0.013263023093602389, 0.011029050827833897, 0.010429256289238853, 0.011046172145477096, 0.14250209368084887, 0.14649749281940994, 0.13730617103378318, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a6f544b7-9c63-4c1a-bde8-fc679ac59b66", "fitness": 0.01962700734981792, "name": "HADE_RLS", "description": "Introduced momentum-based scaling for mutation factors to enhance convergence speed.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n        self.momentum = 0.9  # Momentum factor\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        previous_fitness = fitness.copy()\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget) + self.momentum * (fitness[i] - previous_fitness[i])\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    previous_fitness[i] = fitness[i]\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    previous_fitness[i] = fitness[i]\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 38, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["11d2eb77-1943-405e-b859-dab86fa9367e"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.0019565231960901874, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.036563956787395435, 0.04802555103139683, 0.04105326669801901, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056790948337215874, 0.058525534852800654, 0.05191497015790225, 0.0847786597413478, 0.09285498471446518, 0.09433808861569815, 0.03065079000546378, 0.03396295839890173, 0.03306350114934464, 0.07878766081547106, 0.06656983291785845, 0.0763852928289025, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01403412076883681, 0.014739590877231978, 0.012677123827872894, 0.010388338900447325, 0.010938723075056167, 0.011305746722850119, 0.15452169756859835, 0.14076381325708143, 0.1371180713319451, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f4c9cb5a-a595-4aa6-b96d-d67fb5e01e78", "fitness": 0.020068934507580335, "name": "HADE_RLS", "description": "Introduce adaptive perturbation in Randomized Local Search to improve local exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1 * (1 - eval_count / self.budget), self.dim)  # Adaptive perturbation\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 39, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["11d2eb77-1943-405e-b859-dab86fa9367e"], "operator": null, "metadata": {"aucs": [0.006595012547908952, 0.00418866608827928, 0.004047084955276725, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04628057219802073, 0.04242576808016785, 0.045723893557955586, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.057478892329713926, 0.058525534852800654, 0.054460774187644945, 0.08474390779164165, 0.09228433478969233, 0.09059058218733596, 0.030485898634431186, 0.03567655236513256, 0.03710506258285362, 0.08354622775823117, 0.07169003429346033, 0.07844218546453074, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01431122704754062, 0.014722595551665996, 0.013263023093602389, 0.011029050827833897, 0.010429256289238853, 0.011046172145477096, 0.14250209368084887, 0.14649749281940994, 0.13730617103378318, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "50784696-671f-4d09-bde9-71c2c7315e31", "fitness": 0.02011058630703743, "name": "HADE_RLS", "description": "Introduced a refined adaptive mutation factor to enhance convergence speed.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - (eval_count / self.budget)**2)  # Refined adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 40, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["11d2eb77-1943-405e-b859-dab86fa9367e"], "operator": null, "metadata": {"aucs": [0.004113363534780423, 0.0012586592072144631, 0.0024892467471872015, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.046930779622480046, 0.05052304612000269, 0.04805353339423579, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05203791227159582, 0.06056545492791354, 0.05204828218860291, 0.08663595941398317, 0.09456048235029813, 0.09629186917278865, 0.03397497747369904, 0.04069797170406986, 0.03592389539702645, 0.0766636546562236, 0.07178805522043663, 0.0782114650268686, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014388584805345328, 0.014311730173365511, 0.013271498504602408, 0.011051761306706709, 0.011472810793622501, 0.010966688652019663, 0.14379018101520924, 0.14160737525994216, 0.13476775777516936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4caed479-0f51-4c83-93b3-9392de28ba73", "fitness": 0.020068934507580335, "name": "HADE_RLS", "description": "Enhanced exploration by varying the perturbation scale in the local search phase.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_scale = 0.1 * (1 - eval_count / self.budget)  # Varying perturbation scale\n                perturbation = np.random.normal(0, perturbation_scale, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 41, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["11d2eb77-1943-405e-b859-dab86fa9367e"], "operator": null, "metadata": {"aucs": [0.006595012547908952, 0.00418866608827928, 0.004047084955276725, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04628057219802073, 0.04242576808016785, 0.045723893557955586, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.057478892329713926, 0.058525534852800654, 0.054460774187644945, 0.08474390779164165, 0.09228433478969233, 0.09059058218733596, 0.030485898634431186, 0.03567655236513256, 0.03710506258285362, 0.08354622775823117, 0.07169003429346033, 0.07844218546453074, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01431122704754062, 0.014722595551665996, 0.013263023093602389, 0.011029050827833897, 0.010429256289238853, 0.011046172145477096, 0.14250209368084887, 0.14649749281940994, 0.13730617103378318, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b4f9505b-f061-4661-906a-3b9649dde920", "fitness": 0.020068934507580335, "name": "HADE_RLS", "description": "Adaptive perturbation introduced in localized search for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_scale = 0.1 * (1 - eval_count / self.budget)  # Adaptive perturbation\n                perturbation = np.random.normal(0, perturbation_scale, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 42, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["11d2eb77-1943-405e-b859-dab86fa9367e"], "operator": null, "metadata": {"aucs": [0.006595012547908952, 0.00418866608827928, 0.004047084955276725, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04628057219802073, 0.04242576808016785, 0.045723893557955586, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.057478892329713926, 0.058525534852800654, 0.054460774187644945, 0.08474390779164165, 0.09228433478969233, 0.09059058218733596, 0.030485898634431186, 0.03567655236513256, 0.03710506258285362, 0.08354622775823117, 0.07169003429346033, 0.07844218546453074, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01431122704754062, 0.014722595551665996, 0.013263023093602389, 0.011029050827833897, 0.010429256289238853, 0.011046172145477096, 0.14250209368084887, 0.14649749281940994, 0.13730617103378318, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6443e8fd-66a7-4626-b45d-894aaeca4be9", "fitness": 0.020225935527976392, "name": "HADE_RLS", "description": "Refined mutation scaling by introducing a temperature-like adaptive control for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - (eval_count / self.budget)**0.5)  # Temperature-like adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 43, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["11d2eb77-1943-405e-b859-dab86fa9367e"], "operator": null, "metadata": {"aucs": [0.008905766451031694, 0.004100739523708263, 0.00328371854350773, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.043020941453538075, 0.046683135068206316, 0.05066500180728528, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0590811251551685, 0.05995197237117622, 0.04964079557312029, 0.08899685944232039, 0.09305057974186792, 0.09392575716547524, 0.03253673618163766, 0.03825025141662197, 0.037231245658472245, 0.08279492421578116, 0.07720847205263792, 0.07736742130421248, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014691914893336322, 0.014949654844562343, 0.012968608984125107, 0.011123505084729812, 0.011156899106952167, 0.011056636584613866, 0.1414049248469007, 0.14193916843641285, 0.1307153847155924, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2ce2a20b-cae2-45cd-a761-f4e26ac14ac0", "fitness": 0.0202159677364281, "name": "HADE_RLS", "description": "Introduce dynamic perturbation adjustment in local search based on convergence rate to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - (eval_count / self.budget)**0.5)  # Temperature-like adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_scale = 0.1 * (1 - (eval_count / self.budget))  # Adjusted perturbation scale\n                perturbation = np.random.normal(0, perturbation_scale, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 44, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["6443e8fd-66a7-4626-b45d-894aaeca4be9"], "operator": null, "metadata": {"aucs": [0.008350379608169978, 0.003942975971234275, 0.0030581068731051486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04245248297018467, 0.04602091328683444, 0.05042950711724126, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056782069414059166, 0.058525534852800654, 0.04791712986675123, 0.08718227562754455, 0.09632501702246932, 0.09454783140322409, 0.03361452636742046, 0.036528693293868986, 0.03742547023812337, 0.08082578402989582, 0.0776826442755808, 0.07779184430716646, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014688948178328776, 0.014626126211282231, 0.012928274504574455, 0.011088462062049387, 0.01111248763529682, 0.011043984332531287, 0.14124775749224994, 0.1422862459132026, 0.1375589867763276, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "292c2969-292c-4418-8ce0-2d7c97d49d46", "fitness": 0.020225935527976392, "name": "HADE_RLS", "description": "Enhanced mutation scaling with dynamic temperature control and rotation matrix for optimized exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - (eval_count / self.budget)**0.5)  # Temperature-like adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 45, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["6443e8fd-66a7-4626-b45d-894aaeca4be9"], "operator": null, "metadata": {"aucs": [0.008905766451031694, 0.004100739523708263, 0.00328371854350773, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.043020941453538075, 0.046683135068206316, 0.05066500180728528, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0590811251551685, 0.05995197237117622, 0.04964079557312029, 0.08899685944232039, 0.09305057974186792, 0.09392575716547524, 0.03253673618163766, 0.03825025141662197, 0.037231245658472245, 0.08279492421578116, 0.07720847205263792, 0.07736742130421248, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014691914893336322, 0.014949654844562343, 0.012968608984125107, 0.011123505084729812, 0.011156899106952167, 0.011056636584613866, 0.1414049248469007, 0.14193916843641285, 0.1307153847155924, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "22d60df0-6bea-4974-833d-32157036d795", "fitness": 0.0202159677364281, "name": "HADE_RLS", "description": "Introduced an adaptive perturbation scaling for local search based on evaluation progress to enhance fine-tuning capability.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * (1 - (eval_count / self.budget)**0.5)  # Temperature-like adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                adaptive_perturbation = 0.1 * (1 - eval_count / self.budget)  # Adaptive perturbation scaling\n                perturbation = np.random.normal(0, adaptive_perturbation, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 46, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["6443e8fd-66a7-4626-b45d-894aaeca4be9"], "operator": null, "metadata": {"aucs": [0.008350379608169978, 0.003942975971234275, 0.0030581068731051486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04245248297018467, 0.04602091328683444, 0.05042950711724126, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056782069414059166, 0.058525534852800654, 0.04791712986675123, 0.08718227562754455, 0.09632501702246932, 0.09454783140322409, 0.03361452636742046, 0.036528693293868986, 0.03742547023812337, 0.08082578402989582, 0.0776826442755808, 0.07779184430716646, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014688948178328776, 0.014626126211282231, 0.012928274504574455, 0.011088462062049387, 0.01111248763529682, 0.011043984332531287, 0.14124775749224994, 0.1422862459132026, 0.1375589867763276, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a6b71a19-1a9f-403c-9db5-8e6b2d070aee", "fitness": 0.020369538818738594, "name": "HADE_RLS", "description": "Introduce diversity by varying the mutation factor dynamically throughout the optimization process.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * (1 - (eval_count / self.budget)**0.5)  # Temperature-like adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 47, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["6443e8fd-66a7-4626-b45d-894aaeca4be9"], "operator": null, "metadata": {"aucs": [0.0031851835087935987, 0.008333695783019568, 0.007286948667670767, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044573646334967965, 0.04758348265796464, 0.042167186063880036, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052434983628720455, 0.05868765194083092, 0.048752471464355684, 0.09835397898235565, 0.09539513689517742, 0.09029030340497446, 0.04455548419152744, 0.04097433328969091, 0.037616165149312986, 0.07662032001910057, 0.07031432548505212, 0.08064891570334187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014146344779075393, 0.011750707231158675, 0.012872113523405782, 0.01086151311781225, 0.013962582038563154, 0.013646583549946856, 0.14124775749224994, 0.1410206282748051, 0.13975913438011933, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "368ab1e7-1906-450d-9020-e5399570e794", "fitness": 0.02030878295888798, "name": "HADE_RLS", "description": "Refine the strategy by adjusting the adaptive mutation factor's temperature scaling for improved diversity control.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * (1 - (eval_count / self.budget)**0.3)  # Adjusted temperature scaling\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 48, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["a6b71a19-1a9f-403c-9db5-8e6b2d070aee"], "operator": null, "metadata": {"aucs": [0.00333411659491778, 0.009961542449328231, 0.010215245464728628, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.047965906430386784, 0.04675139005209683, 0.04136335044952377, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049873323962930316, 0.05868765194083092, 0.053890051768746505, 0.09383392802225621, 0.0940687745712937, 0.09504720669713229, 0.04201584371269396, 0.03963747599543277, 0.03799923228686819, 0.07472787775682932, 0.07193107389603226, 0.07921342092902206, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014053566996255484, 0.012313044912282023, 0.012968923991225623, 0.010384681961820963, 0.013408566523437915, 0.0127986603823661, 0.14124775749224994, 0.14076381325708143, 0.13421072715085935, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9a484f8e-d069-461b-953c-4ffcf142f19e", "fitness": 0.020014969709714368, "name": "HADE_RLS", "description": "Introduce a cooling schedule to the crossover rate for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.1  # Changed Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * (1 - (eval_count / self.budget)**0.5)  # Temperature-like adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 49, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["a6b71a19-1a9f-403c-9db5-8e6b2d070aee"], "operator": null, "metadata": {"aucs": [0.0018510582834097011, 0.0037521474026903645, 0.0009185224102370437, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04777561477321279, 0.04861237391806561, 0.04066761876469116, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04893662256156961, 0.05868765194083092, 0.04884546439059512, 0.09562590429100781, 0.08858027049097195, 0.09302089534487179, 0.029905202025370614, 0.03591970926421573, 0.037474562281287094, 0.07341836066203145, 0.07256029202727565, 0.0760351577267181, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01423567964903727, 0.012810320670328945, 0.013471389880977847, 0.011381843959596405, 0.011029508477094718, 0.013740320214647217, 0.1426461643980791, 0.14107308108988648, 0.15853686480942863, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "27b32c84-32f4-4415-bfa6-3c9b552e35df", "fitness": 0.020141172377043732, "name": "HADE_RLS", "description": "Introduce diversity by varying both mutation and crossover factors dynamically throughout the optimization process.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * (1 - (eval_count / self.budget)**0.5)  # Temperature-like adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = (self.CR_init - (self.CR_init - self.CR_final) * np.random.rand()) * (1 - (eval_count / self.budget))  # New adaptive crossover rate\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 50, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["a6b71a19-1a9f-403c-9db5-8e6b2d070aee"], "operator": null, "metadata": {"aucs": [0.0006109301898014063, 0.00043478260869567187, 0.00310876305325547, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05702391203174817, 0.050964839107194404, 0.043697958512580404, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.058009667826989464, 0.05967242867684508, 0.05415301507133452, 0.08534547694445183, 0.08715420407031949, 0.08873958310744134, 0.029116974774504922, 0.03419745459879919, 0.03506918925248215, 0.07684105823363963, 0.07556737289590021, 0.0794703514608146, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014192412637747176, 0.01229128407456781, 0.01438709221452128, 0.011380615929208582, 0.01361442134899693, 0.010372161841858185, 0.14124775749224994, 0.14564232276320188, 0.14829316303669393, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "bed8233b-eab1-42ce-8a88-55c269150269", "fitness": 0.020201675373105108, "name": "HADE_RLS", "description": "Enhance the exploration by adjusting dimension scaling adaptively based on the evaluation count.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * (1 - (eval_count / self.budget)**0.5)  # Temperature-like adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - eval_count / self.budget)  # Adaptive dimension scaling\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 51, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["a6b71a19-1a9f-403c-9db5-8e6b2d070aee"], "operator": null, "metadata": {"aucs": [0.005653801360225086, 0.009959981688200559, 0.008606864433245986, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04610600196837367, 0.046938377180703816, 0.040451493865207744, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04936532969324203, 0.05868765194083092, 0.048078962623066546, 0.09528859424574698, 0.09437132531940906, 0.09208564072663727, 0.04460973023599746, 0.04451399823294566, 0.03731308230110719, 0.07488206536579212, 0.07135792663767915, 0.07770302973836352, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014008734406343315, 0.013000502620404752, 0.012913651155520345, 0.010545375012361524, 0.013454858242162748, 0.013286465768742373, 0.14124775749224994, 0.1413791236320816, 0.12914508358562105, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "3361dfde-2573-4754-9697-e5d589e0c99c", "fitness": 0.020247142278960708, "name": "HADE_RLS", "description": "Enhance exploration by adjusting the perturbation during the Randomized Local Search phase.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * (1 - (eval_count / self.budget)**0.5)  # Temperature-like adaptive mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1 * (1 - eval_count / self.budget), self.dim) # Adjust perturbation\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 52, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["a6b71a19-1a9f-403c-9db5-8e6b2d070aee"], "operator": null, "metadata": {"aucs": [0.0030351487603700322, 0.008421225673972188, 0.007150260485011883, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04453827619550477, 0.04755081733350375, 0.042002687607571754, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05371580155908995, 0.05950620024616471, 0.0520574990313043, 0.09273355322340704, 0.09552789298091346, 0.09016588746751986, 0.04313644795614413, 0.04281300432191426, 0.034123932508878574, 0.07673066395361094, 0.0715558794681328, 0.07939085953087477, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013996462012863087, 0.011717597351071363, 0.012783877791316844, 0.010845251139677825, 0.01402989095784013, 0.013485279088346291, 0.14288942595705023, 0.14076381325708143, 0.1335613908347294, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c22b39fd-0a4c-451a-aee7-4acaac860669", "fitness": 0.020448242502411063, "name": "HADE_RLS", "description": "Enhance diversity by introducing an exponential decay to the mutation factor over time.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 53, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["a6b71a19-1a9f-403c-9db5-8e6b2d070aee"], "operator": null, "metadata": {"aucs": [0.007497377381240455, 0.003928686817604388, 0.00596265808517904, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04015763605495226, 0.045993304301576665, 0.03967766048530552, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049427297474977316, 0.05958285359846105, 0.05396417523792185, 0.0944683718365984, 0.09754175777819696, 0.08992026032331579, 0.047919019387787865, 0.037188139041721135, 0.03773527417155331, 0.0779879691429306, 0.07137656320111097, 0.07912997508592412, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01564548548654543, 0.012798180480829036, 0.012400714328775542, 0.010090683503192643, 0.015454591621767655, 0.014127496026554276, 0.14124775749224994, 0.14703601949812528, 0.14444833493789366, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "50d49f95-c8ba-49cc-b174-ef97affc77e9", "fitness": 0.01997010556629149, "name": "HADE_RLS", "description": "Modify the crossover strategy to include dimension-based adaptive crossover rates for improved exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                dimension_cr = np.random.uniform(0.4, 0.9, self.dim) * (1 - eval_count / self.budget)  # Dimension-based adaptive rates\n                crossover_points = np.random.rand(self.dim) < (CR_adaptive * dimension_cr)\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 54, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.0020959313303416938, 0.00339473556533354, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04322311717873695, 0.06375206753942664, 0.052782644932426015, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05322853949364503, 0.06086294326384234, 0.05320013805263979, 0.08855757086275684, 0.09090887697526617, 0.08884899680908231, 0.032443927399578576, 0.03282504754147997, 0.03724805993965952, 0.07109631277296613, 0.0737681703675045, 0.07488581513520232, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014465661329436497, 0.012229526701469706, 0.013485151236135917, 0.0113068993377613, 0.009915423749502161, 0.01095936618364346, 0.14132287461952353, 0.14339157915342615, 0.1376482233021994, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "57840356-2204-4260-9634-68111a974b0c", "fitness": 0.020183388564635158, "name": "HADE_RLS", "description": "Enhance exploration and solution quality by introducing adaptive perturbation and crossover scaling based on evaluation phase.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_scale = 0.1 * (1 - eval_count / self.budget)  # Adaptive perturbation\n                perturbation = np.random.normal(0, perturbation_scale, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 55, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.007210096411738198, 0.003892819209534215, 0.005941385567780899, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04007289819763327, 0.04582231735158071, 0.03958691738410047, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04676517649848844, 0.05950620024616471, 0.05565318075245218, 0.09328029400344506, 0.1000924612041717, 0.08923526572144136, 0.04783895698838403, 0.03728442200785653, 0.03681463700303533, 0.07184560037095589, 0.07152223710578276, 0.0791665558070821, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015627128077451813, 0.012754845256342517, 0.012397159888094977, 0.010109483674718645, 0.015274390863223575, 0.013903936548511076, 0.14124775749224994, 0.14076381325708143, 0.14002882237312453, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "306946b2-4cad-4d88-87ec-2ea052ed7764", "fitness": 0.020183388564635158, "name": "HADE_RLS", "description": "Introduce dynamic perturbation scaling during randomized local search to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_scale = 0.1 * (1 - eval_count / self.budget)  # Dynamic perturbation scaling\n                perturbation = np.random.normal(0, perturbation_scale, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 56, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.007210096411738198, 0.003892819209534215, 0.005941385567780899, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04007289819763327, 0.04582231735158071, 0.03958691738410047, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04676517649848844, 0.05950620024616471, 0.05565318075245218, 0.09328029400344506, 0.1000924612041717, 0.08923526572144136, 0.04783895698838403, 0.03728442200785653, 0.03681463700303533, 0.07184560037095589, 0.07152223710578276, 0.0791665558070821, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015627128077451813, 0.012754845256342517, 0.012397159888094977, 0.010109483674718645, 0.015274390863223575, 0.013903936548511076, 0.14124775749224994, 0.14076381325708143, 0.14002882237312453, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "06fe4200-2714-42e2-be29-4dfb039d43a9", "fitness": 0.018232175785409716, "name": "HADE_RLS", "description": "Refine mutation strategy by introducing variance scaling to enhance diversity.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                variance_scaling = np.var(population, axis=0)  # Variance scaling\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling * variance_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 57, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.031269723435380814, 0.036688444618252825, 0.030230973129944716, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04989202813835936, 0.05868765194083092, 0.0498697429159054, 0.07870255675368343, 0.08478336057989011, 0.0880719581358188, 0.025184278671173455, 0.032760997119857915, 0.03731308230110719, 0.06608295182637902, 0.06514316784366281, 0.0724669802917145, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013808625015692688, 0.01151256078421814, 0.011608637370515873, 0.009218298852935347, 0.009261496775251121, 0.01013376965564039, 0.14124775749224994, 0.14592195351788895, 0.13198609416575358, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "16dbcd3b-05ef-4e5d-8702-e9c085b93a5b", "fitness": 0.019853338828124553, "name": "HADE_RLS", "description": "Introduce an adaptive crossover rate influenced by the diversity of the population to enhance exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                diversity = np.std(population, axis=0).mean()  # Added line\n                CR_adaptive = (self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)) * diversity\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 58, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.0029398851281388083, 0.0022247483286254033, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03759308742210776, 0.04308305437878612, 0.04462445403459159, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05306161414560784, 0.05868765194083092, 0.050089976792708324, 0.09283437261582672, 0.09171656668860917, 0.09305960982938888, 0.04322535155565199, 0.034966894455958575, 0.03731308230110719, 0.07181330873433545, 0.07460459826880983, 0.08046854101281808, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014190132705387715, 0.012676871000505296, 0.014844498258778205, 0.011340939765603686, 0.010376238709345897, 0.012339227742926284, 0.14333288199304128, 0.14209905282893565, 0.13593375498654037, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ac452a75-d482-4e4c-b45f-9e199aa3baf4", "fitness": 0.01893009075409105, "name": "HADE_RLS", "description": "Enhance search efficiency by adjusting the scaling factor dimensionally, based on fitness variance across dimensions.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * np.std(population, axis=0)  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 59, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.0010997637026463059, 0.0008303582480885252, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.032390071841941426, 0.04828350426513961, 0.03131246909332808, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04899745003094702, 0.05868765194083092, 0.04973731835956341, 0.0817594732668302, 0.08696430151910117, 0.0880719581358188, 0.03267482813786815, 0.03286096787973891, 0.03731308230110719, 0.06676301984628696, 0.06817754825970124, 0.0724669802917145, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014725678922083318, 0.012196249572645201, 0.014171097877930583, 0.009356846707914923, 0.010625500859845372, 0.01072854950664448, 0.14820511571914374, 0.14295851391096592, 0.14160823409672874, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e935cf05-3a82-414a-a54d-4034b7e35063", "fitness": 0.020300948092369923, "name": "HADE_RLS", "description": "Adaptive perturbation radius for local search to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_radius = 0.1 * np.exp(-eval_count / self.budget)  # Adaptive perturbation radius\n                perturbation = np.random.normal(0, perturbation_radius, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 60, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.007259389124325555, 0.003901116539297589, 0.005947503126061848, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04008446228584861, 0.04588262939766541, 0.0395621825145237, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04925349434366444, 0.06077955894770737, 0.05554034151143972, 0.09440250917109516, 0.0993881931266829, 0.0891846984485366, 0.048174055853214326, 0.03781743516111402, 0.03766955634708524, 0.07632886266231453, 0.07299208595610707, 0.07856156615985999, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01563591426797939, 0.01276125161395969, 0.012399692167417431, 0.010110493248082997, 0.015271546128414748, 0.013961044712699433, 0.14124775749224994, 0.14187952840672813, 0.13610617654525348, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "3810e360-d2f1-4b9b-8ac7-73bfde57afc5", "fitness": 0.019872609229318623, "name": "HADE_RLS", "description": "Improve the adaptation of the crossover rate by refining its calculation to consider both time and improvement.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * ((eval_count / self.budget) * (fitness[i] / (np.min(fitness) + 1e-8)))  # Refined crossover adaptation\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 61, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.009742181039342435, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04143066441671828, 0.044715812095156515, 0.04588125435803192, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04919758933081042, 0.05958285359846105, 0.05007803625809348, 0.09568865383102287, 0.09250570976287276, 0.08985967716931553, 0.032451853358458904, 0.03417570905971146, 0.03734498748061821, 0.0721557833025811, 0.07567642742242264, 0.07651237131543953, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01564548548654543, 0.012764860156471158, 0.012400714328775542, 0.01020224033659578, 0.013574659673840084, 0.014127496026554276, 0.14278596428461043, 0.14578592126454104, 0.13610617654525348, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "040dd635-7f20-4ba7-845d-cb5a2d00b023", "fitness": 0.020300948092369923, "name": "HADE_RLS", "description": "Enhance diversity by introducing an exponential decay to both the mutation factor and the perturbation in local search over time.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1 * np.exp(-eval_count / self.budget), self.dim)  # Exponential decay for perturbation\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 62, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.007259389124325555, 0.003901116539297589, 0.005947503126061848, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04008446228584861, 0.04588262939766541, 0.0395621825145237, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04925349434366444, 0.06077955894770737, 0.05554034151143972, 0.09440250917109516, 0.0993881931266829, 0.0891846984485366, 0.048174055853214326, 0.03781743516111402, 0.03766955634708524, 0.07632886266231453, 0.07299208595610707, 0.07856156615985999, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01563591426797939, 0.01276125161395969, 0.012399692167417431, 0.010110493248082997, 0.015271546128414748, 0.013961044712699433, 0.14124775749224994, 0.14187952840672813, 0.13610617654525348, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "edac6ffd-414e-4797-8512-c206ba708114", "fitness": 0.020183388564635158, "name": "HADE_RLS", "description": "Introduce adaptive perturbation scaling based on evaluation progress to improve local search exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_scale = 0.1 * (1 - eval_count / self.budget)  # Adaptive perturbation scaling\n                perturbation = np.random.normal(0, perturbation_scale, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 63, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.007210096411738198, 0.003892819209534215, 0.005941385567780899, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04007289819763327, 0.04582231735158071, 0.03958691738410047, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04676517649848844, 0.05950620024616471, 0.05565318075245218, 0.09328029400344506, 0.1000924612041717, 0.08923526572144136, 0.04783895698838403, 0.03728442200785653, 0.03681463700303533, 0.07184560037095589, 0.07152223710578276, 0.0791665558070821, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015627128077451813, 0.012754845256342517, 0.012397159888094977, 0.010109483674718645, 0.015274390863223575, 0.013903936548511076, 0.14124775749224994, 0.14076381325708143, 0.14002882237312453, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "679e6030-d871-4149-ba66-492b1d741f53", "fitness": 0.019898572115526855, "name": "HADE_RLS", "description": "Introduce Gaussian crossover for smoother exploration and exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points] + np.random.normal(0, 0.1, self.dim)[crossover_points]  # Gaussian crossover\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 64, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.0012880628117757364, 0.006905189578927384, 0.0033376108320254394, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04167292261439204, 0.049131269524837484, 0.04568203026425599, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04787301198386207, 0.058718107564149746, 0.05415626282223296, 0.08780237982485295, 0.09203826179016672, 0.09226193483904666, 0.035156597388170674, 0.03469131735254771, 0.03685084297705721, 0.07135704178498226, 0.07732167158674097, 0.07721892419427545, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013794656267781202, 0.014408523171150156, 0.013223265411003715, 0.011519511397634963, 0.011964108944260143, 0.010475720935271604, 0.14835617565029535, 0.14076381325708143, 0.13516276015785034, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "3d95ecf9-ae41-40ed-8e96-4404cb1d004b", "fitness": 0.020183388564635158, "name": "HADE_RLS", "description": "Introduce adaptive local search step size for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  # Exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                step_size = 0.1 * (1 - eval_count / self.budget)  # Adaptive step size\n                perturbation = np.random.normal(0, step_size, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 65, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.007210096411738198, 0.003892819209534215, 0.005941385567780899, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04007289819763327, 0.04582231735158071, 0.03958691738410047, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04676517649848844, 0.05950620024616471, 0.05565318075245218, 0.09328029400344506, 0.1000924612041717, 0.08923526572144136, 0.04783895698838403, 0.03728442200785653, 0.03681463700303533, 0.07184560037095589, 0.07152223710578276, 0.0791665558070821, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015627128077451813, 0.012754845256342517, 0.012397159888094977, 0.010109483674718645, 0.015274390863223575, 0.013903936548511076, 0.14124775749224994, 0.14076381325708143, 0.14002882237312453, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b8f9c4b1-b7f2-4490-8f87-3d0cd8dcd00e", "fitness": 0.018551983653132435, "name": "HADE_RLS", "description": "Introduce dynamic scaling of the mutation factor based on both the current iteration and the fitness variance across the population.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                fitness_variance = np.var(fitness)\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget) * (1 + fitness_variance)  # Modified mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 66, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004139545599877947, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.031269723435380814, 0.036688444618252825, 0.030230375367466866, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05838324148401708, 0.059934944173446025, 0.05246127827825864, 0.07870255675368343, 0.08442137239844516, 0.0880719581358188, 0.025184278671173455, 0.032760997119857915, 0.03731308230110719, 0.06608295182637902, 0.06514316784366281, 0.0724669802917145, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013808625015692688, 0.012014626696876918, 0.012623570778304338, 0.009598994234386815, 0.013589666468695638, 0.012686946562600498, 0.1416913830043337, 0.14098453220919194, 0.13505479714821367, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "76ec0491-e18f-48e8-9cdc-3bbc27994cd3", "fitness": 0.02029548140524473, "name": "HADE_RLS", "description": "Optimize the decay of the mutation factor in the exponential term for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / (self.budget / 2))  # Adjusted exponential decay for mutation factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim)  # New scaling factor\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 67, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.0029116642213369293, 0.006377015172916667, 0.005451645220288626, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04403675606485469, 0.04639460501531234, 0.04206395272429131, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049283062711796166, 0.05868765194083092, 0.049414321888447854, 0.1024713734093089, 0.09582971079988012, 0.08891985159729343, 0.041960640865533194, 0.040998326026227216, 0.03731308230110719, 0.0772050012402552, 0.0722039950036627, 0.07768688711706073, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01429779031207068, 0.011935614644589587, 0.012777324820241964, 0.010001061197435601, 0.0149135724636007, 0.014010091087064636, 0.14124775749224994, 0.14148157165906772, 0.14183511678959038, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e8ad5af9-6b95-474f-a2d5-407c5968a694", "fitness": 0.02046450544370237, "name": "HADE_RLS", "description": "Enhance diversity by incorporating a varying dimension scaling factor that adjusts over time.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 68, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c22b39fd-0a4c-451a-aee7-4acaac860669"], "operator": null, "metadata": {"aucs": [0.003079563854964329, 0.008241130052137002, 0.00568823463134438, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04411624622484045, 0.04630561117814047, 0.04252424925906961, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0492188098727363, 0.060824908281668866, 0.05137161792294909, 0.10155728925662244, 0.09626865473739543, 0.09158825013230831, 0.042000579349889655, 0.041169360919353415, 0.0384528434160073, 0.0780778055250142, 0.0722217416941432, 0.07747390740305271, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014386337537166782, 0.01212739302909005, 0.012784605813675909, 0.010036569488202307, 0.014545053097606675, 0.013994174010741434, 0.14340898088962994, 0.1449352604076658, 0.13747999656984944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8364545f-6308-4df6-a6ee-802301ba3289", "fitness": 0.02043235406326412, "name": "HADE_RLS", "description": "Dynamically adjust the perturbation scale during Randomized Local Search based on budget consumption.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_scale = 0.1 * (1 - eval_count / self.budget)  # Changed line\n                perturbation = np.random.normal(0, perturbation_scale, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 69, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["e8ad5af9-6b95-474f-a2d5-407c5968a694"], "operator": null, "metadata": {"aucs": [0.0029435055855872028, 0.008347184832160681, 0.00558571811776587, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044145591337128476, 0.045949997633902506, 0.04281064555718117, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048660368391155284, 0.06084318044425541, 0.05318364156138178, 0.10049123256069892, 0.09686974388963754, 0.0912599032636704, 0.0449159032808506, 0.04082017091688672, 0.037590402683366, 0.0774695977237222, 0.07132038674342078, 0.07759717436343261, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014330551280506088, 0.012039335609202007, 0.01275831959164564, 0.009985514394037942, 0.014587229182068784, 0.013807931277880714, 0.1425784307038236, 0.14092956851408933, 0.13974304572425322, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4967ae62-1f54-4589-807f-252f4b6a37d3", "fitness": 0.020754753839885724, "name": "HADE_RLS", "description": "Optimize local search by increasing perturbation variance progressively over evaluations.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 70, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["e8ad5af9-6b95-474f-a2d5-407c5968a694"], "operator": null, "metadata": {"aucs": [0.00366009742046014, 0.007332057259840985, 0.005896167028420551, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044097052197451414, 0.049126844336553344, 0.04246305920369475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048621270682820295, 0.06316588526547928, 0.05016532397570994, 0.1017887189568325, 0.09694021618241, 0.09067990840196627, 0.04497023095546826, 0.03994373686661323, 0.03663657739152493, 0.08046414034691762, 0.07287800893542895, 0.07984599712672102, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014992554839420524, 0.012583380090621654, 0.012887482049894095, 0.010131486976620363, 0.01449431519593869, 0.014426215737925796, 0.1473126401891518, 0.151793694896731, 0.13747999656984944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ef10b308-1767-4011-88b4-dc24e2d2c0ad", "fitness": 0.020472269283339697, "name": "HADE_RLS", "description": "Enhance mutation strategy by introducing dynamic scaling based on a sine wave to increase diversity.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.sin(np.pi * eval_count / (2 * self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 71, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.004936085481547892, 0.005563809268429476, 0.008935499856192464, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04414077952549045, 0.055387785384616306, 0.0441142218522147, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04980332450917957, 0.058525534852800654, 0.054550579121753984, 0.09186673956627578, 0.09668046797503493, 0.09210275721254413, 0.03846477420953265, 0.03814430493227006, 0.03857069123560386, 0.073671080804813, 0.0778492793296085, 0.07632923948139425, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013851139233578502, 0.013499028639898047, 0.01427389912646404, 0.012140688426534707, 0.013874565582325138, 0.011867108797324666, 0.14124775749224994, 0.14076381325708143, 0.14328321585439374, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "556b764b-6a11-471d-9abd-61d353e48cab", "fitness": 0.020180031328342958, "name": "HADE_RLS", "description": "Enhance exploration with adaptive crossover scaling based on distance from the best solution.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                distance_scaling = np.linalg.norm(population[i] - population[np.argmin(fitness)]) / (5.0 * np.sqrt(self.dim))  # Changed line\n                crossover_points = np.random.rand(self.dim) < CR_adaptive * distance_scaling\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 72, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.010389919861783836, 0.004371755473526973, 0.0006188353610484532, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048427757909917934, 0.045775360321210545, 0.04609391451316425, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04848808847349806, 0.06271051859850796, 0.05156707572396202, 0.08968197659310295, 0.09041384132315711, 0.09132174903086554, 0.031940053771713384, 0.035566357187915454, 0.04533872095635039, 0.08307474386603919, 0.07418848238015174, 0.07792735386432492, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014608619342082907, 0.012893476630632228, 0.013104353741436925, 0.011146137267511458, 0.011577196196792205, 0.012041600844151179, 0.14124775749224994, 0.14076381325708143, 0.1381175782672086, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "13368b78-6d47-4be7-950d-a03b93684cd8", "fitness": 0.020754753839885724, "name": "HADE_RLS", "description": "Adaptively adjust the mutation factor to enhance exploration-exploitation balance based on population diversity.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget) \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 73, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.00366009742046014, 0.007332057259840985, 0.005896167028420551, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044097052197451414, 0.049126844336553344, 0.04246305920369475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048621270682820295, 0.06316588526547928, 0.05016532397570994, 0.1017887189568325, 0.09694021618241, 0.09067990840196627, 0.04497023095546826, 0.03994373686661323, 0.03663657739152493, 0.08046414034691762, 0.07287800893542895, 0.07984599712672102, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014992554839420524, 0.012583380090621654, 0.012887482049894095, 0.010131486976620363, 0.01449431519593869, 0.014426215737925796, 0.1473126401891518, 0.151793694896731, 0.13747999656984944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "1a530820-3578-4a40-983b-a62cc19c5c93", "fitness": 0.01916422730030051, "name": "HADE_RLS", "description": "Enhance mutation adaptiveness by introducing dynamic mutation factor scaling based on population diversity.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                diversity = np.std(population, axis=0).mean()  # Changed line\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * (1 + diversity) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 74, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.0004382387770180962, 0.0009255087142300278, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03557095849041436, 0.05253683471640869, 0.03503155272207037, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056214851079465666, 0.058525534852800654, 0.054537358144442494, 0.08402040867502225, 0.08731952346816463, 0.08754231403653512, 0.028283777611762595, 0.03509405733656623, 0.03427449168216601, 0.07048687811794618, 0.07030579383863111, 0.07427609541609614, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014126222769741625, 0.01317920480108925, 0.013891437183740085, 0.009709995293704088, 0.012644571863163812, 0.011429964585630947, 0.1412836349581944, 0.14243978451690287, 0.13573537196972818, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "754af735-6f65-4845-954b-747554c049f9", "fitness": 0.020325234130196157, "name": "HADE_RLS", "description": "Introduce adaptive mutation scaling based on fitness diversity to enhance exploration gradually.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                fitness_diversity = np.std(fitness) / np.mean(fitness)  # Changed line\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * fitness_diversity  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 75, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.0038453082026278507, 0.0098626575926829, 0.007401503670143139, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04426419419553207, 0.04765207670781757, 0.041059798989510066, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050919824970884986, 0.06271051859850796, 0.05321833086966288, 0.083931389674188, 0.08890057279989516, 0.08678982676658864, 0.04277637131236056, 0.03729861873465978, 0.03635721580047191, 0.07579851978172647, 0.0723364388879505, 0.0779795246787719, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014609570036550168, 0.012580934064799543, 0.013111600624745146, 0.010711246463190993, 0.01434503297476275, 0.01098396361199483, 0.149114845745569, 0.15152744220836978, 0.14376431201885342, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "65568d10-900b-48b7-a827-d0af92d5f673", "fitness": 0.02018187801955306, "name": "HADE_RLS", "description": "Enhance local search by adapting mutation factor based on current fitness improvement.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                fitness_improvement_factor = 1.0 if fitness[i] == 0 else max(0.1, min(2.0, np.abs(fitness[i] - np.min(fitness)) / np.maximum(fitness[i], 1e-10)))  # Changed line\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget) * fitness_improvement_factor\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 76, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.0029171628763653423, 0.007510004308833418, 0.007164794243235129, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044142110066907936, 0.04680482099383332, 0.04094807029626657, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04982198292516027, 0.06271051859850796, 0.05342802725952778, 0.0935014959262429, 0.08954415964892926, 0.09204778828159699, 0.04308346588616485, 0.03766750943413333, 0.0368754214454734, 0.0775867713248537, 0.07158131511967813, 0.08038449199633024, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01486460955358715, 0.012589360098125946, 0.013338266838853308, 0.010566059793034044, 0.0141791601880068, 0.010891456665014565, 0.14680382006227433, 0.14125772677057258, 0.13131962941500586, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "942b1976-05b9-4ea0-a6f8-5e92661544c8", "fitness": 0.02062715207012163, "name": "HADE_RLS", "description": "Enhance the local search by adapting perturbation variance using a sigmoid function for improved convergence.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 / (1 + np.exp(-10 * (eval_count / self.budget - 0.5)))  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 77, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.0036318269166992767, 0.0075228198300817395, 0.005673338731194799, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04399448215907342, 0.04743944604338857, 0.0427958876333433, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04983343940271601, 0.0602172855180505, 0.050614864087592415, 0.10205883137422644, 0.09662727131426929, 0.09068944543786861, 0.04638069858743854, 0.03926326190739493, 0.04031516839884397, 0.07560104820117253, 0.07387617003374902, 0.07759034839414436, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015042049619304554, 0.01255263426604536, 0.012808320896862235, 0.010022750149956794, 0.014522139288546843, 0.014388617318584096, 0.14214838789277429, 0.14440986828663538, 0.14556932996749483, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b61b4454-e5a0-4a35-a84e-dc035260e9fa", "fitness": 0.020578159804529664, "name": "HADE_RLS", "description": "Enhance local search by dynamically adjusting perturbation variance with an exponential decay function.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * np.exp(-eval_count / self.budget)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 78, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.003831699416727008, 0.005154399262154108, 0.006192705875000315, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04477001900359068, 0.04908314169516337, 0.04275834246783594, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05029195425262156, 0.0602172855180505, 0.04843481137732519, 0.10241196132709018, 0.095860408993655, 0.0916480361779296, 0.049005167744978095, 0.03916463034425166, 0.039923579535174336, 0.07747742462620966, 0.07264875603692456, 0.07960986745760235, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01494706331922746, 0.012231357584179703, 0.013027294286371838, 0.010258400823636271, 0.014143467580099989, 0.014465281371054628, 0.1444933499544544, 0.14112572139220003, 0.13888616111132213, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "fe8a516f-a5fa-4de9-b162-b4453e22d058", "fitness": 0.020594393492828593, "name": "HADE_RLS", "description": "Enhance local search with adaptive annealing of perturbation variance to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.5 * (1 - np.exp(-5 * eval_count / self.budget))  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 79, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.004830568260427492, 0.005720171254663953, 0.006036941674421703, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0441520175665403, 0.049280223067822315, 0.04223489830525229, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04891008352709836, 0.0602172855180505, 0.053081400974798965, 0.10046261159016778, 0.09522235588299999, 0.09147968035152254, 0.04484012655330649, 0.04126461681123228, 0.036690639907877354, 0.07748401612127354, 0.07553406605428914, 0.07751122845025138, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015819157878303458, 0.012456848208370785, 0.012825281759738072, 0.01044402677856493, 0.014100239121705993, 0.01447260554055807, 0.14301750712378403, 0.14076381325708143, 0.14437870255225027, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "64d7020f-db2b-47bb-b00b-c25c79a4ce84", "fitness": 0.020594156304873084, "name": "HADE_RLS", "description": "Enhance adaptation by dynamically adjusting mutation factor scaling with exponential decay based on evaluations.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / (self.budget * 0.1))  # Changed line\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget)) \n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)  \n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 80, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.004003990735786389, 0.012266752141678938, 0.007817845912623578, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05123307730998672, 0.05463130587716636, 0.04283876106950013, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04885300285320815, 0.06271051859850796, 0.05365271077852318, 0.09446115885966855, 0.09535389998848942, 0.09196128928309599, 0.036818326428900816, 0.040125169512336245, 0.038297623238354395, 0.07653727944386113, 0.07348088026495703, 0.07995182218590402, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015257036341283614, 0.012580966878156574, 0.013117481369814943, 0.010744785226424303, 0.014018910337918133, 0.010915547235092693, 0.1442842481279697, 0.14078717901833604, 0.13651246754201174, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0a8ffbdf-52e8-412c-8f7c-0624fc9745e9", "fitness": 0.020144327766945698, "name": "HADE_RLS", "description": "Enhance mutation by using a dynamic perturbation factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3), self.lower_bound, self.upper_bound)  # Changed line\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 81, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.006960818057458185, 0.00512911076269873, 0.0049447183764704805, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04111938441846852, 0.053091356395152056, 0.04423360106106433, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05683833186945286, 0.06410548796658455, 0.049692180917130124, 0.08991446887446808, 0.09060100272410854, 0.09041909322256958, 0.03667968382605524, 0.036554567073068256, 0.03657041919601933, 0.0676119274836876, 0.07438148569400982, 0.07767615666428729, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015815563491052287, 0.012167966361463445, 0.01265386246170519, 0.010348958661647534, 0.01506736450492574, 0.01377840576592071, 0.14170008141487067, 0.14095440979772456, 0.14181597478672114, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9f22ae58-5a75-4827-b1ab-736d1a939355", "fitness": 0.020214457822686407, "name": "HADE_RLS", "description": "Enhance differential evolution strategy by introducing non-linear scaling for mutation factor adaptation.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count**2 / self.budget**2)  # Changed line\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  \n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 82, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.003334158325665526, 0.005320096909693595, 0.005839941180526442, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.040425146694060055, 0.04675031381674122, 0.040799866889532965, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050226659934016205, 0.06271051859850796, 0.049407961420526725, 0.09861254000147102, 0.09738425350647717, 0.09201075524951052, 0.04246519763250589, 0.03594722123975991, 0.036446025600785914, 0.07719019033636298, 0.07256687948466611, 0.07800217824507949, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01563645235797695, 0.012806697456677174, 0.012784619836773814, 0.010091177340513013, 0.014996807485153862, 0.014550092658286995, 0.14124775749224994, 0.14378916833364508, 0.13453306781494967, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8da10287-2a94-45d2-9c99-5166d54586f1", "fitness": 0.020647763022633873, "name": "HADE_RLS", "description": "Optimize local search by adaptively scaling perturbation range and mutation factor over evaluations.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * ((eval_count / self.budget) ** 1.1)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 83, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.003608215499340761, 0.007452156656987952, 0.005888184126463414, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044063563394351024, 0.049096733599222175, 0.042551209413589475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04869565899549122, 0.06304723182692684, 0.04975859334042332, 0.10190392086085986, 0.097618733730232, 0.09129617294081904, 0.04479850329475521, 0.04005319807637853, 0.03601798962451419, 0.07652666447421441, 0.07274881611932493, 0.07814914575487242, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014951980839054912, 0.01255619288472487, 0.012869764086777535, 0.010088880613222106, 0.014511011847448518, 0.014409439603854435, 0.14232343421643034, 0.14076538761415158, 0.15132293680390274, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a4d5904a-0763-4d4b-8191-3824a5255b07", "fitness": 0.020403510481687, "name": "HADE_RLS", "description": "Enhance adaptive mutation factor by incorporating a dynamic scaling function based on cosine similarity of population members.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  \n                cosine_similarity = np.dot(x1 - x2, x1 - x3) / (np.linalg.norm(x1 - x2) * np.linalg.norm(x1 - x3) + 1e-8)\n                F_adaptive *= np.cos(np.pi * (1 - cosine_similarity))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)  \n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 84, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.002788419568296008, 0.007647000387482228, 0.0049958627470675365, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052724391783869784, 0.053051394022017195, 0.040993256642499865, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048549062193380954, 0.06271051859850796, 0.048683792453997454, 0.08963014229778488, 0.09463000597951043, 0.0936251226735636, 0.03536732147689492, 0.04169444441571635, 0.03709163514393343, 0.07371872312110728, 0.07547960334840553, 0.07872468561749346, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014191608431437186, 0.012798836821880433, 0.013152992390134566, 0.010587517126087964, 0.014097454451593272, 0.01212383327802613, 0.14919164925079553, 0.14349834344529877, 0.13773991962337606, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d1ff9947-629d-4036-95c9-ed295443bc8a", "fitness": 0.020718200335335436, "name": "HADE_RLS", "description": "Optimize local search by adaptively adjusting perturbation variance based on function evaluation progress.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  \n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.5 * (eval_count / self.budget)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 85, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.003820434696148234, 0.006896455238602717, 0.005904009742823235, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0441451680768693, 0.049284324787562284, 0.042311462717963266, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05265960955779514, 0.06235318765977316, 0.04986746099717987, 0.10086497968910879, 0.09758970675820622, 0.09162885937619769, 0.04472158014754568, 0.04288572390998502, 0.03622390041933632, 0.07778257577223469, 0.07631755929108397, 0.07823518170573196, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015213062983667758, 0.01271294989871563, 0.012906047545386712, 0.01015426571729694, 0.014450540318707517, 0.01447304337757549, 0.14124775749224994, 0.1490805972988002, 0.1384147615762985, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "bb0fd915-0a00-41ef-8a3c-7ac1ef69a846", "fitness": 0.020754753839885724, "name": "HADE_RLS", "description": "Optimize local search by increasing perturbation variance progressively over evaluations with adaptive scaling.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 86, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.00366009742046014, 0.007332057259840985, 0.005896167028420551, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044097052197451414, 0.049126844336553344, 0.04246305920369475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048621270682820295, 0.06316588526547928, 0.05016532397570994, 0.1017887189568325, 0.09694021618241, 0.09067990840196627, 0.04497023095546826, 0.03994373686661323, 0.03663657739152493, 0.08046414034691762, 0.07287800893542895, 0.07984599712672102, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014992554839420524, 0.012583380090621654, 0.012887482049894095, 0.010131486976620363, 0.01449431519593869, 0.014426215737925796, 0.1473126401891518, 0.151793694896731, 0.13747999656984944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9e8cfb1a-6fc6-4472-b129-6da79c42b466", "fitness": 0.020804450243980952, "name": "HADE_RLS", "description": "Optimize local search by dynamically adjusting crossover rate based on fitness diversity.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))  # Changed line\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 87, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["4967ae62-1f54-4589-807f-252f4b6a37d3"], "operator": null, "metadata": {"aucs": [0.00366009742046014, 0.007332057259840985, 0.005896167028420551, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044097052197451414, 0.04916814488071497, 0.041333559573795364, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04934677355371586, 0.06316588526547928, 0.05190165568730598, 0.1017887189568325, 0.09703387879317626, 0.09067990840196627, 0.04497023095546826, 0.039943710328682824, 0.03663657739152493, 0.08046414034691762, 0.07287800893542895, 0.08075040187485882, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014261039062787528, 0.01425568462218385, 0.017313985469446513, 0.011478245100278728, 0.010608735275530523, 0.012804210137322913, 0.1473126401891518, 0.151793694896731, 0.13747999656984944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ce1b6403-8da7-4673-af49-57be21d9e6ca", "fitness": 0.02065662766585912, "name": "HADE_RLS", "description": "Enhance exploration by introducing a decay factor to mutation factor F over time.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget) * (1 - eval_count / self.budget)  # Changed line\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  \n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 88, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9e8cfb1a-6fc6-4472-b129-6da79c42b466"], "operator": null, "metadata": {"aucs": [0.003534805784767503, 0.008520224433979151, 0.007887129605521848, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0443578689711307, 0.048230110217618694, 0.0422209170259954, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05246162061768467, 0.06271051859850796, 0.04924255653663179, 0.09958416608300313, 0.09454799073119868, 0.09168494445941588, 0.04388953600885248, 0.03855405480041729, 0.035695009156859525, 0.0761866339519146, 0.07290503885349109, 0.07865575825235516, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014250649747002297, 0.014142615721077112, 0.015455221117333107, 0.010599787486399004, 0.010548411810047398, 0.012284056142163324, 0.15916746426326867, 0.14300136301567812, 0.137393521158237, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a267bbcb-1575-4e14-a179-a234e6e49d4e", "fitness": 0.020690725303810005, "name": "HADE_RLS", "description": "Refine HADE_RLS by introducing an adaptive scaling factor for perturbation during randomized local search.  ", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))  # Changed line\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 89, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9e8cfb1a-6fc6-4472-b129-6da79c42b466"], "operator": null, "metadata": {"aucs": [0.003729578165347136, 0.00712121813447264, 0.006030551345926227, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04406873001064959, 0.04876055460295525, 0.04111440627673113, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052266249770930195, 0.06073696031739617, 0.04839324068332862, 0.10394825553485665, 0.09837010136038182, 0.09129019721469767, 0.041970213091153674, 0.040844761997563706, 0.03762808650929261, 0.07823719746274826, 0.07508670385985283, 0.07879487771197524, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014084807211315442, 0.014330792166635908, 0.01755058972347323, 0.011575746646387386, 0.010652256112243963, 0.01276389447577475, 0.1433110510877742, 0.1452650794776088, 0.14224090353154195, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9b45282f-9c10-4fa0-9c5d-fb2a477715e6", "fitness": 0.02069306710798325, "name": "HADE_RLS", "description": "Optimize local search by dynamically adjusting crossover rate and incorporating population diversity feedback.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                diversity = np.mean([np.linalg.norm(population[j] - population[i]) for j in range(self.population_size)]) / self.dim  # Changed line\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1 + diversity))\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 90, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9e8cfb1a-6fc6-4472-b129-6da79c42b466"], "operator": null, "metadata": {"aucs": [0.00366009742046014, 0.007332057259840985, 0.005787834645930912, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044097052197451414, 0.04916814488071497, 0.041333559573795364, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04934677355371586, 0.06316588526547928, 0.05190165568730598, 0.1017887189568325, 0.09447172621222466, 0.09069313092383613, 0.04497023095546826, 0.039943710328682824, 0.03663657739152493, 0.08041060354452756, 0.07287800893542895, 0.08051043074667963, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014283206029332418, 0.013320635746222886, 0.013291775790372662, 0.010080046610535631, 0.012058774977634745, 0.012594258323251228, 0.1473126401891518, 0.151793694896731, 0.13750438334035608, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "eb494861-41d8-4dfa-8874-58318f24ee3d", "fitness": 0.020804450243980952, "name": "HADE_RLS", "description": "Enhance adaptive crossover by refining differential mutation impact for improved search precision.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1)) \n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 91, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9e8cfb1a-6fc6-4472-b129-6da79c42b466"], "operator": null, "metadata": {"aucs": [0.00366009742046014, 0.007332057259840985, 0.005896167028420551, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.044097052197451414, 0.04916814488071497, 0.041333559573795364, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04934677355371586, 0.06316588526547928, 0.05190165568730598, 0.1017887189568325, 0.09703387879317626, 0.09067990840196627, 0.04497023095546826, 0.039943710328682824, 0.03663657739152493, 0.08046414034691762, 0.07287800893542895, 0.08075040187485882, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014261039062787528, 0.01425568462218385, 0.017313985469446513, 0.011478245100278728, 0.010608735275530523, 0.012804210137322913, 0.1473126401891518, 0.151793694896731, 0.13747999656984944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "00e575f7-00bb-44a5-949d-15d43d5719f1", "fitness": 0.019014429400582195, "name": "HADE_RLS", "description": "Enhance adaptive mutation by incorporating a Lvy flight step to improve exploration in HADE_RLS.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                levy_step = np.random.standard_cauchy(self.dim) * np.exp(-eval_count / self.budget)  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling + levy_step, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 92, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9e8cfb1a-6fc6-4472-b129-6da79c42b466"], "operator": null, "metadata": {"aucs": [0.0007999863223466797, 0.0007752024544385172, 0.0019112775154754846, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04044082796450765, 0.04081244180864474, 0.044673173315872505, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05091876914051563, 0.058525534852800654, 0.053369739772298974, 0.08287146156257019, 0.08780920129233794, 0.08761732660519261, 0.0263286236924839, 0.03505433417741488, 0.033204832360285486, 0.06759710219046133, 0.06765762028400368, 0.07241110855594701, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01487173213932691, 0.012906116303721404, 0.012264311413230478, 0.010155689313383509, 0.009725663156042397, 0.012651230872906982, 0.1482314569499129, 0.14468315970067536, 0.1312057757338151, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a5ff4f09-a2b4-414e-b35b-ed4c58ae095a", "fitness": 0.01972918043065964, "name": "HADE_RLS", "description": "Enhance adaptive DE with self-adaptive mutation scaling and crossover for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget) * (1 + np.std(fitness) / (np.mean(fitness) + 1e-12))  # Changed line\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  \n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1)) + np.random.uniform(-0.1, 0.1)  # Changed line\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)  \n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 93, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9e8cfb1a-6fc6-4472-b129-6da79c42b466"], "operator": null, "metadata": {"aucs": [0.0072212934125717165, 0.0033551827845410553, 0.005242583145270707, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03837273126510843, 0.046862409982637354, 0.04008391803754874, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05390372256126852, 0.058525534852800654, 0.051509315536757305, 0.08572292742138277, 0.08836909412570526, 0.0872468961296845, 0.033202128115702445, 0.03902695999594907, 0.03526432784554856, 0.07105663920289951, 0.07506402269052115, 0.07855714024246718, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01609546077323676, 0.014301152879080958, 0.012323385808738818, 0.011672985200042674, 0.011049931724154027, 0.010852564429726153, 0.14265375275583247, 0.1431060090464522, 0.14029370365055982, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "14db0996-d2af-4d99-a948-718be9471fe7", "fitness": 0.020485984184782577, "name": "HADE_RLS", "description": "Enhance mutation by incorporating weighted randomness based on historical fitness improvements.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                historical_weight = 1.0 + (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-8)  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling * historical_weight, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 94, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9e8cfb1a-6fc6-4472-b129-6da79c42b466"], "operator": null, "metadata": {"aucs": [0.0041775395593266484, 0.011004716942641823, 0.010706725314590049, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04567313612235446, 0.04851027546134645, 0.04289511823291792, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04848808847349806, 0.06271051859850796, 0.05379333127024877, 0.1011669767764144, 0.09713033336248733, 0.09238471660694003, 0.0419701332657455, 0.040003093179579396, 0.03530056815307425, 0.07321147649667636, 0.07134889425323332, 0.0790528728898473, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014274385209803175, 0.013772319885422601, 0.013288721210292564, 0.011192435328503003, 0.01295499777094311, 0.010804933324757626, 0.14124775749224994, 0.14079532441280584, 0.13756625431883251, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "46101965-cbd4-4d37-86db-7c8b9f029d84", "fitness": 0.02034862522204417, "name": "HADE_RLS", "description": "Refine local search by adding a dynamic scaling factor to perturbation variance for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))  # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) * dimension_scaling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))  # Changed line\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = (0.1 + 0.4 * (eval_count / self.budget)) * np.log(1 + eval_count)  # Changed line\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 95, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9e8cfb1a-6fc6-4472-b129-6da79c42b466"], "operator": null, "metadata": {"aucs": [0.00552665939934982, 0.004099546457537184, 0.005481224804008034, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04389800579770131, 0.04744781651408614, 0.043771165398630796, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05094758154304724, 0.0602172855180505, 0.048656418005016744, 0.10162926404253281, 0.0952440629364325, 0.08963933820027647, 0.03950901350892699, 0.03885371216630318, 0.03762011618293892, 0.0751438410606452, 0.07492653374835911, 0.07718827310124221, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014653416474019743, 0.013223107526152633, 0.015143717420506686, 0.011449410631740098, 0.012734142530523407, 0.012005107541933402, 0.14187114192253747, 0.14076381325708143, 0.14389208290629507, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b785c0ec-e43b-4877-bd72-2034c7a08672", "fitness": 0.021986459899720576, "name": "HADE_RLS", "description": "Enhance mutation strategy by incorporating historical best for more effective exploration.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n        best_individual = population[np.argmin(fitness)]  # Track best individual\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) + best_individual - x1, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 96, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9e8cfb1a-6fc6-4472-b129-6da79c42b466"], "operator": null, "metadata": {"aucs": [0.009513442763527946, 0.012154137261633613, 0.02164759074237088, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048144137227678296, 0.06484808396562747, 0.05027369503451773, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05204422221666605, 0.06271051859850796, 0.046206117454652196, 0.09483307053768586, 0.09679623994983344, 0.09887712198290322, 0.05047757000875974, 0.03371920921213867, 0.0426631928907415, 0.08499540420066787, 0.08596678462983287, 0.09456036508538146, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.017303795314526416, 0.015624151197380143, 0.016564271458300195, 0.011458697599166956, 0.01276195076804909, 0.015853716539127705, 0.14451225434509662, 0.1414187459223195, 0.13753140848148304, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "629eed24-c898-4395-9b3b-e886be0bf1a2", "fitness": 0.023717743398406977, "name": "HADE_RLS", "description": "Boost mutation strategy by integrating dynamic scaling with historical best for improved optimization.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n        best_individual = population[np.argmin(fitness)]  # Track best individual\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                # Changed line\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) + dimension_scaling * (best_individual - x1), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 97, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["b785c0ec-e43b-4877-bd72-2034c7a08672"], "operator": null, "metadata": {"aucs": [0.014704085604981487, 0.020803015223732513, 0.02515694464570639, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05631616983923837, 0.06831075747864479, 0.06110768658682719, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052245299157911096, 0.06271051859850796, 0.04654860560044294, 0.09951416292015414, 0.10316293716296254, 0.10106889226611793, 0.05315526543179183, 0.040918404662418695, 0.047013893824590425, 0.09087685368581733, 0.09380754259609547, 0.09861546193304216, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.017684514247531924, 0.01657945830262042, 0.024789970967699193, 0.01330896062742859, 0.014454597577125972, 0.016313058694841565, 0.14908200225501034, 0.15879222526425474, 0.1410710221385012, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d73323ed-e8ac-47c5-b463-f61af04cc532", "fitness": 0.02430117747791989, "name": "HADE_RLS", "description": "Incorporate a dynamic population size adjustment strategy to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n        best_individual = population[np.argmin(fitness)]  # Track best individual\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)  \n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) + dimension_scaling * (best_individual - x1), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n            \n            # Change population size dynamically\n            self.population_size = max(5 * self.dim, int(10 * self.dim * (1 - eval_count / self.budget)))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 98, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["629eed24-c898-4395-9b3b-e886be0bf1a2"], "operator": null, "metadata": {"aucs": [0.02240976201580036, 0.024023194513184243, 0.03303028303511557, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05910595906058436, 0.07010375297817639, 0.06725382284248671, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05452006775173135, 0.058525534852800654, 0.04712568717395382, 0.10003001096453612, 0.10516102054660326, 0.10584152417765813, 0.05003231339689651, 0.04162031384890863, 0.049118916670576995, 0.09423340045796047, 0.09540638251299816, 0.09595773101562743, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.023684505438871795, 0.01849964028529405, 0.025753240332279992, 0.013328841218877119, 0.01646652378710256, 0.022666967407021565, 0.14124775749224994, 0.15879222526425474, 0.1361801819773759, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "42fddef3-6d2d-40d5-9e1f-20206cff4679", "fitness": 0.028254264986021627, "name": "HADE_RLS", "description": "Introduce adaptive mutation based on current generation's best fitness change to improve convergence stability.", "code": "import numpy as np\n\nclass HADE_RLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR_init = 0.9  # Initial Crossover rate\n        self.CR_final = 0.4  # Final Crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count += self.population_size\n        best_individual = population[np.argmin(fitness)]  # Track best individual\n\n        while eval_count < self.budget:\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5) * np.exp(-eval_count / self.budget)\n                dimension_scaling = np.random.uniform(0.5, 1.0, self.dim) * (1 - (eval_count / self.budget))\n                mutant = np.clip(x1 + F_adaptive * (x2 - x3) + dimension_scaling * (best_individual - x1), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.copy(population[i])\n                fitness_variance = np.var(fitness)\n                CR_adaptive = self.CR_init - (self.CR_init - self.CR_final) * (eval_count / self.budget) * (fitness_variance / (fitness_variance + 1))\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    best_individual = population[np.argmin(fitness)]  # Update best individual\n\n                if eval_count >= self.budget:\n                    break\n\n            # Randomized Local Search\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                local_candidate = np.copy(population[i])\n                perturbation_variance = 0.1 + 0.4 * (eval_count / self.budget)\n                perturbation = np.random.normal(0, perturbation_variance, self.dim)\n                local_candidate = np.clip(local_candidate + perturbation, self.lower_bound, self.upper_bound)\n\n                local_fitness = func(local_candidate)\n                eval_count += 1\n                if local_fitness < fitness[i]:\n                    population[i] = local_candidate\n                    fitness[i] = local_fitness\n            \n            # Change population size dynamically\n            self.population_size = max(5 * self.dim, int(10 * self.dim * (1 - eval_count / self.budget)))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 99, "feedback": "The algorithm HADE_RLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["d73323ed-e8ac-47c5-b463-f61af04cc532"], "operator": null, "metadata": {"aucs": [0.04450353333882051, 0.04242705280073922, 0.045631850837173804, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0010426454799182805, 0.00043575977471588256, 0.00045290279879672823, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0007074635047571443, 0.0005072307516235108, 0.0012640445916891618, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08518254846186135, 0.08508895075068679, 0.08565024541166188, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05275707569188437, 0.058525534852800654, 0.046940305486853795, 0.11526522697947839, 0.11944349208031235, 0.10830233272441492, 0.051780453244319014, 0.052047547372875536, 0.052802534969338066, 0.10474728196490979, 0.09984814583958646, 0.10230088332575371, 0.03808997894591415, 0.014965692376233686, 0.00043478260869567187, 0.027414101587996065, 0.04234075162262951, 0.03115791562690151, 0.018435188535237956, 0.023895859595970625, 0.029344747063434595, 0.14124775749224994, 0.15879222526425474, 0.13488086132602328, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
