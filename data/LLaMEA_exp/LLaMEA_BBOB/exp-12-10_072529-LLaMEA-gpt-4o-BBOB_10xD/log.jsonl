{"id": "492cb46d-bb8b-4360-bdbc-a676057fcaf5", "fitness": -0.22332710257881896, "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization (PSO) and Differential Evolution (DE) algorithm that dynamically switches between exploration and exploitation for efficient search.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + dim\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.22333 with standard deviation 0.38860.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.11478059931981266, 0.10809657774961834, 0.1648193753804169, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02917111922925253, 0.028316425034968784, 0.04165790002165948, 0.022978518149076255, 0.020000000000000018, 0.020000000000000018, 0.06522148284807616, 0.05497973631147557, 0.06069474128566332, 0.020000000000000018, 0.043239167037892656, 0.020000000000000018, 0.0450542191189659, 0.08594148016760361, 0.14319531440067135, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17196507350935808, 0.11687153699801944, 0.16586431619102115, 0.03276645114392496, 0.021932798614147098, 0.020000000000000018, 0.09617862423983992, 0.0863116411064907, 0.10846916792870476, 0.1547562419825852, 0.13323277534341382, 0.1434907365223006, 0.11693272981758929, 0.08297101288459174, 0.08638139391159594, 0.1231327667294394, 0.11714317722878276, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.0970863679912668, 0.1694063211033352, 0.11122638369668036, 0.08468330507031763, 0.06527120746322768, 0.08569118045992452, 0.05352436010080941, 0.14542241804867984, 0.14389231572086947, 0.15475448018179316, 0.04816561754391102, 0.038068766640031115, 0.027947782430648882, 0.03612362728819407, 0.03913765231201127, 0.04750095558544132, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017633223372854778, 0.015427226460980048, 0.020926796940933245, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07597524452822457, 0.08641535944306311, 0.08455343531520032, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.06511012280546513, 0.12108828011760409, 0.1008400053821974, 0.10539639329344785, 0.062188728162832274, 0.045967760636741684, 0.053936809511723194, 0.08928240389888176, 0.08770421706415799, 0.10060931417034669, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028107118815342225, 0.032763454154903005, 0.031279780307988725, 0.026872474025902315, 0.029030110593950553, 0.02535068120587991, 0.13141309820135194, 0.13724925115028586, 0.13519823550439147, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.7918460692998317, -0.8, -0.7897162658262706, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.7142873667591374, -0.7313748678153207, -0.7010180471790526, -0.8, -0.8, -0.8, -0.7352715077853036, -0.7317927215026909, -0.7387312883289043, -0.642528376804909, -0.6402821536054275, -0.6499982223217153, -0.7491972857113591, -0.736055230459342, -0.7559975020787741, -0.6569234021052615, -0.6660684249837536, -0.6715222572955977, -0.8, -0.8, -0.8, -0.7780052224433995, -0.781983428427667, -0.7797194269966088, -0.7828740061780812, -0.7809079636362448, -0.7823326024737123, -0.5621524869517471, -0.5640792492944617, -0.5847503854765506, -0.8, -0.8, -0.8]}}
{"id": "2b28bab4-ab2f-4445-9080-fdfea83a01ab", "fitness": -0.22311494886412855, "name": "AdaptiveHybridPSODE", "description": "An adaptive PSO-DE hybrid algorithm incorporating dynamic parameter adjustment based on fitness landscape feedback for improved search efficiency.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + dim\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters based on current best score\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.22311 with standard deviation 0.38848.", "error": "", "parent_ids": ["492cb46d-bb8b-4360-bdbc-a676057fcaf5"], "operator": null, "metadata": {"aucs": [0.11457436525552678, 0.0986291369856338, 0.16621041114654422, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03250957357628392, 0.0244417407974461, 0.04191689756655781, 0.022040483187075632, 0.020000000000000018, 0.020000000000000018, 0.06589179482888508, 0.054946247387112845, 0.060921200985174284, 0.020000000000000018, 0.043260775842374866, 0.020000000000000018, 0.0450542191189659, 0.08594148016760361, 0.14319531440067135, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17147214792005383, 0.11685111788475866, 0.16571690950962426, 0.033052499702056926, 0.02212431937995807, 0.025617101420284727, 0.08652545674627621, 0.0863116411064907, 0.15029944020663122, 0.13782705681139962, 0.13323277534341382, 0.1160417955509998, 0.09384261927178761, 0.0852064290048744, 0.08613220343983585, 0.1486972198127967, 0.10638554080814344, 0.12429589931556895, 0.020000000000000018, 0.020000000000000018, 0.09697599025788417, 0.16653241225553728, 0.11183558697483131, 0.08457678974965832, 0.06527120746322768, 0.08582292144382275, 0.053590658925732004, 0.14777089405399801, 0.14084384575463849, 0.15475448018179316, 0.04536940489346497, 0.039910131734223975, 0.045530220502092766, 0.03322173283513463, 0.038224703619528344, 0.04733438442822302, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017638071804979782, 0.015379497312044021, 0.02077134573835593, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010021656271806068, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07513968393347281, 0.0865182338985645, 0.08439275646837086, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.06639669590161612, 0.12405880598723384, 0.1009425513541945, 0.10323290743837565, 0.062142981463413904, 0.047872017782410126, 0.053936809511723194, 0.1029209025341945, 0.09723186451289845, 0.09914370387198812, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028119750594601256, 0.032704200928186156, 0.03154911157219997, 0.026783386204114246, 0.0289982764440313, 0.025449309674374643, 0.13426034070867843, 0.13422034715510445, 0.13871109724045638, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.794208702036534, -0.8, -0.7898822749412253, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.7150335222568502, -0.7314059885108577, -0.7024886051972699, -0.8, -0.8, -0.8, -0.7313870168758319, -0.7311678311878489, -0.7167367636723041, -0.6404550367662714, -0.6262814138880304, -0.6488786734981975, -0.7449752559701464, -0.7403297959513226, -0.7501443364505307, -0.6575900629739662, -0.6578783205206056, -0.679466209004352, -0.8, -0.8, -0.8, -0.7780362660213558, -0.7817569868491423, -0.7795877940086311, -0.7826829203654087, -0.7809127874843533, -0.7821278614782943, -0.5762247736177568, -0.5591804034549184, -0.5933493139968247, -0.8, -0.8, -0.8]}}
{"id": "814fafc6-4f1f-4c0f-bc1c-6e5605ad90b6", "fitness": -0.2231997109520288, "name": "EnhancedAdaptiveHybridPSODE", "description": "Incorporates a dynamic exploration-exploitation balance using entropy-based diversity measures to enhance the AdaptiveHybridPSODE's convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + dim\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def entropy_diversity(self):\n        \"\"\"Computes the entropy-based diversity of the population.\"\"\"\n        mean_pos = np.mean(self.population, axis=0)\n        stddev = np.std(self.population, axis=0)\n        diversity = np.sum(stddev / (np.abs(mean_pos) + 1e-9)) / self.dim\n        return diversity\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            diversity = self.entropy_diversity()\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores)) * (1 - diversity)))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores)) * diversity))\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.22320 with standard deviation 0.38921.", "error": "", "parent_ids": ["2b28bab4-ab2f-4445-9080-fdfea83a01ab"], "operator": null, "metadata": {"aucs": [0.11368368973665699, 0.09721086341145024, 0.14237859959632404, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027264456006904858, 0.02292387432455667, 0.03931925001873937, 0.03072309549785701, 0.020000000000000018, 0.02023438959237933, 0.07430136236457274, 0.05562175299863514, 0.05910664112508268, 0.020000000000000018, 0.04311522089072528, 0.020000000000000018, 0.0450542191189659, 0.08594148016760361, 0.14319531440067135, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029427000484648413, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17089550887277538, 0.11694265511478052, 0.16707218958998926, 0.030968303619138826, 0.0214114252340023, 0.020000000000000018, 0.10455184381214566, 0.0863116411064907, 0.08666439738548493, 0.14531711373103007, 0.14083566773889378, 0.14441525704224, 0.08119276910362916, 0.07990382579724953, 0.09224876210279986, 0.13898115584555282, 0.11590661997399598, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.09803674581407795, 0.19597569613702615, 0.1040514253610959, 0.10464986719541824, 0.06527120746322768, 0.08365003396768134, 0.04748492566225748, 0.14939621254149105, 0.13962377757634892, 0.15475448018179316, 0.05865717479938648, 0.0498100596029325, 0.04276221563554283, 0.0336698197872366, 0.04109975773173413, 0.047963068853226876, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.019802804315235067, 0.01549947863388601, 0.02442751519344255, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025004180834289125, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07646184934855738, 0.08890879316430489, 0.08580109082705323, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05691981811887259, 0.07192161470928238, 0.06470298631177773, 0.12291563275720618, 0.10944352529937074, 0.11368742459952241, 0.06452419536724474, 0.03801711150149856, 0.054384101309571053, 0.0909517359804205, 0.0851439703721465, 0.10687459871430405, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027596684752948075, 0.032107704099417766, 0.031057000076436525, 0.02737469352189348, 0.03251668387881912, 0.024640285494433645, 0.13141309820135194, 0.14432684450980693, 0.1510834326115038, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.7919197558706057, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.72638627784507, -0.7301425112949249, -0.7036218442429669, -0.8, -0.8, -0.8, -0.7182487593507627, -0.7319521346464846, -0.7299223810062867, -0.6535035351291953, -0.6563455353758081, -0.6594541758938035, -0.7435292350161733, -0.743640810929848, -0.7573079091040518, -0.6678794392959415, -0.6526910703723379, -0.6943140346825643, -0.8, -0.8, -0.8, -0.7792551460320987, -0.7823475717030905, -0.7829814479246375, -0.7864822521702619, -0.7813809297179322, -0.7867559669377342, -0.562765306952935, -0.5604712201988753, -0.5672437439072908, -0.8, -0.8, -0.8]}}
{"id": "9ce2441b-9f21-4db8-b744-c095381f2640", "fitness": -0.2262312026086826, "name": "AdaptiveQuantumHybridPSODE", "description": "Adaptive Quantum-Inspired PSO-DE Hybrid Using Dynamic Quantum Potential and Self-Adaptive Parameters for Enhanced Search Efficiency.", "code": "import numpy as np\n\nclass AdaptiveQuantumHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + dim\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters based on current best score\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n\n            for i in range(self.population_size):\n                # Quantum-inspired PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                quantum_potential = np.random.uniform(-1, 1, self.dim) * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social + quantum_potential\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveQuantumHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.22623 with standard deviation 0.38776.", "error": "", "parent_ids": ["2b28bab4-ab2f-4445-9080-fdfea83a01ab"], "operator": null, "metadata": {"aucs": [0.08768107220983534, 0.08981879998555031, 0.1433175149646625, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.021752150684643534, 0.033443171251105075, 0.020000000000000018, 0.02764920419007877, 0.020000000000000018, 0.020000000000000018, 0.07633235696259832, 0.057760621546849245, 0.0715848924453314, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.044367614564138624, 0.09532156431158367, 0.08820901614742582, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11847079329819254, 0.12447431324415481, 0.14538961612911705, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08111129421691032, 0.10192118526721006, 0.0692403811836858, 0.1324239802617032, 0.13323277534341382, 0.1160417955509998, 0.08887635007941608, 0.07990382579724953, 0.09644729116247475, 0.1292085874449408, 0.1080556133934476, 0.12333485343047357, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1184217544517151, 0.08920687848815756, 0.1005344986119815, 0.06527120746322768, 0.06901183980698111, 0.05258532330607779, 0.16585089329697889, 0.13589170657517036, 0.15475448018179316, 0.05072598152818808, 0.03712619129882244, 0.04062347191560722, 0.03538214962479724, 0.03190567574903058, 0.04447331309738023, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020301159017495074, 0.017554917958396588, 0.014204086566910523, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02099661985967516, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08456423992106632, 0.06073908215594459, 0.08484527046459778, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05921279044702321, 0.06246634213286262, 0.05589135018409319, 0.11869262382913237, 0.1095235398681702, 0.10281775224528589, 0.0630195956926447, 0.044277336113016874, 0.05395184135282616, 0.09212194601624657, 0.07678011513756688, 0.09472111386652093, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03656166416380391, 0.03193561572196979, 0.029889759765381885, 0.024895242935785933, 0.02280571483161764, 0.024640285494433645, 0.15590366335623596, 0.14290691071997064, 0.14465141932040027, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.7998840574714126, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.7359344035851094, -0.7361775772739472, -0.7323709911404874, -0.8, -0.8, -0.8, -0.7377138645362202, -0.7219503025798772, -0.738663202176332, -0.6502793162809939, -0.6381164938205905, -0.6573522714736311, -0.750827497255274, -0.7506612113804212, -0.760211927719034, -0.6735200538756385, -0.6874338201266514, -0.6727555642820167, -0.8, -0.8, -0.8, -0.778452652613381, -0.7801727918723349, -0.7810623874971241, -0.7853110918310293, -0.7809127874843533, -0.7849076330980296, -0.5821646927765185, -0.5537413142412801, -0.5933698566859269, -0.8, -0.8, -0.8]}}
{"id": "bb75b6b0-aad4-4721-b179-2525115aa17a", "fitness": -0.2238570213429458, "name": "EnhancedAdaptiveHybridPSODE", "description": "Incorporate adaptive learning rates and mutation strategies in a PSO-DE hybrid, dynamically adjusting based on population diversity and convergence speed to enhance exploration and exploitation balance. ", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + dim\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Measure diversity and convergence for adaptive adjustment\n            diversity = np.std(self.population, axis=0).mean()\n            convergence_speed = np.std(self.pbest_scores)\n\n            # Adjust parameters based on diversity and convergence\n            self.w = max(0.1, self.w * (1 - adapt_rate * (diversity / (diversity + convergence_speed))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (convergence_speed / (convergence_speed + diversity))))\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                adaptive_f = self.de_f * (1 + adapt_rate * np.random.rand())\n                mutant_vector = np.clip(x1 + adaptive_f * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.22386 with standard deviation 0.38774.", "error": "", "parent_ids": ["2b28bab4-ab2f-4445-9080-fdfea83a01ab"], "operator": null, "metadata": {"aucs": [0.12100169108477987, 0.09811876761262173, 0.16654081967691725, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026904002247043035, 0.03167020474836901, 0.03119265598727139, 0.02051750821441145, 0.020000000000000018, 0.02333954106403835, 0.08472077716036497, 0.05710154310653792, 0.06071913757399694, 0.020000000000000018, 0.06676150241478529, 0.020000000000000018, 0.0652193022451657, 0.11073046944210119, 0.0886610848231163, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14788642167742383, 0.11282958485219297, 0.14773280976846226, 0.03277637914543419, 0.033797884601372896, 0.03318776862673134, 0.08764690548800036, 0.0863116411064907, 0.09178647641495641, 0.13932919242733077, 0.13323277534341382, 0.12829177551154036, 0.0819156381330245, 0.07990382579724953, 0.08179252361467237, 0.12410067545805137, 0.15443820235214278, 0.12973712739095533, 0.020000000000000018, 0.020000000000000018, 0.023337656979025234, 0.11888475870736248, 0.07386667624298515, 0.08702701112138, 0.06720061656035259, 0.07293240766404607, 0.0822852543164787, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.04856514139221024, 0.03758713423514981, 0.034731157058745854, 0.04282405484767182, 0.04123326947582018, 0.07091068650296573, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02527934118495123, 0.015839047655827776, 0.01121450615512476, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08244737699872673, 0.06376061252371645, 0.07625480885505642, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05745909410978489, 0.08665836647246095, 0.05395939349942802, 0.11970948479607146, 0.11282879873548435, 0.10606379407336641, 0.06948197587994442, 0.06182570237961427, 0.053936809511723194, 0.09299224937799, 0.07986124278078544, 0.1111246865869614, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027898321179209762, 0.03304188640070593, 0.031349739270601584, 0.026891729941598053, 0.025745137313678557, 0.026122089018374095, 0.13599012777775177, 0.13579081087181333, 0.13736543718119776, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.783737650315451, -0.7992301052581032, -0.7876576725878004, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.7050322287830455, -0.724837999151908, -0.7179054462736365, -0.8, -0.8, -0.8, -0.733297856980053, -0.7273963504686483, -0.733461802783508, -0.6404264278498788, -0.6305903208332204, -0.6412783749050601, -0.7374509990342621, -0.7439525466012749, -0.7576180525380889, -0.6618202638138555, -0.658603818991861, -0.6566485987812611, -0.8, -0.8, -0.8, -0.7729239441086277, -0.7823396922698189, -0.7802362781174528, -0.7848034747940138, -0.7809103958164076, -0.7837839970033895, -0.5970174316781367, -0.5640792492944617, -0.5827494575789882, -0.8, -0.8, -0.8]}}
{"id": "d9a86257-31ab-4b55-af65-c748b29597ba", "fitness": -0.12513402566749543, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSO-DE with Dynamic Swarm Resizing and Exploration-Exploitation Balance for Efficient Global Search.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n\n            # Dynamic swarm resizing based on progress\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12513 with standard deviation 0.25108.", "error": "", "parent_ids": ["2b28bab4-ab2f-4445-9080-fdfea83a01ab"], "operator": null, "metadata": {"aucs": [0.11457436525552678, 0.0986291369856338, 0.16621041114654422, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03250957357628392, 0.0244417407974461, 0.04191689756655781, 0.022040483187075632, 0.020000000000000018, 0.020000000000000018, 0.06589179482888508, 0.054946247387112845, 0.060921200985174284, 0.020000000000000018, 0.043260775842374866, 0.020000000000000018, 0.0450542191189659, 0.08594148016760361, 0.14319531440067135, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17147214792005383, 0.11685111788475866, 0.16571690950962426, 0.033052499702056926, 0.02212431937995807, 0.025617101420284727, 0.08652545674627621, 0.0863116411064907, 0.15029944020663122, 0.13782705681139962, 0.13323277534341382, 0.1160417955509998, 0.09384261927178761, 0.0852064290048744, 0.08613220343983585, 0.1486972198127967, 0.10638554080814344, 0.12429589931556895, 0.020000000000000018, 0.020000000000000018, 0.09697599025788417, 0.16653241225553728, 0.11183558697483131, 0.08457678974965832, 0.06527120746322768, 0.08582292144382275, 0.053590658925732004, 0.14777089405399801, 0.14084384575463849, 0.15475448018179316, 0.04536940489346497, 0.039910131734223975, 0.045530220502092766, 0.034166367660141916, 0.04070622035177773, 0.046628824043009054, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016827841395535947, 0.015076176168299149, 0.020761394384191445, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07452214491964138, 0.0865182338985645, 0.08629491031472836, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.062457342797158755, 0.06531100438685944, 0.12405880598723384, 0.10135392768077056, 0.10355136836264822, 0.06190731654808401, 0.047872017782410126, 0.05442636906061127, 0.1029209025341945, 0.09723186451289845, 0.09922561874615421, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026924530326860707, 0.03416370715063122, 0.03094782090282, 0.027668958769021312, 0.0289982764440313, 0.025617847225239854, 0.13460721290727973, 0.13422034715510445, 0.13871109724045638, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49981801694458916, -0.5, -0.492034982400539, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.43949158063774596, -0.4422846941479821, -0.4226792770466501, -0.5, -0.5, -0.5, -0.44358739076924913, -0.4433928984398867, -0.43209031786144547, -0.367791511950611, -0.35707369247641485, -0.3755638932090988, -0.45815630057218293, -0.45169031048877883, -0.46189459295070634, -0.38631508212855126, -0.3846351302851778, -0.40232067888958833, -0.5, -0.5, -0.5, -0.4819855833763613, -0.48508336343656855, -0.4841118667215114, -0.487591197373068, -0.4842478312085883, -0.48552535428382715, -0.3166258858700144, -0.29985801630937914, -0.3273231238822061, -0.5, -0.5, -0.5]}}
{"id": "a07fdf65-3623-4d97-8681-2cc94f9fed61", "fitness": -0.1241297066571767, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSO-DE with Improved Mutation Strategy for Enhanced Search Efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n\n            # Dynamic swarm resizing based on progress\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12413 with standard deviation 0.25146.", "error": "", "parent_ids": ["d9a86257-31ab-4b55-af65-c748b29597ba"], "operator": null, "metadata": {"aucs": [0.13365168319153797, 0.0986291369856338, 0.16621877566270216, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030385841755834253, 0.02692017083241982, 0.04191689756655781, 0.033985836140582815, 0.020000000000000018, 0.020000000000000018, 0.07229301501859142, 0.06091335941773901, 0.06289810805811713, 0.020000000000000018, 0.043260775842374866, 0.020000000000000018, 0.0450542191189659, 0.09618406717937789, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17831380297387556, 0.1299244757748862, 0.17212262287524227, 0.03666460381177161, 0.02212431937995807, 0.020000000000000018, 0.10220002418588703, 0.0863116411064907, 0.15302411514964276, 0.14181397293954445, 0.13323277534341382, 0.1160417955509998, 0.09779288587067825, 0.0852064290048744, 0.09316274083271037, 0.1486972198127967, 0.11465300943001044, 0.13851357508224527, 0.020000000000000018, 0.020000000000000018, 0.09697599025788417, 0.16653241225553728, 0.08620648251578122, 0.08457678974965832, 0.06527120746322768, 0.08582292144382275, 0.04849344251402132, 0.16021505721061036, 0.14097999421926977, 0.15475448018179316, 0.04536940489346497, 0.039905509190460764, 0.037041828358660545, 0.05169183489108742, 0.043981942118881845, 0.054274420221067654, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.019126283658323917, 0.014731014667878517, 0.019720139678230164, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07655884084507003, 0.08621866141679502, 0.08588513612359361, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06092877443610378, 0.06226456912839706, 0.05395939349942802, 0.12405880598723384, 0.10139141526713968, 0.11203450956297079, 0.06641462036999468, 0.040064521576433476, 0.05545197213994779, 0.10421955648952719, 0.08846348231276191, 0.09906075608598297, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034177927256791585, 0.04901746597355516, 0.03187076545986034, 0.02904929669913714, 0.03865005135814725, 0.024640285494433645, 0.13141309820135194, 0.13123409970527322, 0.1394681300744708, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49440751961330354, -0.5, -0.49143493171032837, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.42749881090358177, -0.4423697276076768, -0.4209645283381045, -0.5, -0.5, -0.5, -0.4434165970358861, -0.44339553444561286, -0.45256079200387833, -0.3678925981389116, -0.3563799202406681, -0.36804930995379403, -0.45282560020703055, -0.44673325077091164, -0.4648148522460043, -0.38302590535452397, -0.38052857593374, -0.38931208153434915, -0.5, -0.5, -0.5, -0.47894407172291587, -0.4852098656344659, -0.48243458040878173, -0.4873002245547813, -0.4842478312085883, -0.4854616010072972, -0.3140165172496103, -0.2880051091266407, -0.3263705659476406, -0.5, -0.5, -0.5]}}
{"id": "cbc4b4c1-1426-4e95-bf36-8066e38edb1a", "fitness": -0.12656526989899233, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSO-DE with Dynamic Exploration-Exploitation Balance and Adaptive Parameter Control.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n        exploration_weight = 0.8  # Higher weight for exploration at the start\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n\n            # Dynamic swarm resizing based on progress and balance exploration-exploitation\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                exploration_weight = 0.2  # Lower weight for exploration in exploitation phase\n\n            for i in range(self.population_size):\n                # PSO update with dynamic exploration-exploitation\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + (exploration_weight * cognitive + (1 - exploration_weight) * social)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12657 with standard deviation 0.24974.", "error": "", "parent_ids": ["a07fdf65-3623-4d97-8681-2cc94f9fed61"], "operator": null, "metadata": {"aucs": [0.12385370496057246, 0.09856282299634378, 0.16818311055181823, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03799298621382974, 0.02180788942927203, 0.02485195261549611, 0.031197678772158732, 0.020000000000000018, 0.020000000000000018, 0.07410018698889786, 0.05148434054548434, 0.06317950303611897, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09618406717937789, 0.08820901614742582, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16571253952805365, 0.12286605569408071, 0.1470610140183689, 0.024113573686629475, 0.0358762851455523, 0.044523496073327395, 0.08274369323301944, 0.0863116411064907, 0.0744783468296224, 0.13500638659414765, 0.13568851362185397, 0.1160417955509998, 0.07982556629803605, 0.07990382579724953, 0.10193119613839619, 0.12917373977836366, 0.11208979508570427, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1184217544517151, 0.11159666281865688, 0.09480332893305188, 0.07439868317916054, 0.05379465033497155, 0.07320581031174056, 0.1438526290318487, 0.14097999421926977, 0.15475448018179316, 0.044324246765743536, 0.033476644395675104, 0.03151750134482223, 0.04273414691959365, 0.03987450246487745, 0.05898576068497452, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01870591196846816, 0.012081848768308312, 0.01813663057628223, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012428794406575294, 0.010767135888044788, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08173386439762598, 0.07193202700690149, 0.09184810315534875, 0.010000000000000009, 0.010000000000000009, 0.010259720871922284, 0.06135636571937919, 0.06147825531143891, 0.05395939349942802, 0.11869262382913237, 0.09804433806702728, 0.10415335334729636, 0.06811814192622878, 0.043461439229082854, 0.05419556575448736, 0.09743762994545335, 0.08659786535369629, 0.10547723598198078, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03466853154613292, 0.0450023656309948, 0.030566025721036394, 0.029191656380878617, 0.030673454276086032, 0.025850649615547616, 0.13468708525679707, 0.13971882457656792, 0.13871109724045638, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49470771993214324, -0.4994478550382422, -0.4949477890149041, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.43835372861032473, -0.43711285096405295, -0.42260423337509656, -0.5, -0.5, -0.5, -0.4418917083592897, -0.43770557082035144, -0.44539436191017767, -0.3707873328787905, -0.3693617955267947, -0.37251227801985864, -0.45581289621165144, -0.4537102943276565, -0.45960931609072153, -0.3934473090002595, -0.38360302979822736, -0.3904815528281147, -0.5, -0.5, -0.5, -0.4822978717624453, -0.484090752070673, -0.48143313147524425, -0.487269829577313, -0.4842478312085883, -0.4879828273528861, -0.31650292096443744, -0.3036434880944845, -0.3206692392152113, -0.5, -0.5, -0.5]}}
{"id": "59e262f4-8aec-4f77-bb38-96021948c28e", "fitness": -0.12513402566749543, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSO-DE with Improved Mutation Strategy and Adaptive Differential Evolution for Robust Search Efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n\n            # Dynamic swarm resizing based on progress\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)  # Modified line\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12513 with standard deviation 0.25108.", "error": "", "parent_ids": ["a07fdf65-3623-4d97-8681-2cc94f9fed61"], "operator": null, "metadata": {"aucs": [0.11457436525552678, 0.0986291369856338, 0.16621041114654422, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03250957357628392, 0.0244417407974461, 0.04191689756655781, 0.022040483187075632, 0.020000000000000018, 0.020000000000000018, 0.06589179482888508, 0.054946247387112845, 0.060921200985174284, 0.020000000000000018, 0.043260775842374866, 0.020000000000000018, 0.0450542191189659, 0.08594148016760361, 0.14319531440067135, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17147214792005383, 0.11685111788475866, 0.16571690950962426, 0.033052499702056926, 0.02212431937995807, 0.025617101420284727, 0.08652545674627621, 0.0863116411064907, 0.15029944020663122, 0.13782705681139962, 0.13323277534341382, 0.1160417955509998, 0.09384261927178761, 0.0852064290048744, 0.08613220343983585, 0.1486972198127967, 0.10638554080814344, 0.12429589931556895, 0.020000000000000018, 0.020000000000000018, 0.09697599025788417, 0.16653241225553728, 0.11183558697483131, 0.08457678974965832, 0.06527120746322768, 0.08582292144382275, 0.053590658925732004, 0.14777089405399801, 0.14084384575463849, 0.15475448018179316, 0.04536940489346497, 0.039910131734223975, 0.045530220502092766, 0.034166367660141916, 0.04070622035177773, 0.046628824043009054, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016827841395535947, 0.015076176168299149, 0.020761394384191445, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07452214491964138, 0.0865182338985645, 0.08629491031472836, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.062457342797158755, 0.06531100438685944, 0.12405880598723384, 0.10135392768077056, 0.10355136836264822, 0.06190731654808401, 0.047872017782410126, 0.05442636906061127, 0.1029209025341945, 0.09723186451289845, 0.09922561874615421, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026924530326860707, 0.03416370715063122, 0.03094782090282, 0.027668958769021312, 0.0289982764440313, 0.025617847225239854, 0.13460721290727973, 0.13422034715510445, 0.13871109724045638, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49981801694458916, -0.5, -0.492034982400539, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.43949158063774596, -0.4422846941479821, -0.4226792770466501, -0.5, -0.5, -0.5, -0.44358739076924913, -0.4433928984398867, -0.43209031786144547, -0.367791511950611, -0.35707369247641485, -0.3755638932090988, -0.45815630057218293, -0.45169031048877883, -0.46189459295070634, -0.38631508212855126, -0.3846351302851778, -0.40232067888958833, -0.5, -0.5, -0.5, -0.4819855833763613, -0.48508336343656855, -0.4841118667215114, -0.487591197373068, -0.4842478312085883, -0.48552535428382715, -0.3166258858700144, -0.29985801630937914, -0.3273231238822061, -0.5, -0.5, -0.5]}}
{"id": "26695398-c4a5-4ec2-94b3-780b97e225f9", "fitness": -0.12527036231525998, "name": "EnhancedAdaptiveHybridPSODE", "description": "Dynamic Swarm Resizing and Adaptive Parameter Control with Hybrid PSO-DE for Enhanced Convergence in Black Box Optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adaptive strategy for inertia weight and DE scaling factor\n            self.w *= 0.99  # Gradually decrease inertia weight\n            self.de_f = min(0.9, self.de_f * (1 + adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n\n            # Dynamic swarm resizing based on progress\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12527 with standard deviation 0.25129.", "error": "", "parent_ids": ["a07fdf65-3623-4d97-8681-2cc94f9fed61"], "operator": null, "metadata": {"aucs": [0.11525741263486788, 0.09452143111838185, 0.16488465081907722, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.031010704993725824, 0.0244826529583696, 0.041941474472877216, 0.022434349042432133, 0.020000000000000018, 0.020000000000000018, 0.0673983612300253, 0.054977794947681624, 0.06073322144663085, 0.020000000000000018, 0.043294274300374136, 0.020000000000000018, 0.0450542191189659, 0.08594148016760361, 0.14319531440067135, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1718800782783816, 0.11688310532908774, 0.1659465327763422, 0.03314752262246201, 0.02214869567714106, 0.02000512267592003, 0.09434399789763914, 0.0863116411064907, 0.10624305107476872, 0.1534694647587368, 0.13323277534341382, 0.14389569853453144, 0.12110120028804716, 0.08220287618699929, 0.08590543055020261, 0.1165663102105361, 0.15204558311257554, 0.13383265496050223, 0.020000000000000018, 0.020000000000000018, 0.09666265645435135, 0.1690522739356246, 0.11205986497867515, 0.08467845675156727, 0.06527120746322768, 0.08571140805760025, 0.054112544882952474, 0.1456439960059016, 0.13589170657517036, 0.15535217552408143, 0.048772933037402155, 0.04073570117679681, 0.029045888760882432, 0.035872912843020854, 0.044520323351417646, 0.04665304783894475, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01684075398746232, 0.014839571218164704, 0.021318431626497603, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010504630451964703, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07494987745913262, 0.08633561380091748, 0.08669503984086713, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05557359020332642, 0.061830015650951364, 0.05916931193309405, 0.12399005801839724, 0.10300393467195823, 0.10396978943810675, 0.06252739454535539, 0.04623090870014179, 0.05430581681253299, 0.09240093132683525, 0.08861818821695722, 0.09701620123831656, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02696254788543062, 0.033586246836112665, 0.03080096801044563, 0.027958036982492884, 0.029308441138843566, 0.026383830159504074, 0.13141309820135194, 0.1343971021214786, 0.13615763226706123, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49940790328773366, -0.5, -0.49190490336380943, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.43626542984033545, -0.4436530858479171, -0.422734815771304, -0.5, -0.5, -0.5, -0.435411173316546, -0.44339553444561286, -0.4483853955091408, -0.3696923666095313, -0.3692105055484507, -0.37818678589027344, -0.4566729876613125, -0.45196698644094946, -0.4650975223546525, -0.3866225140448185, -0.39048243911082725, -0.3952601287977606, -0.5, -0.5, -0.5, -0.48196419942878954, -0.4852748239059066, -0.4839243754065179, -0.48776704105198565, -0.4842443448876901, -0.48566139391918917, -0.3306966741171147, -0.3036434880944845, -0.32027985284388616, -0.5, -0.5, -0.5]}}
{"id": "66904524-01af-4bf2-98f3-07d5593cf683", "fitness": -0.12550194181947155, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Multi-Phase PSO-DE with Adaptive Learning Mechanism for Improved Global and Local Search Efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.7   # inertia weight, increased for initial exploration\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n        phase_switch_threshold = 0.3  # Threshold to switch from exploration to exploitation\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically\n            performance_ratio = self.gbest_score / np.mean(self.pbest_scores)\n            self.w = max(0.1, self.w * (1 - adapt_rate * performance_ratio))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - performance_ratio)))\n\n            # Update phase and population size based on progress\n            if exploration_phase and evals > self.budget * phase_switch_threshold:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12550 with standard deviation 0.25108.", "error": "", "parent_ids": ["a07fdf65-3623-4d97-8681-2cc94f9fed61"], "operator": null, "metadata": {"aucs": [0.11440335046866124, 0.09881080421026067, 0.16444839043060255, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.031621875951043044, 0.0250605647584482, 0.034591409372493165, 0.023508560300968373, 0.020000000000000018, 0.020000000000000018, 0.06682476419996419, 0.055487453261324204, 0.059499050977252055, 0.020000000000000018, 0.04130256653243236, 0.020000000000000018, 0.0450542191189659, 0.08594148016760361, 0.14316582587937488, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03320721127217641, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17357785073898102, 0.11541715825012633, 0.16191835816630407, 0.02481625134943466, 0.03305238901009344, 0.022846186621439113, 0.09163615867185537, 0.0863116411064907, 0.08624519995169833, 0.1356876908576945, 0.13323277534341382, 0.1160417955509998, 0.09384261927178761, 0.08304634600874405, 0.10904759250602014, 0.13066782059178095, 0.11508845278122726, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.10457848144896131, 0.20702877813124654, 0.10488813551920406, 0.08417570914728689, 0.06527120746322768, 0.08466409618566884, 0.05379916146016628, 0.1438526290318487, 0.1430281921816765, 0.15475448018179316, 0.05801049841679573, 0.034421314593516716, 0.02807187733286709, 0.03471505841047018, 0.037841415535174616, 0.04654173518509419, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016816117376316275, 0.014852498283185023, 0.022011355175670988, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016390487023494993, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07221477596698933, 0.08808349539117577, 0.08481789639127424, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05460360279635035, 0.06340548592854911, 0.0644027026180527, 0.11869262382913237, 0.10378529359458133, 0.10379352686935195, 0.06575731827313647, 0.04703491536206694, 0.05394160233582601, 0.10417769600443316, 0.09028895317389596, 0.09954709068653511, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026943651092192766, 0.034605721217289775, 0.03031709562092577, 0.02842545561565646, 0.02965663479810232, 0.025055813161814933, 0.13374067560317893, 0.1346068054594154, 0.1337936913147434, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.5, -0.5, -0.49069180328578144, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4381511408466776, -0.44327432482831997, -0.4217718769536083, -0.5, -0.5, -0.5, -0.4532421373971869, -0.44195127348233343, -0.4519935829493098, -0.367791511950611, -0.3574691361410176, -0.37684787385752383, -0.4567315286821332, -0.4511901268519418, -0.462270688942068, -0.3863946323067944, -0.3943251006281796, -0.3955622547952651, -0.5, -0.5, -0.5, -0.4819149757392873, -0.48524281430221583, -0.4834779556400599, -0.4880560170839565, -0.48426875672466885, -0.4861583410565373, -0.32429568915530016, -0.3036434880944845, -0.3164317275209956, -0.5, -0.5, -0.5]}}
{"id": "51ff7ced-1f72-4da6-9244-ceebac0921b8", "fitness": -0.1241297066571767, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Dynamic PSO-DE with Adaptive Parameter Tuning and Population Resizing for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically based on convergence\n            avg_pbest_score = np.mean(self.pbest_scores)\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / avg_pbest_score)))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / avg_pbest_score)))\n\n            # Dynamic swarm resizing and exploration-exploitation balance\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size for exploitation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12413 with standard deviation 0.25146.", "error": "", "parent_ids": ["a07fdf65-3623-4d97-8681-2cc94f9fed61"], "operator": null, "metadata": {"aucs": [0.13365168319153797, 0.0986291369856338, 0.16621877566270216, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030385841755834253, 0.02692017083241982, 0.04191689756655781, 0.033985836140582815, 0.020000000000000018, 0.020000000000000018, 0.07229301501859142, 0.06091335941773901, 0.06289810805811713, 0.020000000000000018, 0.043260775842374866, 0.020000000000000018, 0.0450542191189659, 0.09618406717937789, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17831380297387556, 0.1299244757748862, 0.17212262287524227, 0.03666460381177161, 0.02212431937995807, 0.020000000000000018, 0.10220002418588703, 0.0863116411064907, 0.15302411514964276, 0.14181397293954445, 0.13323277534341382, 0.1160417955509998, 0.09779288587067825, 0.0852064290048744, 0.09316274083271037, 0.1486972198127967, 0.11465300943001044, 0.13851357508224527, 0.020000000000000018, 0.020000000000000018, 0.09697599025788417, 0.16653241225553728, 0.08620648251578122, 0.08457678974965832, 0.06527120746322768, 0.08582292144382275, 0.04849344251402132, 0.16021505721061036, 0.14097999421926977, 0.15475448018179316, 0.04536940489346497, 0.039905509190460764, 0.037041828358660545, 0.05169183489108742, 0.043981942118881845, 0.054274420221067654, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.019126283658323917, 0.014731014667878517, 0.019720139678230164, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07655884084507003, 0.08621866141679502, 0.08588513612359361, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06092877443610378, 0.06226456912839706, 0.05395939349942802, 0.12405880598723384, 0.10139141526713968, 0.11203450956297079, 0.06641462036999468, 0.040064521576433476, 0.05545197213994779, 0.10421955648952719, 0.08846348231276191, 0.09906075608598297, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034177927256791585, 0.04901746597355516, 0.03187076545986034, 0.02904929669913714, 0.03865005135814725, 0.024640285494433645, 0.13141309820135194, 0.13123409970527322, 0.1394681300744708, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49440751961330354, -0.5, -0.49143493171032837, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.42749881090358177, -0.4423697276076768, -0.4209645283381045, -0.5, -0.5, -0.5, -0.4434165970358861, -0.44339553444561286, -0.45256079200387833, -0.3678925981389116, -0.3563799202406681, -0.36804930995379403, -0.45282560020703055, -0.44673325077091164, -0.4648148522460043, -0.38302590535452397, -0.38052857593374, -0.38931208153434915, -0.5, -0.5, -0.5, -0.47894407172291587, -0.4852098656344659, -0.48243458040878173, -0.4873002245547813, -0.4842478312085883, -0.4854616010072972, -0.3140165172496103, -0.2880051091266407, -0.3263705659476406, -0.5, -0.5, -0.5]}}
{"id": "ccd34e3c-1a89-450d-9b8d-f2fe7fa104f4", "fitness": -0.12670910322277024, "name": "EnhancedAdaptiveHybridPSODE", "description": "Adaptive Hybrid PSO-DE with Dynamic Parameter Control for Improved Global and Local Search Balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.9   # inertia weight\n        self.de_f = 0.8  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.2  # Increased rate for parameter adaptation\n        exploration_phase = True  # Start with exploration\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically\n            self.w = max(0.4, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.2, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n\n            # Dynamic swarm resizing based on progress\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12671 with standard deviation 0.25056.", "error": "", "parent_ids": ["a07fdf65-3623-4d97-8681-2cc94f9fed61"], "operator": null, "metadata": {"aucs": [0.13210943987863577, 0.09614486081597762, 0.14727360863958694, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026059123055748867, 0.023017642893306434, 0.027940556819356144, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0847592357525716, 0.09594961882508402, 0.059125651517840105, 0.020000000000000018, 0.05497712375460995, 0.020000000000000018, 0.0575458293249127, 0.08594148016760361, 0.09685816982216433, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13493325197233785, 0.12192425210904867, 0.15666674931060276, 0.03457160713406782, 0.02958933969949895, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.10196979306306064, 0.141934516530695, 0.1344538179349939, 0.1160417955509998, 0.07541911716425109, 0.07990382579724953, 0.08781527340853612, 0.1290962679947646, 0.12593478990553364, 0.12837348276746274, 0.020000000000000018, 0.020000000000000018, 0.10081360011553098, 0.14296718730769353, 0.07213075594865004, 0.09225408831133564, 0.06527120746322768, 0.07042422666847326, 0.05488856907494, 0.15326365276985698, 0.13589170657517036, 0.15475448018179316, 0.053648007249601615, 0.0337746689595535, 0.027303296787024478, 0.028340651195051136, 0.028581297962204655, 0.04680272212641645, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03102247716915041, 0.019089142695564054, 0.021154168551467567, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010436964081067979, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07669792984268442, 0.06725257930848738, 0.08696133439456677, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05884678874496041, 0.06187653660860404, 0.05395939349942802, 0.11869262382913237, 0.09930493029389387, 0.10604728610153069, 0.06410911779864292, 0.04229760553879913, 0.05603074125353624, 0.08901709370063371, 0.0745178871778216, 0.09606234043413797, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034931140418933526, 0.03595635427141286, 0.035841296482340246, 0.026696385615657903, 0.025292960305170364, 0.026471988546532876, 0.13633282062665375, 0.14982317465605488, 0.13904291904814814, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.5, -0.5, -0.4998815419592766, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4978460217080909, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.44552384403811085, -0.4474240736644808, -0.43091762847091264, -0.5, -0.5, -0.5, -0.44690624443738414, -0.4402371575045674, -0.44044255867982085, -0.37203150470554047, -0.36939827676576553, -0.3791398805569086, -0.4567255937196566, -0.451159533890757, -0.4673456652074979, -0.3972517355297638, -0.4048837556090117, -0.4076907006931416, -0.5, -0.5, -0.5, -0.4810272458446254, -0.48515413034690646, -0.48509450634601214, -0.48829314309631533, -0.48358196861040503, -0.4863983190737151, -0.31581159677223436, -0.30249365536860817, -0.33475092451067545, -0.5, -0.5, -0.5]}}
{"id": "454f0d9f-7604-487a-8958-3b2bd8f4650c", "fitness": -0.1241140283919349, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced parameter adaptation in Adaptive Hybrid PSO-DE for improved convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n            self.c1 = max(0.1, self.c1 * (1 + adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score)))  # Change\n\n            # Dynamic swarm resizing based on progress\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12411 with standard deviation 0.25145.", "error": "", "parent_ids": ["a07fdf65-3623-4d97-8681-2cc94f9fed61"], "operator": null, "metadata": {"aucs": [0.13365168319153797, 0.0986291369856338, 0.16621877566270216, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030385841755834253, 0.02692017083241982, 0.04191689756655781, 0.033985836140582815, 0.020000000000000018, 0.020000000000000018, 0.07229301501859142, 0.06091335941773901, 0.06289810805811713, 0.020000000000000018, 0.043260775842374866, 0.020000000000000018, 0.0450542191189659, 0.09618406717937789, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17831380297387556, 0.1299244757748862, 0.17212262287524227, 0.03666460381177161, 0.02212431937995807, 0.020000000000000018, 0.10220002418588703, 0.0863116411064907, 0.15302411514964276, 0.14181397293954445, 0.13323277534341382, 0.1160417955509998, 0.09779288587067825, 0.0852064290048744, 0.09316274083271037, 0.1486972198127967, 0.11465300943001044, 0.13851357508224527, 0.020000000000000018, 0.020000000000000018, 0.09697599025788417, 0.16653241225553728, 0.08620648251578122, 0.08457678974965832, 0.06527120746322768, 0.08582292144382275, 0.04849344251402132, 0.16021505721061036, 0.14097999421926977, 0.15475448018179316, 0.04536940489346497, 0.039905509190460764, 0.037041828358660545, 0.05169183489108742, 0.043981942118881845, 0.05427446356010468, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.019126283658323917, 0.014731014667878517, 0.019720139678230164, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07655884084507003, 0.08621866141679502, 0.08588513612359361, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06092877443610378, 0.06226456912839706, 0.05395939349942802, 0.12405880598723384, 0.10139324051085186, 0.11214898063125844, 0.06641462036999468, 0.040064521576433476, 0.05545197213994779, 0.10421955648952719, 0.08865227947181031, 0.09914134688249998, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034177927256791585, 0.04901746597355516, 0.031877278325073366, 0.02904929669913714, 0.03865005135814725, 0.024640285494433645, 0.13141309820135194, 0.13123409970527322, 0.1394681300744708, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49440751961330354, -0.5, -0.49143493171032837, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.42749881090358177, -0.4423697276076768, -0.4209645283381045, -0.5, -0.5, -0.5, -0.4434165970358861, -0.44160457790268626, -0.45256079200387833, -0.3678925981389116, -0.3563799202406681, -0.36804930995379403, -0.451597151412682, -0.44673325077091164, -0.46469355723102956, -0.38302590535452397, -0.3804930537357627, -0.38931208153434915, -0.5, -0.5, -0.5, -0.47894407172291587, -0.4852098656344659, -0.48243237543035744, -0.48748438726301657, -0.4842478312085883, -0.4854616010072972, -0.3140165172496103, -0.2880051091266407, -0.3263705659476406, -0.5, -0.5, -0.5]}}
{"id": "2837a113-d623-4a8f-a63d-f800618b7389", "fitness": -0.12410831436958951, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Introduce adaptive learning rate and mutation strategies in Enhanced Adaptive Hybrid PSO-DE for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n            self.c1 = max(0.1, self.c1 * (1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score)))\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 14, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12411 with standard deviation 0.25145.", "error": "", "parent_ids": ["454f0d9f-7604-487a-8958-3b2bd8f4650c"], "operator": null, "metadata": {"aucs": [0.12668916703454158, 0.1082531822850129, 0.16497898179411574, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.049747902177819325, 0.03096049041144211, 0.041684010132664207, 0.03501351293393096, 0.020000000000000018, 0.027986258822623955, 0.07159105434954294, 0.06087417032437803, 0.06247492140142019, 0.020000000000000018, 0.04324132479727738, 0.020000000000000018, 0.0450542191189659, 0.08607968519782527, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05878567709757865, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17793543732278327, 0.12537953053557482, 0.17611741810484594, 0.038367065962195857, 0.02195200175355483, 0.023838181820287185, 0.09457292980441645, 0.09224350170875395, 0.10663139988600501, 0.14182543205866271, 0.13323277534341382, 0.15126824024365415, 0.07711447140296745, 0.08320501576238482, 0.0859348138139695, 0.13627985799609865, 0.11899923032801207, 0.14418839004129258, 0.020000000000000018, 0.020000000000000018, 0.09707534529126949, 0.16909302988458097, 0.08563781214905863, 0.0846789413432435, 0.06527120746322768, 0.08570743406973802, 0.04843169389032764, 0.14601657059334994, 0.14234700938592582, 0.15799924870351134, 0.043310078795063545, 0.03736930917929626, 0.03503346783056671, 0.052901419845658104, 0.04049222038588507, 0.051812590451176144, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018634207992672458, 0.014679337857784303, 0.020077215267357174, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08182369440784532, 0.08611972693615666, 0.0860709574878572, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270883108147, 0.06147825531143891, 0.058747502990533995, 0.12146659776843505, 0.10127912560834607, 0.11097007119383295, 0.08082137090092856, 0.040778108038887484, 0.05406614515966157, 0.09191515143575746, 0.08844850012127192, 0.10050652970905971, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03415225675882505, 0.048638050500057095, 0.03197401870821637, 0.029094899011054443, 0.038768214881140795, 0.024640285494433645, 0.13209621685414363, 0.1375160694082984, 0.13498079672782182, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4940683862805124, -0.5, -0.49122841255212446, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4280151660317728, -0.4413042337739177, -0.4212457602118789, -0.5, -0.5, -0.5, -0.4419547277283058, -0.44339553444561286, -0.4524881217554366, -0.36900313660394746, -0.36167209402858846, -0.3744154374098623, -0.4514457680951074, -0.4448756630661166, -0.46361908034494603, -0.37456242232763626, -0.37703333869967715, -0.38989047326589676, -0.5, -0.5, -0.5, -0.47892570402480095, -0.4852109214349727, -0.48238068960660363, -0.4871975476666528, -0.48424433817679535, -0.48561247002416064, -0.319124990607748, -0.3036434880944845, -0.32220672206589995, -0.5, -0.5, -0.5]}}
{"id": "aeb4143e-9b0f-4084-af79-46569f3c7884", "fitness": -0.12457725671277838, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Refine adaptive mutation strategy by increasing crossover probability during intense exploitation to enhance local search.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n            self.c1 = max(0.1, self.c1 * (1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score)))\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < (self.de_cr + 0.1)  # Increase crossover probability\n\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 15, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12458 with standard deviation 0.25095.", "error": "", "parent_ids": ["2837a113-d623-4a8f-a63d-f800618b7389"], "operator": null, "metadata": {"aucs": [0.12605495679326428, 0.0904857420404076, 0.16497898179411574, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.038039917601599305, 0.03096049041144211, 0.041684010132664207, 0.02288442297739368, 0.020000000000000018, 0.027986258822623955, 0.0717252882333268, 0.06087417032437803, 0.06247492140142019, 0.020000000000000018, 0.04324132479727738, 0.020000000000000018, 0.0450542191189659, 0.0882618602415155, 0.14319531440067135, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1799842546289423, 0.10912974574385015, 0.16584965714536626, 0.032795680525084636, 0.02195200175355483, 0.021801189405853738, 0.09457292980441645, 0.09512595611619956, 0.10663139988600501, 0.14179031559053812, 0.13323277534341382, 0.13169481097267943, 0.0802227208018984, 0.08320501576238482, 0.08580442658277865, 0.1362542168828963, 0.11940210055178713, 0.1537055505269579, 0.020000000000000018, 0.020000000000000018, 0.09707534529126949, 0.16909302988458097, 0.08563781214905863, 0.0846789413432435, 0.07872210727515239, 0.08570743406973802, 0.05195976077689568, 0.1438526290318487, 0.1444656472530359, 0.15475448018179316, 0.05166410266861843, 0.041940667866124715, 0.02962914677588402, 0.04953996176780451, 0.04480719499927199, 0.05488317968442402, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028077137126073293, 0.012930862091712125, 0.016846174740150377, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01127478966173423, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08494952699230973, 0.08611972693615666, 0.08592448724877289, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270883108147, 0.06147825531143891, 0.058705076916418575, 0.12046009051948037, 0.10074131754115012, 0.11008482636010586, 0.08082137090092856, 0.041035913689894676, 0.053936809511723194, 0.09997856313960685, 0.08737029267776464, 0.09677416029221608, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.032481098958620835, 0.03366787560263096, 0.03646890094411559, 0.028004501092152467, 0.025027110398443964, 0.025756267836783198, 0.13141309820135194, 0.1328630202162594, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4958714454625297, -0.4999896390455769, -0.4907129388598741, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4369749417717741, -0.4337849503382034, -0.4210603153269181, -0.5, -0.5, -0.5, -0.4400328111180283, -0.4318776849150072, -0.44458327346667237, -0.36740798107179384, -0.36528599361489, -0.3664558001720999, -0.45213855696649485, -0.45050964904780266, -0.45767426806742084, -0.3815629175020703, -0.3807856874078286, -0.3857443414789359, -0.5, -0.5, -0.5, -0.48145185271480795, -0.48433419553611534, -0.48256488039935785, -0.48667102004835705, -0.48424433817679535, -0.48564093127520125, -0.3265813540125335, -0.3016879947247515, -0.32213723970400854, -0.5, -0.5, -0.5]}}
{"id": "14b30b06-a0d2-4222-a523-2c33430b9821", "fitness": -0.12514238651655796, "name": "AdvancedHybridPSODE", "description": "Introduce dynamic adaptive inertia weight and competitive DE scaling factor based on population diversity to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass AdvancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Calculate population diversity\n            diversity = np.mean(np.std(self.population, axis=0))\n\n            # Adjust parameters dynamically using diversity\n            self.w = 0.9 - 0.7 * (evals / self.budget)  # Dynamic inertia weight\n            self.de_f = 0.5 + 0.5 * ((diversity - 0.5) / (1.5 - 0.5))  # DE scaling factor\n\n            # Dynamic swarm resizing\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 16, "feedback": "The algorithm AdvancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12514 with standard deviation 0.25106.", "error": "", "parent_ids": ["2837a113-d623-4a8f-a63d-f800618b7389"], "operator": null, "metadata": {"aucs": [0.11579808111522283, 0.08543886689184288, 0.1598909976204702, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026276389129515576, 0.024588827017134496, 0.035368420254537125, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09057556457944627, 0.14117411190234241, 0.05985389494700144, 0.020000000000000018, 0.026261300511657315, 0.020000000000000018, 0.07124518498198318, 0.08594148016760361, 0.08860065016317464, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1725993841341833, 0.11569197518466356, 0.16020564978568697, 0.034936610588572004, 0.03295413378504497, 0.020072195417197625, 0.1259457592517993, 0.0863116411064907, 0.08573496943184378, 0.13394478815031785, 0.13323277534341382, 0.14884606789443955, 0.08155677491736246, 0.08459979253836447, 0.10265765062013155, 0.12768677142921503, 0.10865860264099458, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.08248098321335517, 0.1907134816597187, 0.06360782465788817, 0.0821134314443438, 0.0744681812038176, 0.08276166510276683, 0.061837867873310914, 0.14880796121573125, 0.14180009800556126, 0.15475448018179316, 0.04784419949301855, 0.03862155491900854, 0.02657375009670604, 0.029546584217023386, 0.032597721857927975, 0.046517086189879486, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0745915275994895, 0.026732437431185585, 0.025452872265878, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01368691474646222, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07096165014517697, 0.08820607862784668, 0.08241635133441161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06536239689526413, 0.0707675999087286, 0.0654240451551199, 0.12282920828845656, 0.10426907547106756, 0.10281775224528589, 0.06304371619766302, 0.05201813810907596, 0.053936809511723194, 0.08669510467543862, 0.08309711403035946, 0.10070189113865335, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026257124785270203, 0.03297618844380523, 0.029839972264028014, 0.02867740601403057, 0.026005618544961306, 0.024640285494433645, 0.13780181716574702, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49909012761898963, -0.5, -0.4905975035776955, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4997220151683075, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.43776204022341014, -0.44422677652181, -0.42101112958179177, -0.5, -0.5, -0.5, -0.4417055495977298, -0.44332992865871357, -0.44225900113693917, -0.3710875595489884, -0.3689160425657778, -0.3739119229582877, -0.4568258388560624, -0.45148152121183016, -0.46174936773875963, -0.382737248731325, -0.37266691299769605, -0.3923378512102351, -0.5, -0.5, -0.5, -0.48185667901530516, -0.48528744917641564, -0.4832564797711085, -0.4881489769798706, -0.4842939513388709, -0.4863710576284419, -0.3296453928534302, -0.3036434880944845, -0.32467606759360557, -0.5, -0.5, -0.5]}}
{"id": "ce8dc63c-c07c-4908-8edb-4eddaf082071", "fitness": -0.22322796095230277, "name": "EnhancedAdaptiveHybridPSODE", "description": "Introduce adaptive inertia weight decay and crossover rate scaling in Enhanced Adaptive Hybrid PSO-DE for improved convergence and balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.9   # initial inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.1\n        exploration_phase = True\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adapt inertia weight with dynamic decay\n            self.w = max(0.3, self.w * 0.99)\n\n            # Adapt crossover rate based on performance\n            self.de_cr = min(0.9, self.de_cr * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.22323 with standard deviation 0.38869.", "error": "", "parent_ids": ["2837a113-d623-4a8f-a63d-f800618b7389"], "operator": null, "metadata": {"aucs": [0.11667226380968887, 0.10651130335083248, 0.1579327287304898, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027479967502708313, 0.030714292473773774, 0.03836772938644406, 0.025070164759229407, 0.020000000000000018, 0.020000000000000018, 0.06755274343169215, 0.0563569661418134, 0.05784286164193131, 0.020000000000000018, 0.05475973534669665, 0.020000000000000018, 0.05188347105605973, 0.10160847940546658, 0.09089715808842092, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17432395934890332, 0.1125963262598133, 0.15967977981001524, 0.03238818925123088, 0.02234268657992966, 0.020000000000000018, 0.10226110387057363, 0.0863116411064907, 0.07077482106263733, 0.1547562419825852, 0.13323277534341382, 0.12739428155862498, 0.11693272981758929, 0.08159699444832602, 0.10121644966116095, 0.12461079374506767, 0.12653462692777817, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.056119765219106776, 0.195950289776739, 0.09919192519943976, 0.1066560448049938, 0.06527120746322768, 0.0812069398919596, 0.05336778299318323, 0.1683557023523521, 0.15312752236446325, 0.15475448018179316, 0.05217392932408449, 0.047748214035581826, 0.033265835076195405, 0.034830019797926326, 0.038718521232243175, 0.04645856409905458, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01737767570212867, 0.015542433227109465, 0.022700096072166165, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013551581553153946, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07250862827526017, 0.08945972615652853, 0.08117928620492298, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.054714613183673766, 0.06147825531143891, 0.061844126355062534, 0.12888817142311781, 0.1028461719243251, 0.10443062002313352, 0.06352273546123155, 0.05613315667725771, 0.053936809511723194, 0.0918970326545353, 0.08733549322064349, 0.09906697955777799, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028362432829270312, 0.03265963417150275, 0.03126139667302141, 0.027481322895686278, 0.03078654220243704, 0.024640285494433645, 0.14378042854015793, 0.14268931420413566, 0.15088222826988484, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.7944000175829375, -0.7993005901229446, -0.7865710562942163, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.7985887229220896, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.7121230240268019, -0.730791561034817, -0.7009079894649353, -0.8, -0.8, -0.8, -0.7337551828327609, -0.7319521346464846, -0.7418377698510197, -0.639135203881358, -0.6385611090162733, -0.6392831111823905, -0.7416668239714967, -0.7456935994739944, -0.7545832044649345, -0.6634152854620599, -0.6650313417161597, -0.6675720721253307, -0.8, -0.8, -0.8, -0.7778735981715663, -0.7820694074120829, -0.7786525645697264, -0.7848368892046722, -0.7810888569603376, -0.7837569115333942, -0.5795698876116275, -0.5640792492944617, -0.5808193496963836, -0.8, -0.8, -0.8]}}
{"id": "561da5da-08a7-4f5d-887f-58e526d262ca", "fitness": -0.12417977234338619, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Enhance exploitation capability by introducing a dynamic inertia weight adjustment based on variance of population scores.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            score_variance = np.var(self.pbest_scores)\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (score_variance / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n            self.c1 = max(0.1, self.c1 * (1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score)))\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 18, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12418 with standard deviation 0.25144.", "error": "", "parent_ids": ["2837a113-d623-4a8f-a63d-f800618b7389"], "operator": null, "metadata": {"aucs": [0.12086764840264752, 0.10501569261873267, 0.16239656082382847, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04354023777376037, 0.034449210435518296, 0.0302427375897365, 0.036899954198725826, 0.020000000000000018, 0.020000000000000018, 0.07152138082704862, 0.060828603261802505, 0.06273327615877866, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04603787793605807, 0.09195635161785076, 0.14132529975484442, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1733867236775546, 0.12156293139354846, 0.17897990076775416, 0.02778914797896026, 0.04944063376244545, 0.020000000000000018, 0.08738508948916635, 0.0961487618993182, 0.09724248077769615, 0.1420810510948769, 0.13323277534341382, 0.14441525704224, 0.0911873931574072, 0.07990382579724953, 0.07998425672639853, 0.12674325377043028, 0.11127499168623356, 0.13326324031639103, 0.020000000000000018, 0.020000000000000018, 0.12713350070600726, 0.16901133179204597, 0.0856080705151342, 0.0846804459403725, 0.06527120746322768, 0.08570732648788038, 0.04841955156996747, 0.1507722875143912, 0.14900766500060203, 0.16609905855797757, 0.050418885586868245, 0.03954507717374023, 0.039677520723673476, 0.04990899854293673, 0.04083223841382222, 0.05364735040246915, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018669994719942018, 0.01468085072440073, 0.019809324913178994, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03555271916951086, 0.010847845942231649, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08647377546485091, 0.0819908181318122, 0.08811832604693148, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270883108147, 0.06147825531143891, 0.05774943975208102, 0.12343792424778766, 0.110103431832561, 0.11368742459952241, 0.06769612468089914, 0.056040275433075215, 0.055938221345008365, 0.10078777373297598, 0.0946174882611196, 0.11158735171332279, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034165162074945354, 0.04866594179105055, 0.03198060126715363, 0.029080989478556307, 0.038747818487559815, 0.024640285494433645, 0.13241078662162908, 0.1343132807371029, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4898410047073676, -0.5, -0.4915044613200079, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.42781037818388823, -0.4377804926719364, -0.422998763630533, -0.5, -0.5, -0.5, -0.4417857045988458, -0.44339553444561286, -0.45103184623319637, -0.37048611171439694, -0.3599234842904926, -0.37547129362418796, -0.4561296053631141, -0.44473772191647765, -0.46255314612494436, -0.38385704147774735, -0.3799206316391446, -0.38048975270642393, -0.5, -0.5, -0.5, -0.47892337755637127, -0.4852117497368207, -0.48237555012143707, -0.48721877286630355, -0.48424426658115727, -0.48562847027740963, -0.3255091608091374, -0.3036434880944845, -0.31963427116629095, -0.5, -0.5, -0.5]}}
{"id": "827c5298-d9db-4d5b-bd2a-82d64745afba", "fitness": -0.12412179294134212, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Enhance dynamic adaptation by adjusting inertia weight more responsively relative to gbest improvement.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + 0.05)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n            self.c1 = max(0.1, self.c1 * (1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score)))\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 19, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12412 with standard deviation 0.25159.", "error": "", "parent_ids": ["2837a113-d623-4a8f-a63d-f800618b7389"], "operator": null, "metadata": {"aucs": [0.12666152541495168, 0.10817108054885549, 0.16430510684191746, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04271217731097254, 0.030123204735234332, 0.03877818180344972, 0.029975772226560227, 0.020000000000000018, 0.021487934376650752, 0.07170415613875758, 0.060951810430431075, 0.0620982148347875, 0.020000000000000018, 0.042713432476076285, 0.020000000000000018, 0.0450542191189659, 0.08594148016760361, 0.14347377790516758, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.028053801619909446, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17838628179172433, 0.125825534120951, 0.1757014726780265, 0.03559084198031026, 0.02369653216774248, 0.02363953235333993, 0.09646795712650746, 0.09262759376241514, 0.0960666158515544, 0.1422926252796789, 0.13599905564482218, 0.14407687515722645, 0.08093408258591184, 0.08865625317070791, 0.0979029344516621, 0.12732071124037703, 0.11433322791097711, 0.1966166428378705, 0.020000000000000018, 0.020000000000000018, 0.10095680331525159, 0.17289272920111243, 0.0846165412239358, 0.08465042015910251, 0.06527120746322768, 0.08545540529217788, 0.04799714693789592, 0.1438526290318487, 0.1406585649115576, 0.16440171145561777, 0.05032989843610214, 0.042040883872737966, 0.03294875711170675, 0.053553975235375306, 0.04224832654093558, 0.052083546991785856, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0186059311273854, 0.014750203945213536, 0.020407649907449588, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02447639706061211, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08074107283447529, 0.08654850882585041, 0.08568472008712047, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270883108147, 0.06147825531143891, 0.05944082173461285, 0.12259988828853974, 0.1022108165177954, 0.109862758325178, 0.07823122203528488, 0.038081257094596754, 0.053936809511723194, 0.09620527547554925, 0.0867141454092315, 0.10113112720090855, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03421288027909897, 0.04907995281088251, 0.032774402083190046, 0.02885259102292126, 0.03851580284123568, 0.024640285494433645, 0.13141309820135194, 0.13123409970527322, 0.13490608823551842, 0.010000000000000009, 0.010000000000000009, 0.010071999149309674, -0.49443299233635263, -0.5, -0.49133650249341887, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4999783275115186, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4281119956396626, -0.44178360197020794, -0.4214945295104864, -0.5, -0.5, -0.5, -0.44107063843420913, -0.44339553444561286, -0.4499017046696554, -0.3698248008389162, -0.3580219889748344, -0.37513488948459495, -0.4527217663798131, -0.44393084607007816, -0.4608497834504095, -0.37922494189487965, -0.38586399120454895, -0.39153862135037065, -0.5, -0.5, -0.5, -0.4789023265901753, -0.48522222571095797, -0.4823321536830145, -0.4874138850414176, -0.48424680246996576, -0.4857824258681547, -0.3274041460628332, -0.3036434880944845, -0.3104923277390512, -0.5, -0.5, -0.5]}}
{"id": "77adc9ab-defc-4914-b65d-2c804978c0c5", "fitness": -0.12408122434497255, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Introduce a gradual increase in the cognitive component for better exploitation late in the search process.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 20, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12408 with standard deviation 0.25145.", "error": "", "parent_ids": ["2837a113-d623-4a8f-a63d-f800618b7389"], "operator": null, "metadata": {"aucs": [0.12668916703454158, 0.1082531822850129, 0.16497898179411574, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.049747902177819325, 0.03096049041144211, 0.041684010132664207, 0.03501351293393096, 0.020000000000000018, 0.027986258822623955, 0.07159105434954294, 0.06087417032437803, 0.06247492140142019, 0.020000000000000018, 0.04324132479727738, 0.020000000000000018, 0.0450542191189659, 0.08607968519782527, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05878567709757865, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17793543732278327, 0.12537953053557482, 0.17611741810484594, 0.038367065962195857, 0.02195200175355483, 0.023838181820287185, 0.09457292980441645, 0.09224350170875395, 0.10663139988600501, 0.14182543205866271, 0.13323277534341382, 0.15126824024365415, 0.07711447140296745, 0.08320501576238482, 0.0859348138139695, 0.13627985799609865, 0.11899923032801207, 0.14418839004129258, 0.020000000000000018, 0.020000000000000018, 0.09707534529126949, 0.16909302988458097, 0.08563781214905863, 0.0846789413432435, 0.06527120746322768, 0.08570743406973802, 0.04843169389032764, 0.14601657059334994, 0.14234700938592582, 0.15799924870351134, 0.043310078795063545, 0.03736930917929626, 0.03503346783056671, 0.052901419845658104, 0.04049222038588507, 0.05181265107440358, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018634207992672458, 0.014679337857784303, 0.020077215267357174, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08182369440784532, 0.08611972693615666, 0.0860709574878572, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270883108147, 0.06147825531143891, 0.058747502990533995, 0.12146744681545729, 0.10127923516437842, 0.11097864902821375, 0.08082137090092856, 0.040778108038887484, 0.05428022588583603, 0.09191515143575746, 0.09071725025850086, 0.09886653337397167, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03415225675882505, 0.048638050500057095, 0.03197401870821637, 0.029094899011054443, 0.038768214881140795, 0.024640285494433645, 0.13437338723142733, 0.1375160694082984, 0.13498079672782182, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4940683862805124, -0.5, -0.49122841255212446, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4280151660317728, -0.4413042337739177, -0.4212457602118789, -0.5, -0.5, -0.5, -0.4419547277283058, -0.44339553444561286, -0.4522267418543451, -0.36900308571790763, -0.36167209402858846, -0.3744154374098623, -0.45147682370411624, -0.4448756630661166, -0.4642998001324228, -0.37456242232763626, -0.37703333869967715, -0.38989047326589676, -0.5, -0.5, -0.5, -0.47892570402480095, -0.4852109214349727, -0.48238082391738524, -0.4871977650941033, -0.48424433817679535, -0.48561247002416064, -0.319124990607748, -0.3036434880944845, -0.31903418236731085, -0.5, -0.5, -0.5]}}
{"id": "f987f862-d184-4fad-a87f-647787fe003d", "fitness": -0.12408040827914349, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Enhance exploration with a diversity boost by increasing the DE crossover probability slightly earlier in the search process.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / np.mean(self.pbest_scores))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Slightly increase DE crossover probability earlier to boost diversity\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 21, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12408 with standard deviation 0.25143.", "error": "", "parent_ids": ["77adc9ab-defc-4914-b65d-2c804978c0c5"], "operator": null, "metadata": {"aucs": [0.12668916703454158, 0.1082531822850129, 0.16497898179411574, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.049747902177819325, 0.03096049041144211, 0.041684010132664207, 0.03501351293393096, 0.020000000000000018, 0.027986258822623955, 0.07159105434954294, 0.06087417032437803, 0.06247492140142019, 0.020000000000000018, 0.04324132479727738, 0.020000000000000018, 0.0450542191189659, 0.08607968519782527, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05878567709757865, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17793543732278327, 0.12537953053557482, 0.17611741810484594, 0.038367065962195857, 0.02195200175355483, 0.023838181820287185, 0.09457292980441645, 0.09224350170875395, 0.10663139988600501, 0.14182543205866271, 0.13323277534341382, 0.15126824024365415, 0.07711447140296745, 0.08320501576238482, 0.0859348138139695, 0.13627985799609865, 0.11899923032801207, 0.14418839004129258, 0.020000000000000018, 0.020000000000000018, 0.09707534529126949, 0.16909302988458097, 0.08563781214905863, 0.0846789413432435, 0.06527120746322768, 0.08570743406973802, 0.04843169389032764, 0.14601657059334994, 0.14234700938592582, 0.15799924870351134, 0.043310078795063545, 0.03736930917929626, 0.03503346783056671, 0.052901419845658104, 0.04147920720589593, 0.05190333281309789, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01865837222368827, 0.014679337857784303, 0.020077215267357174, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08215208563104126, 0.08611972693615666, 0.08592501061633451, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270883108147, 0.06147825531143891, 0.058747502990533995, 0.12134032081118207, 0.10129243658032161, 0.11008501932015702, 0.08082137090092856, 0.03932457995710681, 0.0541970552033072, 0.09210438223096862, 0.08844850012127192, 0.09920400969557452, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03415225675882505, 0.04916631976352703, 0.03278618099292674, 0.029160063021742677, 0.038768214881140795, 0.024640285494433645, 0.13437338723142733, 0.1375160694082984, 0.13498079672782182, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49379168461844425, -0.49990389038365945, -0.49058753620777584, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4277359883065974, -0.4413042337739177, -0.4215199072212463, -0.5, -0.5, -0.5, -0.44161310251479646, -0.4431495511758592, -0.4522267418543451, -0.3690265318878514, -0.3614201428610593, -0.3744154374098623, -0.45147682370411624, -0.4448756630661166, -0.46414299450989027, -0.37456242232763626, -0.37727705658403976, -0.38969733361987546, -0.5, -0.5, -0.5, -0.4788983196954093, -0.48514906175542416, -0.48238082391738524, -0.48768128623652096, -0.48424433817679535, -0.48561247002416064, -0.319124990607748, -0.3034175765646865, -0.31903418236731085, -0.5, -0.5, -0.5]}}
{"id": "2b5ce2a2-885e-4fc1-9197-389e14120022", "fitness": -0.12480222090084842, "name": "EnhancedAdaptiveHybridPSODE", "description": "Introduce a dynamic inertia weight and adaptive mutation strategy to improve the balance between exploration and exploitation in PSO and DE.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Dynamic inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * (evals / self.budget)\n\n            # Adaptive DE mutation strategy\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n\n            # Slightly increase DE crossover probability earlier to boost diversity\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12480 with standard deviation 0.25132.", "error": "", "parent_ids": ["f987f862-d184-4fad-a87f-647787fe003d"], "operator": null, "metadata": {"aucs": [0.12018922684744071, 0.09120719940676902, 0.15929340920697233, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04585634408472783, 0.027596141547936992, 0.036471716064219506, 0.028802219889311642, 0.020000000000000018, 0.020000000000000018, 0.07055612488320251, 0.06145928401363521, 0.06228047733170572, 0.020000000000000018, 0.04518418178110006, 0.020000000000000018, 0.05188347105605973, 0.08594148016760361, 0.09144691046419728, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.18026073673292364, 0.12584511970813705, 0.17427933284962283, 0.035409864160730775, 0.024935930053350486, 0.023272001299716627, 0.10426443262988583, 0.0863116411064907, 0.08732000500498682, 0.14946289271887425, 0.1362047188050287, 0.12562529150492807, 0.08324188894657936, 0.08339541876858292, 0.0826207099445927, 0.18607008198533526, 0.1270784972302167, 0.13747290427761272, 0.020000000000000018, 0.020000000000000018, 0.07314732919468359, 0.1919634859555831, 0.07455817246103724, 0.08156294290726185, 0.06527120746322768, 0.0823002801433329, 0.04350723192894834, 0.15487230195805068, 0.13712089057001686, 0.15475448018179316, 0.049730699984202764, 0.04406142123328205, 0.03171149278709384, 0.05581119053690986, 0.042521848504936455, 0.05639629218018216, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01945509711532012, 0.014468330414179054, 0.021239419394877612, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013644480708324247, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08159376004536834, 0.08833099180856552, 0.08373927387433522, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06167332307055151, 0.05395939349942802, 0.12567071248609607, 0.10489395620822473, 0.1129838017376592, 0.06860221003561395, 0.055019961094378456, 0.055107619749786396, 0.10507714461190942, 0.08942464165521247, 0.1020383672708397, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04604413234493254, 0.062389694330129974, 0.034278359046096774, 0.028817800948578443, 0.029672893775353648, 0.024640285494433645, 0.13141309820135194, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4985091116368847, -0.4996520791399013, -0.48968436834077234, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.49979386076146226, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4285341967125569, -0.4447104307847001, -0.4190039002017385, -0.5, -0.5, -0.5, -0.44723678840686687, -0.44339553444561286, -0.4526104368789672, -0.3684889680590948, -0.3693476119854848, -0.37116184176249534, -0.4550622386877239, -0.44466777862285123, -0.46193591594868244, -0.3779558854319809, -0.38664400726957804, -0.38191347265916153, -0.5, -0.5, -0.5, -0.47882814256385564, -0.48528155373818604, -0.4825537191510949, -0.4885556606807404, -0.4843306752730303, -0.4851676178764506, -0.3310942570837936, -0.3036434880944845, -0.3318431490535929, -0.5, -0.5, -0.5]}}
{"id": "239e0a9f-3949-40e1-97a4-f28ed72ec8cb", "fitness": -0.12408040820489454, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Introduce adaptive learning rate adjustment by slightly modifying the way adaptation affects the DE scaling factor to enhance convergence speed.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))  # Added a small constant to denominator\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Slightly increase DE crossover probability earlier to boost diversity\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 23, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12408 with standard deviation 0.25143.", "error": "", "parent_ids": ["f987f862-d184-4fad-a87f-647787fe003d"], "operator": null, "metadata": {"aucs": [0.1266891670338921, 0.10825318228494951, 0.16497898179411574, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04974790217780278, 0.03096049041144211, 0.041684010132664207, 0.03501351293392707, 0.020000000000000018, 0.027986258822623844, 0.07159105434955193, 0.06087417032437825, 0.06247492140142219, 0.020000000000000018, 0.04324132479727738, 0.020000000000000018, 0.0450542191189659, 0.08607968519782527, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05878567709757865, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1779354373227826, 0.12537953053556994, 0.1761174181048477, 0.038367065962191305, 0.02195200175355483, 0.02383818182028652, 0.09457292980441645, 0.0922435017116553, 0.10663139988600501, 0.1418254320578507, 0.13323277534341382, 0.1512682563762059, 0.07711447140297423, 0.08320501576238482, 0.08593481381396817, 0.13627985799716014, 0.11899923032873505, 0.14418839003172168, 0.020000000000000018, 0.020000000000000018, 0.09707534529126949, 0.16909302988458097, 0.08563781214905863, 0.0846789413432435, 0.06527120746322768, 0.08570743406973802, 0.04843169389031776, 0.14601657059334994, 0.1423470093870851, 0.1579992486913543, 0.043310078795157914, 0.03736930917931969, 0.03503346782984551, 0.05290141984560093, 0.04147920720594811, 0.05190333281317483, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018658372223692377, 0.014679337857785857, 0.020077215267357063, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08215208563105636, 0.08611972693615666, 0.08592501061633695, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270882061895, 0.06147825531143891, 0.05874750299049525, 0.12134032081146717, 0.1012924365799317, 0.11008501932038639, 0.08082137090098163, 0.03932457995710148, 0.0541970552033072, 0.09210438220132033, 0.08844850011183458, 0.0992040096965695, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03415225675885125, 0.049166319763569444, 0.03278618099292585, 0.0291600630217288, 0.03876821488111504, 0.024640285494433645, 0.13437338722253056, 0.1375160694134664, 0.13498079672829932, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49379168461844425, -0.49990389038365945, -0.49058753620777584, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4277359883049727, -0.4413042337739177, -0.421519907221088, -0.5, -0.5, -0.5, -0.44161310251161323, -0.4431495511757433, -0.45222674185433664, -0.3690265319072734, -0.3614201428517412, -0.37441543741825223, -0.4514768237041198, -0.4448756630660311, -0.4641429945099993, -0.37456242235104464, -0.37727705656781274, -0.38969733362355097, -0.5, -0.5, -0.5, -0.4788983196954093, -0.4851490617554246, -0.48238082391738524, -0.4876812862365216, -0.48424433817679535, -0.4856124700241602, -0.3191249906081024, -0.3034175765648812, -0.3190341823676681, -0.5, -0.5, -0.5]}}
{"id": "dfc31e15-2b00-4306-9603-8cbd630f0aa6", "fitness": -0.12408040820489454, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Slightly refine the adaptive learning rate formula to further balance exploration and exploitation phases.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))  # Added a small constant to denominator\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Slightly increase DE crossover probability earlier to boost diversity\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 24, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12408 with standard deviation 0.25143.", "error": "", "parent_ids": ["239e0a9f-3949-40e1-97a4-f28ed72ec8cb"], "operator": null, "metadata": {"aucs": [0.1266891670338921, 0.10825318228494951, 0.16497898179411574, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04974790217780278, 0.03096049041144211, 0.041684010132664207, 0.03501351293392707, 0.020000000000000018, 0.027986258822623844, 0.07159105434955193, 0.06087417032437825, 0.06247492140142219, 0.020000000000000018, 0.04324132479727738, 0.020000000000000018, 0.0450542191189659, 0.08607968519782527, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05878567709757865, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1779354373227826, 0.12537953053556994, 0.1761174181048477, 0.038367065962191305, 0.02195200175355483, 0.02383818182028652, 0.09457292980441645, 0.0922435017116553, 0.10663139988600501, 0.1418254320578507, 0.13323277534341382, 0.1512682563762059, 0.07711447140297423, 0.08320501576238482, 0.08593481381396817, 0.13627985799716014, 0.11899923032873505, 0.14418839003172168, 0.020000000000000018, 0.020000000000000018, 0.09707534529126949, 0.16909302988458097, 0.08563781214905863, 0.0846789413432435, 0.06527120746322768, 0.08570743406973802, 0.04843169389031776, 0.14601657059334994, 0.1423470093870851, 0.1579992486913543, 0.043310078795157914, 0.03736930917931969, 0.03503346782984551, 0.05290141984560093, 0.04147920720594811, 0.05190333281317483, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018658372223692377, 0.014679337857785857, 0.020077215267357063, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08215208563105636, 0.08611972693615666, 0.08592501061633695, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270882061895, 0.06147825531143891, 0.05874750299049525, 0.12134032081146717, 0.1012924365799317, 0.11008501932038639, 0.08082137090098163, 0.03932457995710148, 0.0541970552033072, 0.09210438220132033, 0.08844850011183458, 0.0992040096965695, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03415225675885125, 0.049166319763569444, 0.03278618099292585, 0.0291600630217288, 0.03876821488111504, 0.024640285494433645, 0.13437338722253056, 0.1375160694134664, 0.13498079672829932, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49379168461844425, -0.49990389038365945, -0.49058753620777584, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4277359883049727, -0.4413042337739177, -0.421519907221088, -0.5, -0.5, -0.5, -0.44161310251161323, -0.4431495511757433, -0.45222674185433664, -0.3690265319072734, -0.3614201428517412, -0.37441543741825223, -0.4514768237041198, -0.4448756630660311, -0.4641429945099993, -0.37456242235104464, -0.37727705656781274, -0.38969733362355097, -0.5, -0.5, -0.5, -0.4788983196954093, -0.4851490617554246, -0.48238082391738524, -0.4876812862365216, -0.48424433817679535, -0.4856124700241602, -0.3191249906081024, -0.3034175765648812, -0.3190341823676681, -0.5, -0.5, -0.5]}}
{"id": "91187b1a-39ff-4d22-a6e0-919b4a25b5b9", "fitness": -0.12415667528827393, "name": "ImprovedDynamicRefinedAdaptiveHybridPSODE", "description": "Introduce a dynamic exploration-exploitation balance by modifying DE and PSO strategies based on iteration feedback to enhance convergence.", "code": "import numpy as np\n\nclass ImprovedDynamicRefinedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Adjust DE crossover probability to enhance diversity or intensification\n            if evals > self.budget * 0.3:\n                self.de_cr = max(0.5, min(1.0, self.de_cr + 0.05 * np.sign(np.random.rand() - 0.5)))\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 25, "feedback": "The algorithm ImprovedDynamicRefinedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12416 with standard deviation 0.25144.", "error": "", "parent_ids": ["239e0a9f-3949-40e1-97a4-f28ed72ec8cb"], "operator": null, "metadata": {"aucs": [0.1266891670338921, 0.10825318228494951, 0.16497898179411574, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04974790217780278, 0.03096049041144211, 0.041684010132664207, 0.03501351293392707, 0.020000000000000018, 0.027986258822623844, 0.07159105434955193, 0.06087417032437825, 0.06247492140142219, 0.020000000000000018, 0.04324132479727738, 0.020000000000000018, 0.0450542191189659, 0.08607968519782527, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05878567709757865, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1779354373227826, 0.12537953053556994, 0.1761174181048477, 0.038367065962191305, 0.02195200175355483, 0.02383818182028652, 0.09457292980441645, 0.0922435017116553, 0.10663139988600501, 0.1418254320578507, 0.13323277534341382, 0.1512682563762059, 0.07711447140297423, 0.08320501576238482, 0.08593481381396817, 0.13627985799716014, 0.11899923032873505, 0.14418839003172168, 0.020000000000000018, 0.020000000000000018, 0.09707534529126949, 0.16909302988458097, 0.08563781214905863, 0.0846789413432435, 0.06527120746322768, 0.08570743406973802, 0.04843169389031776, 0.14601657059334994, 0.1423470093870851, 0.1579992486913543, 0.043310078795157914, 0.03736930917931969, 0.03503346782984551, 0.04964817311177194, 0.040492220385891176, 0.051740821082492894, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018698210313960018, 0.014520231926969607, 0.020077215267357063, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08171350892026563, 0.08611972693615666, 0.08550092800415365, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270882061895, 0.06147825531143891, 0.05881273234689233, 0.12506782747011824, 0.10078921079161807, 0.11008501932038639, 0.08082137090098163, 0.040168416533959306, 0.0541970552033072, 0.09205615802099198, 0.08844850011183458, 0.09865476698268894, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03415225675885125, 0.048638050500102614, 0.031939788749640985, 0.028987630259526997, 0.039641721496751825, 0.024640285494433645, 0.13141309820135194, 0.1347655546850297, 0.13498079672829932, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.49675054270186303, -0.5, -0.4897628769203599, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.49866105654755377, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.42801516603177125, -0.4408402992801137, -0.42168596343213216, -0.5, -0.5, -0.5, -0.44195472772407673, -0.44339553444561286, -0.4511042550256237, -0.3684932533402796, -0.3628454108168506, -0.3754369282373684, -0.4548555339321334, -0.44466775863942676, -0.4641960822538065, -0.37456242235104464, -0.37711958262674106, -0.38872056428757196, -0.5, -0.5, -0.5, -0.47892570402480095, -0.48517870206875635, -0.4823618376141865, -0.48748347662529223, -0.48424433817679535, -0.48486389250658446, -0.3191249906081024, -0.3032705919611036, -0.3239891052860806, -0.5, -0.5, -0.5]}}
{"id": "13e58cb5-3e2d-408a-bde1-3b16a61d9282", "fitness": -0.12436840505212342, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Fine-tune the adaptive learning rate modulation to further enhance dynamic parameter adjustment.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.12   # Learning rate for adaptation (modified)\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))  # Added a small constant to denominator\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Slightly increase DE crossover probability earlier to boost diversity\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 26, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12437 with standard deviation 0.25120.", "error": "", "parent_ids": ["239e0a9f-3949-40e1-97a4-f28ed72ec8cb"], "operator": null, "metadata": {"aucs": [0.12649705149629964, 0.10824964092316125, 0.16501038079365304, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04877109375897615, 0.03098257632589252, 0.041689226911357236, 0.03463938816319967, 0.020000000000000018, 0.027971572855038485, 0.07160670049385798, 0.06087390561726602, 0.06248420658937415, 0.020000000000000018, 0.04324175643224981, 0.020000000000000018, 0.0450542191189659, 0.08613129898652527, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17794470363161707, 0.12553587420170442, 0.17603273219959614, 0.03710555849952091, 0.02195584460452482, 0.023763520889093837, 0.09521501780640251, 0.09277286149140362, 0.10655795817823077, 0.14194702736826637, 0.13323277534341382, 0.12520067682015235, 0.07809614782537522, 0.08325160853142877, 0.08586135216898372, 0.13577190829951635, 0.11612103328739665, 0.153489218481629, 0.020000000000000018, 0.020000000000000018, 0.09707314034618864, 0.16903099846163439, 0.08565352875541155, 0.08467790046241763, 0.06527120746322768, 0.08571060300716538, 0.04843319169797833, 0.14502306528406228, 0.14173292503811719, 0.1593443624705947, 0.04351043653580233, 0.037135153682035904, 0.03385296331337917, 0.0529062087113461, 0.04347011229193143, 0.05188195398063311, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018669032521947626, 0.014680445080225701, 0.02006960720330142, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08199543873747783, 0.08612193849435057, 0.08592121364389138, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06677178778629089, 0.06147825531143891, 0.05858445104298371, 0.12289141808049109, 0.10091860493186033, 0.10989321848309086, 0.07746714017543976, 0.039353068340679975, 0.053936809511723194, 0.09789181661586799, 0.08407829868306915, 0.09861171307769379, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03415387701824657, 0.049181566975721736, 0.03278180816144416, 0.02915961055636873, 0.03876593178899801, 0.024640285494433645, 0.13209817389039458, 0.13688650009886028, 0.13444883833653076, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4938032518830531, -0.49990753488910733, -0.49060509271406527, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.42766595670450935, -0.44130639071230027, -0.42148905443994233, -0.5, -0.5, -0.5, -0.4415904888986075, -0.443003902865867, -0.452113449489407, -0.3679379932686473, -0.361885766487513, -0.37488625891567295, -0.4513807761023867, -0.4441948204205479, -0.46423730001480745, -0.3773333438320854, -0.3736967490843204, -0.3875716457068725, -0.5, -0.5, -0.5, -0.47889801499418216, -0.48514941082098484, -0.4823818882554256, -0.4876780540935173, -0.48424436024049866, -0.4856092824842335, -0.32179358836547767, -0.30112344697823623, -0.32261018633453964, -0.5, -0.5, -0.5]}}
{"id": "274cc99a-67db-4959-9fd5-feb515ab2b7c", "fitness": -0.12400469060254753, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Introduce a dynamic inertia weight decay to improve convergence speed.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))  # Added a small constant to denominator\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Dynamic inertia weight decay for improved convergence\n            self.w *= 0.99\n\n            # Slightly increase DE crossover probability earlier to boost diversity\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 27, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12400 with standard deviation 0.25154.", "error": "", "parent_ids": ["239e0a9f-3949-40e1-97a4-f28ed72ec8cb"], "operator": null, "metadata": {"aucs": [0.1266911958881406, 0.10825976211920785, 0.16504093561126043, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05069996140509492, 0.03097635854794334, 0.04196679050322771, 0.03545140021006521, 0.020000000000000018, 0.02790209310099867, 0.07157983827207826, 0.060866474965747375, 0.06251266693944846, 0.020000000000000018, 0.043296428033608225, 0.020000000000000018, 0.0450542191189659, 0.08613129898652527, 0.14331081011573188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05862101632233907, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17788927717788838, 0.12533447332105396, 0.17615850561727142, 0.03756438834603837, 0.02216733951134353, 0.023852718882980684, 0.09587542626646184, 0.09088437637517499, 0.10565196284591649, 0.14250757509129042, 0.13323277534341382, 0.15380849386590245, 0.07658739940903769, 0.0824389552480227, 0.08563276830835964, 0.1341641086823756, 0.139316063041656, 0.14489214696836594, 0.020000000000000018, 0.020000000000000018, 0.09665162254619364, 0.1687480132832857, 0.08571919144517892, 0.08467262574929724, 0.06527120746322768, 0.08572665785472466, 0.04847313334076919, 0.1438526290318487, 0.13731546255806504, 0.15475448018179316, 0.0433390972463783, 0.03520597911379386, 0.0354143377913837, 0.05283412385233788, 0.04151227157712123, 0.0518824096668713, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018661159969848296, 0.014678959213667464, 0.020034823555274195, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02799426798360205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08223249969132562, 0.08607541960492493, 0.08596265226653277, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06464270882061895, 0.06147825531143891, 0.058482886299521475, 0.12138422422735817, 0.10208055116747161, 0.11038421056991288, 0.08052371853411566, 0.04017058070941526, 0.0540796082566104, 0.09285265709495105, 0.08550004051210958, 0.10335715995038053, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034136218286778375, 0.04916489692271664, 0.03276762368961239, 0.029174636949462096, 0.038791872775110536, 0.024640285494433645, 0.13514017783701915, 0.1462112652936115, 0.1337832524086161, 0.010011444614532516, 0.010000000000000009, 0.010000000000000009, -0.49367840471664914, -0.49990275245152826, -0.49060651203824013, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.42773012293428136, -0.44125244225345917, -0.42154312590344434, -0.5, -0.5, -0.5, -0.4422710775553873, -0.44304783743377607, -0.45227167451205763, -0.36904442990152897, -0.3614286957530084, -0.37434765399528214, -0.4514631986013564, -0.4450090340893771, -0.46406202635752924, -0.3781742487799995, -0.38171213048698416, -0.38785831906161294, -0.5, -0.5, -0.5, -0.47889705826827567, -0.4851505449000413, -0.48238606166772224, -0.48766017789508265, -0.48424448276023235, -0.4855965908743394, -0.320993508593969, -0.29985002390496307, -0.31692233961631633, -0.5, -0.5, -0.5]}}
{"id": "aa79f732-406d-477a-9256-8d80e237d47b", "fitness": -0.12350009005208185, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Enhance exploration by introducing an additional velocity term that scales velocity by random noise.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))  # Added a small constant to denominator\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Dynamic inertia weight decay for improved convergence\n            self.w *= 0.99\n\n            # Slightly increase DE crossover probability earlier to boost diversity\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, 0.1, self.dim)  # Introduce random noise\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 28, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12350 with standard deviation 0.25214.", "error": "", "parent_ids": ["274cc99a-67db-4959-9fd5-feb515ab2b7c"], "operator": null, "metadata": {"aucs": [0.1245553391467541, 0.162540235177969, 0.14690782645691203, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03862450771127057, 0.02614203553964889, 0.020000000000000018, 0.02199179294122755, 0.036884032187939675, 0.020000000000000018, 0.07475534575775844, 0.062301816338209304, 0.05120227017312784, 0.020000000000000018, 0.04281087553622853, 0.020000000000000018, 0.07139623909771042, 0.13971598506764904, 0.09580511640498413, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03515621375910716, 0.020000000000000018, 0.022680229335481417, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14415339311292075, 0.14100092699966704, 0.16564423008418405, 0.0424197344105256, 0.030975273509747825, 0.03973186366257919, 0.08072694858327945, 0.14062307433047294, 0.09446964110222411, 0.1341938323511337, 0.13610971640273528, 0.13213327570460265, 0.08446526613407601, 0.09026631478243274, 0.0740036478765832, 0.13018182102914166, 0.13145575248275032, 0.13878644226488424, 0.020000000000000018, 0.12256013666181298, 0.12394311295954252, 0.11976456704789984, 0.08386974506804479, 0.11037974421823349, 0.06527120746322768, 0.07520608115700977, 0.060144431163012935, 0.1522061182384118, 0.1505960489980902, 0.15475448018179316, 0.05014385349142936, 0.03720637607951938, 0.03339388215724337, 0.06037171775211325, 0.041649425772108395, 0.06406550727532045, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0326902655788075, 0.01672251175012429, 0.013836513897537706, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016766790445328805, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09093371049869847, 0.07365258477627179, 0.08682124946730507, 0.010000000000000009, 0.014326557834610898, 0.010000000000000009, 0.07326771301832158, 0.06158457970444231, 0.05469320440257486, 0.12722137048584203, 0.1065650112457115, 0.11187441996323555, 0.0629730860997253, 0.044110484577101206, 0.05764572893204023, 0.0977796627537647, 0.09204109778870173, 0.10390524939572576, 0.010696943336975129, 0.010000000000000009, 0.010000000000000009, 0.03293933409193839, 0.0440374264730411, 0.048911745107008464, 0.027059639702553206, 0.029275655100592934, 0.02971897944671309, 0.13253099036296878, 0.1324729168685056, 0.13798609462075417, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4933732916736895, -0.4993948172328464, -0.4936840433679992, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4329240586916625, -0.4402746308437755, -0.4359336579279076, -0.5, -0.5, -0.5, -0.44102961364181237, -0.43559556065362215, -0.44291097317377814, -0.36131252045843043, -0.36708332754453266, -0.364840399193721, -0.45538085970666353, -0.4515216900296142, -0.458123681472977, -0.3823071766835806, -0.38951035881840457, -0.38800548360798226, -0.5, -0.5, -0.5, -0.4800787265404489, -0.48560770549835497, -0.4844971253073902, -0.4867124490096211, -0.48419619345149445, -0.4834155860776659, -0.32795519512427185, -0.3036434880944845, -0.3320858062906, -0.5, -0.5, -0.5]}}
{"id": "588788f8-2e44-477d-9197-6bf1d17a796b", "fitness": -0.12349211399311406, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Enhance convergence by refining inertia weight decay and increasing perturbation noise.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))  # Added a small constant to denominator\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Dynamic inertia weight decay for improved convergence\n            self.w *= 0.98  # Adjusted from 0.99 to 0.98\n\n            # Slightly increase DE crossover probability earlier to boost diversity\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, 0.2, self.dim)  # Increased random noise from 0.1 to 0.2\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 29, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12349 with standard deviation 0.25191.", "error": "", "parent_ids": ["aa79f732-406d-477a-9256-8d80e237d47b"], "operator": null, "metadata": {"aucs": [0.12394139218444677, 0.1618900478444002, 0.14683560962493591, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.032275875167174894, 0.026728791426008036, 0.020000000000000018, 0.027956195758980895, 0.03414086839312591, 0.020000000000000018, 0.07601300144854362, 0.06266232688845863, 0.051445170276217644, 0.020000000000000018, 0.04271148837885397, 0.020000000000000018, 0.07150175561125482, 0.13914359214961902, 0.09477849171565178, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02978401877929504, 0.020000000000000018, 0.022363333177142453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03423672929634425, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14442097604894566, 0.1408652480188346, 0.1644039668299493, 0.042495018090752956, 0.031110659823712528, 0.03946023652834085, 0.08072694858327945, 0.14062307433047294, 0.08103827731483548, 0.13686329072103864, 0.13323277534341382, 0.11994912790617729, 0.09164344014590464, 0.08706248403239714, 0.07439563604661004, 0.1435887822303118, 0.13145575248275032, 0.1234602918547989, 0.020000000000000018, 0.1211195563476728, 0.12270400273823212, 0.12002546655856738, 0.08242701871460711, 0.10907304875993984, 0.06527120746322768, 0.07522143678465709, 0.06161333278874759, 0.1454398234312072, 0.15212672908366442, 0.15475448018179316, 0.044960175885007114, 0.03717397729279781, 0.037097564559087415, 0.06078259614233483, 0.04171672504531054, 0.06520547750577177, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03274374418270909, 0.01682768849032812, 0.013831891628194315, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010767753219946052, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09091382816426319, 0.07371144181412115, 0.08647316276816797, 0.010000000000000009, 0.015814731645928837, 0.010000000000000009, 0.0747708379402543, 0.06147825531143891, 0.056925622553184896, 0.12313991490095011, 0.10393179326997015, 0.11102226193819531, 0.07039594455081388, 0.04478333356530373, 0.059330081304639126, 0.10010391788826878, 0.08869214657857538, 0.10491394438544821, 0.010107716646756137, 0.010000000000000009, 0.010000000000000009, 0.03347964203229159, 0.04376666369553306, 0.05256534223485532, 0.02709712070958359, 0.028779740813569155, 0.02948350614599715, 0.13141309820135194, 0.1362288269753198, 0.13440570269631014, 0.010000000000000009, 0.010000000000000009, 0.010850346674657896, -0.4939299639777395, -0.499306618289838, -0.49370270402961003, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.43291330589111743, -0.44049077579032403, -0.4352582248306347, -0.5, -0.5, -0.5, -0.44580279582233606, -0.435963701945826, -0.44122502118349494, -0.36304264138604925, -0.3671013924145736, -0.3661310053398621, -0.4507494775852763, -0.44953923844312915, -0.45689717563965293, -0.39189821724832097, -0.3949672986582824, -0.3845969498382542, -0.5, -0.5, -0.5, -0.48009673595011404, -0.4855992696739455, -0.4844294266934106, -0.4866565526871909, -0.4841587809498977, -0.48338626993976797, -0.3000235313078119, -0.3036434880944845, -0.3234533555642256, -0.5, -0.5, -0.5]}}
{"id": "bdab50c7-609b-449e-9281-fbc226d21ba2", "fitness": -0.12368870950729624, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Improving the adaptive strategy by further optimizing parameter adjustments for enhanced convergence.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1  # Rate at which parameters are adapted\n        adapt_lr = 0.1    # Learning rate for adaptation\n        exploration_phase = True  # Start with exploration\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically using a learning rate\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.c2 = min(2.0, self.c2 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8)))  # Modified c2 adaptation\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))  # Added a small constant to denominator\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Dynamic inertia weight decay for improved convergence\n            self.w *= 0.98  # Adjusted from 0.99 to 0.98\n\n            # Slightly increase DE crossover probability earlier to boost diversity\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic swarm resizing and mutation strategy\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)  # Reduce population size\n                adapt_lr += 0.05  # Increase learning rate for adaptation\n\n            for i in range(self.population_size):\n                # PSO update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, 0.2, self.dim)  # Increased random noise from 0.1 to 0.2\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # DE update with adaptive mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 30, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12369 with standard deviation 0.25178.", "error": "", "parent_ids": ["588788f8-2e44-477d-9197-6bf1d17a796b"], "operator": null, "metadata": {"aucs": [0.1239381935607543, 0.14666958421570886, 0.1472130676147284, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03362335058111965, 0.027502762271593206, 0.020000000000000018, 0.02577631779956069, 0.03878535086869506, 0.020000000000000018, 0.07606996998454407, 0.06267008836322019, 0.05147915807808179, 0.020000000000000018, 0.042769628907153856, 0.020000000000000018, 0.07150175561125482, 0.13915081585673672, 0.09478405628337616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030586520163997433, 0.020000000000000018, 0.022621822853360674, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14392480231281635, 0.14112467517638294, 0.164990631398496, 0.04340289726176172, 0.03131409237076199, 0.040449093630775534, 0.08072694858327945, 0.14062307433047294, 0.07942616853037476, 0.13753130096132482, 0.13424367825793082, 0.12508134209663058, 0.08798479343085053, 0.09285308075607757, 0.072485189593958, 0.1329477263113168, 0.13918319829613612, 0.1322007193589695, 0.020000000000000018, 0.12089205051261576, 0.1205948708705461, 0.12001862244501382, 0.08243657401665982, 0.10908463488140085, 0.06527120746322768, 0.07554321312202827, 0.06149632085632528, 0.1454398234312072, 0.13589170657517036, 0.15475448018179316, 0.05194189212769029, 0.036236417436300905, 0.03793225011610002, 0.060127001322713536, 0.041605391789575785, 0.0651863635744554, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03274765436252314, 0.01687143001247393, 0.013840243547895148, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010765497160254545, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09095461933645399, 0.07369600562810197, 0.08671411975794496, 0.010000000000000009, 0.014377751672320471, 0.010000000000000009, 0.07494106107441656, 0.06147825531143891, 0.05790706520874134, 0.11941764596134552, 0.1045675778607168, 0.110164334857346, 0.06793364536463065, 0.04527516869710757, 0.058215041495262576, 0.09914739588842958, 0.08470728926745463, 0.10037486226397407, 0.010092853837966542, 0.010000000000000009, 0.010000000000000009, 0.03346595296898425, 0.043770664076244414, 0.0525682099394692, 0.02709385840168832, 0.02875223282728856, 0.029473324694451408, 0.13497393775110778, 0.13397140229506732, 0.1367938639996712, 0.010000000000000009, 0.010000000000000009, 0.010038126164359062, -0.49395849876557096, -0.49936334030204765, -0.4937940171356445, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.43316888899061734, -0.44057690021528884, -0.4353851450691517, -0.5, -0.5, -0.5, -0.4451558911058717, -0.43520550141343217, -0.44160004762960514, -0.36757742877908783, -0.370158473046307, -0.36989759738995276, -0.45168611453221597, -0.45062791272426295, -0.45664314557533126, -0.38012121230910023, -0.3976747266429248, -0.3851498909289319, -0.5, -0.5, -0.5, -0.4800969014846217, -0.48559948088870986, -0.4844295813161805, -0.4866556835368083, -0.4841587809498977, -0.4833864015040976, -0.30295764062311314, -0.3036434880944845, -0.32326833070288896, -0.5, -0.5, -0.5]}}
{"id": "1b0dd243-d44a-4517-ad46-8151124bcc3b", "fitness": -0.12337254782616916, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Introduce adaptive cooling and perturbation strategy to enhance convergence and maintain diversity in search space.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.1\n        cooling_factor = 0.995  # New cooling factor for adaptive cooling\n        perturbation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Adaptive perturbation strategy\n            perturbation_strength = max(0.05, perturbation_strength * cooling_factor)\n\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, perturbation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 31, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12337 with standard deviation 0.25209.", "error": "", "parent_ids": ["588788f8-2e44-477d-9197-6bf1d17a796b"], "operator": null, "metadata": {"aucs": [0.12388570240279673, 0.16243954666920757, 0.14681505025233765, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03212855899038203, 0.026830760672077902, 0.02008104535448485, 0.027980571679089628, 0.03394500035746717, 0.020000000000000018, 0.0760616922383146, 0.06271667131230918, 0.05148001409124592, 0.020000000000000018, 0.04269750364158287, 0.020000000000000018, 0.07150175561125482, 0.13914359214961902, 0.09615092454897645, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029615595099031666, 0.020000000000000018, 0.02208553907142463, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.025842486397066877, 0.02605336723786167, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1444991088262202, 0.1408159482964325, 0.16437513201813092, 0.04245056960147087, 0.03107510767479771, 0.03942750569431874, 0.08072694858327945, 0.14062307433047294, 0.08188643223731984, 0.1364290779608277, 0.13371213278618088, 0.11984724251118295, 0.08992608840028737, 0.08553432655415749, 0.07235335276170818, 0.15862829720067817, 0.13482997494437654, 0.14451296638519262, 0.020000000000000018, 0.12101645709398101, 0.12314531542699314, 0.1201302613314017, 0.08267456335483503, 0.1092867992347919, 0.06527120746322768, 0.07484790449277368, 0.06159296979953088, 0.1454398234312072, 0.15093952374897301, 0.15475448018179316, 0.047728250345944856, 0.03574182234011658, 0.03787200570956428, 0.06070909068716546, 0.04167500501213828, 0.06529083345748421, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03273683574804098, 0.016809933695437373, 0.01388298442563296, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010765497160254545, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09090705091895812, 0.07373363775337638, 0.0864337905051511, 0.010000000000000009, 0.015995638126457212, 0.010000000000000009, 0.07433843681390828, 0.06147825531143891, 0.056680385369475395, 0.12517207832180288, 0.10349147082052024, 0.1104200628027816, 0.07051240109518075, 0.044848557951049806, 0.058577633065914236, 0.09709491758095123, 0.08378985332644373, 0.11220447329796757, 0.010039715040696673, 0.010000000000000009, 0.010000000000000009, 0.0336093095316089, 0.0437596978487349, 0.05236234016884367, 0.027106278327300726, 0.028779310516044765, 0.029546791858801824, 0.13151352980934883, 0.13162623274499707, 0.13648682571669357, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4939350994307705, -0.4993091506880498, -0.49355613541134313, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.4329229724836059, -0.4405107844316771, -0.43526592170966816, -0.5, -0.5, -0.5, -0.4444660589145746, -0.4359385338863979, -0.4404842643914402, -0.36317559433802393, -0.36710562158328686, -0.36648921938255197, -0.45058259165508896, -0.44978453311253297, -0.4582438334876662, -0.3814634413424891, -0.4012014904426804, -0.38416561023161666, -0.5, -0.5, -0.5, -0.4800966049876414, -0.4855971036120186, -0.4844195113163865, -0.4866623263923693, -0.48415759751542975, -0.4833840162131713, -0.3072915157131706, -0.3036434880944845, -0.3265462129937091, -0.5, -0.5, -0.5]}}
{"id": "3de942fe-295a-4ab4-aa4a-684f0f1cd98c", "fitness": -0.1235694174978926, "name": "RefinedEnhancedMultiPhaseHybridPSODE", "description": "Introduce multi-phase adaptive inertia and differential mutation control to enhance global exploration and local exploitation balance. ", "code": "import numpy as np\n\nclass RefinedEnhancedMultiPhaseHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.6  # cognitive component\n        self.c2 = 1.4  # social component\n        self.w = 0.7  # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.2\n        adapt_lr = 0.1\n        cooling_factor = 0.995\n        perturbation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Multi-phase adaptive strategies\n            inertia_weight_phase = (1 - evals / self.budget) if evals < self.budget * 0.5 else evals / self.budget\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * inertia_weight_phase))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            perturbation_strength = max(0.05, perturbation_strength * cooling_factor)\n\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, perturbation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 32, "feedback": "The algorithm RefinedEnhancedMultiPhaseHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12357 with standard deviation 0.25196.", "error": "", "parent_ids": ["1b0dd243-d44a-4517-ad46-8151124bcc3b"], "operator": null, "metadata": {"aucs": [0.12330673919526136, 0.14981490043208812, 0.14184992666091656, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026097468773216392, 0.02268464099145273, 0.020000000000000018, 0.020000000000000018, 0.031541927928176006, 0.020000000000000018, 0.07618869505366777, 0.06405924958904086, 0.05142896543708675, 0.020000000000000018, 0.044926037002831376, 0.020000000000000018, 0.06953802640550766, 0.08848906714244098, 0.09270241051114969, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.049591900657764865, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14914985610074705, 0.1368703220538765, 0.16510301735647315, 0.04386578812097153, 0.027491245139596332, 0.03769346086985148, 0.09572285430257044, 0.14473015916219012, 0.08746378452899872, 0.1418070932426181, 0.142038846085774, 0.1160417955509998, 0.07711560021850827, 0.08741725370731923, 0.0753586026046329, 0.1367055874746924, 0.11990122950633653, 0.12929245300851389, 0.020000000000000018, 0.12327734992180428, 0.11854613933369729, 0.12305597947144675, 0.08325011981781882, 0.11094312646483273, 0.06527120746322768, 0.07270132159795528, 0.06216111118858492, 0.1721741362044087, 0.14144518313508125, 0.18760074096294754, 0.0653767841400833, 0.03341707084135015, 0.035984094974680025, 0.06237877280693782, 0.04107872532322521, 0.06761162006299015, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03212262395563992, 0.01464625957558241, 0.01452497180847867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010642801922469136, 0.012140467994594117, 0.010080557125462186, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09016243669738566, 0.07400388338077224, 0.083207540636283, 0.010000000000000009, 0.012059310986486937, 0.010000000000000009, 0.06932295001051003, 0.06597681658015642, 0.06494592489495143, 0.12991144466232907, 0.10208485387224475, 0.10281775224528589, 0.06379575469334653, 0.04843019119171177, 0.055557783461697596, 0.09598645719759002, 0.09281538116743127, 0.1022588951422948, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04127442831597994, 0.04589838446324268, 0.03703928395624534, 0.0336315614165934, 0.0323664961264033, 0.043234817925187574, 0.13141309820135194, 0.13225787622100782, 0.1353980030850317, 0.010000000000000009, 0.010439207367429648, 0.010225256990546105, -0.4942758144053301, -0.4970484674629798, -0.49485699160524743, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.43146985839189034, -0.44029143206073873, -0.4329910449110168, -0.5, -0.5, -0.5, -0.4482181425102283, -0.4326450854403643, -0.44082256815580356, -0.3674471386768854, -0.36384237213596404, -0.372699497909893, -0.45212645577090593, -0.45655803077889123, -0.45877706284543907, -0.3862366409806084, -0.3943497245209411, -0.3843125354787529, -0.5, -0.5, -0.5, -0.47999656795796963, -0.4851239848714539, -0.4840477894536135, -0.4874639605840585, -0.48344385886611896, -0.48323013330041054, -0.31716111904116584, -0.3036434880944845, -0.31085027513171815, -0.5, -0.5, -0.5]}}
{"id": "b5cdc9b9-f284-4e4c-81ea-debf13e903d4", "fitness": -0.2213630229140575, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Enhance exploration and balance diversity with refined adaptive perturbation and dynamic inertia weight strategies.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.1\n        cooling_factor = 0.995  # New cooling factor for adaptive cooling\n        perturbation_strength = 0.2\n        exploration_phase = True\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Adaptive perturbation strategy\n            perturbation_strength = max(0.05, perturbation_strength * cooling_factor)\n\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = 2 * max(5, self.population_size // 2)  # Adjusted line\n                adapt_lr += 0.05\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, perturbation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 33, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.22136 with standard deviation 0.38948.", "error": "", "parent_ids": ["1b0dd243-d44a-4517-ad46-8151124bcc3b"], "operator": null, "metadata": {"aucs": [0.12388570240279673, 0.16243954666920757, 0.14681505025233765, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03212855899038203, 0.026830760672077902, 0.02008104535448485, 0.027980571679089628, 0.03394500035746717, 0.020000000000000018, 0.0760616922383146, 0.06271667131230918, 0.05148001409124592, 0.020000000000000018, 0.04269750364158287, 0.020000000000000018, 0.07150175561125482, 0.13914359214961902, 0.09615092454897645, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029615595099031666, 0.020000000000000018, 0.02208553907142463, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.025842486397066877, 0.02605336723786167, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1444991088262202, 0.1408159482964325, 0.16437513201813092, 0.04245056960147087, 0.03107510767479771, 0.03942750569431874, 0.08072694858327945, 0.14062307433047294, 0.08188643223731984, 0.1364290779608277, 0.13371213278618088, 0.11984724251118295, 0.08992608840028737, 0.08553432655415749, 0.07235335276170818, 0.15862829720067817, 0.13482997494437654, 0.14451296638519262, 0.020000000000000018, 0.12101645709398101, 0.12314531542699314, 0.1201302613314017, 0.08267456335483503, 0.1092867992347919, 0.06527120746322768, 0.07484790449277368, 0.06159296979953088, 0.1454398234312072, 0.15093952374897301, 0.15475448018179316, 0.047728250345944856, 0.03574182234011658, 0.03787200570956428, 0.05980334331645376, 0.042190146879732326, 0.06312676142903895, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.032534163187020515, 0.01599002625314694, 0.012257102388451568, 0.010000000000000009, 0.010000000000000009, 0.011910132005005236, 0.012200976175913647, 0.010751333277271402, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08992280973784605, 0.07453155026448233, 0.0862721353470508, 0.010000000000000009, 0.015995638126457212, 0.010000000000000009, 0.07433843681390828, 0.06147825531143891, 0.056680385369475395, 0.12517207832180288, 0.10250848982651273, 0.11176685431767652, 0.07051240109518075, 0.0433083438580496, 0.05925632489042376, 0.09737196373868118, 0.08351319194506612, 0.11187510216735974, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0336093095316089, 0.043511920957185146, 0.04935487853451859, 0.02721520243168707, 0.03221227770637913, 0.027547118690420258, 0.13141309820135194, 0.13132838645248257, 0.1360261951067563, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.7899312625421613, -0.8, -0.7861960927470284, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.712986251382498, -0.725263355378847, -0.7203913072964929, -0.8, -0.8, -0.8, -0.7318306068083524, -0.7214623888530616, -0.7268003762166892, -0.6331723479656728, -0.6373945261531611, -0.6376751553523743, -0.7387318044116802, -0.7377892129663584, -0.7476538184206567, -0.6625893665314881, -0.6749878880993294, -0.6564702782438627, -0.8, -0.8, -0.8, -0.7760361811915546, -0.7824167055298603, -0.781314620284717, -0.7824441446164905, -0.7807907066053741, -0.7794120451906315, -0.5656747212913178, -0.5640792492944617, -0.5879549182168389, -0.8, -0.8, -0.8]}}
{"id": "af31f793-690c-4b72-a711-6ec87b32620e", "fitness": -0.15715228346346344, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Enhance perturbation and exploration balance by modifying initial population size and crossover rate.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 + dim  # Modified initial population size\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.95  # Modified DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.1\n        cooling_factor = 0.995  # New cooling factor for adaptive cooling\n        perturbation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Adaptive perturbation strategy\n            perturbation_strength = max(0.05, perturbation_strength * cooling_factor)\n\n            if exploration_phase and evals > self.budget * 0.3:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, perturbation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 34, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.15715 with standard deviation 0.29618.", "error": "", "parent_ids": ["1b0dd243-d44a-4517-ad46-8151124bcc3b"], "operator": null, "metadata": {"aucs": [0.12111174959000892, 0.10616519906271638, 0.15325943825981814, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02320328530559801, 0.03571041537268238, 0.031142769693037975, 0.020000000000000018, 0.020000000000000018, 0.02544583332612571, 0.06730994914322141, 0.053106911983536564, 0.05445410381052884, 0.020000000000000018, 0.058643706169106524, 0.020000000000000018, 0.0651718027081779, 0.09960588750525201, 0.11422657680720039, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034639217269452294, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022812161336393744, 0.020000000000000018, 0.020000000000000018, 0.14090229158076228, 0.11949766181481392, 0.14843536172902727, 0.028648493530466057, 0.028918801568345698, 0.04218350140808824, 0.08154783044297598, 0.08955190313673311, 0.08334929926884316, 0.14252797538127138, 0.14585834889641236, 0.13117250036974948, 0.08687737996066547, 0.09523292595334265, 0.08009345882728236, 0.1308773408874151, 0.13241123834402213, 0.12636200473916748, 0.020000000000000018, 0.020000000000000018, 0.11751306636312975, 0.124177267058037, 0.0938659987223125, 0.09262088889015796, 0.07006136421569664, 0.0782652023613819, 0.06582099924658624, 0.1438526290318487, 0.15306801123254143, 0.15475448018179316, 0.04365885341361264, 0.040655180023752235, 0.04112046145873871, 0.04783153007221197, 0.04591784024667245, 0.06380292742480509, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0194403290326558, 0.028034627821958757, 0.015277129810872925, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.023298625419115204, 0.010000000000000009, 0.0104021808056034, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09775680615923643, 0.07295264825093095, 0.08502458985374428, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06537442426008189, 0.058819786766593385, 0.12871870349066317, 0.10533190777866741, 0.10691720961886575, 0.06829186000319898, 0.045210565313934414, 0.0559375374085892, 0.10290376179197847, 0.08357965671941348, 0.10690217339569219, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04417069861237677, 0.036336781615323166, 0.0314301496971926, 0.02646757310299519, 0.03103679970156281, 0.029195068881166297, 0.14422414956594098, 0.13207066290425018, 0.14176175866224783, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.5730369348628697, -0.5953841887710973, -0.5868697947756625, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.5985800466988911, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.5254989665577723, -0.5192305306634339, -0.5153340117619383, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.5483674308831348, -0.5391224374553929, -0.5348922383398846, -0.45108563881663777, -0.4506121363233455, -0.4669499535682897, -0.5492748607047953, -0.5429827365119215, -0.5664966036076666, -0.4560155211719936, -0.47293798745337345, -0.47998303494404304, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.5823455751154747, -0.5809802872657281, -0.5798958958612952, -0.583615967259743, -0.582177308392408, -0.5825151721051074, -0.4132595704079034, -0.3904554084944769, -0.40590513407422235, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001]}}
{"id": "d6589d04-fef5-4ed0-9c9a-a9546b5848ab", "fitness": -0.22176520627555316, "name": "EnhancedDynamicAdaptiveHybridPSODE", "description": "Introduce multi-phase dynamic adaptation of exploration-exploitation trade-off to further enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1, self.c2 = 1.5, 1.5\n        self.w = 0.7  \n        self.de_f, self.de_cr = 0.5, 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.1\n        cooling_factor = 0.995\n        perturbation_strength = 0.2\n        phase_switch = [0.25, 0.5, 0.75]  # Multi-phase points\n        current_phase = 0\n        phase_weight_decay = [0.9, 0.6, 0.3]  # Different decay rates for each phase\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adapt parameters\n            phase_progress = evals / self.budget\n            if current_phase < len(phase_switch) and phase_progress > phase_switch[current_phase]:\n                current_phase += 1\n\n            self.w *= phase_weight_decay[current_phase]\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            perturbation_strength *= cooling_factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, perturbation_strength, self.dim)\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social + noise\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedDynamicAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.22177 with standard deviation 0.38934.", "error": "", "parent_ids": ["1b0dd243-d44a-4517-ad46-8151124bcc3b"], "operator": null, "metadata": {"aucs": [0.12153333910008579, 0.1749749967359111, 0.13583211687209196, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020981428679676006, 0.030210442665944415, 0.020000000000000018, 0.026425030454043874, 0.027046069863431277, 0.020000000000000018, 0.07943819456066481, 0.06442441811644217, 0.052581876116848614, 0.020000000000000018, 0.04213629709817568, 0.020000000000000018, 0.06973112380640445, 0.08594148016760361, 0.09270040376324884, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14611949257287193, 0.13968422449502815, 0.161586118361987, 0.04190844596255572, 0.020000000000000018, 0.03652352686110316, 0.08072694858327945, 0.14062307433047294, 0.08706418073417677, 0.1408822795348208, 0.13883514601933045, 0.11841827790609605, 0.07517997509065955, 0.07990382579724953, 0.06337518786686969, 0.13146757272387732, 0.13145575248275032, 0.141459782143171, 0.020000000000000018, 0.123259760016592, 0.12327692560656256, 0.12224917222733533, 0.08468989019859474, 0.11029408489826753, 0.06527120746322768, 0.07862603345423946, 0.06362713368393091, 0.1454398234312072, 0.1657876886144024, 0.15475448018179316, 0.07555627005521925, 0.03388791590399609, 0.03713730603366405, 0.058749777226831945, 0.0422728118620771, 0.06703417210038798, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.032384935169296636, 0.0161647580483526, 0.012690920753056556, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010045643005659133, 0.010626365543064509, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01902563629842502, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08960716279094005, 0.07509146818965173, 0.08506399933217412, 0.010000000000000009, 0.014310518843848707, 0.010000000000000009, 0.07713093940207405, 0.06147825531143891, 0.05475629904010215, 0.1271924537309076, 0.09710428340269961, 0.1079049005843079, 0.07614616381008688, 0.041795460670536966, 0.056994240311174726, 0.09779211182100345, 0.08655232190311113, 0.12818152820155404, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.036394429493176395, 0.04851137952587892, 0.04084486619152339, 0.027621049053701885, 0.029741451308875066, 0.029570160128632783, 0.13794326907183097, 0.13407259422936546, 0.14320818147861603, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.7870834052287952, -0.7987281300745217, -0.7901782109757622, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.7095967039764557, -0.7236756465010168, -0.7164573132921117, -0.8, -0.8, -0.8, -0.7389501638355838, -0.7311421213716971, -0.7221411604923629, -0.6337089198907933, -0.6386228876834388, -0.6359711852963705, -0.7363707870155867, -0.7490617412333795, -0.7490316831656814, -0.6625979422389514, -0.6665763323787399, -0.6556022629566107, -0.8, -0.8, -0.8, -0.775234659923822, -0.7825306197340112, -0.7795092532429475, -0.7817581901463433, -0.7805132784769564, -0.7786376496146254, -0.5944814406562182, -0.5577938898559509, -0.5823622053310193, -0.8, -0.8, -0.8]}}
{"id": "e83f8689-bcb2-43e9-953a-afdcc747f135", "fitness": -0.09949328436615128, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Introduce multi-phase adaptive learning with dynamic mutation and elite retention to enhance convergence and exploration balance.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.1\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = max(0.05, mutation_strength * cooling_factor)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 36, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09949 with standard deviation 0.21793.", "error": "", "parent_ids": ["1b0dd243-d44a-4517-ad46-8151124bcc3b"], "operator": null, "metadata": {"aucs": [0.13623165031835816, 0.1335220873622086, 0.1571502395780029, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.025995407367571444, 0.020000000000000018, 0.020000000000000018, 0.03394500035746717, 0.020000000000000018, 0.08310184354688044, 0.05558167317596341, 0.05195654992790566, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07150175561125482, 0.08786987952918535, 0.09297506874290573, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02208553907142463, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13983183120976184, 0.17082168987156532, 0.16437513201813092, 0.021939407748138295, 0.03107510767479771, 0.03942750569431874, 0.08072694858327945, 0.14062307433047294, 0.07945022132257062, 0.13582836972499734, 0.14356105607866876, 0.12262897303291032, 0.08112615395450495, 0.07990382579724953, 0.07537161004848625, 0.15242382409223698, 0.1274979098306901, 0.12191976134240401, 0.10483712355311836, 0.04390317191385895, 0.12314531542699314, 0.10819636878037442, 0.09816424822535774, 0.0843503944225017, 0.15243706978102833, 0.09295934478433343, 0.05105201761947342, 0.1454398234312072, 0.14531943464335806, 0.15475448018179316, 0.05081985620257545, 0.03725316315101823, 0.03787200570956428, 0.06238714561863712, 0.03243577987458646, 0.050248370577381074, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.022347062938727236, 0.01273371397690537, 0.012687196247651245, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02345421911902179, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08715236584988195, 0.06991814275079533, 0.08790657740062935, 0.010000000000000009, 0.015995638126457212, 0.010000000000000009, 0.07433843681390828, 0.06323169721937572, 0.05395939349942802, 0.12341500560517615, 0.10415013277516172, 0.105349137676785, 0.06911899232001051, 0.04692978782213142, 0.05894062887897267, 0.0918836743634881, 0.0857484595279897, 0.11942261771260121, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.035514467154916796, 0.04200020861123366, 0.037144716751908224, 0.031051214122601034, 0.03050500500830633, 0.03860406358965751, 0.13141309820135194, 0.13123409970527322, 0.13481049833479508, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.42303052994876644, -0.42533332176837013, -0.4396550882454415, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.36861421233984903, -0.37377326478580875, -0.3603436784962226, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3495500611530289, -0.3404434635008504, -0.3526728607741987, -0.316141990804675, -0.31096814283955077, -0.2970971545800938, -0.34558401149809037, -0.3761419676100801, -0.3613454897680617, -0.2919781174085032, -0.3279030515759609, -0.3268255625954899, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.4012720506258438, -0.4070022852997053, -0.4019731890717464, -0.426871057001035, -0.40540550285654553, -0.3865070042799408, -0.2611103306005327, -0.23419395177449043, -0.25579654483241443, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995]}}
{"id": "219879a8-42d4-40d4-a73e-9f704526f71c", "fitness": -0.09949079635035155, "name": "RefinedEnhancedAdaptiveHybridPSODE", "description": "Introduce dynamic reduction of mutation strength during the cooling phase to enhance fine-tuning in the optimization process.", "code": "import numpy as np\n\nclass RefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.1\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = max(0.05, mutation_strength * cooling_factor * 0.98)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 37, "feedback": "The algorithm RefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09949 with standard deviation 0.21792.", "error": "", "parent_ids": ["e83f8689-bcb2-43e9-953a-afdcc747f135"], "operator": null, "metadata": {"aucs": [0.13627355913227035, 0.13353021786889652, 0.15717077830453552, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02599017649576385, 0.020000000000000018, 0.020000000000000018, 0.034060168503584176, 0.020000000000000018, 0.08306067251170901, 0.05556123580288186, 0.051975898141575216, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07150175561125482, 0.08786987952918535, 0.09297506874290573, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02210843549526631, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13983416594522624, 0.1707086776993466, 0.1644276786701312, 0.021952769402347916, 0.03107119993669183, 0.03945393896966298, 0.08072694858327945, 0.14062307433047294, 0.08006361799838768, 0.13565032799018495, 0.14344005716572017, 0.1252193818563363, 0.08027936136072777, 0.07990382579724953, 0.0760471104452195, 0.1315366220101356, 0.1470748869129911, 0.12489238759210253, 0.1048380555695636, 0.04458407168933154, 0.12325466842233168, 0.10819636878037442, 0.09812945328248102, 0.08431918360524293, 0.15214789527486305, 0.09298056057261084, 0.05102031511260574, 0.1454398234312072, 0.14374473312581626, 0.15688007180881525, 0.05023012343056632, 0.035971054461383045, 0.03846562195397074, 0.06234555483389426, 0.03247369080467055, 0.05024783812135203, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0223535312019848, 0.012727463516982729, 0.012700833209159712, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02345421911902179, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08716149014822439, 0.06994760158444324, 0.08793744188336095, 0.010000000000000009, 0.01598570180271608, 0.010000000000000009, 0.07473622747791298, 0.06331075927982344, 0.05429751039953257, 0.12382416937910368, 0.10303511431302581, 0.105349137676785, 0.06901524547144677, 0.050509109215059134, 0.058943931318663045, 0.08991820123330607, 0.08223561085141551, 0.11125612547096642, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.035508597258685604, 0.041989553439048755, 0.03714523846217588, 0.031104755418431607, 0.03051548692013395, 0.03868191825840184, 0.13408105065538778, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4229884306467091, -0.42532178147680955, -0.4396541909686271, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3686122134952916, -0.3737743494065351, -0.3603339312918319, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3491297989934987, -0.33970100146803706, -0.3520400622863078, -0.31613150648411503, -0.311001861935718, -0.297110534352802, -0.34540431991547793, -0.37604954640405674, -0.36151941759548234, -0.3098847404993055, -0.32275568409767486, -0.3325520357873284, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.40126445260195687, -0.40700300908023546, -0.4019731232106931, -0.4268681065465987, -0.4054024588659677, -0.3865064049182263, -0.2630247582517895, -0.21683156769449208, -0.2501690635665792, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995]}}
{"id": "64f2579c-61f1-4419-89d7-9ecde46e490e", "fitness": -0.10010159516542146, "name": "EnhancedAdaptivePSODE", "description": "Enhance the mutation strategy by dynamically adjusting crossover probability and introducing adaptive velocity scaling based on fitness variance.", "code": "import numpy as np\n\nclass EnhancedAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        cooling_factor = 0.98\n        mutation_strength = 0.2\n        exploration_phase = True\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            fitness_variance = np.var(self.pbest_scores)\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_rate * (np.mean(self.pbest_scores) / (self.gbest_score + 1e-8)))\n\n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05 * (1 - fitness_variance))\n\n            mutation_strength = max(0.05, mutation_strength * cooling_factor * 0.98)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_rate += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.10010 with standard deviation 0.21792.", "error": "", "parent_ids": ["219879a8-42d4-40d4-a73e-9f704526f71c"], "operator": null, "metadata": {"aucs": [0.1516791267933819, 0.0878745926880421, 0.15673680352570185, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020278395565632046, 0.03468774724259249, 0.020000000000000018, 0.04236853530467499, 0.034777961253342204, 0.020000000000000018, 0.08262061431562007, 0.05571728013292554, 0.05201609729866741, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.060349888918552974, 0.0873194251000391, 0.0815042690410479, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1492202855699949, 0.1640401839767026, 0.17329503771991628, 0.02320797224727078, 0.022606355528613786, 0.06065586002913681, 0.08072694858327945, 0.11300962997018105, 0.07544575038264834, 0.14964563738578918, 0.14340078716603333, 0.1160417955509998, 0.08050423431322284, 0.07990382579724953, 0.07722571798807021, 0.1308481424871616, 0.14782672448285983, 0.14672756438134205, 0.09710321390587795, 0.020000000000000018, 0.12285555649294155, 0.10819636878037442, 0.098301017410233, 0.08377986332747056, 0.13891426902396764, 0.09468630214118856, 0.05078938635156238, 0.1438526290318487, 0.15186170654353248, 0.15475448018179316, 0.05540579252063982, 0.042804149672112324, 0.03475343669837816, 0.05986798158797513, 0.033601963329539575, 0.046357266021892385, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02295021358990401, 0.012678242833914388, 0.01206895628898974, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.022755517018657967, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08529448495826397, 0.06882193641154122, 0.0807378846798883, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07679871737597754, 0.06147825531143891, 0.054046918857379556, 0.11869262382913237, 0.10477245995885098, 0.1036844634514148, 0.0686969962066758, 0.04681929228352122, 0.058226669118086716, 0.08738359445042221, 0.0800708452656883, 0.10575185105079532, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030601060098845223, 0.043163289782752634, 0.0375115651937975, 0.026938498804957578, 0.030992125660085357, 0.03864260202024805, 0.13329492969307266, 0.13880841913329822, 0.1432013905770546, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4230146242029713, -0.42546393805175153, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.37171621922401954, -0.37501189372175214, -0.3597314558853488, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.34796892030905635, -0.3664471077253806, -0.3670166779875772, -0.2933803994662221, -0.30714822361650596, -0.2999123261386276, -0.37693089147126435, -0.377052169767339, -0.3807640444443643, -0.31254357935460697, -0.30376693429321544, -0.33218114160145795, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.4017695175009539, -0.407024197271904, -0.40262345810455447, -0.42695656441579044, -0.4053846644783683, -0.3865159130359417, -0.26451476874736723, -0.2314681571139241, -0.2806691454674499, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993]}}
{"id": "c3d30a6e-0d73-4944-8789-1c0240be198d", "fitness": -0.09891338797616823, "name": "ImprovedRefinedEnhancedAdaptiveHybridPSODE", "description": "Integrate adaptive velocity clamping and stochastic restarts to enhance convergence reliability and exploration in PSO-DE hybrid optimization.", "code": "import numpy as np\n\nclass ImprovedRefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.1\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = max(0.05, mutation_strength * cooling_factor * 0.98)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 39, "feedback": "The algorithm ImprovedRefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09891 with standard deviation 0.21701.", "error": "", "parent_ids": ["219879a8-42d4-40d4-a73e-9f704526f71c"], "operator": null, "metadata": {"aucs": [0.13898124516495447, 0.11048923005258449, 0.15717077830453552, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03843119401690398, 0.03283288305400678, 0.020000000000000018, 0.02852433796379994, 0.026485280761963326, 0.020000000000000018, 0.08093512763719923, 0.054020568281786696, 0.04956030618232932, 0.020000000000000018, 0.060208086239528, 0.020000000000000018, 0.09078659442284509, 0.08903484726198829, 0.080410060646123, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02210843549526631, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10983216528146589, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15522771419577153, 0.1403766048592826, 0.16618088393338692, 0.027572978140700588, 0.02246688175085554, 0.04154748004159248, 0.08072694858327945, 0.14062307433047294, 0.08203063309073344, 0.13606790715141504, 0.14639546792243696, 0.14047639026965986, 0.07847137664959292, 0.07990382579724953, 0.07293287416551208, 0.11985716189599471, 0.11957067467644622, 0.12978435909978847, 0.020000000000000018, 0.03938237583901805, 0.12325466842233168, 0.10819636878037442, 0.07472533771567758, 0.08473818021328094, 0.1021184342778696, 0.10642876989472438, 0.05102031511260574, 0.1454398234312072, 0.14751405565868336, 0.15475448018179316, 0.05014481178045127, 0.04384887950717686, 0.03846562195397074, 0.06340452467914504, 0.033427730978355163, 0.07051453727778612, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016617387485432733, 0.011756103303938503, 0.01345238479891564, 0.010000000000000009, 0.011009323221230827, 0.010000000000000009, 0.010000000000000009, 0.03011504421306399, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013230721730100092, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08966737049912088, 0.07137169808517863, 0.09220060995903134, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07473622747791298, 0.06147825531143891, 0.06154010030917467, 0.12287528042241536, 0.105466850111265, 0.1091179619616035, 0.06366382285741923, 0.05047200979708133, 0.056994240311174726, 0.10132489398294264, 0.08413878274010156, 0.11364888411471907, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04083502484292656, 0.03924780619588819, 0.040974303474595075, 0.029049668114028315, 0.025054115774814534, 0.031843618623785486, 0.13254693794839512, 0.13468305667472147, 0.1341153999880328, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.418227059523145, -0.4137785545716557, -0.4136961964516912, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3621450363601746, -0.3666875226893922, -0.3308297297842213, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3674163341607324, -0.3655679182097493, -0.3702642726360681, -0.3163319997391314, -0.2900402941344504, -0.2971690962454594, -0.3643888340942294, -0.3738383851580329, -0.38079407066156823, -0.32593595675203013, -0.3074712027493647, -0.28213985557106924, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.4015069854484148, -0.3862993001059123, -0.4035018542142017, -0.4276786792215044, -0.4054024588659677, -0.38626345706538023, -0.2569292682093218, -0.23419395177449043, -0.2574247058113355, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995]}}
{"id": "b77b6728-5ffe-427d-8fc8-9ee825ddd3f8", "fitness": -0.09900607880059667, "name": "ImprovedRefinedEnhancedAdaptiveHybridPSODE", "description": "Enhance exploration by increasing the mutation strength during the exploration phase to diversify search.", "code": "import numpy as np\n\nclass ImprovedRefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.1\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = max(0.05, mutation_strength * cooling_factor * 1.02)  # Changed line\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 40, "feedback": "The algorithm ImprovedRefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09901 with standard deviation 0.21724.", "error": "", "parent_ids": ["c3d30a6e-0d73-4944-8789-1c0240be198d"], "operator": null, "metadata": {"aucs": [0.13897134303935244, 0.11052771845844878, 0.15712870565140835, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03772314322299142, 0.032916586702890216, 0.020000000000000018, 0.02841059292545478, 0.02634907543321474, 0.020000000000000018, 0.08101377803318688, 0.05404889744348296, 0.04956030618232932, 0.020000000000000018, 0.06165284800173154, 0.020000000000000018, 0.09045831632885704, 0.08903484726198829, 0.080410060646123, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022062411495178957, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11385601128803158, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1552667264547678, 0.14030995929841372, 0.16615688249502913, 0.027943520467996863, 0.02254461484907211, 0.041426786025789974, 0.08072694858327945, 0.14062307433047294, 0.08128318631229237, 0.13573360614411445, 0.14671399224878623, 0.14101745224586404, 0.07824082928303466, 0.07990382579724953, 0.07196102780978886, 0.13377966476088687, 0.1321690594998236, 0.13070983340323916, 0.020000000000000018, 0.03829309103638534, 0.12303247043625432, 0.10819636878037442, 0.07470452894797308, 0.0847887928368678, 0.10237547183924933, 0.10653743930389314, 0.051083527578560384, 0.1454398234312072, 0.14375791881013722, 0.15475448018179316, 0.049746147485319914, 0.0471474649039858, 0.037215432510927404, 0.0634726989251948, 0.03439512257562316, 0.07048812222180079, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01656546517498203, 0.011765842423418493, 0.013445621048403522, 0.010000000000000009, 0.011020174791585347, 0.010000000000000009, 0.010000000000000009, 0.023564563440004682, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01054676118993636, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08969684393069355, 0.07137466684090132, 0.09220617405648324, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0741311354370714, 0.06147825531143891, 0.06216246801276437, 0.12250187770297927, 0.10542451273343834, 0.10906160079970473, 0.06333000887888429, 0.050111589989123795, 0.056994240311174726, 0.09360230485766263, 0.08665677721987575, 0.10840338359111579, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04085584391601016, 0.03904970443159983, 0.0409633112034703, 0.02903239872343566, 0.025065087142571607, 0.03180886924793269, 0.13198677485352517, 0.13282184198725144, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4183204538455936, -0.4137983578762183, -0.4137564328423957, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3621782616691769, -0.3667022552198318, -0.3308192270189505, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3673194426648032, -0.36571526126428866, -0.3700107807150881, -0.3164646824630728, -0.2898626012790453, -0.2970576145614039, -0.36476237593004357, -0.37389751571575824, -0.38043337628315066, -0.3264973244068412, -0.3061045883318767, -0.30409774468077844, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.4014987383266584, -0.38631077855514273, -0.4034977621444513, -0.4276818281941701, -0.4054085688475484, -0.3862464797183043, -0.26725596065705104, -0.21236388193428457, -0.25272661136912933, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995]}}
{"id": "cdac7e0c-0bdf-4ed3-a8ec-47e23465f039", "fitness": -0.0986534234508486, "name": "ImprovedRefinedEnhancedAdaptiveHybridPSODE", "description": "Refine the adaptive inertia weight adjustment rate for improved convergence efficiency.", "code": "import numpy as np\n\nclass ImprovedRefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2  # Adjusted adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = max(0.05, mutation_strength * cooling_factor * 0.98)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 41, "feedback": "The algorithm ImprovedRefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09865 with standard deviation 0.21656.", "error": "", "parent_ids": ["c3d30a6e-0d73-4944-8789-1c0240be198d"], "operator": null, "metadata": {"aucs": [0.14116443351023866, 0.11026889523575278, 0.15720497785872511, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.038397100393679606, 0.030027057332032814, 0.020000000000000018, 0.028517546867075194, 0.026462542688795776, 0.020000000000000018, 0.08092793001837928, 0.05410753696062898, 0.04956030618232932, 0.020000000000000018, 0.06296358863571128, 0.020000000000000018, 0.09078659442284509, 0.08903484726198829, 0.08115795987804741, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02173637115285776, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1570661133741611, 0.1418382730006783, 0.16634076234203898, 0.025887884945910877, 0.022475386273467457, 0.04490835288665607, 0.08072694858327945, 0.14473015916219012, 0.08253158145661932, 0.13626315194004324, 0.14640993103773614, 0.13028387164590205, 0.07847239072857481, 0.07990382579724953, 0.07288754612787074, 0.13610088712393176, 0.12880630140804028, 0.132357126199106, 0.020000000000000018, 0.0393933833953648, 0.1232474307949587, 0.10819636878037442, 0.07473520555384394, 0.0847011954575072, 0.10257426703030148, 0.10651747799940448, 0.05100060143332397, 0.1721741362044087, 0.14898961942865596, 0.15475448018179316, 0.04953719725617278, 0.04455092388708226, 0.03830569451467025, 0.063530234254352, 0.03347712383336132, 0.07048223747034943, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016642747258723833, 0.01175863035468927, 0.01345836364134756, 0.010000000000000009, 0.01100659246369906, 0.010000000000000009, 0.010000000000000009, 0.03013679260503821, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01323199884202031, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0893231924064598, 0.07136771211268678, 0.09263345831071634, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0742184684434325, 0.06147825531143891, 0.06038547738190947, 0.12332335301419661, 0.10506632922899906, 0.10874635810585576, 0.0627281962740025, 0.05129473021262099, 0.053936809511723194, 0.10292882233401368, 0.08718238039551185, 0.11267612170658436, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.040722500614057244, 0.039047921413830955, 0.04104198817068183, 0.02907910552385362, 0.02506531515310262, 0.0318535505910198, 0.13264578900010815, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.41822622380669205, -0.4137843023372252, -0.41369812577365583, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3621359804014177, -0.3667145181886995, -0.3308307843277316, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.36703749640499783, -0.36548127906472105, -0.3699860124477288, -0.29443983652525674, -0.28598336276767355, -0.2983601715399764, -0.3675238945313333, -0.3735441272757334, -0.3807806664373752, -0.30586591870076396, -0.306943364194999, -0.2810633492495058, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.401476232478702, -0.3862943469337097, -0.4035063634479079, -0.4276897849480883, -0.40540074412312377, -0.38626484829037233, -0.2534112848271117, -0.21618051212396838, -0.250990006639511, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993]}}
{"id": "3b1964ed-1727-4e6e-b85d-0ebba2542a29", "fitness": -0.09856244430525406, "name": "ImprovedRefinedEnhancedAdaptiveHybridPSODE", "description": "Adjust velocities based on a quasi-sinusoidal adaptive strategy for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass ImprovedRefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2  # Adjusted adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = max(0.05, mutation_strength * cooling_factor * 0.98)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 42, "feedback": "The algorithm ImprovedRefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09856 with standard deviation 0.21693.", "error": "", "parent_ids": ["cdac7e0c-0bdf-4ed3-a8ec-47e23465f039"], "operator": null, "metadata": {"aucs": [0.14010698882382044, 0.1093395763437155, 0.15642771582613935, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029819096512609722, 0.028374568748075424, 0.0202894401808712, 0.02786071220590569, 0.026339047234245738, 0.020000000000000018, 0.07999767133404245, 0.05386260950686872, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08759004049762009, 0.08903484726198829, 0.0824992113071672, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026545334546326238, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05339851145861363, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15685363390862928, 0.14428936995169328, 0.16634138849571256, 0.03452345604374385, 0.024574614740453415, 0.04778015601206387, 0.08072694858327945, 0.14473015916219012, 0.07124575058238858, 0.1457113787819373, 0.14853220875400752, 0.13950185195890685, 0.07560206462168806, 0.07990382579724953, 0.07349813573120012, 0.12782390079172046, 0.11942560527109891, 0.17675830096142964, 0.020000000000000018, 0.04585177084262182, 0.1199775031805086, 0.10819636878037442, 0.07467864181214978, 0.08300720363550196, 0.08952430288563873, 0.10760774194562484, 0.050549430223924774, 0.1721741362044087, 0.15924967655023836, 0.15475448018179316, 0.05917756647933514, 0.04033759258251701, 0.04035671709223354, 0.06406515612235253, 0.034237061254009826, 0.07089720522066756, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01669352914786859, 0.011733865384929376, 0.012554027015130531, 0.010000000000000009, 0.010781132835198215, 0.010000000000000009, 0.0107281887622378, 0.022829064827905032, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08951760449412771, 0.07173553430343005, 0.0920772778168707, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07388018074089886, 0.06147825531143891, 0.06280526036389589, 0.12274710791209642, 0.10589331493976617, 0.11145910208798016, 0.0674541491577394, 0.05331300912773229, 0.056182422759758266, 0.09522298451830824, 0.0838331994485586, 0.10976012608234131, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03927057335776496, 0.04081012310231591, 0.04241582512724007, 0.029527414528137563, 0.025107494653167195, 0.03265798577590728, 0.13141309820135194, 0.13123409970527322, 0.13682921567212036, 0.010000000000000009, 0.010000000000000009, 0.010683134969129537, -0.418340543907155, -0.41288513917418723, -0.41316070038712005, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3628913717277007, -0.3659235567873207, -0.3307395541557334, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.36800340480305693, -0.36553044131526824, -0.36690624408065475, -0.2941988182739461, -0.2861545779204433, -0.2977034714858531, -0.3686657432874554, -0.37310733259034157, -0.377818985702699, -0.30615912562394043, -0.30731260903766344, -0.2846285569397644, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.4012529924479302, -0.3862914597357645, -0.4034932517371479, -0.42781821488923755, -0.4053858890801707, -0.4060528424488523, -0.24231885892146843, -0.21683156769449208, -0.23605200102376034, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995]}}
{"id": "31d62366-bb08-44e2-b1f3-b2a57cb9b9a0", "fitness": -0.09858857788457408, "name": "ImprovedRefinedEnhancedAdaptiveHybridPSODE", "description": "Introduced adaptive mutation strength scaling for enhanced diversity and exploration capabilities.", "code": "import numpy as np\n\nclass ImprovedRefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2  # Adjusted adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = max(0.05, mutation_strength * cooling_factor * (0.98 + 0.02 * np.sin(evals / self.budget * np.pi)))  # Changed line\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 43, "feedback": "The algorithm ImprovedRefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09859 with standard deviation 0.21701.", "error": "", "parent_ids": ["3b1964ed-1727-4e6e-b85d-0ebba2542a29"], "operator": null, "metadata": {"aucs": [0.14010191921853932, 0.10934532810954167, 0.15643198681983994, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029745056663740277, 0.028394226977806913, 0.02028453247485884, 0.027838997945376587, 0.02639861681253053, 0.020000000000000018, 0.08001020412587789, 0.053867238094262526, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08759004049762009, 0.08903484726198829, 0.0824992113071672, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02653818173246758, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.053732282335782644, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15685925503157339, 0.14427926318745132, 0.1663419017673411, 0.03445692826758073, 0.02456358856653107, 0.047736320163963675, 0.08072694858327945, 0.14473015916219012, 0.0712592960171442, 0.1457196212893842, 0.14847111360506904, 0.14053849515060224, 0.07573882959926093, 0.07990382579724953, 0.07348744083150638, 0.1282151070694013, 0.12796141339863154, 0.17303494111327022, 0.020000000000000018, 0.04565102788984976, 0.11992578212061122, 0.10819636878037442, 0.07467501709726099, 0.08301230778398372, 0.08961502660348741, 0.10762371444239638, 0.05056069066740265, 0.1721741362044087, 0.15548474627483755, 0.15475448018179316, 0.05698510516492661, 0.0402693761144951, 0.04028796499244014, 0.06408215762980218, 0.034224215557031146, 0.07089191169629872, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016685332812932163, 0.011737240310640717, 0.012550892566267291, 0.010000000000000009, 0.010784073727929666, 0.010000000000000009, 0.0107281887622378, 0.022829064827905032, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08952468342633735, 0.07173622837406268, 0.09208259431869281, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07412087465881012, 0.06147825531143891, 0.06279070074566562, 0.12272042162738084, 0.10576638922473525, 0.11144298394284691, 0.06728666297288133, 0.05319608501133377, 0.05615211895708061, 0.10032437199022615, 0.08561015031117025, 0.11083424312770662, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03927251731002601, 0.04078654965261663, 0.04241414275618671, 0.029524153434826395, 0.025110001925924497, 0.032650610337553565, 0.13141309820135194, 0.1313162251296095, 0.13681629452982802, 0.010000000000000009, 0.010000000000000009, 0.010626479759876295, -0.4183743067894119, -0.4128924754421568, -0.4131835325237234, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3629046233835991, -0.3659270169837652, -0.3307355456705401, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.36793588350650563, -0.3656902236489312, -0.3676264852334288, -0.2941638452896449, -0.2861669967312712, -0.29758679886115824, -0.36874173324648374, -0.3732547737511547, -0.3776972352368957, -0.2995460014541649, -0.30452858047149767, -0.3050816981639597, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.4012490689864847, -0.38629360588650874, -0.4034934715082701, -0.427818546006713, -0.4053879488525254, -0.40604777617443766, -0.24069170201418166, -0.21683156769449208, -0.23940446396474235, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995]}}
{"id": "bce6cbba-af4a-43bf-943b-30bf25dbedce", "fitness": -0.1818343606750734, "name": "FrequencyAdaptivePSODE", "description": "Introduce adaptive frequency-based learning with a dynamic inertia weight and crossover adjustment for enhanced convergence in diverse landscapes.", "code": "import numpy as np\n\nclass FrequencyAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            self.w *= cooling_factor\n            \n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = max(0.05, mutation_strength * cooling_factor * 0.98)\n            \n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            frequency = np.sin(np.pi * evals / self.budget) ** 2\n            velocity_adaptive_factor = 0.5 + 0.5 * frequency\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = velocity_adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 44, "feedback": "The algorithm FrequencyAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.18183 with standard deviation 0.33339.", "error": "", "parent_ids": ["3b1964ed-1727-4e6e-b85d-0ebba2542a29"], "operator": null, "metadata": {"aucs": [0.13956537404469826, 0.10890928530502153, 0.15542369064604566, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.028024564855445577, 0.02999791255174611, 0.021553680654438967, 0.02516558933385038, 0.021054244026947222, 0.020000000000000018, 0.07958377001699146, 0.05373744478687659, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08934726490087319, 0.10206150953601933, 0.08279144011515005, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.028344070993617798, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05909080170051395, 0.04772057272983776, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15678616100666531, 0.14539164129268145, 0.16701875416419254, 0.03181425708709551, 0.02423629495310653, 0.048814936544046894, 0.08072694858327945, 0.14473015916219012, 0.08295304614278731, 0.1391442991726567, 0.14463767896320234, 0.1391554832358637, 0.0726702486575409, 0.07990382579724953, 0.07723757483254956, 0.1331334078830707, 0.1155098632104804, 0.16009267037983188, 0.020000000000000018, 0.04879041720403743, 0.1193726228057983, 0.10819636878037442, 0.07464093818109263, 0.0821044689475201, 0.08214177909827025, 0.10796674497271908, 0.05033385653354738, 0.1721741362044087, 0.13589170657517036, 0.15475448018179316, 0.0590581610080787, 0.04157737270020623, 0.03553740981577225, 0.06707712653533449, 0.03407516360062435, 0.06923412536030027, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017619146280800635, 0.01131352225075366, 0.010716334825283669, 0.010000000000000009, 0.010708639837018863, 0.010000000000000009, 0.011903042757633098, 0.022994725608501576, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010540041234198716, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09129111130664436, 0.07194843232318004, 0.09208909932191933, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07332452313685223, 0.06147825531143891, 0.06226782505719497, 0.12029080375893475, 0.1068165581503574, 0.10975756166884088, 0.0673358112003587, 0.052571703295518524, 0.05440136793428796, 0.1031771396958635, 0.08921324906569339, 0.10790727288815172, 0.03753581082341473, 0.010000000000000009, 0.010000000000000009, 0.0374633098013234, 0.03857107083025313, 0.04318986775153433, 0.03044118551113173, 0.026573346364088146, 0.03551490993667361, 0.1439423831825688, 0.13511906645947247, 0.14029467981269894, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.6470669479096298, -0.6676127195996981, -0.6686020312684946, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.5864671475685588, -0.5901599353025915, -0.5944600631296497, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6140009662384147, -0.6085652525548897, -0.6194625687522382, -0.5291665146866324, -0.5199308707033403, -0.5343550750286161, -0.6188256447429905, -0.6202759896081986, -0.6268522074815022, -0.5392178943670314, -0.538642865029616, -0.5449011519510987, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6568285715072237, -0.6627659590528054, -0.6597293647024352, -0.6658207131813614, -0.6625455638668267, -0.6624736839832759, -0.47498951558186286, -0.459904944814471, -0.46972519253893164, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999]}}
{"id": "8e770dfc-ca68-4191-8850-a470c36163f7", "fitness": -0.09856244430525406, "name": "EnhancedAdaptiveHybridMetaheuristic", "description": "Introduce a dynamic diversity mechanism and dual-phase exploration-exploitation balance to enhance convergence and robustness.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        diversity_threshold = 1e-5\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = max(0.05, mutation_strength * cooling_factor * 0.98)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            # Calculate population diversity\n            population_diversity = np.std(self.population, axis=0).mean()\n            if population_diversity < diversity_threshold:\n                self.population += np.random.normal(0, 0.1, self.population.shape)  # Add diversity\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedAdaptiveHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09856 with standard deviation 0.21693.", "error": "", "parent_ids": ["3b1964ed-1727-4e6e-b85d-0ebba2542a29"], "operator": null, "metadata": {"aucs": [0.14010698882382044, 0.1093395763437155, 0.15642771582613935, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029819096512609722, 0.028374568748075424, 0.0202894401808712, 0.02786071220590569, 0.026339047234245738, 0.020000000000000018, 0.07999767133404245, 0.05386260950686872, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08759004049762009, 0.08903484726198829, 0.0824992113071672, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026545334546326238, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05339851145861363, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15685363390862928, 0.14428936995169328, 0.16634138849571256, 0.03452345604374385, 0.024574614740453415, 0.04778015601206387, 0.08072694858327945, 0.14473015916219012, 0.07124575058238858, 0.1457113787819373, 0.14853220875400752, 0.13950185195890685, 0.07560206462168806, 0.07990382579724953, 0.07349813573120012, 0.12782390079172046, 0.11942560527109891, 0.17675830096142964, 0.020000000000000018, 0.04585177084262182, 0.1199775031805086, 0.10819636878037442, 0.07467864181214978, 0.08300720363550196, 0.08952430288563873, 0.10760774194562484, 0.050549430223924774, 0.1721741362044087, 0.15924967655023836, 0.15475448018179316, 0.05917756647933514, 0.04033759258251701, 0.04035671709223354, 0.06406515612235253, 0.034237061254009826, 0.07089720522066756, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01669352914786859, 0.011733865384929376, 0.012554027015130531, 0.010000000000000009, 0.010781132835198215, 0.010000000000000009, 0.0107281887622378, 0.022829064827905032, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08951760449412771, 0.07173553430343005, 0.0920772778168707, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07388018074089886, 0.06147825531143891, 0.06280526036389589, 0.12274710791209642, 0.10589331493976617, 0.11145910208798016, 0.0674541491577394, 0.05331300912773229, 0.056182422759758266, 0.09522298451830824, 0.0838331994485586, 0.10976012608234131, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03927057335776496, 0.04081012310231591, 0.04241582512724007, 0.029527414528137563, 0.025107494653167195, 0.03265798577590728, 0.13141309820135194, 0.13123409970527322, 0.13682921567212036, 0.010000000000000009, 0.010000000000000009, 0.010683134969129537, -0.418340543907155, -0.41288513917418723, -0.41316070038712005, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3628913717277007, -0.3659235567873207, -0.3307395541557334, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.36800340480305693, -0.36553044131526824, -0.36690624408065475, -0.2941988182739461, -0.2861545779204433, -0.2977034714858531, -0.3686657432874554, -0.37310733259034157, -0.377818985702699, -0.30615912562394043, -0.30731260903766344, -0.2846285569397644, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.4012529924479302, -0.3862914597357645, -0.4034932517371479, -0.42781821488923755, -0.4053858890801707, -0.4060528424488523, -0.24231885892146843, -0.21683156769449208, -0.23605200102376034, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995]}}
{"id": "f17948c4-d0d0-4115-afab-dbe9f1e7acf0", "fitness": -0.09913203641642065, "name": "RefinedAdaptiveHybridPSODE", "description": "Introduce dynamically adaptive inertia weight and elite-focused differential mutation to refine exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.9   # initial inertia weight\n        self.w_min = 0.1\n        self.w_max = 0.9\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_lr = 0.2\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            mean_pbest_score = np.mean(self.pbest_scores)\n            self.w = max(self.w_min, self.w_max * (1 - np.exp(-adapt_lr * (self.gbest_score / (mean_pbest_score + 1e-8)))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * (1 - self.gbest_score / (mean_pbest_score + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * (mean_pbest_score / self.gbest_score))\n            \n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = max(0.05, mutation_strength * 0.99)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 46, "feedback": "The algorithm RefinedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09913 with standard deviation 0.21638.", "error": "", "parent_ids": ["3b1964ed-1727-4e6e-b85d-0ebba2542a29"], "operator": null, "metadata": {"aucs": [0.15958549593152982, 0.11697837506553588, 0.1575471385359143, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026429455177764405, 0.029047542949970362, 0.024417011988910553, 0.022058980072260814, 0.020000000000000018, 0.022931229672069287, 0.07858201866809145, 0.054915304081339156, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06725238203640227, 0.10105761634885024, 0.06914003575177519, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03602299257317443, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02504493213181913, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13386908427229438, 0.1624117242791172, 0.16782149585816541, 0.02668849221216918, 0.0270821108043503, 0.032293914102334065, 0.08185638334466683, 0.0863116411064907, 0.07975430125931782, 0.13938849516653107, 0.1443828043992057, 0.123732220658613, 0.07196360739889318, 0.08428569725121915, 0.08261029700799216, 0.13522253947000407, 0.1417226379440243, 0.1582352840843455, 0.020000000000000018, 0.04696803165343877, 0.11686426795046234, 0.10819636878037442, 0.07479300997516702, 0.07956139591978317, 0.07653694931085497, 0.10861378773868813, 0.049566789882854345, 0.14525385335404506, 0.15676754567694895, 0.15600406653299104, 0.0493739984158984, 0.0324046344069322, 0.036879909480413975, 0.06664446786339395, 0.03515403929611138, 0.07098523104265497, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020365886787174325, 0.010570643762915832, 0.012769467677619661, 0.010000000000000009, 0.010420484293865773, 0.010000000000000009, 0.010061565756618651, 0.023351181326079273, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08770684978444176, 0.07274914568514557, 0.09301742522603718, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08283146613091574, 0.06147825531143891, 0.06158893120444642, 0.1216227233226681, 0.1109746110424722, 0.10794294800568294, 0.06594589719618182, 0.05625825633078263, 0.056934022237082216, 0.10065747027659189, 0.09101473952886352, 0.10760497074513964, 0.012777623425801354, 0.011468615224599743, 0.010000000000000009, 0.03622074273006182, 0.04479882895866272, 0.04521201007612474, 0.032192488157285815, 0.032612547426859484, 0.03423694011989875, 0.13141309820135194, 0.13123409970527322, 0.13629763711781662, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4191701936792749, -0.430571658466242, -0.4131126269365253, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.36841577572991047, -0.3659799804358479, -0.32994157774852617, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3680482866991721, -0.3664471077253806, -0.3708889942950808, -0.29427029117734627, -0.28904355520869074, -0.2942668770048771, -0.3731252648788763, -0.34851270138615287, -0.37112653304902343, -0.3048350503761561, -0.30370179645026263, -0.2997326663180069, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.4007736493797227, -0.38635199602959824, -0.40324339213821125, -0.4285418177997531, -0.4053864304246455, -0.4060143826698883, -0.247028214820894, -0.21683156769449208, -0.2422609452686888, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993]}}
{"id": "3bbf9582-f4f0-4cbe-ba6a-c12f2b1b71cf", "fitness": -0.09846453809913494, "name": "ImprovedRefinedEnhancedAdaptiveHybridPSODE", "description": "Enhance the adaptive strategy by dynamically adjusting the mutation strength based on a sinusoidal function.", "code": "import numpy as np\n\nclass ImprovedRefinedEnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2  # Adjusted adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 47, "feedback": "The algorithm ImprovedRefinedEnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09846 with standard deviation 0.21694.", "error": "", "parent_ids": ["3b1964ed-1727-4e6e-b85d-0ebba2542a29"], "operator": null, "metadata": {"aucs": [0.14023234998643996, 0.10918062240026838, 0.1562710017102763, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03385130205196352, 0.027770716907781434, 0.020455969216249037, 0.02845363184081917, 0.024831231925325548, 0.020000000000000018, 0.07965531280294047, 0.053735784630506434, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08791831859160826, 0.08903484726198829, 0.0824992113071672, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026731964731689706, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03219047315661494, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15669890644264028, 0.14456362858254979, 0.16632038938391436, 0.03578024822799586, 0.024896147455965245, 0.04896276240574893, 0.08072694858327945, 0.14473015916219012, 0.07250305112818578, 0.14544033478320362, 0.1487494016699955, 0.138027118645219, 0.07408942204880642, 0.07990382579724953, 0.07370181956250066, 0.1221802373976828, 0.11875398167749585, 0.1428285551355657, 0.020000000000000018, 0.05160806437621124, 0.12127632839859204, 0.10819636878037442, 0.07477446877857319, 0.08284859220028284, 0.0871054773518185, 0.10714764683294709, 0.05023310045748319, 0.1721741362044087, 0.16050040364606843, 0.15475448018179316, 0.05432940018195476, 0.04198724455436975, 0.042595004056991015, 0.06393079109040978, 0.03434686744807247, 0.07103277204775471, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016705535150068118, 0.011731546218564981, 0.012548114414444367, 0.010000000000000009, 0.010759338976969235, 0.010000000000000009, 0.010000000000000009, 0.031098890288769776, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08940511502837922, 0.07172415469100502, 0.0921961607292413, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07333068771355011, 0.06147825531143891, 0.06627955276523356, 0.12335729513003812, 0.10663653429593101, 0.11104632903087819, 0.07005590744723078, 0.055756754054326896, 0.05655786499657145, 0.10034238950568675, 0.09234500219017605, 0.1118393880545534, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.039113534049469934, 0.042554543876952344, 0.042439974099406474, 0.029600339459540992, 0.025064475580436008, 0.032768820903138485, 0.141169082161837, 0.13862283141014586, 0.15643397541415227, 0.010000000000000009, 0.010000000000000009, 0.010068517515987585, -0.4181932510522559, -0.41286308418618756, -0.41304265012390795, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3628403007051173, -0.365916078844879, -0.3307572086488577, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3678630031876844, -0.3421811881855208, -0.366154335432999, -0.2943570843554437, -0.28610227122558163, -0.2976265950272261, -0.3684718676658638, -0.37242839817154083, -0.3783003268435383, -0.32373907723755924, -0.3037844400860905, -0.28617126730862474, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.4012737668491446, -0.3862761439134481, -0.40349240503393924, -0.427808084900825, -0.40537699939808824, -0.38631251191153115, -0.25509459802035295, -0.21683156769449208, -0.2281837632488406, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995]}}
{"id": "4579c2af-b000-43e2-9dd2-721988a110c1", "fitness": -0.10086274186079916, "name": "RefinedAdaptiveSinusoidalPSODE", "description": "Integrate adaptive learning rates and dynamic crossover strategies with a sinusoidal velocity update to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass RefinedAdaptiveSinusoidalPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.de_f = 0.5\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.25\n        cooling_factor = 0.99\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 48, "feedback": "The algorithm RefinedAdaptiveSinusoidalPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.10086 with standard deviation 0.21599.", "error": "", "parent_ids": ["3bbf9582-f4f0-4cbe-ba6a-c12f2b1b71cf"], "operator": null, "metadata": {"aucs": [0.11599532361308262, 0.10744898787911383, 0.15617508144530845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.033629906420666766, 0.026493018982950756, 0.020000000000000018, 0.02840445725119678, 0.023292424808353585, 0.020000000000000018, 0.05771297691307442, 0.043189138520207115, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03582439940421078, 0.08903484726198829, 0.07815172182767172, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026687919180768627, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14627252796706147, 0.13072278965479223, 0.1571144720817056, 0.03572024684146302, 0.020000000000000018, 0.022934246070413722, 0.08072694858327945, 0.0863116411064907, 0.07494466349313089, 0.1456393419069909, 0.14868046237057764, 0.1359931460757693, 0.0740730640288999, 0.07990382579724953, 0.07136429908289221, 0.12188680672909302, 0.11421830568223545, 0.13377859263340153, 0.020000000000000018, 0.05167619932582146, 0.12125487606130436, 0.10819636878037442, 0.07012052903117383, 0.08279453170701312, 0.06527120746322768, 0.10717427400282131, 0.0612970331268029, 0.1438526290318487, 0.15723771431010047, 0.15475448018179316, 0.05836764319144916, 0.0379205390678129, 0.04254682893849149, 0.06165959032253676, 0.03314194319790076, 0.07102782154787013, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011654720434619792, 0.010267602610090076, 0.01036316313756469, 0.010000000000000009, 0.010757409358342351, 0.010000000000000009, 0.010000000000000009, 0.02522650015429395, 0.010833134619632312, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08320909027998102, 0.07166346370333387, 0.0885946049989812, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058564563993263374, 0.06147825531143891, 0.06619865796999758, 0.12383145591841993, 0.10758390929406714, 0.11104669528187572, 0.06971966568471988, 0.05598255524954998, 0.05655458180371442, 0.10056234201677938, 0.08619049492181208, 0.10263898499516744, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.033490689669503526, 0.040906554988632826, 0.04249066772505661, 0.030238306146942784, 0.02562084733305059, 0.02886103988824662, 0.131545759565308, 0.1329518426863765, 0.15922282508043994, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.41838925938981153, -0.43888669480348685, -0.413661215318194, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3640189147979027, -0.3663703206955049, -0.3307537677612158, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3716993370121886, -0.36488508998587843, -0.36764740907669324, -0.31217818122088836, -0.26860526376046967, -0.2983675579916709, -0.3698636134345381, -0.37270986528776917, -0.3723227897629098, -0.30547107344859437, -0.3271582836196214, -0.27959922913132407, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.38303376765612707, -0.40589384770808756, -0.38472705670630125, -0.4272889178447241, -0.4053759685558693, -0.4273416831898036, -0.2575741204982227, -0.21683156769449208, -0.2741279294862493, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993]}}
{"id": "20892c43-9310-4074-b021-f9c0664b1a31", "fitness": -0.18200104241347023, "name": "HierarchicalAdaptiveHybridPSODE", "description": "Introduce a hierarchical adaptive strategy with multi-tiered exploration and exploitation phases, using dynamic resource allocation based on convergence speed.", "code": "import numpy as np\n\nclass HierarchicalAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.de_f = 0.5\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.eval_counter = 0\n\n    def __call__(self, func):\n        adapt_rate = 0.1\n        adapt_lr = 0.2\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        exploitation_trigger = self.budget * 0.6\n\n        while self.eval_counter < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                self.eval_counter += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if self.eval_counter >= self.budget:\n                break\n\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))))\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score))\n            self.w *= cooling_factor\n\n            if self.eval_counter > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(self.eval_counter / self.budget * np.pi))\n\n            if exploration_phase and self.eval_counter > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            if not exploration_phase and self.eval_counter > exploitation_trigger:\n                self.population_size = min(self.initial_population_size, self.population_size * 2)\n                exploitation_trigger += self.budget * 0.1\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            angle = (self.eval_counter / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                self.eval_counter += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if self.eval_counter % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 49, "feedback": "The algorithm HierarchicalAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.18200 with standard deviation 0.33332.", "error": "", "parent_ids": ["3bbf9582-f4f0-4cbe-ba6a-c12f2b1b71cf"], "operator": null, "metadata": {"aucs": [0.14023234998643996, 0.10918062240026838, 0.1562710017102763, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03385130205196352, 0.027770716907781434, 0.020455969216249037, 0.02845363184081917, 0.024831231925325548, 0.020000000000000018, 0.07965531280294047, 0.053735784630506434, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08791831859160826, 0.08903484726198829, 0.0824992113071672, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026731964731689706, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03219047315661494, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15669890644264028, 0.14456362858254979, 0.16632038938391436, 0.03578024822799586, 0.024896147455965245, 0.04896276240574893, 0.08072694858327945, 0.14473015916219012, 0.07250305112818578, 0.14544033478320362, 0.1487494016699955, 0.138027118645219, 0.07408942204880642, 0.07990382579724953, 0.07370181956250066, 0.1221802373976828, 0.11875398167749585, 0.1428285551355657, 0.020000000000000018, 0.05160806437621124, 0.12127632839859204, 0.10819636878037442, 0.07477446877857319, 0.08284859220028284, 0.0871054773518185, 0.10714764683294709, 0.05023310045748319, 0.1721741362044087, 0.16050040364606843, 0.15475448018179316, 0.05432940018195476, 0.04198724455436975, 0.042595004056991015, 0.06393079109040978, 0.03434686744807247, 0.07103277204775471, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016705535150068118, 0.011731546218564981, 0.012548114414444367, 0.010000000000000009, 0.010759338976969235, 0.010000000000000009, 0.010000000000000009, 0.031098890288769776, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08940511502837922, 0.07172415469100502, 0.0921961607292413, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07333068771355011, 0.06147825531143891, 0.06627955276523356, 0.12335729513003812, 0.10663653429593101, 0.11104632903087819, 0.07005590744723078, 0.055756754054326896, 0.05655786499657145, 0.10034238950568675, 0.09234500219017605, 0.1118393880545534, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.039113534049469934, 0.042554543876952344, 0.042439974099406474, 0.029600339459540992, 0.025064475580436008, 0.032768820903138485, 0.141169082161837, 0.13862283141014586, 0.15643397541415227, 0.010000000000000009, 0.010000000000000009, 0.010068517515987585, -0.6468641069359942, -0.6676294693652707, -0.6684236028784831, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.585746689464292, -0.5908190793387105, -0.5945530345414434, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6153825779599706, -0.609634077947905, -0.6134253425017815, -0.5294610894908534, -0.5183135967171015, -0.5299441979051198, -0.6170578992161762, -0.6223614941566651, -0.6296226824507289, -0.54112358487644, -0.5393628679437388, -0.5399921621840826, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6569977456112395, -0.6628418841147374, -0.6597929419717505, -0.6654965350599511, -0.6625457777412556, -0.662663991077677, -0.48345509494032846, -0.459904944814471, -0.47191072994979133, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999]}}
{"id": "fc64d1f2-b236-4c91-96ea-58a427ccb92c", "fitness": -0.09783654533979663, "name": "ChaoticAdaptiveHybridPSODE", "description": "Introduce a chaotic sequence for adaptive parameters to enhance exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2  # Adjusted adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 50, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09784 with standard deviation 0.21479.", "error": "", "parent_ids": ["3bbf9582-f4f0-4cbe-ba6a-c12f2b1b71cf"], "operator": null, "metadata": {"aucs": [0.11613788550553605, 0.1316437029836911, 0.19666441963080616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03070587982457651, 0.031427180025650925, 0.03208339318626885, 0.031010621654634307, 0.021473048221546276, 0.020000000000000018, 0.05629403171828107, 0.0483113550742752, 0.05564438955503814, 0.020000000000000018, 0.0725683207591249, 0.020000000000000018, 0.0630104829836422, 0.09404191616084001, 0.0950505622715504, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020921449318437313, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13944824440624615, 0.133523182924157, 0.1709984093697824, 0.021385067413101755, 0.020688167064402574, 0.02069636810101949, 0.09239883488803546, 0.0863116411064907, 0.06617621355857095, 0.13661016016412697, 0.14704797749762866, 0.1548386421627942, 0.08016097402179245, 0.0820741079435624, 0.12224881968238543, 0.12628442028552056, 0.11069276846070286, 0.1363863955091429, 0.020000000000000018, 0.10191068643713241, 0.11421629740479267, 0.10819636878037442, 0.0794977424328972, 0.08282422390945199, 0.07209790169319763, 0.08155451686178228, 0.04462598168278675, 0.1438526290318487, 0.13589170657517036, 0.17843056125529133, 0.05772063778208536, 0.034175513010364145, 0.03719056228929729, 0.05297886376212435, 0.04263973656998399, 0.06440220750605108, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015098878480023448, 0.011187202432029753, 0.012750948116313499, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08789238415385525, 0.08437478634068651, 0.08142626928484387, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06130818542910277, 0.06460770561164852, 0.059823019089922935, 0.13326244135029586, 0.10622871429325376, 0.10723137426281437, 0.07514540764796207, 0.053477978853406216, 0.059357614612679854, 0.10221872462558435, 0.0923795767309109, 0.10915276156512876, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.047300525628151124, 0.04590851437015109, 0.04195507307649027, 0.027156561631382026, 0.0365570757559045, 0.026315164515337885, 0.1454989390666691, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4283087430721495, -0.41269194982762225, -0.43790308531141986, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3490197677104434, -0.37689426117953984, -0.3211185880957439, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3660393568454523, -0.3664471077253806, -0.38684328994647466, -0.3158934401443745, -0.2938195407216102, -0.276441680394119, -0.3724163789317205, -0.37403696753864035, -0.36766239305685655, -0.2875074129061834, -0.29935206652949753, -0.32440460708271446, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3980371547268675, -0.40257486164467426, -0.4031405446034979, -0.427442088864445, -0.4248902944961461, -0.38404416935159724, -0.24337173541141555, -0.21683156769449208, -0.26535908903943195, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999]}}
{"id": "0015d714-bdcb-4b24-82f7-f8de44c7733b", "fitness": -0.15322153831646637, "name": "MultiPhaseChaoticPSODE", "description": "Utilize multi-phase exploration-exploitation cycles with adaptive chaotic control for enhanced convergence stability.", "code": "import numpy as np\n\nclass MultiPhaseChaoticPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.de_f = 0.5\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2\n        mutation_strength = 0.2\n        phases = [0.3, 0.6, 1.0] # Define exploration-exploitation phases\n        phase_index = 0\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Multi-phase exploration-exploitation strategy\n            if evals / self.budget > phases[phase_index]:\n                phase_index += 1\n                self.population_size = max(5, int(self.initial_population_size * (1 - 0.2 * phase_index)))\n                adapt_lr += 0.05\n\n            # Adjust adaptive parameters with chaotic control\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n\n            # Adaptive mutation strength\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            # Elite retention\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 51, "feedback": "The algorithm MultiPhaseChaoticPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.15322 with standard deviation 0.29211.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.11453983495321585, 0.13041552732377493, 0.19756065946622103, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027411909020072067, 0.03876287303229331, 0.027451163575815563, 0.04189857959866261, 0.03282051063391056, 0.020000000000000018, 0.05629403171828107, 0.04825325653442547, 0.05441382168072517, 0.020000000000000018, 0.07021730539022941, 0.020000000000000018, 0.08011482973822615, 0.09404191616084001, 0.09652877437760199, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13986048556947028, 0.13193815568868217, 0.17544010209917194, 0.030401382940906663, 0.02030332030046733, 0.020000000000000018, 0.08072694858327945, 0.09401569336223137, 0.08564182323259895, 0.1380638907577213, 0.14854892338591807, 0.12651866735422912, 0.08212424003978247, 0.07999543433062395, 0.1025607977710139, 0.1423007878646516, 0.12439558891789715, 0.12191976134240401, 0.024101804866960452, 0.10754015738039835, 0.11619582976424314, 0.11960804369145084, 0.08131844247973485, 0.08381861132633617, 0.07209790169319763, 0.08175493928643451, 0.04421651546148331, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.055468386813428805, 0.031379704466177105, 0.03785043365134433, 0.05351785604843029, 0.04270867342512219, 0.06310916675661005, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013993847354511924, 0.01156322289144096, 0.011383470563646525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010041836001067006, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08696032054346314, 0.08442639153125764, 0.08187993743635913, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.060641237183017616, 0.06220969184090985, 0.06006123988153933, 0.14092514619487118, 0.10632114617308286, 0.10627772324511653, 0.0816607480453112, 0.05249050173483627, 0.05431859998320432, 0.0992901733811693, 0.08180770459251907, 0.10471916563369765, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04563565632420519, 0.04398859984199588, 0.044817561454861155, 0.02610700216596329, 0.03402104081335122, 0.0261698076597221, 0.1454989390666691, 0.13450660276577187, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.5879099598330819, -0.5703577411090452, -0.5914024004198688, -0.6000000000000001, -0.5800000000000001, -0.6000000000000001, -0.5800000000000001, -0.5800000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.5800000000000001, -0.5800000000000001, -0.5800000000000001, -0.5800000000000001, -0.5800000000000001, -0.6200000000000001, -0.5800000000000001, -0.6000000000000001, -0.5800000000000001, -0.5800000000000001, -0.6000000000000001, -0.6000000000000001, -0.5800000000000001, -0.5800000000000001, -0.5800000000000001, -0.5800000000000001, -0.5800000000000001, -0.6000000000000001, -0.5800000000000001, -0.6200000000000001, -0.6000000000000001, -0.5800000000000001, -0.6200000000000001, -0.6000000000000001, -0.5800000000000001, -0.5800000000000001, -0.5800000000000001, -0.500632494758319, -0.5284290671218421, -0.48935187135934166, -0.6000000000000001, -0.6000000000000001, -0.5800000000000001, -0.5250924572933169, -0.5201244106862786, -0.5172966609242766, -0.4608257776806184, -0.4385282648566651, -0.43853089469716533, -0.5209546668294482, -0.5470454200827108, -0.5427444429687742, -0.4685866433196213, -0.47051213566355043, -0.4536687160676658, -0.6000000000000001, -0.6000000000000001, -0.6000000000000001, -0.5551547487187543, -0.5803817826128568, -0.580709678097699, -0.5676344320950375, -0.5632998898307195, -0.5616065674475224, -0.3911641937281838, -0.37309302441447834, -0.3909807800975804, -0.6000000000000001, -0.5800000000000001, -0.6000000000000001]}}
{"id": "f4ed1b4d-549c-436c-aa92-58f1be492df0", "fitness": -0.0981032226627761, "name": "RefinedChaoticAdaptiveHybridPSODE", "description": "Introduce a time-varying self-adaptive chaotic sequence and elite competition to enhance exploration-exploitation balance and dynamic adaptation.", "code": "import numpy as np\n\nclass RefinedChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + dim\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.de_f = 0.5\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        fail_count = 0\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n                    fail_count = 0  # Reset fail count on improvement\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n\n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_rate += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n                else:\n                    fail_count += 1\n\n            if fail_count >= self.population_size:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n                fail_count = 0\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 52, "feedback": "The algorithm RefinedChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09810 with standard deviation 0.21367.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.19293752825479915, 0.1093389874641475, 0.14453393126688718, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02690534805372291, 0.03851964444085054, 0.020000000000000018, 0.04144460974706832, 0.020000000000000018, 0.020000000000000018, 0.05223922850379703, 0.04803004719950876, 0.05408130782633469, 0.020000000000000018, 0.07024129674431412, 0.020000000000000018, 0.052838387437443735, 0.09404191616084001, 0.09241837735918434, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13668029297997775, 0.1317636376569037, 0.17554332802095762, 0.030235385599934106, 0.020000000000000018, 0.0352976119531444, 0.08072694858327945, 0.08737731523890613, 0.08242141071471532, 0.13815927669420636, 0.1452932159561945, 0.13649033629444707, 0.07261016608596949, 0.08335059048363325, 0.10379147359840235, 0.12652195504355657, 0.11856313698691412, 0.12511329591983056, 0.020000000000000018, 0.020000000000000018, 0.11609137198570951, 0.10819636878037442, 0.08831757469660173, 0.08366175829913824, 0.06527120746322768, 0.07448080566056292, 0.04434729390011749, 0.144959531197552, 0.15474685019612966, 0.15475448018179316, 0.04931658595224098, 0.03220554669869724, 0.06716083258991579, 0.05360401329920772, 0.04385220934070744, 0.06278950550036111, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014918356874482064, 0.010582620178489655, 0.010874072841211224, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08246766695468521, 0.0834649571880618, 0.08272009958825055, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06631901574105814, 0.0662210723656067, 0.05863427214923689, 0.1187289867240513, 0.1080991493253678, 0.10558971274334117, 0.08234770728992624, 0.04576066881470198, 0.053936809511723194, 0.09309900151164852, 0.08539689002598028, 0.10041220826278452, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04975226933425925, 0.04409652951398502, 0.030018994901093388, 0.026224051715555974, 0.035858652957239445, 0.024640285494433645, 0.1400717432342391, 0.1432908446542791, 0.13387217297901033, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.43082486339231485, -0.3966578936359384, -0.41849322577007486, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3496305203692145, -0.358974564613773, -0.321980714020379, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.34858376184135986, -0.3608317652983397, -0.36508668978741476, -0.2925955656054804, -0.2874101673033891, -0.2781687115338678, -0.3980239289017786, -0.3747789002977775, -0.3691437935885977, -0.30147577040663, -0.2881037434353484, -0.2869508429031882, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.39806159718362233, -0.4057362228303314, -0.3998329347438374, -0.4283521586932302, -0.42491826964216206, -0.3841193448483826, -0.23170769302828598, -0.21649380525489126, -0.2620233831169396, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999]}}
{"id": "31033c40-3a27-4597-8c4a-18b83570d4ea", "fitness": -0.09784923565847402, "name": "EnhancedChaoticHybridPSO_DE", "description": "Introduce a dynamic chaotic sequence and adaptive learning for better exploration-exploitation balance and enhanced convergence in high-dimensional spaces.", "code": "import numpy as np\n\nclass EnhancedChaoticHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.3  # Enhanced adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Dynamic chaotic sequence adjustment\n            chaotic_factor = np.sin(self.chaotic_seq[evals % self.budget] * np.pi)\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedChaoticHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09785 with standard deviation 0.21432.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.1260176074976067, 0.13042725971044378, 0.1684291431446201, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027525566129716017, 0.03134820191202048, 0.032782072682007724, 0.04018014535237158, 0.020100618406337145, 0.020000000000000018, 0.08420948005930906, 0.04840545105877336, 0.05697708037553184, 0.020000000000000018, 0.07087616322042523, 0.020000000000000018, 0.049535420542290765, 0.09404191616084001, 0.09222728885214504, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1383412123460792, 0.13350118024605906, 0.1767605877182732, 0.02997577498948667, 0.026580796661509698, 0.020000000000000018, 0.08072694858327945, 0.08724109652437362, 0.08837373878783916, 0.14086714281083912, 0.14703815665415276, 0.13734728445485278, 0.07657874478631765, 0.09376708283061785, 0.10971028283437045, 0.13167685700080511, 0.113476223919734, 0.12575912943109102, 0.020000000000000018, 0.10219154298442934, 0.11569521126230609, 0.10819636878037442, 0.07944123418306615, 0.08374193856552414, 0.09610238813166061, 0.08106300629297836, 0.04429582077567917, 0.1441224611051679, 0.13589170657517036, 0.15475448018179316, 0.04788948417157368, 0.028687064647483274, 0.03207576478422414, 0.053661083498457995, 0.04242484088482268, 0.06315858781787487, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.022366825485902075, 0.011400268670807678, 0.01958722544882463, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0853341662698418, 0.08501704452278713, 0.08182105951713325, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06359780435623774, 0.06505093013281993, 0.060960191510210815, 0.13121730999787684, 0.10886674970598409, 0.10562621606324507, 0.08344173329412707, 0.05129526556749331, 0.053936809511723194, 0.0936653021448195, 0.08850560702159416, 0.10121937100171308, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0449738879536149, 0.04249518687397302, 0.03545301182742333, 0.026502984335373014, 0.0340592379813357, 0.024640285494433645, 0.1355982135360222, 0.13123409970527322, 0.1438711197317768, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4296598810977039, -0.4116238100581353, -0.4185570193304553, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3493787007404874, -0.3778878107509467, -0.3210372061824245, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3702140500682327, -0.3597193458459125, -0.3678475604883906, -0.31499943871833747, -0.29272684385173187, -0.2778871931168434, -0.3956565534241676, -0.3732316591853473, -0.38173949684349817, -0.30322406876284713, -0.31138670675457725, -0.29161348102589946, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3982674099235086, -0.4032827335653182, -0.38326546275593776, -0.42776975387020766, -0.42491180108533166, -0.3844698576923786, -0.25380052421785915, -0.23419395177449043, -0.23301912908849154, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999]}}
{"id": "2cf59a10-f410-4aa2-8e0b-c416d8ab3f8f", "fitness": -0.09834607977069235, "name": "EnhancedChaoticAdaptiveHybridPSODE", "description": "Implement a multi-phase chaotic learning strategy with adaptive elitism to enhance both exploration and exploitation dynamics.", "code": "import numpy as np\n\nclass EnhancedChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + dim\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.de_f = 0.6\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evals = 0\n        adaptation_factor = 0.1\n        mutation_strength = 0.2\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adaptation_factor * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adaptation_factor * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adaptation_factor * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n\n            if evals > self.budget * 0.4:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            if self.exploration_phase and evals > self.budget * 0.6:\n                self.exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adaptation_factor += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            adaptive_factor = 0.5 + 0.5 * np.sin((evals / self.budget) * np.pi)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 3) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09835 with standard deviation 0.21452.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.11740230923217465, 0.12354471315875226, 0.19334640273144632, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.031069287726062655, 0.035864152011450545, 0.03000954785912424, 0.038310429673475754, 0.020000000000000018, 0.020000000000000018, 0.07745398375282353, 0.05241556202990583, 0.05638130836375066, 0.020000000000000018, 0.07006123768375916, 0.020000000000000018, 0.05083818492199366, 0.09404191616084001, 0.10033145749282069, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13907093405512627, 0.14660070257603341, 0.1756665272176211, 0.026231469559475307, 0.027112072536212506, 0.020000000000000018, 0.08767980418285215, 0.09580766968023402, 0.09346972834913769, 0.14055762110167924, 0.15112014673506424, 0.1160417955509998, 0.07171347352559398, 0.0816222003868593, 0.11225650969101164, 0.12951241119165813, 0.1161373894913783, 0.14447326801182125, 0.020000000000000018, 0.020000000000000018, 0.11566541708244671, 0.10819636878037442, 0.07940499772194898, 0.08400066281029706, 0.06527120746322768, 0.07663946935566512, 0.04454790483931903, 0.15165531332901538, 0.13589170657517036, 0.15475448018179316, 0.04843891609764672, 0.029020760634974718, 0.035472715348539574, 0.053524848319417395, 0.042189023347267596, 0.0627712672527041, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018556318724121557, 0.011293821800290926, 0.015390643734804144, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0881992399171585, 0.08947962942054599, 0.08370757188418221, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06915821771361752, 0.06147825531143891, 0.057916035996093074, 0.11869262382913237, 0.10908151706175073, 0.10673670973947191, 0.0817281449642282, 0.049919475078425646, 0.053936809511723194, 0.09557387530466821, 0.09153520700524709, 0.10451922989560303, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04588061215567851, 0.044893158482667284, 0.03717253725201064, 0.02676625073654737, 0.03320390178221866, 0.024640285494433645, 0.14963100196860335, 0.13228466429508057, 0.13836235487328064, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4105703949526949, -0.4123911758809322, -0.41861865321536706, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.34699292588997843, -0.34980130916308827, -0.3211253732437003, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.36743014372714833, -0.3659287407299521, -0.37177825510034324, -0.29731122766174, -0.28768731071277065, -0.2775944245729789, -0.3889857613676839, -0.3738159307657576, -0.3815532151566705, -0.3285421814646572, -0.30368618655346014, -0.30743515495565, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.39860191137973633, -0.4040402631809592, -0.3832649424347867, -0.4284294611090389, -0.42486601661468515, -0.3843223986306554, -0.25532825110261426, -0.21683156769449208, -0.24914742292197678, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993]}}
{"id": "082c0ef8-35b0-4e3d-872a-dd55b0713a7e", "fitness": -0.1004773434623662, "name": "ChaoticAdaptiveHybridPSODE", "description": "Enhance dynamic adaptation by refining chaotic sequences and tuning learning rates for improved exploration and convergence stability.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        # Refined chaotic sequence for better adaptation\n        self.chaotic_seq = np.sin(np.linspace(0, 5 * np.pi, self.budget))\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        # Slightly increased adaptive learning rate\n        adapt_lr = 0.25  \n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 55, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.10048 with standard deviation 0.21707.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.1127637020247576, 0.15590486216681965, 0.15084256353333247, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029495031311697395, 0.03492894559798809, 0.02106880423521129, 0.03384196303904441, 0.027634208600744725, 0.022613093289269415, 0.08523540155099751, 0.090206985912194, 0.05489102654221101, 0.020000000000000018, 0.02026272843151533, 0.020000000000000018, 0.0658695623267519, 0.08594148016760361, 0.077871059101561, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12486743279184287, 0.12749615539472137, 0.15731165825006943, 0.0299356331882763, 0.020064247990678297, 0.02289423162655968, 0.08072694858327945, 0.0863116411064907, 0.07402677215690856, 0.13684695951895476, 0.15810479032452207, 0.12724836677744333, 0.08179309620195185, 0.08534283831525269, 0.07102658134973217, 0.13335610628283634, 0.12091627916717174, 0.13659453189947457, 0.020000000000000018, 0.03592059843438311, 0.1218473653903357, 0.10819636878037442, 0.08018118772220328, 0.08413244527261898, 0.06527120746322768, 0.09415715223509491, 0.04573904280293517, 0.1438526290318487, 0.13596538936856262, 0.15475448018179316, 0.060370698467569484, 0.03834981779130853, 0.03014751441915786, 0.06358199375260387, 0.03497878980581315, 0.06920197186391652, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01676092453346556, 0.011701645203377242, 0.014362293832729467, 0.010000000000000009, 0.010738750836116417, 0.010000000000000009, 0.01171232134529121, 0.02522650015429395, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08908249106587629, 0.07180883667835314, 0.0904563248709015, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08407066174794342, 0.06147825531143891, 0.06350063185716082, 0.12392252625634637, 0.10611239783556015, 0.11075049865315234, 0.06889580520930683, 0.052383953094250146, 0.05528278344593529, 0.09849290840177505, 0.08444854042495065, 0.10686719799615019, 0.01967783865088757, 0.010000000000000009, 0.010000000000000009, 0.04933806849645861, 0.041666848493350006, 0.0427920426183358, 0.02947462596204109, 0.025007340680049617, 0.038959094685454665, 0.13141309820135194, 0.1369486595774747, 0.13679789151535038, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.41897698372351466, -0.4390955264835592, -0.4147549372070243, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.36782212491060373, -0.34491286870869575, -0.34876323189211833, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.38639004083409967, -0.3658938974500807, -0.33645219399152015, -0.2894391979456683, -0.26916866164664843, -0.3175710585413085, -0.3725783167507395, -0.3660144701285586, -0.3517787567398176, -0.3110453821277963, -0.29284650127443235, -0.2919840870246353, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.40234498730769475, -0.4063154224883945, -0.4031519198842175, -0.4281807695396225, -0.4251905059011343, -0.42683323636450754, -0.23095732554639414, -0.21683156769449208, -0.25882831494056835, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993]}}
{"id": "354e64ce-42a1-463e-a04b-5eed853913a8", "fitness": -0.09786846458246944, "name": "EnhancedChaoticAdaptiveHybridPSODE", "description": "Enhance the adaptive hybrid PSO-DE by introducing a spiral flight strategy to improve local search capability and convergence speed.", "code": "import numpy as np\n\nclass EnhancedChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.de_f = 0.5\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            spiral_factor = 0.05  # Spiral flight factor\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                spiral_movement = spiral_factor * (self.population[i] - self.gbest_position)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social + spiral_movement\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09787 with standard deviation 0.21531.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.11637635758478526, 0.13502418952421125, 0.19600190396921935, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03216842294416866, 0.030743310884838615, 0.03786044268470279, 0.028456068220783948, 0.02031100082856918, 0.020000000000000018, 0.05629403171828107, 0.04855147852163666, 0.05564082611405663, 0.020000000000000018, 0.06174240237612805, 0.020000000000000018, 0.05642914686915712, 0.09404191616084001, 0.09437459126165071, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03524963694312222, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1372608791300195, 0.13421485485439333, 0.1694151213732905, 0.026721335427948634, 0.02657961841693146, 0.027001453926323027, 0.08092618901276016, 0.08925545384264755, 0.07626171396259818, 0.13350495052556122, 0.1450970587651974, 0.14709992132162086, 0.08810718822755492, 0.08273963000889961, 0.10631003051336607, 0.13629768601197956, 0.10820044512759286, 0.13635351531125617, 0.020000000000000018, 0.11215665081114423, 0.11272062544968176, 0.10819636878037442, 0.08204448412420429, 0.08282422390945199, 0.07209790169319763, 0.0798390267411242, 0.04462598168278675, 0.19352819798556153, 0.13589170657517036, 0.15475448018179316, 0.06070362797579265, 0.03421892554336792, 0.043422111254352136, 0.054282475177819145, 0.043424211599549345, 0.06253836994050033, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0149729179997109, 0.011113076411105038, 0.012372569421109758, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08766010024138227, 0.08582076694934537, 0.08068007355490092, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08551775175727283, 0.06147825531143891, 0.05395939349942802, 0.14012393729252481, 0.10455500533762918, 0.10699000941555992, 0.0747946806741353, 0.0504934939957703, 0.05623204985743402, 0.10400828233493098, 0.08641065695245442, 0.10111033791933377, 0.018724037978008035, 0.010000000000000009, 0.010000000000000009, 0.04809966639567076, 0.03748333871938936, 0.03921296519215478, 0.026480522955282138, 0.030794712064255214, 0.02625290592293661, 0.15124169605733473, 0.13246624490062908, 0.13710047586595664, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.42923319730708975, -0.4133537946596868, -0.4377835947389199, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3509557219040891, -0.3789786302748368, -0.3221406400497806, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3925483172210944, -0.34192327045286564, -0.3838194275835147, -0.29556457154527327, -0.29276485001815633, -0.2977457315428882, -0.3923738506594403, -0.3748799037072803, -0.3877182616363044, -0.30951609494030774, -0.30581565240075226, -0.3099498566659029, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.398464201175287, -0.40350737675111326, -0.40334167369566876, -0.4274558627880489, -0.40515074743985413, -0.38420692014001867, -0.25157850133349524, -0.21683156769449208, -0.27601819825628815, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999]}}
{"id": "6df69e92-36cf-4789-a78c-fe255cf03d92", "fitness": -0.09866318485988312, "name": "EnhancedChaoticAdaptivePSODE", "description": "Enhance the Chaotic Adaptive Hybrid PSO-DE with adaptive mutation and elitist learning to improve convergence and prevent stagnation.", "code": "import numpy as np\n\nclass EnhancedChaoticAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.de_f = 0.5\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.3\n        cooling_factor = 0.995\n        exploration_phase = True\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedChaoticAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09866 with standard deviation 0.21681.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.11535794106089237, 0.1452241182189863, 0.14843605255262649, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05371118490400817, 0.031461840463225865, 0.020256650144379384, 0.02139551032356768, 0.020000000000000018, 0.020000000000000018, 0.06825405699773346, 0.062107279014857575, 0.04956030618232932, 0.020000000000000018, 0.07048754725144135, 0.020000000000000018, 0.049066188566372126, 0.10999400696974637, 0.08579395251570776, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.18019323190700154, 0.12565769920852743, 0.1617026411840896, 0.021077155653890123, 0.022232109416723156, 0.028630969589376276, 0.08072694858327945, 0.0863116411064907, 0.07791853974891838, 0.14201855795506957, 0.14505783902326796, 0.13564410949782368, 0.08020853384035542, 0.07990382579724953, 0.07696633695507271, 0.11857398167266131, 0.15018735791623894, 0.12487110763947906, 0.13381478137658798, 0.12269790737237518, 0.12665999657401406, 0.11836298672387613, 0.07989206183164721, 0.08214009836555358, 0.06527120746322768, 0.04965204560599734, 0.051203484544320776, 0.15411205457524546, 0.13589170657517036, 0.15475448018179316, 0.04483202558532018, 0.043844016778165074, 0.03826264690479908, 0.060243308476466195, 0.050983867750399425, 0.05931472069845045, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01726822020134633, 0.017056733282007075, 0.010854416048814541, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02436533472890201, 0.010335958139947254, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0894116417084102, 0.0855256622574303, 0.09100403072900487, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.060411312730307865, 0.06147825531143891, 0.06836117333804492, 0.12176868843499156, 0.11469569675458047, 0.1083360644902025, 0.07012727182402234, 0.053014573449427504, 0.058556407442625025, 0.10332402860040413, 0.0932222931523442, 0.10694177353451939, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028352019421512553, 0.035244968362127316, 0.06927159331508848, 0.02573650532952798, 0.036540766695076776, 0.027883804755115538, 0.13799249760919774, 0.13123409970527322, 0.13493520713850327, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.42178744208564467, -0.4386748416030437, -0.41754763960022734, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.35897617308250585, -0.36256784191475133, -0.3472903169210715, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.39400178400324526, -0.36561140923329827, -0.37071483454310794, -0.30844072506109965, -0.2956879770730909, -0.2940625656523712, -0.3667019576528705, -0.3719676719679288, -0.3895192825789735, -0.3194549061976264, -0.31356880258527875, -0.29119617221788463, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.42179003591598385, -0.38422164315271545, -0.38286370648107426, -0.40529669751877173, -0.40418783238603817, -0.4067615435031855, -0.27112929753951187, -0.23419395177449043, -0.24720449522395693, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999]}}
{"id": "94abc247-af27-40e9-b1e0-a597675cd847", "fitness": -0.09904491480577332, "name": "ChaoticAdaptiveHybridPSODE", "description": "Incorporate a dynamic elite retention strategy and exploit local diversity for improved exploration and convergence.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2  # Adjusted adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Dynamic elite retention strategy using adaptive threshold\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 8)]\n\n            # Exploit local diversity to escape local minima\n            diversity_factor = np.std(self.population, axis=0)\n\n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social + diversity_factor\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 58, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09904 with standard deviation 0.21390.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.09936432694173292, 0.11835763857349946, 0.13015625223022687, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.025964310189995343, 0.04191910386808184, 0.08959489582620217, 0.09131922059994968, 0.07360082502588494, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06717439771005407, 0.08594148016760361, 0.057929235093625686, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13641381298249655, 0.1391638616339983, 0.13364579351627082, 0.034801183403886826, 0.020000000000000018, 0.020000000000000018, 0.11707487629602131, 0.0863116411064907, 0.07456266074899787, 0.13242664937262616, 0.13323277534341382, 0.13536784462028495, 0.08986066121852132, 0.09467927434997658, 0.09431459220782079, 0.1152745358618128, 0.12407321678742167, 0.12191976134240401, 0.020000000000000018, 0.1030568848168898, 0.1275630200847666, 0.10819636878037442, 0.07791720983440653, 0.07667167264800068, 0.07209790169319763, 0.09642454661892441, 0.05171309646446898, 0.1438526290318487, 0.16200576468501238, 0.15475448018179316, 0.038669801718039354, 0.060117680308169996, 0.03758931011732802, 0.05416262324930865, 0.03816594242348759, 0.053162052117226355, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0173170775235596, 0.014344224968177888, 0.010982393489820996, 0.010000000000000009, 0.01393624622023737, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011478917163436186, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0952889329072093, 0.0780966232157343, 0.08729956687500162, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05621143213674229, 0.07045274847226035, 0.05395939349942802, 0.11869262382913237, 0.11197598454222901, 0.11845017496544175, 0.05756835603815702, 0.0640858017881969, 0.054738598414531325, 0.07918790021730127, 0.08657996279071567, 0.097000241325093, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029248592613612345, 0.029043163533977734, 0.03295428915180654, 0.025606193640062447, 0.02557036848307903, 0.024640285494433645, 0.14582648967935596, 0.14274748812636417, 0.1373691138434736, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4250678711954905, -0.418432272151241, -0.41995706692834767, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.34412623476831383, -0.3558244015871992, -0.35147229269999336, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3367829423972688, -0.3664471077253806, -0.389460725846587, -0.30474365905384615, -0.2827164463805971, -0.30534005392032215, -0.3755971980051094, -0.3818028375494713, -0.39167550563112163, -0.3038244621764912, -0.30420836113296534, -0.3216596369934277, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.40498528110359566, -0.40556563842827065, -0.38664398499285246, -0.4293501418353223, -0.4054506279581167, -0.3879026393811891, -0.2653847800039406, -0.21683156769449208, -0.26366685724720584, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993]}}
{"id": "4487578f-9e4f-48fa-b845-e950974ee9f6", "fitness": -0.10747442362091351, "name": "ChaoticAdaptiveHybridPSODE", "description": "Integrate adaptive chaotic dynamics with a hybrid local search to enhance both exploration and exploitation.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2  # Adjusted adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            # Hybrid local search in high diversity\n            if np.std(self.pbest_scores) > 0.1 and evals < self.budget * 0.75:\n                local_search_indices = np.random.choice(self.population_size, 3, replace=False)\n                for idx in local_search_indices:\n                    local_candidate = self.population[idx] + 0.1 * np.random.normal(0, 1, self.dim)\n                    local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                    candidate_score = func(local_candidate)\n                    evals += 1\n                    if candidate_score < self.pbest_scores[idx]:\n                        self.pbest_positions[idx] = local_candidate\n                        self.pbest_scores[idx] = candidate_score\n                        if candidate_score < self.gbest_score:\n                            self.gbest_score = candidate_score\n                            self.gbest_position = local_candidate\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 59, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.10747 with standard deviation 0.22862.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.11613788550553605, 0.1316437029836911, 0.19666441963080616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03070587982457651, 0.031427180025650925, 0.03733070375439629, 0.031010621654634307, 0.021473048221546276, 0.020000000000000018, 0.05629403171828107, 0.0483113550742752, 0.05089209971620623, 0.020000000000000018, 0.0725683207591249, 0.020000000000000018, 0.0630104829836422, 0.11307337064675893, 0.09158185750579972, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020921449318437313, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13944824440624615, 0.133523182924157, 0.1709984093697824, 0.021385067413101755, 0.020688167064402574, 0.02069636810101949, 0.09239883488803546, 0.0863116411064907, 0.08597266258711966, 0.13661016016412697, 0.14704797749762866, 0.1548386421627942, 0.08016097402179245, 0.08205530239750969, 0.12224881968238543, 0.12628442028552056, 0.11069276846070286, 0.13606945089425948, 0.020000000000000018, 0.10191068643713241, 0.11421629740479267, 0.1167491119834082, 0.0794977424328972, 0.0825004054220071, 0.07209790169319763, 0.08155451686178228, 0.06043424313915691, 0.1438526290318487, 0.13589170657517036, 0.17843056125529133, 0.05772063778208536, 0.034175513010364145, 0.03719056228929729, 0.053537793969102965, 0.04263973656998399, 0.06482667939803821, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014503685363153274, 0.010652734413901355, 0.012370108067080943, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0862068493243785, 0.08437478634068651, 0.0821377225062464, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06130818542910277, 0.06317600010493662, 0.059821883421573574, 0.13326244135029586, 0.10586009980999134, 0.1064823024895084, 0.0755629809051096, 0.05305590729763976, 0.059441287134365584, 0.10220284232959942, 0.0923795767309109, 0.10862487942223198, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.047300525628151124, 0.04087736154092558, 0.041615890614065454, 0.026242216145481723, 0.03228001551395365, 0.026315164515337885, 0.1454989390666691, 0.13186025048878636, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4594749748337523, -0.44247150078132336, -0.465336093389378, -0.44999999999999996, -0.42999999999999994, -0.44999999999999996, -0.44999999999999996, -0.44999999999999996, -0.44999999999999996, -0.47, -0.47, -0.44999999999999996, -0.42999999999999994, -0.44999999999999996, -0.47, -0.44999999999999996, -0.42999999999999994, -0.47, -0.44999999999999996, -0.44999999999999996, -0.44999999999999996, -0.44999999999999996, -0.42999999999999994, -0.44999999999999996, -0.44999999999999996, -0.42999999999999994, -0.44999999999999996, -0.44999999999999996, -0.42999999999999994, -0.47, -0.42999999999999994, -0.47, -0.42999999999999994, -0.44999999999999996, -0.47, -0.47, -0.42999999999999994, -0.42999999999999994, -0.44999999999999996, -0.3795670118687602, -0.40664858250803726, -0.3492324029634677, -0.44999999999999996, -0.44999999999999996, -0.42999999999999994, -0.39753498609867544, -0.3953027677454677, -0.41544341950221275, -0.34371527576314187, -0.32181324997207206, -0.3036505335031463, -0.40067306337235076, -0.402832475785047, -0.3963792866629072, -0.3143590469765578, -0.3266106168830907, -0.35156522787897604, -0.44999999999999996, -0.47, -0.44999999999999996, -0.42776576660455135, -0.43233280713291133, -0.43248762170385224, -0.45692020875487493, -0.45460063251133964, -0.41349429389161463, -0.275015537447707, -0.24287514381448982, -0.29127509013631614, -0.47, -0.42999999999999994, -0.42999999999999994]}}
{"id": "ee1fcc4d-e29b-473d-8b20-1098d351461d", "fitness": -0.09974852806408975, "name": "ChaoticAdaptiveHybridPSODE", "description": "Enhance elite retention and dynamic velocity scaling to improve convergence stability and solution quality.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2  # Adjusted adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(3, self.population_size // 9)]  # Changed line\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.6 + 0.4 * np.sin(angle)  # Changed line\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 60, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09975 with standard deviation 0.21886.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.12190918689276942, 0.13141529249230022, 0.18801997719352737, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034913359041342074, 0.031993797071085184, 0.020000000000000018, 0.031814702443226706, 0.020000000000000018, 0.02671989190083257, 0.05629403171828107, 0.04829993730917237, 0.055488980979538916, 0.020000000000000018, 0.07077737908670212, 0.020000000000000018, 0.07016579530109734, 0.10583144113652354, 0.09500174950709894, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03880150140030603, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1307525277048046, 0.12748495913837887, 0.17191138687601581, 0.020503344253462896, 0.020000000000000018, 0.020187114324180633, 0.08170635077043842, 0.08642042526603488, 0.07585332763649888, 0.13988639127625357, 0.14644452216233428, 0.12858785419160823, 0.08509711780933682, 0.07990382579724953, 0.10801130788400226, 0.13472198001799507, 0.112976287267324, 0.15535818042132976, 0.020000000000000018, 0.10839637100612431, 0.12175655932700413, 0.12028308144478872, 0.08350049903777634, 0.08331432064682243, 0.07209790169319763, 0.08858517043649439, 0.044630699424787146, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.053022675706936195, 0.03439358399284065, 0.033033686679056595, 0.05141410756343945, 0.03939403420412635, 0.06340014982908349, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015149344355762984, 0.013022359748528056, 0.012813529480927843, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016081426374148555, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08428670516250758, 0.08432872735526586, 0.08133325014357129, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06325465376367168, 0.06147825531143891, 0.059352066521168645, 0.14096098707511207, 0.10682517846822837, 0.11478863107170656, 0.06977003196588771, 0.05441366162225647, 0.053936809511723194, 0.10427482517607967, 0.08957261446039444, 0.10728859314828132, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05426474310966978, 0.03948259258672637, 0.03927975123217453, 0.025586070038658537, 0.03809460922682173, 0.026152258427582953, 0.1454989390666691, 0.134102203504876, 0.13766671020454324, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4086653149638537, -0.3928915406905278, -0.41724852556199377, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.53, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.53, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.53, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.53, -0.41999999999999993, -0.3307165087610928, -0.3770296124769479, -0.3212959497578616, -0.3999999999999999, -0.41999999999999993, -0.53, -0.367144791572662, -0.3664471077253806, -0.3855042309071244, -0.29747397338002735, -0.2937100885253341, -0.2759500321778672, -0.3533577914011343, -0.37370048517012955, -0.36892219153981576, -0.3029554543551296, -0.2911815994753508, -0.30714031367380157, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.398073691605662, -0.40259360253967946, -0.4031295524519387, -0.4078019270824915, -0.40513009616294515, -0.5123879550445596, -0.23682639079551304, -0.21683156769449208, -0.23960687751679943, -0.41999999999999993, -0.53, -0.41999999999999993]}}
{"id": "ae427d4a-be54-413c-a7bb-aff5325c85e7", "fitness": -0.09818483147728221, "name": "EnhancedStochasticAdaptivePSODE", "description": "Introduce a stochastic approach with dynamic population resizing and enhanced adaptive strategies to improve exploration and exploitation balance. ", "code": "import numpy as np\n\nclass EnhancedStochasticAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.de_f = 0.5\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        dynamic_lr = 0.1\n        cooling_factor = 0.993\n        mutation_strength_base = 0.2\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - dynamic_lr * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + dynamic_lr * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + dynamic_lr * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = mutation_strength_base * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.7:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                dynamic_lr += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedStochasticAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09818 with standard deviation 0.21505.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.12436714397272386, 0.12235673827568183, 0.20400141569640484, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02750675848485573, 0.031531471364200425, 0.030284427638727518, 0.030698308449722878, 0.020000000000000018, 0.020000000000000018, 0.058845738212551124, 0.04853961385992567, 0.056086436833824416, 0.020000000000000018, 0.07089384635673146, 0.020000000000000018, 0.06550887084860113, 0.09404191616084001, 0.0950505622715504, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13947286441074203, 0.1339546872627767, 0.171119402741715, 0.024476350366439914, 0.030303931852264432, 0.02475238109492839, 0.0885051373990623, 0.0863116411064907, 0.07232415580757168, 0.13895788438825296, 0.14239434574423493, 0.1375909412389268, 0.0948726739662692, 0.08226961648194986, 0.12293030786313397, 0.13312750414976715, 0.12974717624828092, 0.1421428628546395, 0.020000000000000018, 0.0750244576132445, 0.11422027348683617, 0.10819636878037442, 0.0790790199552015, 0.08257298268218893, 0.07155336395826506, 0.08065098461017983, 0.044643876085848744, 0.14824922537523832, 0.13589170657517036, 0.15475448018179316, 0.055479891745723986, 0.02910492603058812, 0.04605234584468687, 0.05306293664587902, 0.04237248953259698, 0.06332228594091416, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014960859936309245, 0.010756473469371364, 0.01146054869906632, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08829582749624754, 0.08528232473314712, 0.08460582027377905, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06665068628173632, 0.06532706863603399, 0.056691980158133815, 0.12250737645731835, 0.10664035744748035, 0.10281775224528589, 0.07508266190685975, 0.05372574894278315, 0.059374364344086716, 0.09408258483945209, 0.08856915275361421, 0.11726000708759377, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04767816501465505, 0.04000288822137532, 0.041789274340477744, 0.026553274722852183, 0.03565206960019707, 0.02680108909551282, 0.13333056144601274, 0.13123409970527322, 0.14392324405438361, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4293490132644908, -0.4121178083561601, -0.43838567876026646, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3474105655762987, -0.37698935180878457, -0.3201838910519703, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3729140451457953, -0.362602356457834, -0.3818919090542414, -0.2965811647829679, -0.2676408025167074, -0.2766483632287402, -0.37524480293733764, -0.37259135865803295, -0.36787851742521105, -0.3094597748259216, -0.29843972851801315, -0.3250801006078934, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.39791685494025986, -0.40259541449375735, -0.403179115076735, -0.427312727315464, -0.42493477612965713, -0.38395430585421475, -0.23131984766424663, -0.23419395177449043, -0.2813623632250235, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999]}}
{"id": "19b10ab9-cf0d-40bb-8e32-5453de54cb93", "fitness": -0.09733970983132254, "name": "ChaoticAdaptiveHybridPSODE", "description": "Enhance the adaptive parameters' sensitivity and mutation mechanism to improve convergence and escape local optima.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.15  # Increased chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15  # Increased adaptation rate\n        adapt_lr = 0.25  # Increased adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.25  # Increased mutation strength\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 62, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09734 with standard deviation 0.21447.", "error": "", "parent_ids": ["fc64d1f2-b236-4c91-96ea-58a427ccb92c"], "operator": null, "metadata": {"aucs": [0.1141554727936136, 0.1291459946773138, 0.19203091637009462, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027622625477985108, 0.03142386667611563, 0.026715394377397672, 0.03288674472393549, 0.020000569534250556, 0.020000000000000018, 0.06438790346869505, 0.04837823100889527, 0.056375633295080885, 0.020000000000000018, 0.07088508603758814, 0.020000000000000018, 0.0680124889966035, 0.09404191616084001, 0.10039950825633781, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037290248305882345, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1395413788170765, 0.13350814170425063, 0.1719996502125989, 0.022463136065458134, 0.026611305886414693, 0.026196641259952802, 0.10422776738914119, 0.0863116411064907, 0.06845270485770893, 0.1425387371587593, 0.14691436263125612, 0.12842499322086243, 0.08498365869712288, 0.09523012795212993, 0.10745972239924806, 0.16011617359464625, 0.1288726271894649, 0.1248511980223338, 0.020000000000000018, 0.10218759093435836, 0.11423059695655868, 0.11612890262451148, 0.07940857926055367, 0.08306445120653028, 0.06527120746322768, 0.08127081042661233, 0.044588954914043244, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.06851994257272775, 0.032357983240143384, 0.02951655818548804, 0.053168325289642104, 0.042510807714405296, 0.06339706309210869, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016504377903074796, 0.011193808867652755, 0.013614657099763616, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010060584716275245, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08725522969205468, 0.08473635690528813, 0.08175164220162057, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.061641424263841005, 0.06514149335649189, 0.06269867868296086, 0.13064201961063981, 0.1071409948297517, 0.10281775224528589, 0.06935767099580403, 0.05385251240695188, 0.05856976033432004, 0.10667364048718497, 0.09403696062571709, 0.10432959716801049, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.046793455127402295, 0.04609935005901411, 0.04036594298359897, 0.02722560181051381, 0.03600587603626959, 0.026333848977832197, 0.13544605816634858, 0.13123409970527322, 0.13405854924959404, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.42872201948014843, -0.41228000283968136, -0.418493178452533, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3488191377324876, -0.3772418001673983, -0.3201503867412985, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3670864474300506, -0.3664471077253806, -0.38887905471368023, -0.29590672571009, -0.2917124956091717, -0.2763527562201713, -0.3709375482313231, -0.3738736155347928, -0.3697947618656199, -0.29975376676733223, -0.3013048243832881, -0.30283507601246273, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.39803949792109505, -0.4026504363591412, -0.38332809177903093, -0.42748807889982743, -0.4249215577661112, -0.38411866779517845, -0.24012036900056777, -0.21683156769449208, -0.23544745323712002, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999]}}
{"id": "c6788722-74b4-43b4-a48c-03754ab800c9", "fitness": -0.09949059604901025, "name": "EnhancedChaoticAdaptiveHybridPSODE", "description": "Introduce a dynamic turbulence factor and stochastic chaotic perturbations to enhance diversity and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.de_f = 0.5\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.3  # Increased chaotic sequence range\n        \n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15\n        adapt_lr = 0.25\n        cooling_factor = 0.995\n        mutation_strength = 0.25\n        exploration_phase = True\n        turbulence_factor = 0.1  # New turbulence factor\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n            turbulence_factor *= 0.99  # Decrease turbulence over time\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                turbulence = np.random.uniform(-turbulence_factor, turbulence_factor, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise + turbulence) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09949 with standard deviation 0.21617.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.11062256155179062, 0.10900450297205344, 0.17284491028868276, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03828973884955433, 0.025420499482214365, 0.02476017719199919, 0.028468678233631084, 0.021553356906247267, 0.024487371213427922, 0.08700112990365583, 0.0519992119212066, 0.05891973705100084, 0.020000000000000018, 0.07088931038046864, 0.020000000000000018, 0.07515018111416594, 0.0903237436527834, 0.08368853158772604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02282689366820323, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1469683891348269, 0.10851460868591578, 0.14685185008182056, 0.029087449937092336, 0.02848499760988199, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07461953130066146, 0.14504465527947952, 0.1623862385966105, 0.12438772524066666, 0.0691524292130471, 0.07990382579724953, 0.08297451917767651, 0.1157698509076116, 0.10891976151895255, 0.15125981462420157, 0.10426598761142192, 0.0522645138568012, 0.10963193851249287, 0.11992194606313489, 0.06376509817166165, 0.0866915992254016, 0.09431534410618536, 0.08059256053908925, 0.07612434496044074, 0.1438526290318487, 0.14054632213079965, 0.15475448018179316, 0.0556545647280402, 0.03141077245115165, 0.045059465536579246, 0.07300188557148413, 0.048553976395010356, 0.05949238060707818, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.022137247178860786, 0.012432972155002053, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011406435388777947, 0.010942644638177623, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08534404941069906, 0.08915716189621736, 0.11051059991531187, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.061450063147717504, 0.13787915101654324, 0.10282935699788842, 0.10475450785142337, 0.06644993780611264, 0.04928788945498619, 0.05424555848323209, 0.09973070590970035, 0.09143514886404946, 0.10066558310974005, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028009319628297225, 0.03168028831670344, 0.03434961648147161, 0.025766162742999033, 0.026019304545931266, 0.024640285494433645, 0.13928012057932437, 0.1369413098927691, 0.14318000927977148, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.42990978934206514, -0.41300669189024597, -0.3931423826653053, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.369381694977684, -0.37120654044238943, -0.3548466555212866, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3649484759956838, -0.36364579640795425, -0.36537165612692823, -0.30673036976771817, -0.30478590156241037, -0.2982496660714071, -0.3652911918448867, -0.3932300052649855, -0.3619211711642285, -0.3197160691223351, -0.32810692813952813, -0.31228707923065624, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.4035547844424814, -0.42609381104476607, -0.4023633504697861, -0.4286762358684353, -0.42508094038451993, -0.40605829169130137, -0.2522189397906309, -0.20923138445472045, -0.24503116401418001, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999]}}
{"id": "afef4fcf-6f90-4776-9aa2-d939974971d0", "fitness": -0.18324227637306278, "name": "RefinedChaoticHybridPSODE", "description": "Refine chaotic adaptive hybrid PSO with dynamic adaptive coefficients and elite differential evolution for improved global search capability.", "code": "import numpy as np\n\nclass RefinedChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.7  # increased cognitive component\n        self.c2 = 1.7  # increased social component\n        self.w = 0.7   # increased inertia weight for initial exploration\n        self.de_f = 0.7  # increased DE scaling factor for better exploration\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1  # adjusted chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2\n        cooling_factor = 0.99\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters dynamically\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * cooling_factor + chaotic_factor)\n            self.c1 = self.c1 * (1 + adapt_rate * chaotic_factor)\n            self.c2 = self.c2 * (1 + adapt_rate * chaotic_factor)\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 8)]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * (self.velocities[i]) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-5:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 64, "feedback": "The algorithm RefinedChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.18324 with standard deviation 0.33355.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.11123151356915428, 0.1268357683845729, 0.1482349923082904, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04600678201233965, 0.028081285661856303, 0.02635142573070004, 0.03074713034866816, 0.027062506549470955, 0.020000000000000018, 0.06938143948596687, 0.06687349684233168, 0.04956030618232932, 0.020000000000000018, 0.0695393785071089, 0.020000000000000018, 0.05311066664285302, 0.10624549877115097, 0.108835244314744, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.20024282195415988, 0.12360282465231565, 0.15770127672246248, 0.02348785053117808, 0.020000000000000018, 0.021381676780631853, 0.09328648936549, 0.0863116411064907, 0.09122121504566194, 0.1373949164647903, 0.13547136236270385, 0.14017555159327144, 0.0856513836245465, 0.08075462389285348, 0.07838746634412597, 0.13572404897481338, 0.1199011523223723, 0.13644389629071152, 0.020000000000000018, 0.05209554559956231, 0.09175031823310886, 0.11804051284767947, 0.08479352367742166, 0.08810509852700721, 0.07980221753543015, 0.05118256755527395, 0.0495753909287856, 0.14463976400366718, 0.13589170657517036, 0.15475448018179316, 0.04717573868024916, 0.03829084553544215, 0.04351292292842457, 0.05802158032569438, 0.0491775550462763, 0.058114381392024184, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018187045587629402, 0.020794037381073327, 0.011319301468988074, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0251154239117376, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08786973928997344, 0.08156355849788222, 0.09310550660126604, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06535810137173126, 0.06147825531143891, 0.06760569232419211, 0.12629864396355062, 0.11010859632996328, 0.10655673798489673, 0.06629255885931262, 0.05905477918832025, 0.053936809511723194, 0.10309370300517773, 0.09152657310403367, 0.11293593461838936, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030838502160219328, 0.030950490607424164, 0.07223644669868079, 0.024895242935785933, 0.03548992457137923, 0.03604246069806516, 0.14680305472063027, 0.13640414162575953, 0.13395777555914212, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.6601095112460917, -0.6778049415424992, -0.67995019438469, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6795464530552839, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.5809646685418643, -0.6135046206470463, -0.5941645022354904, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6188200655647844, -0.6142030763730424, -0.6218152828993129, -0.5312804888960412, -0.5180957685678222, -0.5415522625461748, -0.6301974360322986, -0.6330681364185928, -0.6327539737312704, -0.5507273339575574, -0.5505844787036198, -0.5428084833818829, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999, -0.6588716106109123, -0.6611606821323759, -0.6601785001921676, -0.6659789895205572, -0.6606639502647298, -0.664764360160192, -0.47710947397670944, -0.4549467411101533, -0.4846865306898993, -0.6799999999999999, -0.6799999999999999, -0.6799999999999999]}}
{"id": "6a2c8dae-a388-4c0c-8e7f-632eb9b326cf", "fitness": -0.09974497153369132, "name": "ChaoticAdaptiveHybridPSODE", "description": "Fine-tune the elite retention strategy and enhance the velocity update to improve convergence stability.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.15  # Increased chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15  # Increased adaptation rate\n        adapt_lr = 0.25  # Increased adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.25  # Increased mutation strength\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Refine elite retention strategy: preserve more top solutions for stability\n            elites = np.argsort(self.pbest_scores)[:max(3, self.population_size // 8)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.6 + 0.4 * np.sin(angle)  # Adjusted adaptive factor for better stability\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 65, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09974 with standard deviation 0.21936.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.12151081637016647, 0.12894383510979768, 0.18822395236627842, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.021595075485446147, 0.03223679179412553, 0.020000000000000018, 0.02542292358523157, 0.020000000000000018, 0.027730706182956366, 0.06438790346869505, 0.04836694365059235, 0.0561699722943092, 0.020000000000000018, 0.07077547084922875, 0.020000000000000018, 0.058527271700003825, 0.10583144113652354, 0.10039950825633781, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.032033987971872624, 0.04319980952818725, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13365901382557255, 0.12724354130021565, 0.17296333874358572, 0.023345504014219087, 0.0272315461181466, 0.020000000000000018, 0.0840768214961588, 0.0863116411064907, 0.08133064535787471, 0.13819354442210596, 0.14684340060278056, 0.1160417955509998, 0.08724879191699553, 0.07990382579724953, 0.1093749941994605, 0.13073181152650448, 0.12726737874967187, 0.17478590543360595, 0.020000000000000018, 0.10840078871197822, 0.12027029610328399, 0.12332694346556994, 0.08347950654654368, 0.08354791722214994, 0.06527120746322768, 0.08852216954302117, 0.04456832344042738, 0.1527790293337412, 0.13589170657517036, 0.15475448018179316, 0.05214227560844076, 0.03021097473747758, 0.034198045855829085, 0.05716828745695568, 0.03887975014909162, 0.0633284840476882, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015846320611288767, 0.013096247010979556, 0.013750751877175449, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016976418809694027, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08492982944358585, 0.08468114901670021, 0.0836175651602451, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0662106795927585, 0.06147825531143891, 0.059276347491739934, 0.13263544045283093, 0.10900449986011451, 0.11495285053936699, 0.06992609767395397, 0.054550327556904143, 0.05405023668740483, 0.10358367414553837, 0.08995942843778626, 0.09947820516265604, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06752586104006564, 0.03949286442454314, 0.038649769577224324, 0.025403925358732704, 0.037685926079097376, 0.025993977579457983, 0.1365467925767706, 0.131631722726404, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.40903112787925755, -0.39263011731682185, -0.41849364323372384, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.53, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.53, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.53, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.53, -0.41999999999999993, -0.3305227391268235, -0.3773501097182206, -0.3202826958417222, -0.3999999999999999, -0.41999999999999993, -0.53, -0.3474643904437362, -0.3664471077253806, -0.36802904636461364, -0.29556463768603747, -0.2918886385023325, -0.2758597863321639, -0.3707778298921014, -0.3545212937668323, -0.49557265716040355, -0.2935638190198804, -0.28700056446406963, -0.30741707115003014, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.39808552169469724, -0.4026689695525618, -0.38334870961664613, -0.4078277736828013, -0.42491833299064163, -0.5124730750107362, -0.2423632631735082, -0.21683156769449208, -0.23734787520394796, -0.43999999999999995, -0.53, -0.3999999999999999]}}
{"id": "9ac96442-9e71-4d12-90ca-d444e5183ba3", "fitness": -0.09740015977408427, "name": "ChaoticAdaptiveHybridPSODE", "description": "Introduce adaptive chaotic sequences and elite hypermutation to further enhance convergence and diversity escape mechanisms.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.2  # Adjusted chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15\n        adapt_lr = 0.25\n        cooling_factor = 0.995\n        mutation_strength = 0.25  \n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            elite_mutation_strength = 0.5  # Added hypermutation for elites\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n                elif i in elites:  # Apply hypermutation for elites\n                    self.population[i] += np.random.normal(0, elite_mutation_strength, self.dim) \n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 66, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09740 with standard deviation 0.21427.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.1115044137261425, 0.12918885987061857, 0.18612027576214774, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.025641341143037177, 0.03140294984469505, 0.020932969423161252, 0.036574609743825315, 0.020000000000000018, 0.020000000000000018, 0.07410589016884406, 0.04839317595628212, 0.056921944840431005, 0.020000000000000018, 0.07088250047284061, 0.020000000000000018, 0.06627197684601427, 0.09404191616084001, 0.10039950825633781, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03432966531194748, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13809180316403347, 0.13350634923416893, 0.17294640690292862, 0.02416072061679042, 0.02682236257952697, 0.020000000000000018, 0.091092824544167, 0.0863116411064907, 0.09894128715814421, 0.13699927480483753, 0.1469317930126931, 0.12873629268383158, 0.08762431209115906, 0.09590850976942367, 0.10929710320830976, 0.13305265589229354, 0.12194022558831208, 0.1258945922873087, 0.020000000000000018, 0.10220342943226002, 0.11445021375388509, 0.10819636878037442, 0.07940724769494734, 0.08331813380001818, 0.06527120746322768, 0.08118228824639662, 0.0445238673260786, 0.16316346467481002, 0.13589170657517036, 0.1631901834957219, 0.05553551698589243, 0.03414531398605991, 0.030608944442535924, 0.053332127562794374, 0.04246775263133684, 0.06332326829187862, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017672505675919048, 0.011249142961724523, 0.016042645482958195, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010723223020717154, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08759306166351666, 0.08485075286283983, 0.0817226665827766, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0670553732449658, 0.06405616136688086, 0.06256002652108594, 0.13149274031521296, 0.10748432509859696, 0.10408281573755362, 0.07670175235950594, 0.052851559526618797, 0.05698235456402134, 0.10143823417975906, 0.08451786875564526, 0.10374929709514336, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.046261528670414, 0.04433691411772689, 0.03902922285570498, 0.027193761576112196, 0.03540175932324274, 0.024640285494433645, 0.13696974951420682, 0.13123409970527322, 0.14074319999316554, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4289759995062261, -0.41205407058555354, -0.41849908013714154, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3489335451366151, -0.3774795906922579, -0.32096235658045846, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3663440036647858, -0.3660204513584042, -0.3704799483529553, -0.2987751093262885, -0.2934273571310828, -0.27518126751017147, -0.372632418088223, -0.37354713293422126, -0.3667642768602324, -0.3002229049823757, -0.3063394115311999, -0.3078917340827134, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.39808421998242927, -0.4027367619778073, -0.38333112680636394, -0.4275636561186864, -0.4249187308018356, -0.38421528881444944, -0.25613488203322854, -0.23419395177449043, -0.22654345001270237, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993]}}
{"id": "9bb30c35-3f18-4c45-902d-435a2be2116d", "fitness": -0.14550939260139695, "name": "EnhancedChaoticMPAdaptivePSODE", "description": "Introduce multi-population mechanism with nonlinear adaptive inertia and mutation for improved exploration and convergence in dynamic landscapes.", "code": "import numpy as np\n\nclass EnhancedChaoticMPAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0  # Increased cognitive component\n        self.c2 = 2.0  # Increased social component\n        self.w = 0.7   # Increased inertia weight\n        self.de_f = 0.7  # Increased DE scaling factor\n        self.de_cr = 0.8  # Adjusted DE crossover probability\n        self.populations = [np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim)) for _ in range(3)]\n        self.velocities = [np.random.uniform(-1, 1, (self.population_size, dim)) for _ in range(3)]\n        self.pbest_positions = [np.copy(pop) for pop in self.populations]\n        self.pbest_scores = [np.full(self.population_size, np.inf) for _ in range(3)]\n        self.gbest_positions = [None, None, None]\n        self.gbest_scores = [np.inf, np.inf, np.inf]\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(3, self.budget) * 0.15  # Chaotic sequences per population\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2\n        mutation_strength = 0.3\n        cooling_factor = 0.99  # Faster cooling\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for pop_idx in range(3):  # Handle multiple populations\n                for i in range(self.population_size):\n                    score = func(self.populations[pop_idx][i])\n                    evals += 1\n\n                    if score < self.pbest_scores[pop_idx][i]:\n                        self.pbest_scores[pop_idx][i] = score\n                        self.pbest_positions[pop_idx][i] = self.populations[pop_idx][i]\n\n                    if score < self.gbest_scores[pop_idx]:\n                        self.gbest_scores[pop_idx] = score\n                        self.gbest_positions[pop_idx] = self.populations[pop_idx][i]\n\n                if evals >= self.budget:\n                    break\n\n                # Adjust adaptive parameters using chaotic sequence\n                chaotic_factor = self.chaotic_seq[pop_idx, evals % self.budget]\n                avg_pbest_score = np.mean(self.pbest_scores[pop_idx])\n                self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_scores[pop_idx] / avg_pbest_score)) + chaotic_factor)\n                self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_scores[pop_idx] / (avg_pbest_score + 1e-8))) + chaotic_factor)\n                self.c1 = min(3.0, self.c1 + adapt_lr * adapt_rate * (avg_pbest_score / self.gbest_scores[pop_idx]) + chaotic_factor)\n\n                # Nonlinear adaptive cooling strategy\n                self.w *= cooling_factor ** (evals / self.budget)\n\n                if exploration_phase and evals > self.budget * 0.5:\n                    exploration_phase = False\n                    self.population_size = max(5, self.population_size // 2)\n                    adapt_lr += 0.05\n\n                # Elite retention strategy: preserve the best solutions\n                elites = np.argsort(self.pbest_scores[pop_idx])[:max(2, self.population_size // 10)]\n                \n                # Quasi-sinusoidal adaptive strategy for velocity\n                angle = (evals / self.budget) * np.pi\n                adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n                for i in range(self.population_size):\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    cognitive = self.c1 * r1 * (self.pbest_positions[pop_idx][i] - self.populations[pop_idx][i])\n                    social = self.c2 * r2 * (self.gbest_positions[pop_idx] - self.populations[pop_idx][i])\n                    noise = np.random.normal(0, mutation_strength, self.dim)\n                    self.velocities[pop_idx][i] = adaptive_factor * self.w * (self.velocities[pop_idx][i] + noise) + cognitive + social\n                    self.velocities[pop_idx][i] = np.clip(self.velocities[pop_idx][i], -self.velocity_clamp, self.velocity_clamp)\n                    self.populations[pop_idx][i] = np.clip(self.populations[pop_idx][i] + self.velocities[pop_idx][i], self.lower_bound, self.upper_bound)\n\n                    if i in elites:\n                        continue  # Skip DE mutation for elite solutions\n\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = self.populations[pop_idx][indices]\n                    mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_positions[pop_idx] - x1)), self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.populations[pop_idx][i])\n                    crossover_mask = np.random.rand(self.dim) < self.de_cr\n                    trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                    trial_score = func(trial_vector)\n                    evals += 1\n\n                    if trial_score < func(self.populations[pop_idx][i]):\n                        self.populations[pop_idx][i] = trial_vector\n\n                # Stochastic restart if stuck\n                if evals % (self.budget // 4) == 0:\n                    if np.ptp(self.pbest_scores[pop_idx]) < 1e-6:\n                        self.populations[pop_idx] = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                        self.velocities[pop_idx] = np.random.uniform(-1, 1, (self.population_size, dim))\n                        self.pbest_positions[pop_idx] = np.copy(self.populations[pop_idx])\n                        self.pbest_scores[pop_idx].fill(np.inf)\n\n        best_global_idx = np.argmin(self.gbest_scores)\n        return self.gbest_positions[best_global_idx], self.gbest_scores[best_global_idx]", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedChaoticMPAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.14551 with standard deviation 0.28116.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.11372296617096533, 0.10757367155882147, 0.14606945451251785, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030966561243579105, 0.02502983063297759, 0.020000000000000018, 0.020000000000000018, 0.021703807414507614, 0.020000000000000018, 0.0846125740526068, 0.05395102247426853, 0.059945912621455766, 0.020000000000000018, 0.07109805666975633, 0.020000000000000018, 0.05641267251876103, 0.12244062513985143, 0.07700769402072094, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1554880157686267, 0.13407787052095055, 0.15124225722693607, 0.020000000000000018, 0.020000000000000018, 0.02217757714338786, 0.08072694858327945, 0.0863116411064907, 0.08505867522976529, 0.16227646524180328, 0.15809724320960938, 0.13902907640843631, 0.09297372976438012, 0.09672819457005333, 0.11748481514773479, 0.12723685371540727, 0.11441473279185199, 0.13431547535642185, 0.035851152713886614, 0.03912236952800485, 0.11362868606149756, 0.10819636878037442, 0.12029694129874902, 0.08539130344263124, 0.09638420371325696, 0.06223730905334435, 0.0687785448847319, 0.1438526290318487, 0.1455835636290358, 0.15475448018179316, 0.044737970580800424, 0.04144199957347472, 0.034316561151044644, 0.07455900339036203, 0.06083643798775806, 0.0632211528700084, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02830754407393654, 0.017254706233347683, 0.017797268558144785, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012980248588336574, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08859792413772749, 0.0730342355044481, 0.09677278038293646, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05917690404009779, 0.06147825531143891, 0.05395939349942802, 0.14016952075656886, 0.10623032409824984, 0.11205936744271927, 0.07235059305299818, 0.05009762278880192, 0.060885743529736414, 0.1062352197777181, 0.09106831116948211, 0.10270019416480924, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029935668589400333, 0.042342393076014506, 0.034769579342089574, 0.024895242935785933, 0.034189014125293404, 0.02609855758461943, 0.14153617391863693, 0.13278570662331535, 0.1386003798437444, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.5397105662089743, -0.5543104073296456, -0.5649151366818728, -0.55, -0.5700000000000001, -0.5900000000000001, -0.5700000000000001, -0.55, -0.5700000000000001, -0.55, -0.55, -0.5700000000000001, -0.5700000000000001, -0.5700000000000001, -0.5700000000000001, -0.5900000000000001, -0.55, -0.5700000000000001, -0.55, -0.5700000000000001, -0.5700000000000001, -0.5700000000000001, -0.5700000000000001, -0.5700000000000001, -0.55, -0.55, -0.5700000000000001, -0.5700000000000001, -0.5700000000000001, -0.55, -0.5900000000000001, -0.5700000000000001, -0.55, -0.55, -0.55, -0.55, -0.5700000000000001, -0.55, -0.5700000000000001, -0.4870359249687397, -0.5042109423922172, -0.47589374869079015, -0.5900000000000001, -0.5900000000000001, -0.5700000000000001, -0.5274652839295664, -0.5135360956415411, -0.512043047529021, -0.4517922381743642, -0.41614149313478865, -0.44752578380267694, -0.5155847614041462, -0.5041822441102, -0.5449851903658953, -0.4279327905839394, -0.4328281658195794, -0.4515923261034027, -0.55, -0.55, -0.55, -0.5473591096791268, -0.5333401596183109, -0.5516804301417451, -0.5782099641106797, -0.5478148029991257, -0.5358292951768957, -0.36032973123202994, -0.38177421645447773, -0.37967891745634486, -0.5700000000000001, -0.55, -0.5700000000000001]}}
{"id": "2dd0b0f8-6cec-4289-8c52-f40a183225b8", "fitness": -0.0981808995022445, "name": "ChaoticAdaptiveHybridPSODE", "description": "Fine-tune inertia weight decay to enhance convergence control in the optimization process.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.7   # Increased inertia weight for better convergence control\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.15  # Increased chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15  # Increased adaptation rate\n        adapt_lr = 0.25  # Increased adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.25  # Increased mutation strength\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 68, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09818 with standard deviation 0.21554.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.11345385321912138, 0.12803606649582422, 0.1934714488782373, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.021419641959547042, 0.03899833451242363, 0.03056973059475776, 0.042353273924224055, 0.0326673418416622, 0.020000000000000018, 0.06438790346869505, 0.04831850129613702, 0.055315560273563213, 0.020000000000000018, 0.07018048126578624, 0.020000000000000018, 0.058527271700003825, 0.09404191616084001, 0.09434300678993102, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13986591670045556, 0.1319462051484137, 0.1758444612440916, 0.03128336349941241, 0.020054353831422733, 0.024399514392580923, 0.09766775765916036, 0.09179927912433783, 0.08404913739177255, 0.1466239352123313, 0.1489365740376064, 0.13872524925486696, 0.06890008862013497, 0.08048180133458827, 0.10053172439111757, 0.15193660571496703, 0.12726737874967187, 0.13702147180439228, 0.020000000000000018, 0.10814359095091541, 0.1165842156490764, 0.11793465194649799, 0.08127150130509786, 0.08383830984363716, 0.06527120746322768, 0.08148068119144625, 0.04418801125673155, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.05349391313052354, 0.03562238754177416, 0.033445544055749066, 0.05381396681986006, 0.04260915053438297, 0.06274595581551623, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01584636902467096, 0.011697507022314535, 0.01466747778982691, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08817047351940654, 0.08425340691569216, 0.08212749841767875, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06207447419423018, 0.06275693303850649, 0.06198655884629245, 0.1386020741589511, 0.11279068883179888, 0.10526867747852042, 0.07979598491658246, 0.0515829490446198, 0.053936809511723194, 0.09816598817702382, 0.08701255397970942, 0.10141867093561119, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.044619524765329155, 0.04531402553340769, 0.03870637030136892, 0.027172711340936684, 0.03580818816181397, 0.02621426599657173, 0.13897959023180517, 0.13236674719495667, 0.1504287251135662, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4085695667858129, -0.4115515448756897, -0.43857147820849685, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.34902666263643933, -0.37716851291564546, -0.32098897302140506, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3719988773231353, -0.366385391432839, -0.3656439802582514, -0.3152273193519257, -0.29342596264115794, -0.2781203358001034, -0.38815785992862684, -0.3743571028496395, -0.3818550275609278, -0.3066881825035861, -0.31071302312711024, -0.32367671530609976, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.39860131330410886, -0.40264329282444633, -0.38298036895680876, -0.4285487152509533, -0.424887494655255, -0.38450559670167417, -0.2759905869192856, -0.23419395177449043, -0.2427227537991461, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999]}}
{"id": "c7b17207-eaf1-4dce-9327-257ce781ed78", "fitness": -0.12458378354023497, "name": "EnhancedChaoticAdaptiveHybridPSODE", "description": "Enhance search efficiency by integrating adaptive chaotic dynamics, elite retention, and multi-phase exploration-exploitation to improve convergence.", "code": "import numpy as np\n\nclass EnhancedChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.de_f = 0.5\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.1\n        adapt_lr = 0.2\n        cooling_factor = 0.99\n        mutation_strength = 0.3\n        exploration_phase = True\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n\n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.4:\n                self.de_cr = min(1.0, self.de_cr + 0.1)\n\n            mutation_strength = 0.25 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.6:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.1\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 5)]\n            \n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 3) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.12458 with standard deviation 0.25338.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.1251152496926926, 0.11850529631134332, 0.18561323915688277, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.025032732755526532, 0.02840269239095794, 0.020000000000000018, 0.02655329274764906, 0.020000000000000018, 0.02632436686939854, 0.07758443740867838, 0.04893136919057606, 0.05715047127597961, 0.020000000000000018, 0.07086469761775849, 0.020000000000000018, 0.050142232410961274, 0.10014311480516358, 0.0953711022748377, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037046251576729916, 0.03735939418371037, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12456785985883012, 0.12530291955196105, 0.17518512415013676, 0.024336941530033296, 0.028041429517346006, 0.020000000000000018, 0.08072694858327945, 0.08667152648148257, 0.07132253331947236, 0.1416735527471854, 0.15160165129919645, 0.1160417955509998, 0.08579489211981806, 0.07990382579724953, 0.10185521712564083, 0.14578650914758295, 0.12198507154487426, 0.1272348196765788, 0.020000000000000018, 0.1057285758797406, 0.1208021107189069, 0.15713910280871612, 0.08377718432057069, 0.08349936592900742, 0.1354171258441491, 0.08755219555527471, 0.04478304749893769, 0.15360577512859497, 0.13589170657517036, 0.15475448018179316, 0.05113554958085331, 0.03396148670570742, 0.03510038567599849, 0.05042667962526093, 0.0345102330207574, 0.0699739572987581, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01693855405763045, 0.010763464118361155, 0.011650646013970034, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07758417145568908, 0.08918755965947855, 0.081873434182135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06719752852766903, 0.06199698842655654, 0.05792784338036139, 0.11869262382913237, 0.10359540394232203, 0.11053092582726332, 0.07377514141090113, 0.045505743802195964, 0.05680016058371873, 0.09383269996560772, 0.09162425062989399, 0.10369751345184297, 0.11745250252874129, 0.010000000000000009, 0.010000000000000009, 0.04673408147716429, 0.04013602390606341, 0.03977335858301456, 0.025755326940201773, 0.0287446315439861, 0.024640285494433645, 0.13822994630130447, 0.14716348162372184, 0.136735213579268, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4960740388634983, -0.485875791179071, -0.4840264660017315, -0.51, -0.51, -0.51, -0.51, -0.49, -0.51, -0.53, -0.53, -0.51, -0.51, -0.47, -0.53, -0.49, -0.49, -0.51, -0.49, -0.53, -0.51, -0.51, -0.47, -0.47, -0.51, -0.51, -0.49, -0.51, -0.49, -0.49, -0.51, -0.51, -0.51, -0.51, -0.49, -0.53, -0.51, -0.49, -0.51, -0.4525425174520583, -0.4429507769311478, -0.41384680893832515, -0.47, -0.47, -0.51, -0.4599442732328516, -0.4530140877856419, -0.4485206250217726, -0.376127727263478, -0.3430503379157832, -0.3796122902104906, -0.44503197293588403, -0.46499469843086594, -0.4551797409119356, -0.3821315739041733, -0.36534597648561906, -0.37278675937590844, -0.51, -0.49, -0.49, -0.4857176368013638, -0.49199117870685116, -0.49344119829420463, -0.4977080889621215, -0.5139742682047341, -0.5146749070031773, -0.32396966030837726, -0.2858129783517702, -0.33652189147925715, -0.53, -0.49, -0.49]}}
{"id": "97874d07-4972-4067-9257-44d3d0ad847e", "fitness": -0.09734693117606606, "name": "EnhancedChaoticAdaptivePSODE", "description": "Enhance the synergy of chaotic dynamics and adaptive strategies for better convergence and global search capability.", "code": "import numpy as np\n\nclass EnhancedChaoticAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.4  # slightly reduced cognitive component for balance\n        self.c2 = 1.6  # slightly increased social component for global attraction\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.2  # Adjusted chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.18  # Further increased adaptation rate\n        adapt_lr = 0.3  # Further increased adaptive learning rate\n        cooling_factor = 0.994\n        mutation_strength = 0.3  # Further increased mutation strength\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.25:\n                self.de_cr = min(1.0, self.de_cr + 0.06)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.25 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedChaoticAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09735 with standard deviation 0.21451.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.11351187762508597, 0.13060522837304978, 0.1897747949503933, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023029111884508735, 0.02852341766395372, 0.02915063851919575, 0.03505584194742806, 0.024859876228091715, 0.020000000000000018, 0.07483302594266139, 0.05068957944824337, 0.05731164347477913, 0.020000000000000018, 0.07088020626453939, 0.020000000000000018, 0.06091960758664017, 0.0903237436527834, 0.09992842374210009, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13952734628897057, 0.133380488855522, 0.1696025012944946, 0.029094426596734557, 0.030082126379070595, 0.020000000000000018, 0.08467568503290634, 0.1004628511852258, 0.10238086850013528, 0.13613030995480324, 0.1522620713482402, 0.1325763438742209, 0.08202275167433892, 0.09618580397929521, 0.1297309853442482, 0.1294031969330297, 0.1354276376515995, 0.12191976134240401, 0.020000000000000018, 0.09757014126383756, 0.11425594510595116, 0.10819636878037442, 0.08096679766283732, 0.08349252742214963, 0.06527120746322768, 0.08328226321955312, 0.04465016274996958, 0.16031593397850552, 0.14299779029138415, 0.1746594011296726, 0.049953932740828044, 0.03576695308804634, 0.029877829351268592, 0.051652521099612825, 0.043060274517128794, 0.06410929807986188, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01863501151727709, 0.011277705913550706, 0.01643901534455461, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010909196674034005, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08683206065600302, 0.08437236713246066, 0.08214479586463808, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05721548359333217, 0.06147825531143891, 0.05395939349942802, 0.1321579778185321, 0.1095177403938904, 0.10281775224528589, 0.06872231466854117, 0.053494746147761285, 0.053936809511723194, 0.09981592621733992, 0.08565947230521898, 0.10256958528545324, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04491109665221127, 0.04419901106449342, 0.03826553476425332, 0.027807977841652343, 0.035262717064970306, 0.024640285494433645, 0.13141309820135194, 0.13178955187872565, 0.14264416460050144, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.40586377365507365, -0.39759487376598646, -0.4190406436106855, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.3608105697510744, -0.37482720175023165, -0.31984254518166133, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.36407627936003784, -0.36029685091580177, -0.3610147228126155, -0.27572225652193016, -0.2891263186680777, -0.2835296776471745, -0.3699010148483981, -0.3985938240620346, -0.36334997457202456, -0.3059452007309773, -0.27749082191920915, -0.3085504870760618, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.39819683593567445, -0.4066196646601308, -0.40284519781121, -0.4079774592044212, -0.42488884026377227, -0.38395486020943204, -0.25480720972149884, -0.2206475011244151, -0.24865309739662278, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999]}}
{"id": "0c50d7b6-af90-4c87-9361-37037ec4a40a", "fitness": -0.09750441039364938, "name": "EnhancedAdaptiveHybridPSODE", "description": "Incorporate adaptive learning rates via a quadratic chaotic map and elitist differential evolution to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.7   # inertia weight, increased for better exploration\n        self.de_f = 0.8  # DE scaling factor, increased for stronger differential mutation\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.2  # Adjusted chaotic sequence range\n        self.learning_rate = self._init_quadratic_chaotic_map()\n\n    def _init_quadratic_chaotic_map(self):\n        # Initialize a quadratic chaotic map for adaptive learning rate\n        mu = 3.9\n        lr = np.empty(self.budget)\n        lr[0] = 0.5\n        for i in range(1, self.budget):\n            lr[i] = mu * lr[i - 1] * (1 - lr[i - 1])\n        return lr\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.2  # Adjusted adaptation rate\n        cooling_factor = 0.995\n        exploration_phase = True\n        mutation_strength = 0.3  # Increased initial mutation strength\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            lr = self.learning_rate[evals % self.budget]\n            \n            # Adjust parameters using chaotic sequence and quadratic map\n            self.w = max(0.1, self.w * (1 - lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = 0.25 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09750 with standard deviation 0.21331.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.11446121129196629, 0.12866881160656618, 0.1524984709161249, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029256839451059835, 0.037969211221631216, 0.020000000000000018, 0.04344133459178667, 0.020000000000000018, 0.020000000000000018, 0.08561762660648276, 0.05810569902592333, 0.060558127072419254, 0.020000000000000018, 0.07010627570627204, 0.020000000000000018, 0.020000000000000018, 0.09404191616084001, 0.09454224451990101, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13749647266823162, 0.14124271084227857, 0.18088761122319952, 0.028368706692949996, 0.020000000000000018, 0.02035961526963148, 0.08389028371922247, 0.0911032370793633, 0.08207649062453592, 0.14273757605637438, 0.15056056134724605, 0.11910769561018753, 0.07417911897444929, 0.08829290734494866, 0.0973624998397401, 0.1748118300838264, 0.12137435731239488, 0.12841413694865256, 0.020000000000000018, 0.07694111792442515, 0.11772542575535982, 0.10819636878037442, 0.08055338427091929, 0.08427301403370124, 0.06527120746322768, 0.08742297447670577, 0.04420152302177682, 0.1438526290318487, 0.16173912340563956, 0.15475448018179316, 0.04664308755306079, 0.027548125352369057, 0.03010443409554342, 0.053728889315025063, 0.042067763675296854, 0.06273043315699045, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02564845472118482, 0.012469082318033897, 0.026441912999842332, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08565215571637419, 0.08409206132842262, 0.08197550100343942, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0736174852203092, 0.06258272698906797, 0.05979969092878479, 0.12480693683603317, 0.10790856220139855, 0.10281775224528589, 0.0793719185347882, 0.04872070137137441, 0.053936809511723194, 0.09415883164686223, 0.08675301718094308, 0.10088474505506606, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.043598314738586996, 0.047578866554945254, 0.03019993616795924, 0.026045142393378073, 0.03171589383913942, 0.024640285494433645, 0.13141309820135194, 0.13123409970527322, 0.13390985431645974, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.41083979598003406, -0.3974146153802358, -0.43866197038756605, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3499498291988479, -0.36291677739208184, -0.3234738785202982, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.36772024590146635, -0.3664471077253806, -0.3716828173264488, -0.29647879415446066, -0.2692117906045066, -0.29266564490601743, -0.3906252878227596, -0.3742996094763771, -0.384948604023833, -0.30619233406045376, -0.3051787035648319, -0.2876559696178189, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.3987504979328056, -0.42660158777003687, -0.4029646807617906, -0.42837279017176466, -0.40509237325622416, -0.3843989489654296, -0.24011101766723408, -0.21683156769449208, -0.2527268032878005, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999]}}
{"id": "81b99bd1-7370-44b5-9e06-0db10f5062ff", "fitness": -0.09747377259413555, "name": "RefinedChaoticAdaptiveHybridPSODE", "description": "Introduce dynamic fitness-based parameter tuning and diversify the initialization strategy to enhance convergence and exploitation capabilities.", "code": "import numpy as np\n\nclass RefinedChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.5  # DE scaling factor\n        self.de_cr = 0.9  # DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.15 \n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15  \n        adapt_lr = 0.25  \n        cooling_factor = 0.995\n        mutation_strength = 0.25  \n        exploration_phase = True\n\n        while evals < self.budget:\n            # Evaluate scores\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust parameters dynamically with fitness-based logic\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            fitness_diversity = np.std(self.pbest_scores)\n            self.w = max(0.1, self.w * cooling_factor * (1 - adapt_lr * adapt_rate * (self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / (self.gbest_score + 1e-8)) + chaotic_factor)\n            \n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            # Switch from exploration to exploitation phase\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 72, "feedback": "The algorithm RefinedChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09747 with standard deviation 0.21454.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.11415294112423335, 0.1291458893263574, 0.19204280856067613, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027598722757910865, 0.03142355059952062, 0.026727564106895474, 0.03291874509027193, 0.020001148635994115, 0.020000000000000018, 0.06438790346869505, 0.04837822671741521, 0.05637163921487154, 0.020000000000000018, 0.0708850471009268, 0.020000000000000018, 0.0680124889966035, 0.09404191616084001, 0.10039950825633781, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03807700124800095, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13954257484432442, 0.13350809750897819, 0.17201409013847524, 0.02248950686607787, 0.02661150739004481, 0.02618928729407599, 0.10466393824252662, 0.0863116411064907, 0.06848259891738384, 0.14254910490564354, 0.14691463520096848, 0.1284276555332694, 0.08504206177153861, 0.09523066865808039, 0.10732190019819621, 0.16500195866889056, 0.12914187537091348, 0.12322265013306799, 0.020000000000000018, 0.10218765520965745, 0.11423233015855727, 0.11613632229480741, 0.07940871932866544, 0.08306856273359597, 0.06527120746322768, 0.08127085497881847, 0.04458814499665886, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.06859756409599327, 0.03235790527995508, 0.029551206918659534, 0.05317084069148381, 0.042510866069650266, 0.06339599340659552, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01650316692424658, 0.011194132343607666, 0.013618575447735592, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010060584716275245, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08725594182278595, 0.08473614536030138, 0.08175265402893328, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.061421253953975796, 0.06505783800761844, 0.06253797630870228, 0.13060970509781822, 0.10714296959189396, 0.10281775224528589, 0.06932791897289337, 0.05386102937351833, 0.058542400605832046, 0.09666308735372542, 0.0936427104248041, 0.10392185462705483, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04678594182848583, 0.04610259548018747, 0.040362193886541275, 0.02722660380184283, 0.03600436294382958, 0.026333578984595096, 0.13404532167440453, 0.13123409970527322, 0.13387393863919872, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4287215832848188, -0.4122792171725538, -0.41849317522390295, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.34882179934254065, -0.37724239764548395, -0.32015494016265156, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.36709422872068154, -0.3664471077253806, -0.38872470112500546, -0.2959131622685698, -0.29171521358008157, -0.276324220339889, -0.3709371955968308, -0.37385178759736637, -0.3697427266893798, -0.30227466351841903, -0.3005776964048308, -0.32221055662571474, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3980400023102759, -0.4026504310647723, -0.3833283439805646, -0.42748866690311194, -0.42492151427495894, -0.38412005545903294, -0.2400953429877939, -0.21683156769449208, -0.2354467603151824, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999]}}
{"id": "d5316f2e-36af-471f-8022-d0f1ebbfd6e1", "fitness": -0.0971918912761027, "name": "ChaoticAdaptiveHybridPSODE", "description": "Fine-tune the synergy between chaotic sequences and adaptive mechanisms to improve exploration and convergence balance.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.4  # Slightly reduced cognitive component\n        self.c2 = 1.6  # Slightly increased social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.6  # Increased DE scaling factor\n        self.de_cr = 0.85  # Slightly reduced DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.15  # Increased chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15  # Increased adaptation rate\n        adapt_lr = 0.25  # Increased adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.25  # Increased mutation strength\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 73, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09719 with standard deviation 0.21422.", "error": "", "parent_ids": ["19b10ab9-cf0d-40bb-8e32-5453de54cb93"], "operator": null, "metadata": {"aucs": [0.13726193763074912, 0.13107702633973128, 0.18044887014341304, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026174658336722167, 0.02333721642827502, 0.03524151526994146, 0.03341201489027379, 0.021849312521128206, 0.020000000000000018, 0.08033444390743627, 0.0520813425100779, 0.05748006904003655, 0.020000000000000018, 0.07091702938909128, 0.020000000000000018, 0.04527173409212093, 0.0903237436527834, 0.09510016683002609, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13940212075432357, 0.13405821823692066, 0.16777479744965118, 0.026521032140874756, 0.03124432517369824, 0.020000000000000018, 0.08072694858327945, 0.10593856053579653, 0.07855467176037112, 0.1325739698478513, 0.15245371745633152, 0.13740537621077098, 0.08011473652281265, 0.09051162832281878, 0.11074394597525739, 0.12494449391162699, 0.10957259599625302, 0.13905720600161686, 0.020000000000000018, 0.132213806908286, 0.11319023101041836, 0.10819636878037442, 0.079854689828739, 0.08306445120653028, 0.06527120746322768, 0.08032875206192658, 0.044588954914043244, 0.1673083504924926, 0.14302699161282972, 0.15475448018179316, 0.053228749577150736, 0.03798624798331163, 0.030590379492287267, 0.05167622259801197, 0.04251849852311129, 0.0639462950917854, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02024114974915947, 0.011150769873835564, 0.013839583202316041, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.019803106495987155, 0.011708498323864669, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08450900930320304, 0.08956944526081179, 0.08233911099988844, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058403811626825175, 0.06147825531143891, 0.05395939349942802, 0.1364554195535419, 0.10939238313955613, 0.1045573794159883, 0.06641418448037517, 0.05047665440598337, 0.0559484145920528, 0.09632590129157759, 0.09531901446040036, 0.10939864962266854, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0456699061587692, 0.04307364956198867, 0.03430835158612, 0.052334141073342, 0.033228208882250865, 0.024640285494433645, 0.13141309820135194, 0.13123409970527322, 0.14645511955777124, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.41104720600751143, -0.4113915711828451, -0.4389578176928517, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.34726706280769837, -0.3446209710063328, -0.32044095427321007, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3672756039168761, -0.37245289047240226, -0.37035643109971805, -0.2931744133490013, -0.2913326343680469, -0.2830270308139049, -0.3831419538385945, -0.39703657279694493, -0.3644185447200865, -0.30952589238865014, -0.3082029314079291, -0.29202110455462904, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.39814100796897955, -0.40417773230077936, -0.4029210514380168, -0.40896372815993143, -0.4248833940513259, -0.38387643235869007, -0.23668991208747703, -0.21683156769449208, -0.27857320129984453, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999]}}
{"id": "c6dea3d2-197a-4e92-b303-108d331423fb", "fitness": -0.09730106487409174, "name": "ChaoticAdaptiveHybridPSODE", "description": "Enhance the synergy between chaotic sequences and adaptive mechanisms by fine-tuning adaptive learning rates and refining exploration-exploitation balance.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.4  # Slightly reduced cognitive component\n        self.c2 = 1.6  # Slightly increased social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.6  # Increased DE scaling factor\n        self.de_cr = 0.85  # Slightly reduced DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.15  # Increased chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.12  # Decreased adaptation rate\n        adapt_lr = 0.3  # Increased adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.25  # Increased mutation strength\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 74, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09730 with standard deviation 0.21418.", "error": "", "parent_ids": ["d5316f2e-36af-471f-8022-d0f1ebbfd6e1"], "operator": null, "metadata": {"aucs": [0.1369313111215521, 0.1312369770781675, 0.18028679976247697, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02638396832692902, 0.023333116353648542, 0.03546904403804829, 0.0334196502218167, 0.02159394492984379, 0.020000000000000018, 0.08029656757195403, 0.05206950923886877, 0.057478658570294994, 0.020000000000000018, 0.07091695150238064, 0.020000000000000018, 0.04527173409212093, 0.0903237436527834, 0.09510016683002609, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13939756039795181, 0.13406167528617308, 0.16771266058926115, 0.026522596845749424, 0.031123247285034572, 0.020000000000000018, 0.08072694858327945, 0.10853187549370513, 0.07786873591344934, 0.13276332363660714, 0.15246673783268416, 0.13169627536556017, 0.08007898266694358, 0.0903895371584249, 0.11073316288488977, 0.12744408405407337, 0.10119846899188678, 0.14166882695568173, 0.020000000000000018, 0.1321684771250239, 0.11319039819245058, 0.10819636878037442, 0.07990272032652812, 0.08306837094132424, 0.06527120746322768, 0.08035464433973583, 0.04458826133187255, 0.16250204976706195, 0.14341866459097974, 0.15475448018179316, 0.05322141908278577, 0.038271139269208776, 0.03036632373309578, 0.051674637918346256, 0.04252311821260679, 0.06394899877182869, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02022161920881249, 0.011153188829109983, 0.013840601420623155, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.019803106495987155, 0.011708498323864669, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08451372297519666, 0.08958297875713772, 0.08235038133905004, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05833354628420717, 0.06147825531143891, 0.05395939349942802, 0.13618111680909306, 0.10916341844058297, 0.10468451942610513, 0.06639243873429268, 0.05035739553050167, 0.055967827043167606, 0.1018320338438563, 0.09189550340847896, 0.10931886917200362, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.045662011883006004, 0.04308526960603187, 0.034306340526576995, 0.05232812460719505, 0.033214091674207524, 0.024640285494433645, 0.13141309820135194, 0.13164505280077843, 0.1439246281517228, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4110462650062021, -0.4113863593591345, -0.4389577756192389, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.34733209760519235, -0.3445959457698491, -0.32053290876949037, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3672972383178348, -0.37249539828675315, -0.3705291761944445, -0.2933328773884998, -0.29123079162477716, -0.2831424778093561, -0.38318335539412707, -0.39691540857606533, -0.36434872712260136, -0.3022516038620242, -0.3087852939478817, -0.29075933912010665, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3981441530669596, -0.4041768779569508, -0.4029204513729012, -0.4089642883679667, -0.4248819633408183, -0.3838782240692995, -0.2371455720194211, -0.23419395177449043, -0.27947693212018687, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999]}}
{"id": "4f085f87-12a2-42b5-878b-67ec26898bea", "fitness": -0.0988221959063728, "name": "ChaoticAdaptiveHybridPSODE", "description": "Enhance the quasi-sinusoidal adaptive strategy and elite retention mechanism to improve convergence and stability.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.4  # Slightly reduced cognitive component\n        self.c2 = 1.6  # Slightly increased social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.6  # Increased DE scaling factor\n        self.de_cr = 0.85  # Slightly reduced DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.15  # Increased chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15  # Increased adaptation rate\n        adapt_lr = 0.25  # Increased adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.25  # Increased mutation strength\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.22 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))  # Changed to 0.22\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(3, self.population_size // 10)]  # Changed to max 3\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.6 + 0.5 * np.sin(angle)  # Changed to 0.6\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 75, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09882 with standard deviation 0.21765.", "error": "", "parent_ids": ["d5316f2e-36af-471f-8022-d0f1ebbfd6e1"], "operator": null, "metadata": {"aucs": [0.13474211527353785, 0.1307908486072038, 0.18526864973470825, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027633003559033975, 0.023264779104546607, 0.020000000000000018, 0.03121988714776025, 0.020000000000000018, 0.032614775861061096, 0.08033444390743627, 0.05209226241676901, 0.05714207146257677, 0.020000000000000018, 0.07070009548584721, 0.020000000000000018, 0.03558174493742794, 0.09236446960397271, 0.10037571891904451, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.046957311258678414, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12575523885477902, 0.127955862732818, 0.17051788568307458, 0.02190853910879864, 0.02803300442214829, 0.026900844715955996, 0.08741732898028431, 0.1094661941131595, 0.07809583385019692, 0.14784488801096562, 0.15021007258535857, 0.1160417955509998, 0.07990704079500244, 0.08921172632261143, 0.11977504881290679, 0.1439068864623383, 0.12650622834476577, 0.16464622605128043, 0.020000000000000018, 0.13452291086312496, 0.11689149393043263, 0.11761644170612873, 0.06407520648969234, 0.08806032261864116, 0.06527120746322768, 0.09133390627536153, 0.04454120425182151, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.045332259259508345, 0.039159268100660394, 0.03327314931886893, 0.057924169457359787, 0.044745428318428204, 0.06346242197973795, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018738565835057286, 0.015065156753737652, 0.016468218130086143, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.019237078532425178, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08313480319854094, 0.0914216103560126, 0.08488736918196138, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05697657421825908, 0.06668712837028645, 0.05395939349942802, 0.13624665921192092, 0.11043502328712362, 0.11574141478684197, 0.07346740815994468, 0.046800670335735206, 0.05880951634389253, 0.09984243544801263, 0.09227735517895197, 0.09474661587493616, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06607763186471127, 0.03819160391961429, 0.038468858193369204, 0.02527896011368913, 0.03503749269184253, 0.024640285494433645, 0.13596780043938028, 0.13215900605536746, 0.14110078164202922, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4109142384580926, -0.3916797276531374, -0.4191088097539184, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.53, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.53, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.53, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.32885581749675374, -0.34469947704183146, -0.3210681767196042, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.36776223642025774, -0.35271019330660525, -0.3739110198057105, -0.29334539803641313, -0.2912771634572997, -0.2849010631561868, -0.36446760153481694, -0.3984443445788637, -0.3633734798261796, -0.3079053260053348, -0.2907876040040489, -0.3090752123959377, -0.3999999999999999, -0.43999999999999995, -0.3999999999999999, -0.3983432865990013, -0.4041398351902512, -0.3829231235267232, -0.4090077732445627, -0.4248733031086125, -0.5123186759255747, -0.3557288911692362, -0.32968706421448224, -0.23204191876353542, -0.43999999999999995, -0.3999999999999999, -0.53]}}
{"id": "d04877bf-73e9-494d-b5f5-edfebc59b97e", "fitness": -0.09694498426521204, "name": "ChaoticAdaptiveHybridPSODE", "description": "Fine-tune chaotic sequences and adaptive mechanisms for enhanced exploration and convergence balance.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.4  # Slightly reduced cognitive component\n        self.c2 = 1.6  # Slightly increased social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.6  # Increased DE scaling factor\n        self.de_cr = 0.85  # Slightly reduced DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1  # Decreased chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15  # Increased adaptation rate\n        adapt_lr = 0.25  # Increased adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.25  # Increased mutation strength\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 76, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09694 with standard deviation 0.21443.", "error": "", "parent_ids": ["d5316f2e-36af-471f-8022-d0f1ebbfd6e1"], "operator": null, "metadata": {"aucs": [0.11210843251803349, 0.13105210901136788, 0.186937604200216, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024415014224523746, 0.02339452939428044, 0.03237312566388051, 0.03077971724663542, 0.021220823962310176, 0.020000000000000018, 0.07602658520484429, 0.05204536404054749, 0.05773373918141911, 0.020000000000000018, 0.0709194804238561, 0.020000000000000018, 0.046782643639559196, 0.0903237436527834, 0.09992842374210009, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02434706476213444, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13920045287927563, 0.13406021174130867, 0.16607651499966325, 0.026379513372527863, 0.031156582801377564, 0.020000000000000018, 0.0953842092313415, 0.10906083457776117, 0.0980373086279468, 0.13466536222135828, 0.15244352048016963, 0.13808758404534904, 0.0782762928973727, 0.09054818199841463, 0.11385555286451288, 0.13096050718534813, 0.10941539713520498, 0.15576902999849973, 0.020000000000000018, 0.1321431853473678, 0.11302547713400213, 0.10819636878037442, 0.0799671822815301, 0.08277274382773325, 0.06527120746322768, 0.08045965828528923, 0.04463077365835488, 0.1478528133477155, 0.15331735308266592, 0.15475448018179316, 0.05917389667909356, 0.038488062170728754, 0.03560949806990843, 0.05150895741343675, 0.04254828699534097, 0.06399822309827807, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017941320303354935, 0.011092675754157955, 0.013457127819223036, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08620429846848399, 0.08965653656037031, 0.08239103703022477, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.061984896941214784, 0.06432931345964166, 0.05395939349942802, 0.13596379001338277, 0.10879526827134578, 0.10780239930288871, 0.0684410663845253, 0.048659215738575456, 0.054885936762757215, 0.10329958016587615, 0.0872696625714543, 0.1102862582300509, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04620635579464705, 0.042607231430079606, 0.03598468460222992, 0.04723314603534978, 0.033818263017634353, 0.024640285494433645, 0.13141309820135194, 0.14108552074129221, 0.13557600820424798, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4110590723801324, -0.411413496884679, -0.4175155712380212, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3471322203766598, -0.34473757283237405, -0.319922910207564, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3673345392900702, -0.375389834050992, -0.3704215452872568, -0.29228014029530014, -0.2900446410207784, -0.2813498933279015, -0.3837689236743964, -0.39697854680482636, -0.3675728547814554, -0.32352908007254433, -0.28584172962890797, -0.3059180123506511, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3980828728645891, -0.4040381162993305, -0.3831821958144943, -0.4089565833009001, -0.4248589440311128, -0.38377712673125863, -0.23967165844395133, -0.21683156769449208, -0.23097494814214925, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999]}}
{"id": "c371938a-23f8-4ca4-93eb-32c9541ec210", "fitness": -0.09717064293437508, "name": "ChaoticAdaptiveHybridPSODE", "description": "Enhance chaotic exploration and adaptive velocity for improved convergence robustness.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5  # Tweaked cognitive component\n        self.c2 = 1.5\n        self.w = 0.6  # Slightly increased inertia weight\n        self.de_f = 0.6\n        self.de_cr = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.15\n        adapt_lr = 0.25\n        cooling_factor = 0.995\n        mutation_strength = 0.25\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n            \n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 77, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09717 with standard deviation 0.21444.", "error": "", "parent_ids": ["d04877bf-73e9-494d-b5f5-edfebc59b97e"], "operator": null, "metadata": {"aucs": [0.11114058259842219, 0.13273693834994238, 0.18618288734158062, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02495499799248857, 0.033121274905395626, 0.022016451306947182, 0.03589289647308869, 0.024775914108771224, 0.020000000000000018, 0.07602658520484429, 0.051897606606415625, 0.05690076112064335, 0.020000000000000018, 0.07057570542980118, 0.020000000000000018, 0.049414534583962055, 0.09404191616084001, 0.09887200909794847, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13810416502518608, 0.13367240136044534, 0.1730502466293138, 0.025181515160334733, 0.03233095771073391, 0.020000000000000018, 0.08586102160555642, 0.11591345255655372, 0.10314790072079316, 0.15762625840338784, 0.1452770015035303, 0.1262485513250411, 0.08708478464063663, 0.08209306181210141, 0.11035150638654301, 0.13179501094687085, 0.12087355986632287, 0.12963999972313411, 0.020000000000000018, 0.1321665602079557, 0.11448242430533184, 0.10819636878037442, 0.07914562866720598, 0.08332404810931893, 0.06527120746322768, 0.0767339159651057, 0.04452136084055891, 0.15034598674717192, 0.145231318920234, 0.15475448018179316, 0.051099681425430976, 0.032755273755330494, 0.031096431134673752, 0.05334833258677374, 0.04212809638124382, 0.0631958131993029, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017590759231063124, 0.011232177400690713, 0.013664522611704921, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010229991364536617, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08709422265835798, 0.08887179531741085, 0.08210114443948757, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06707772263177758, 0.06802147886603604, 0.05818270093707045, 0.13207880943710493, 0.10664931496971508, 0.10542635977547132, 0.07581673161337366, 0.04817984301990752, 0.053936809511723194, 0.09692398477782982, 0.08786645964704565, 0.10265539417047786, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04624584790986186, 0.04560762234261806, 0.03499461258958381, 0.04375630916765705, 0.032875103666579086, 0.024640285494433645, 0.1355874362551155, 0.14482443262646938, 0.13945350462768413, 0.01000988968228489, 0.010000000000000009, 0.010000000000000009, -0.4306540501198932, -0.41044009934103887, -0.4185022938882015, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.347591071372948, -0.3647704410937629, -0.32059839161040293, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.36761291131003193, -0.36599940991694435, -0.3720924740284657, -0.3165850626525235, -0.29358030192571594, -0.27516956098938783, -0.36831978308826674, -0.3931321843807205, -0.3662820184744411, -0.3017898843975715, -0.30449438065680456, -0.30197135225615446, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3985210954537215, -0.4040609119147953, -0.38330868957468844, -0.4279823269919476, -0.42489995600625385, -0.3842047038045078, -0.23301224282567778, -0.23419395177449043, -0.24528397604734775, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993]}}
{"id": "f9be8f9b-75ca-4373-bf56-c367fab39499", "fitness": -0.0985449375167584, "name": "ChaoticAdaptiveHybridPSODE", "description": "Enhance exploration with increased adaptive rates and improved elite retention for better convergence.", "code": "import numpy as np\n\nclass ChaoticAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.4  # Slightly reduced cognitive component\n        self.c2 = 1.6  # Slightly increased social component\n        self.w = 0.5   # inertia weight\n        self.de_f = 0.6  # Increased DE scaling factor\n        self.de_cr = 0.85  # Slightly reduced DE crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1  # Decreased chaotic sequence range\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.25  # Increased adaptation rate\n        adapt_lr = 0.3  # Increased adaptive learning rate\n        cooling_factor = 0.995\n        mutation_strength = 0.25  # Increased mutation strength\n        exploration_phase = True\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            # Adjust adaptive parameters using chaotic sequence\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * (self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor)\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * (np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n            \n            # Apply adaptive cooling strategy\n            self.w *= cooling_factor\n\n            # Increase DE crossover probability for exploration\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.05)\n\n            # Dynamic mutation strength adjustment\n            mutation_strength = 0.2 * (0.5 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.05\n\n            # Elite retention strategy: preserve the best solutions\n            elites = np.argsort(self.pbest_scores)[:max(3, self.population_size // 10)]  # Increased elite count\n            \n            # Introduce quasi-sinusoidal adaptive strategy for velocity\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, mutation_strength, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue  # Skip DE mutation for elite solutions\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            # Stochastic restart if stuck\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 78, "feedback": "The algorithm ChaoticAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09854 with standard deviation 0.21839.", "error": "", "parent_ids": ["d04877bf-73e9-494d-b5f5-edfebc59b97e"], "operator": null, "metadata": {"aucs": [0.12276893883871765, 0.12573389802428891, 0.18539854193088923, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02593589593506107, 0.023734974961616362, 0.020000000000000018, 0.02692120188119529, 0.020000000000000018, 0.02909947427777415, 0.07687614610331428, 0.052339170573231786, 0.05781837227376452, 0.020000000000000018, 0.07092142172762683, 0.020000000000000018, 0.032702397727055965, 0.11612809081234687, 0.09513538496040785, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06425615139318808, 0.029537705869220332, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12534871671894332, 0.12827745761986564, 0.1661681259272021, 0.0264107594691112, 0.03167868517369132, 0.020000000000000018, 0.0843060234480072, 0.10591501009639814, 0.0863630714335113, 0.14788094093073312, 0.1508785107021141, 0.1160417955509998, 0.07851094192770958, 0.0980130430017806, 0.1135674370238019, 0.14535144337725714, 0.11371919382129392, 0.1459194749349535, 0.020000000000000018, 0.13294556129991264, 0.11768918755755453, 0.11631305765433264, 0.06518411171010607, 0.08411335601861991, 0.06527120746322768, 0.09065251482860315, 0.04468713205723729, 0.1476771136934235, 0.14331927618968165, 0.15475448018179316, 0.05615299420760411, 0.025047546334364457, 0.029950489128463986, 0.05944649988280526, 0.04601806275688802, 0.06372691522842444, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018044597427790743, 0.014013000162592548, 0.015794585469797617, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01569964397461221, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08260882858544893, 0.09173680928330785, 0.08354127044544513, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0640669373983982, 0.062101457538225824, 0.0540031041254907, 0.13863225456562223, 0.11039747566509672, 0.1136393231953724, 0.06781181922570534, 0.04475380826919251, 0.0627503746342416, 0.0975166035380256, 0.09234767035609992, 0.09924240302203136, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07486986601353474, 0.03911156815143224, 0.040081314580998284, 0.025824506892041188, 0.03610253200657576, 0.024640285494433645, 0.14138847589851067, 0.13282232745799594, 0.1498419568152234, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4110833333966417, -0.3920609434517923, -0.4182831507946754, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.53, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.53, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.53, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3272687979176778, -0.3457368865587369, -0.31978736497002047, -0.3999999999999999, -0.41999999999999993, -0.53, -0.3639921806932589, -0.3572869770912994, -0.34854507666671375, -0.27553880139886733, -0.27099792674284684, -0.27823751659902296, -0.363822203004182, -0.3967818536487995, -0.4935584979463936, -0.307799382520934, -0.29350809065561556, -0.3114304785090618, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.3980217135271227, -0.4040597461783806, -0.3831817506960009, -0.38906968847989076, -0.4248930386928902, -0.5119897786370737, -0.22825405732210968, -0.21683156769449208, -0.20967840465867216, -0.41999999999999993, -0.3999999999999999, -0.53]}}
{"id": "6121e319-ded8-4e52-9e8c-f8a549dcddf0", "fitness": -0.09683687030214576, "name": "EnhancedChaoticPSODE", "description": "Enhance exploration with a dynamic chaotic mutation strategy and adaptive elitism to improve convergence rates.", "code": "import numpy as np\n\nclass EnhancedChaoticPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.w = 0.5\n        self.de_f = 0.6\n        self.de_cr = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.20\n        adapt_lr = 0.30\n        cooling_factor = 0.990\n        exploration_phase = True\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * np.sqrt(self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - np.sqrt(self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * np.sqrt(np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n\n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.07)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.10\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, 0.3, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedChaoticPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09684 with standard deviation 0.21451.", "error": "", "parent_ids": ["d04877bf-73e9-494d-b5f5-edfebc59b97e"], "operator": null, "metadata": {"aucs": [0.11320610113801988, 0.13163467470622148, 0.19021126015701983, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023589155193170064, 0.023671349736699487, 0.022971755273419214, 0.03739555286526641, 0.020000000000000018, 0.020000000000000018, 0.06939565167749773, 0.052029810755291006, 0.057114502667095945, 0.020000000000000018, 0.07077916444332288, 0.020000000000000018, 0.056698992742601484, 0.0866989002416696, 0.08000487615921936, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03092272932137108, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1382208772392659, 0.13723961711541222, 0.15260782284189245, 0.031009863455948916, 0.02476084870411943, 0.020000000000000018, 0.08072694858327945, 0.10534795581131651, 0.08613071287548346, 0.1578798495615955, 0.15647504192669726, 0.18692346309392693, 0.08371330181795456, 0.08480345806599798, 0.12583594886954985, 0.13790434043097233, 0.10918520067649107, 0.12469423933712875, 0.020000000000000018, 0.13571558513565674, 0.11360169094413253, 0.10819636878037442, 0.08493282200816776, 0.08319385021698611, 0.06527120746322768, 0.08026213123112469, 0.04512941659126013, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.06193359215955607, 0.03543396668150278, 0.04177712104992448, 0.05225480912206959, 0.04862449258322188, 0.06553508820807896, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01666690458729514, 0.01102739040126044, 0.013226084208964206, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011248094629035976, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07817684390464086, 0.0857406354889162, 0.08284087678299401, 0.010000000000000009, 0.010000000000000009, 0.011057600248736144, 0.059196418659899885, 0.06507778132814779, 0.05857474464247392, 0.13102189605419468, 0.10793219809073884, 0.11124804717079007, 0.09029275616504961, 0.05350248136461677, 0.055362890235357676, 0.0990467201251769, 0.08429849421730407, 0.09986650389011908, 0.010657423080881578, 0.010000000000000009, 0.010000000000000009, 0.04525305955993775, 0.04493969088715777, 0.03586633271882478, 0.04383966715162757, 0.03424379778847031, 0.024640285494433645, 0.14328218188421582, 0.146741634798219, 0.13769793903801297, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.4082682814876495, -0.4107147034407226, -0.4380177760061317, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3626905400143712, -0.35759135781700024, -0.31863227219358947, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.36378039814973384, -0.3795629110747729, -0.3744146137153248, -0.2940293967412637, -0.2873943568558912, -0.28353718291314745, -0.3647658496043116, -0.3967061357678545, -0.36524191355792546, -0.30469612113150846, -0.2836654936653975, -0.3129755597577337, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.3979582681854279, -0.4040303412751056, -0.402864523745482, -0.38907379664595765, -0.42480507342688156, -0.3838461139228486, -0.2187956657614496, -0.22271014295659253, -0.274707495495921, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999]}}
{"id": "87cd4196-bc2c-45c4-a7ed-6c6a42058857", "fitness": -0.09775825915279937, "name": "RefinedChaoticPSODE", "description": "Introduce a multi-phase adaptive learning rate and chaotic convergence strategy to enhance global and local search balance in dynamic environments.", "code": "import numpy as np\n\nclass RefinedChaoticPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.5\n        self.c2 = 1.7\n        self.w = 0.5\n        self.de_f = 0.7\n        self.de_cr = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.25\n        adapt_lr = 0.35\n        cooling_factor = 0.995\n        exploration_phase = True\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * np.sqrt(self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - np.sqrt(self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * np.sqrt(np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n\n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.4:\n                self.de_cr = min(1.0, self.de_cr + 0.1)\n\n            if exploration_phase and evals > self.budget * 0.6:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.15\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.cos(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, 0.3, self.dim)\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 80, "feedback": "The algorithm RefinedChaoticPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09776 with standard deviation 0.21400.", "error": "", "parent_ids": ["6121e319-ded8-4e52-9e8c-f8a549dcddf0"], "operator": null, "metadata": {"aucs": [0.13476577427984926, 0.12722799968489096, 0.17961851745311253, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03503941319195636, 0.0316379285679268, 0.0338314815279982, 0.03973228437331866, 0.020000000000000018, 0.020698103649122057, 0.08443950570826331, 0.05575347939987718, 0.05676555630272562, 0.020000000000000018, 0.08067722025517776, 0.020000000000000018, 0.04275941368317204, 0.0903237436527834, 0.08232599517243955, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14087603381821479, 0.1400346646326429, 0.1425668009044193, 0.03522038525837923, 0.023342775377395375, 0.020000000000000018, 0.08072694858327945, 0.0915947590271502, 0.08686332246408712, 0.14405217075290522, 0.13703258669255058, 0.1783297080828692, 0.08164213597629144, 0.08173748511072143, 0.10423222953462186, 0.1377841469967711, 0.11413041214643405, 0.14816081253845015, 0.020000000000000018, 0.020000000000000018, 0.10991038218677263, 0.11684625521170999, 0.07647048757892139, 0.09079961218741861, 0.06527120746322768, 0.08133254495399977, 0.04483265072147857, 0.1503476863637645, 0.13960598392277535, 0.15475448018179316, 0.05331782604641777, 0.03764522180237573, 0.047707162969446104, 0.051254287636474216, 0.04556092296312175, 0.0672393483200231, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021496508124632885, 0.010826445742466384, 0.01638651591272644, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010010856096077436, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08020356763934344, 0.08436620945882856, 0.08359843874944872, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05695482419915776, 0.06303348282349153, 0.05408148735755647, 0.13761529578554965, 0.11030875119818939, 0.10685698527235243, 0.06901191056454725, 0.05063036689124023, 0.053936809511723194, 0.10479156249219967, 0.08431558291833208, 0.09939720984478706, 0.01209070041243776, 0.013517291011710841, 0.010000000000000009, 0.043058318100792414, 0.04177320219250702, 0.03999860348768314, 0.025756376030793282, 0.03470829477318926, 0.025443687102886248, 0.13698563923948526, 0.1348751641157646, 0.1337832524086161, 0.011877090119266964, 0.010000000000000009, 0.010000000000000009, -0.427818723727708, -0.39517393221874575, -0.4387849250405247, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.36267671560615167, -0.3491473696080547, -0.33889395922523424, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.3615945572528283, -0.3554328789257215, -0.3508596360352403, -0.29554996131611144, -0.28811269012941776, -0.32427252614516955, -0.3741169819886141, -0.3776050957329764, -0.3651539357406577, -0.29337987097949103, -0.2846571109870135, -0.32664941496852773, -0.3999999999999999, -0.43999999999999995, -0.3999999999999999, -0.3977288273119879, -0.40522078176620147, -0.40261232994038987, -0.40880920414862865, -0.42488518905493344, -0.38331772082814886, -0.23826096493649573, -0.2122594704113494, -0.26131948786564374, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993]}}
{"id": "ba62092a-1d7c-40c9-9655-9ab1da489834", "fitness": -0.09791837826650468, "name": "EnhancedChaoticPSODE", "description": "Refine chaotic mutation and adaptive elitism with enhanced crossover and velocity adaptation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedChaoticPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.w = 0.5\n        self.de_f = 0.6\n        self.de_cr = 0.9  # Changed from 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.chaotic_seq = np.random.rand(self.budget) * 0.1\n\n    def __call__(self, func):\n        evals = 0\n        adapt_rate = 0.20\n        adapt_lr = 0.35  # Changed from 0.30\n        cooling_factor = 0.995  # Changed from 0.990\n        exploration_phase = True\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            chaotic_factor = self.chaotic_seq[evals % self.budget]\n            self.w = max(0.1, self.w * (1 - adapt_lr * adapt_rate * np.sqrt(self.gbest_score / np.mean(self.pbest_scores))) + chaotic_factor)\n            self.de_f = max(0.1, self.de_f * (1 + adapt_lr * adapt_rate * (1 - np.sqrt(self.gbest_score / (np.mean(self.pbest_scores) + 1e-8))) + chaotic_factor))\n            self.c1 = min(2.0, self.c1 + adapt_lr * adapt_rate * np.sqrt(np.mean(self.pbest_scores) / self.gbest_score) + chaotic_factor)\n\n            self.w *= cooling_factor\n\n            if evals > self.budget * 0.3:\n                self.de_cr = min(1.0, self.de_cr + 0.07)\n\n            if exploration_phase and evals > self.budget * 0.5:\n                exploration_phase = False\n                self.population_size = max(5, self.population_size // 2)\n                adapt_lr += 0.10\n\n            elites = np.argsort(self.pbest_scores)[:max(2, self.population_size // 10)]\n\n            angle = (evals / self.budget) * np.pi\n            adaptive_factor = 0.5 + 0.5 * np.sin(angle)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                noise = np.random.normal(0, 0.25, self.dim)  # Changed from 0.3\n                self.velocities[i] = adaptive_factor * self.w * (self.velocities[i] + noise) + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                if i in elites:\n                    continue\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.population[indices]\n                mutant_vector = np.clip(x1 + self.de_f * (x2 - x3 + (self.gbest_position - x1)), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evals += 1\n\n                if trial_score < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n            if evals % (self.budget // 4) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedChaoticPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.09792 with standard deviation 0.21407.", "error": "", "parent_ids": ["6121e319-ded8-4e52-9e8c-f8a549dcddf0"], "operator": null, "metadata": {"aucs": [0.11337741774818666, 0.13134948788106027, 0.19073002691365815, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02475306763149121, 0.022897294751325625, 0.023915351251499017, 0.035228654218375954, 0.021851198656670512, 0.020000000000000018, 0.06970162967957605, 0.052057529328630614, 0.05721358383542108, 0.020000000000000018, 0.07082960106451341, 0.020000000000000018, 0.06597380987328028, 0.0866989002416696, 0.08000487615921936, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02760643941839902, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14011662224174737, 0.13715930021675637, 0.1523181529416795, 0.03251347335684929, 0.028367789791896914, 0.020000000000000018, 0.08072694858327945, 0.10610517852236823, 0.08880429792562494, 0.13727508868551042, 0.15666525418483335, 0.18999384909172368, 0.0834320803886347, 0.08367274475086506, 0.11478643659591559, 0.1217018087011954, 0.10649681166377467, 0.1284870482961432, 0.020000000000000018, 0.020000000000000018, 0.11330195091124051, 0.10819636878037442, 0.07646367982541591, 0.08306057788335752, 0.06527120746322768, 0.07840945565576762, 0.0449803238421157, 0.1438526290318487, 0.1363678179423059, 0.15475448018179316, 0.05768539984252419, 0.030495415431751716, 0.04313960982365583, 0.051547999039698644, 0.04895974955828164, 0.06651493515092044, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016984274938966704, 0.011212740559130352, 0.016242816262613924, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0120417930150859, 0.010184522463159484, 0.010115938705443583, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07774150252561585, 0.0857449227271112, 0.0828425075389454, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06484456764317659, 0.06481010519165975, 0.05395939349942802, 0.13044225625192585, 0.10753470818090027, 0.1091008181900206, 0.09132332333344106, 0.052948856887374496, 0.05574438784835534, 0.09314941808354371, 0.08810849669377563, 0.10281494760749266, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04570427709042124, 0.04805454771345763, 0.038363995936363526, 0.02834987530740052, 0.034510296235494176, 0.024640285494433645, 0.13568829288791295, 0.13155158409762213, 0.13976416643842082, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.408339991069671, -0.41222053398153546, -0.43933011000648725, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3999999999999999, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.41999999999999993, -0.3999999999999999, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.41999999999999993, -0.43999999999999995, -0.43999999999999995, -0.3999999999999999, -0.3999999999999999, -0.41999999999999993, -0.3626690745524892, -0.3480779053314418, -0.3187975363527915, -0.3999999999999999, -0.41999999999999993, -0.3999999999999999, -0.3639232503501273, -0.3632133047848316, -0.37545569007827706, -0.2943491036215582, -0.2891042911663695, -0.28263223013773087, -0.38703427121644274, -0.3991422730742591, -0.36686070635591106, -0.2807614748059277, -0.30623634892480145, -0.30497148963105336, -0.41999999999999993, -0.43999999999999995, -0.41999999999999993, -0.3980998191340184, -0.4039921373352908, -0.40290892428341873, -0.40805783807055995, -0.42488296999474096, -0.3837961838691757, -0.23088857693662557, -0.23410449701432334, -0.2408521477899055, -0.41999999999999993, -0.3999999999999999, -0.3999999999999999]}}
{"id": "6a3b66fe-3608-4976-9542-e56cbac66d41", "fitness": -0.024613874213076287, "name": "EnhancedDynamicPSO", "description": "Introduce a multi-phase dynamic adaptation mechanism for exploration-exploitation balance and adaptive inertia weight to boost convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02461 with standard deviation 0.11772.", "error": "", "parent_ids": ["6121e319-ded8-4e52-9e8c-f8a549dcddf0"], "operator": null, "metadata": {"aucs": [0.10088395872021183, 0.1214210283759184, 0.14601256451707845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026927718916525123, 0.020000000000000018, 0.02813704211767598, 0.05195220173758652, 0.022352926488559022, 0.02559048076603776, 0.08820174733316188, 0.09455369172747607, 0.06995091783550866, 0.04210435172625937, 0.07699405322255481, 0.027814997237016414, 0.05769439077696403, 0.0880886975494326, 0.09611982082805215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03638255207981289, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029859745277293848, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16045833450271152, 0.12675270811090456, 0.14909471045398504, 0.02840420324316706, 0.020000000000000018, 0.0247959685457525, 0.08072694858327945, 0.0863116411064907, 0.0888550686957632, 0.16122593295272414, 0.16036547030863402, 0.13555635429606416, 0.07971958302641435, 0.09553987163855193, 0.07579394194771083, 0.18697269439193231, 0.10588039897337242, 0.12917272599232443, 0.14044546440932426, 0.020000000000000018, 0.036971456285601834, 0.1638062123033709, 0.07294831597279794, 0.08162259254456983, 0.09144009340085402, 0.11755367476596634, 0.05268383956379241, 0.15632213659423533, 0.13589170657517036, 0.15475448018179316, 0.05267301268595814, 0.03769181517553166, 0.033352600786122344, 0.06274510054025073, 0.05437007973106733, 0.06899799709893084, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05322268646967798, 0.01946293511469621, 0.028263848167494388, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013411610238187821, 0.04296289246091345, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09718187699192637, 0.06331801525289682, 0.10170146636103194, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06021812410709271, 0.06576124917700754, 0.0570725899462069, 0.12034678054162906, 0.10449935574485247, 0.11319828555503164, 0.06535942998398125, 0.046558065824034434, 0.05465689558881037, 0.09828718945006354, 0.09295523164527197, 0.10816526545139438, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04481088852155779, 0.03214999653376149, 0.04614310490515061, 0.036678441135112316, 0.03161868323535755, 0.03216770189170559, 0.15862824119760732, 0.1488696658700399, 0.13418547373103895, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19143168741482408, -0.19542537810874538, -0.19575041527133252, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19674595937162342, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.14597747650652604, -0.14618601196036485, -0.1454861616418821, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1422774912735929, -0.15483893424474116, -0.147156061870225, -0.0963611779052369, -0.09541245975507318, -0.10452816314456892, -0.16540424530247755, -0.17021045596426077, -0.16283136429274436, -0.10915885695665484, -0.10604316651849888, -0.09576168896976633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18172032668837512, -0.1875739252099231, -0.18726490832174503, -0.18822379924340082, -0.18758074892807786, -0.18827423017046874, -0.061348747280697946, -0.043207726894507026, -0.05721127452592545, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "708f9a0b-6f00-4135-889c-837e2f71aee8", "fitness": -0.02403315546235727, "name": "EnhancedDynamicPSO", "description": "Introduce Stochastic Restarts to escape local minima by probabilistically restarting particles to new random positions.", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < 0.01:  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02403 with standard deviation 0.11818.", "error": "", "parent_ids": ["6a3b66fe-3608-4976-9542-e56cbac66d41"], "operator": null, "metadata": {"aucs": [0.11587334303260677, 0.1411367627788438, 0.14601256451707845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026927718916525123, 0.029161034909685357, 0.03283845034265964, 0.03656363285834208, 0.030799166238995923, 0.02559048076603776, 0.07839525502396671, 0.09428481905990393, 0.06945900921492976, 0.02725864037466097, 0.07699405322255481, 0.020000000000000018, 0.05769439077696403, 0.0912689377378223, 0.09611982082805215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03638255207981289, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04777952778419192, 0.029859745277293848, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16045833450271152, 0.1306852736393309, 0.14629755862693938, 0.029480867557237223, 0.020000000000000018, 0.03487719484854179, 0.08237218408025404, 0.0863116411064907, 0.0882076532979349, 0.16122593295272414, 0.16036547030863402, 0.13555635429606416, 0.08487978641170602, 0.09553987163855193, 0.0775150528715085, 0.18697269439193231, 0.10718200650811383, 0.12917272599232443, 0.14044546440932426, 0.09871861378100977, 0.036971456285601834, 0.1638062123033709, 0.06844089199785264, 0.09828322528584688, 0.09144009340085402, 0.1085356093722365, 0.0470785146907895, 0.14831885243012843, 0.14380640872097838, 0.15475448018179316, 0.05267301268595814, 0.03769181517553166, 0.02664262378448956, 0.06273625700368757, 0.04919536661281887, 0.06899799709893084, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059770616210894856, 0.02608542980974138, 0.020736634987649327, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013411610238187821, 0.027266992394312406, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08659697178131998, 0.0654534520456882, 0.10133556635120389, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057460394783998114, 0.06185839854218278, 0.0570725899462069, 0.12009373860173933, 0.10804708630151783, 0.10604216120793675, 0.06925052089880235, 0.04603293932126007, 0.055037363747681534, 0.09828718945006354, 0.09328090860440907, 0.10816526545139438, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04961145630574293, 0.044462767236901346, 0.04343014159615921, 0.027470077299184048, 0.03043557572968003, 0.03175794127196907, 0.15862824119760732, 0.1488696658700399, 0.14914708320300119, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19143168741482408, -0.1930131805690969, -0.19575041527133252, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19641700692123742, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.144743329647137, -0.14618601196036485, -0.1454861616418821, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1422774912735929, -0.15383647429818859, -0.147156061870225, -0.09707132158404286, -0.09541837370690098, -0.10398850421566341, -0.16540424530247755, -0.17052575427055694, -0.1631758576724085, -0.10915885695665484, -0.10604316651849888, -0.09576168896976633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18172032668837512, -0.1875739252099231, -0.18694239452555683, -0.18833215205554432, -0.18758074892807786, -0.18827423017046874, -0.05860939518555042, -0.043207726894507026, -0.05721127452592545, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "752ce5a1-942d-4376-8001-896bdfe0575b", "fitness": -0.02403315546235727, "name": "EnhancedDynamicPSO", "description": "Implement dynamic population resizing in PSO to adaptively focus computational resources on promising areas of the search space and enhance convergence speed.", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n        self.dynamic_rescale_threshold = 0.1 * self.population_size\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < 0.01:  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n            if len(np.unique(self.pbest_scores)) < self.dynamic_rescale_threshold:\n                self.population_size = max(int(self.population_size * 0.9), self.initial_population_size)\n                self.population = self.population[:self.population_size]\n                self.velocities = self.velocities[:self.population_size]\n                self.pbest_positions = self.pbest_positions[:self.population_size]\n                self.pbest_scores = self.pbest_scores[:self.population_size]\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02403 with standard deviation 0.11818.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11587334303260677, 0.1411367627788438, 0.14601256451707845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026927718916525123, 0.029161034909685357, 0.03283845034265964, 0.03656363285834208, 0.030799166238995923, 0.02559048076603776, 0.07839525502396671, 0.09428481905990393, 0.06945900921492976, 0.02725864037466097, 0.07699405322255481, 0.020000000000000018, 0.05769439077696403, 0.0912689377378223, 0.09611982082805215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03638255207981289, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04777952778419192, 0.029859745277293848, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16045833450271152, 0.1306852736393309, 0.14629755862693938, 0.029480867557237223, 0.020000000000000018, 0.03487719484854179, 0.08237218408025404, 0.0863116411064907, 0.0882076532979349, 0.16122593295272414, 0.16036547030863402, 0.13555635429606416, 0.08487978641170602, 0.09553987163855193, 0.0775150528715085, 0.18697269439193231, 0.10718200650811383, 0.12917272599232443, 0.14044546440932426, 0.09871861378100977, 0.036971456285601834, 0.1638062123033709, 0.06844089199785264, 0.09828322528584688, 0.09144009340085402, 0.1085356093722365, 0.0470785146907895, 0.14831885243012843, 0.14380640872097838, 0.15475448018179316, 0.05267301268595814, 0.03769181517553166, 0.02664262378448956, 0.06273625700368757, 0.04919536661281887, 0.06899799709893084, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059770616210894856, 0.02608542980974138, 0.020736634987649327, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013411610238187821, 0.027266992394312406, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08659697178131998, 0.0654534520456882, 0.10133556635120389, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057460394783998114, 0.06185839854218278, 0.0570725899462069, 0.12009373860173933, 0.10804708630151783, 0.10604216120793675, 0.06925052089880235, 0.04603293932126007, 0.055037363747681534, 0.09828718945006354, 0.09328090860440907, 0.10816526545139438, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04961145630574293, 0.044462767236901346, 0.04343014159615921, 0.027470077299184048, 0.03043557572968003, 0.03175794127196907, 0.15862824119760732, 0.1488696658700399, 0.14914708320300119, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19143168741482408, -0.1930131805690969, -0.19575041527133252, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19641700692123742, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.144743329647137, -0.14618601196036485, -0.1454861616418821, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1422774912735929, -0.15383647429818859, -0.147156061870225, -0.09707132158404286, -0.09541837370690098, -0.10398850421566341, -0.16540424530247755, -0.17052575427055694, -0.1631758576724085, -0.10915885695665484, -0.10604316651849888, -0.09576168896976633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18172032668837512, -0.1875739252099231, -0.18694239452555683, -0.18833215205554432, -0.18758074892807786, -0.18827423017046874, -0.05860939518555042, -0.043207726894507026, -0.05721127452592545, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "c492df07-77d9-47f8-861a-79c6da194ea1", "fitness": -0.02403315546235727, "name": "EnhancedDynamicPSO", "description": "Introduce a dynamic stochastic restart probability that increases slightly with each phase to improve exploration.", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < 0.01 * phase:  # Dynamic stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02403 with standard deviation 0.11818.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11587334303260677, 0.1411367627788438, 0.14601256451707845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026927718916525123, 0.029161034909685357, 0.03283845034265964, 0.03656363285834208, 0.030799166238995923, 0.02559048076603776, 0.07839525502396671, 0.09428481905990393, 0.06945900921492976, 0.02725864037466097, 0.07699405322255481, 0.020000000000000018, 0.05769439077696403, 0.0912689377378223, 0.09611982082805215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03638255207981289, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04777952778419192, 0.029859745277293848, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16045833450271152, 0.1306852736393309, 0.14629755862693938, 0.029480867557237223, 0.020000000000000018, 0.03487719484854179, 0.08237218408025404, 0.0863116411064907, 0.0882076532979349, 0.16122593295272414, 0.16036547030863402, 0.13555635429606416, 0.08487978641170602, 0.09553987163855193, 0.0775150528715085, 0.18697269439193231, 0.10718200650811383, 0.12917272599232443, 0.14044546440932426, 0.09871861378100977, 0.036971456285601834, 0.1638062123033709, 0.06844089199785264, 0.09828322528584688, 0.09144009340085402, 0.1085356093722365, 0.0470785146907895, 0.14831885243012843, 0.14380640872097838, 0.15475448018179316, 0.05267301268595814, 0.03769181517553166, 0.02664262378448956, 0.06273625700368757, 0.04919536661281887, 0.06899799709893084, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059770616210894856, 0.02608542980974138, 0.020736634987649327, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013411610238187821, 0.027266992394312406, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08659697178131998, 0.0654534520456882, 0.10133556635120389, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057460394783998114, 0.06185839854218278, 0.0570725899462069, 0.12009373860173933, 0.10804708630151783, 0.10604216120793675, 0.06925052089880235, 0.04603293932126007, 0.055037363747681534, 0.09828718945006354, 0.09328090860440907, 0.10816526545139438, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04961145630574293, 0.044462767236901346, 0.04343014159615921, 0.027470077299184048, 0.03043557572968003, 0.03175794127196907, 0.15862824119760732, 0.1488696658700399, 0.14914708320300119, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19143168741482408, -0.1930131805690969, -0.19575041527133252, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19641700692123742, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.144743329647137, -0.14618601196036485, -0.1454861616418821, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1422774912735929, -0.15383647429818859, -0.147156061870225, -0.09707132158404286, -0.09541837370690098, -0.10398850421566341, -0.16540424530247755, -0.17052575427055694, -0.1631758576724085, -0.10915885695665484, -0.10604316651849888, -0.09576168896976633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18172032668837512, -0.1875739252099231, -0.18694239452555683, -0.18833215205554432, -0.18758074892807786, -0.18827423017046874, -0.05860939518555042, -0.043207726894507026, -0.05721127452592545, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "9ab1e803-9097-4b54-9810-42f3f0116930", "fitness": -0.024662792381738977, "name": "AdaptiveDynamicPSO", "description": "Enhance convergence by dynamically adjusting swarm size and learning rates based on performance metrics.", "code": "import numpy as np\n\nclass AdaptiveDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n        improvement_threshold = 1e-5\n        no_improvement_count = 0\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n                    no_improvement_count = 0\n\n            if evals >= self.budget:\n                break\n\n            # Dynamic adjustment of learning rates and inertia\n            improvement = np.abs(np.min(self.pbest_scores) - self.gbest_score)\n            if improvement < improvement_threshold:\n                no_improvement_count += 1\n            else:\n                no_improvement_count = 0\n\n            if no_improvement_count > self.budget // 10:  # If no improvement over a significant period\n                self.population_size = min(self.population_size + 5, self.initial_population_size * 2)\n                self.population = np.vstack([self.population, np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))])\n                self.velocities = np.vstack([self.velocities, np.random.uniform(-1, 1, (5, self.dim))])\n                self.pbest_positions = np.vstack([self.pbest_positions, np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))])\n                self.pbest_scores = np.concatenate([self.pbest_scores, np.full(5, np.inf)])\n\n            self.w = 0.5 + 0.4 * (1 - evals / self.budget)\n            self.c1 = 1.5 + 0.5 * (1 - evals / self.budget)\n            self.c2 = 2.5 - 0.5 * (1 - evals / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.01:  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 86, "feedback": "The algorithm AdaptiveDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02466 with standard deviation 0.11750.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11818067299809709, 0.153963250624225, 0.14358952197004526, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04859135669220804, 0.02760100721182479, 0.02827379664739571, 0.041074771635990714, 0.03757693557808184, 0.021013389105768554, 0.0783388860734271, 0.10070905592401236, 0.06999799443760368, 0.024831821359094564, 0.07456613009817314, 0.024449247563367194, 0.06162122189510422, 0.08674254365263268, 0.09741237223676957, 0.020000000000000018, 0.020000000000000018, 0.03568427967281995, 0.034049124244625806, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04259058577062358, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15624158452156733, 0.13358806067546813, 0.14666404546780454, 0.025470125862545157, 0.020000000000000018, 0.04116193997497608, 0.08943066201977912, 0.09372563576037918, 0.08848068584198543, 0.14539125862333435, 0.17121080034618996, 0.13100580422663766, 0.09561059413305772, 0.08558617619432707, 0.07213732108799831, 0.133120206254695, 0.119073092577334, 0.12847637219257646, 0.15794569703531924, 0.020000000000000018, 0.020000000000000018, 0.16415866240396326, 0.07374063038993739, 0.09648112428859168, 0.0919237175665728, 0.10695331744537073, 0.04667241694634994, 0.14921203206584732, 0.14076479132429143, 0.15475448018179316, 0.04267521921930495, 0.0443796676748327, 0.033057007039358544, 0.06298390004198273, 0.048691180389117794, 0.06826168188728776, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06317784567630591, 0.02275163340664943, 0.02131889324968017, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01328435798005545, 0.026906890208675538, 0.010084898186473512, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08586673586436377, 0.06401083119040696, 0.09963903391200801, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05771931064940017, 0.06371133155753517, 0.05724759406045621, 0.12215912440710097, 0.10648738229500909, 0.10838821998327419, 0.06400040412000996, 0.04668387467281421, 0.05413301216621624, 0.1036252236803944, 0.09165215608461763, 0.10337251568173644, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.046756879881385216, 0.039465264077593765, 0.04414507381225319, 0.030284409880600438, 0.03048253581396576, 0.0327269473044991, 0.13177304946073276, 0.1391473827610784, 0.13795763078031142, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.1929801997163494, -0.19451040070534797, -0.1963376844200979, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19467426666858234, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15103869593812425, -0.1465438708273583, -0.14708327325978932, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.14101440201057036, -0.1506450148502474, -0.16201484239767172, -0.09420817209507426, -0.0929798460465141, -0.10487141797414545, -0.16599260087475098, -0.15625818737820607, -0.15890826726994822, -0.11484446385217151, -0.1071326976631155, -0.10023005125197493, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18189298449124713, -0.18846585352327883, -0.18670764730490697, -0.18812116219731134, -0.18759968518260606, -0.18833741819546668, -0.05313795105939856, -0.043207726894507026, -0.0562726702649301, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "95f39260-e604-420b-9594-2b4b4e5fc6d1", "fitness": -Infinity, "name": "EnhancedDynamicPSO", "description": "Introduce an adaptive learning factor for stochastic restarts based on diversity to improve convergence speed and robustness.", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < (0.01 + 0.1 * np.std(self.pbest_scores) / (self.gbest_score + 1e-9)):  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 87, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (5,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (5,) (10,) ')", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {}}
{"id": "d9053733-bd89-435b-9175-ac314507becc", "fitness": -0.02689336482089282, "name": "DynamicAdaptivePSO", "description": "Dynamic Adaptive PSO with Fitness-Based Velocity Adjustment enhances convergence by adapting velocity based on fitness improvement rate.", "code": "import numpy as np\n\nclass DynamicAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n        self.improvement_rate = np.zeros(self.population_size)\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n                improvement = self.pbest_scores[i] - score\n\n                if improvement > 0:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n                    self.improvement_rate[i] = improvement / score\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                velocity_adjustment = 1.0 + self.improvement_rate[i]\n                self.velocities[i] = self.w * self.velocities[i] * velocity_adjustment + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n                    self.improvement_rate.fill(0)\n\n            if np.random.rand() < 0.01:  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n                self.improvement_rate.fill(0)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 88, "feedback": "The algorithm DynamicAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02689 with standard deviation 0.12771.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.0941006713422915, 0.09949584109851262, 0.12111305630268887, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.6360761041569201, 0.5714953387100654, 0.05677728351789513, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.057929235093625686, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10273879703462696, 0.1072873812205728, 0.13084903150896143, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09083108962931374, 0.0863116411064907, 0.07472961621262353, 0.1329366697426011, 0.13571493492881226, 0.12447807254299093, 0.05943272979281122, 0.07990382579724953, 0.05610455226583122, 0.11205586464406281, 0.08503307741421029, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.06360782465788817, 0.08523633648721007, 0.06527120746322768, 0.04616535580723691, 0.043369709139307044, 0.1438526290318487, 0.1387501100963422, 0.15913875020120827, 0.038669801718039354, 0.024229576080161186, 0.02657375009670604, 0.03916060196802318, 0.04698010346208381, 0.04504365850582315, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.039813328815496485, 0.045705506055700784, 0.024860017200469042, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08839552676276918, 0.052105224897132985, 0.07245549618395475, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06648906611841854, 0.055413499703506286, 0.11890004373701091, 0.10211239229331037, 0.10998873439023027, 0.05756835603815702, 0.03768986428017085, 0.053936809511723194, 0.07896945735270666, 0.06539405484546112, 0.08807105303750307, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025202877901636223, 0.029043163533977734, 0.026018756973356538, 0.024895242935785933, 0.02255610680040465, 0.024640285494433645, 0.14617885359443994, 0.131240333511619, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1987473804753186, -0.19982875559813884, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15610643703624594, -0.1608168490617179, -0.16668254584955844, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15870523495013278, -0.15337590689187808, -0.1576381742129822, -0.09672201610875542, -0.0969399174480643, -0.0984377340858118, -0.17483764429509918, -0.1708859526233497, -0.17760710554761028, -0.12156757854714062, -0.12982477324864217, -0.13108436736253992, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18832264645009378, -0.18953099590788547, -0.18867049822916426, -0.191147705244745, -0.18780676904453797, -0.19128855528143762, -0.05412983056520093, -0.043207726894507026, -0.05858279696896318, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "5dd96ed2-c0d1-4ce2-bd0a-dcc232f7cc22", "fitness": -0.02601783470893874, "name": "AdaptiveSwarmTopologyPSO", "description": "Adaptive Swarm Topology PSO with Dynamic Interaction Neighborhoods to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveSwarmTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.neighborhood_size = max(1, self.population_size // 5)\n        self.communication_probability = 0.05\n\n    def __call__(self, func):\n        evals = 0\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                neighbors = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                best_neighbor_position = min(neighbors, key=lambda x: self.pbest_scores[x])\n                social = self.c2 * r2 * (self.pbest_positions[best_neighbor_position] - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < self.communication_probability:  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 89, "feedback": "The algorithm AdaptiveSwarmTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02602 with standard deviation 0.11688.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11532688676658731, 0.11260785227762138, 0.1319027425462299, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02283280792475917, 0.028172980313198925, 0.028405418866945364, 0.020000000000000018, 0.02210191518475957, 0.02290878795709661, 0.09577834230131343, 0.11049957238456543, 0.05357450027374011, 0.020000000000000018, 0.07602330928693812, 0.020000000000000018, 0.055826440960713875, 0.09988518739097896, 0.09912395881101499, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026017720284162493, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1657156685966089, 0.13083644237363923, 0.13084903150896143, 0.037332899699257904, 0.020000000000000018, 0.04317097511261925, 0.08144433545279384, 0.09927005686099277, 0.07019959314188418, 0.16038439179466124, 0.1455137385498816, 0.12411938579896087, 0.09362337491652295, 0.10437147526146129, 0.08328304335102898, 0.12954018338708861, 0.121559485649812, 0.15379503776397652, 0.13351349808007396, 0.020000000000000018, 0.020000000000000018, 0.11600386508427307, 0.1128363645475281, 0.1118076750215028, 0.10498022095879378, 0.07260715608964863, 0.04704194445371257, 0.14905058004026184, 0.14085469279309326, 0.15475448018179316, 0.06199191567220452, 0.037899229519712474, 0.03327900098193581, 0.05008911786705772, 0.06881151182685263, 0.048780120731716003, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03287932286699369, 0.02046884561475648, 0.01105655321808785, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014757279787603217, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08421580024043895, 0.07767615174508391, 0.07968616218275182, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.056707764813800354, 0.06996723253086212, 0.06199920555795957, 0.12161255876027799, 0.10810099416289731, 0.10498656884334256, 0.06695870240286439, 0.04550640091288538, 0.053936809511723194, 0.10052009803935902, 0.08969617408974073, 0.10059870398572746, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.038099577042940314, 0.04333726782703062, 0.03748282395989788, 0.029971097842559247, 0.025701272326037805, 0.024640285494433645, 0.13218190505018046, 0.13993795203855142, 0.1542509337119895, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19763380405172515, -0.19767235564994046, -0.1954766358670179, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.14999261484288762, -0.14607641075370248, -0.1381869930584787, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.14916207660992886, -0.15483893424474116, -0.15634295391823305, -0.09846122570521354, -0.09013765318988254, -0.10166533591121985, -0.17328277065396436, -0.1617874791245375, -0.16455749976540868, -0.10844807641772936, -0.11205962366473732, -0.11257377657433953, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18404999345101314, -0.18751353863317033, -0.18658009263035025, -0.1909250459338554, -0.18780676904453797, -0.18807601982069322, -0.056828419271490516, -0.04242559478610075, -0.06452396471758637, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "4261e739-7e18-4f9d-8af8-886a8112f5e4", "fitness": -0.02509625219348879, "name": "EnhancedDynamicPSO", "description": "Introduce Adaptive Population Resizing and Dynamic Subgroups to enhance diversity and convergence speed by adjusting population size and forming subgroups based on diversity metrics.", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n        self.restart_threshold = self.budget // 5\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            diversity = np.std(self.population, axis=0).mean()\n            if diversity < 0.1:\n                self.population_size = max(5, self.population_size - 1)\n            else:\n                self.population_size = min(self.initial_population_size, self.population_size + 1)\n            \n            if evals % self.restart_threshold == 0:\n                subgroups = max(2, int(self.population_size / 3))\n                for _ in range(subgroups):\n                    idx = np.random.choice(np.arange(self.population_size), size=self.population_size // subgroups, replace=False)\n                    self.population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, (len(idx), self.dim))\n                    self.velocities[idx] = np.random.uniform(-1, 1, (len(idx), self.dim))\n                    self.pbest_positions[idx] = np.copy(self.population[idx])\n                    self.pbest_scores[idx].fill(np.inf)\n\n            if np.random.rand() < 0.01:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02510 with standard deviation 0.11744.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11587334303260677, 0.1411367627788438, 0.14601256451707845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026927718916525123, 0.029161034909685357, 0.03283845034265964, 0.03656363285834208, 0.030799166238995923, 0.02559048076603776, 0.07839525502396671, 0.09428481905990393, 0.06945900921492976, 0.02725864037466097, 0.07699405322255481, 0.020000000000000018, 0.05769439077696403, 0.0912689377378223, 0.09611982082805215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03638255207981289, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04777952778419192, 0.029859745277293848, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16045833450271152, 0.1306852736393309, 0.14629755862693938, 0.029480867557237223, 0.020000000000000018, 0.03487719484854179, 0.08237218408025404, 0.0863116411064907, 0.0882076532979349, 0.16122593295272414, 0.16036547030863402, 0.13555635429606416, 0.08487978641170602, 0.09553987163855193, 0.0775150528715085, 0.18697269439193231, 0.10718200650811383, 0.12917272599232443, 0.14044546440932426, 0.09871861378100977, 0.036971456285601834, 0.1638062123033709, 0.06844089199785264, 0.09828322528584688, 0.09144009340085402, 0.1085356093722365, 0.0470785146907895, 0.14831885243012843, 0.14380640872097838, 0.15475448018179316, 0.05267301268595814, 0.03769181517553166, 0.02664262378448956, 0.041044671670480315, 0.038049365642215505, 0.060906600408929035, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01153598373580167, 0.018820853760673217, 0.010656509076683474, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013535665253399332, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08734266398499069, 0.06520968722828813, 0.08191099986961126, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06041587248275193, 0.06178231390743094, 0.05662382154027956, 0.1199511076130425, 0.11000507364308831, 0.11866374404687718, 0.06132217131723794, 0.04858233778937093, 0.05399029682907808, 0.10884118626597061, 0.09893067245501497, 0.10339351071378966, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029155481843680442, 0.030495078615302984, 0.031187855436155543, 0.030293834709703926, 0.027196030348960787, 0.024640285494433645, 0.13166155317347072, 0.13123409970527322, 0.14016810230706656, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19143168741482408, -0.19276655949008648, -0.19575041527133252, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19927789525212347, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.144743329647137, -0.14618601196036485, -0.1454861616418821, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1422774912735929, -0.15483893424474116, -0.147156061870225, -0.09707132158404286, -0.09439677196667629, -0.10355611381703778, -0.16540424530247755, -0.17052575427055694, -0.1631758576724085, -0.10915885695665484, -0.10604316651849888, -0.09576168896976633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18172032668837512, -0.18612510496097823, -0.18669796060132393, -0.18834926725723955, -0.18758074892807786, -0.18827423017046874, -0.06008444733031504, -0.043207726894507026, -0.05639754998461277, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "7d1514db-55ff-4471-a9f1-b0a9e6aabfcf", "fitness": -0.031057974351445458, "name": "AdaptiveNeighborhoodPSO", "description": "Adaptive Particle Swarm Optimization with Dynamic Neighborhoods to enhance exploration-exploitation balance and prevent premature convergence.", "code": "import numpy as np\n\nclass AdaptiveNeighborhoodPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.neighborhood_radius = 2.0\n    \n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n                \n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n                    \n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n            \n            if evals >= self.budget:\n                break\n            \n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n            \n            for i in range(self.population_size):\n                local_best = self._get_local_best(i)\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (local_best - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n            \n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n                    self.neighborhood_radius = 2.0  # Reset neighborhood radius\n\n            if np.random.rand() < 0.01:  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n                self.neighborhood_radius = 2.0\n    \n        return self.gbest_position, self.gbest_score\n    \n    def _get_local_best(self, index):\n        dists = np.linalg.norm(self.population - self.population[index], axis=1)\n        neighborhood_mask = dists < self.neighborhood_radius\n        neighborhood_indices = np.where(neighborhood_mask)[0]\n        if len(neighborhood_indices) > 0:\n            local_best_index = neighborhood_indices[np.argmin(self.pbest_scores[neighborhood_indices])]\n            return self.pbest_positions[local_best_index]\n        return self.gbest_position", "configspace": "", "generation": 91, "feedback": "The algorithm AdaptiveNeighborhoodPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.03106 with standard deviation 0.11374.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.08301056944362517, 0.08529805523460066, 0.12166816711033335, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027277590804816065, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026536422411312488, 0.05327287744196274, 0.043840871072323484, 0.05042037489136875, 0.020000000000000018, 0.05241130382744674, 0.020000000000000018, 0.020000000000000018, 0.09703414783186981, 0.09549625223025571, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.112714549103062, 0.10326186401109883, 0.1387217276483219, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.11337788724154862, 0.13136478663951157, 0.13323277534341382, 0.12062559183652832, 0.0674565543781992, 0.0842683170114159, 0.07216449998696783, 0.18697269439193231, 0.09331837863811787, 0.1342042377448328, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12440207371528089, 0.10027146488878913, 0.08542051167445497, 0.07303993841300593, 0.06458459655261917, 0.043369709139307044, 0.14965793633081947, 0.13904928914119297, 0.15475448018179316, 0.04376719320921241, 0.037059750807861724, 0.03151362632688437, 0.025530011661955898, 0.017555384401946705, 0.04046900865431735, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01001142629908669, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06673629950626714, 0.05238181533861275, 0.0657491231548134, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05544224675177223, 0.07162213653512428, 0.06251906609769664, 0.1199446069521406, 0.09453216563726263, 0.10281775224528589, 0.05813665349240538, 0.03637440858739782, 0.053936809511723194, 0.08626719866550248, 0.07223891690925655, 0.09226200017186315, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02888167316099488, 0.029722066264633362, 0.028824155183172162, 0.02570928463625155, 0.0367886694258448, 0.025838155832121235, 0.14149990354131847, 0.13514312442704945, 0.13796794065763418, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15644576255947062, -0.16339480232400372, -0.16675058721950986, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15512584930558693, -0.1507188311442189, -0.15749591380191785, -0.10224465948450723, -0.10298944008266675, -0.1064252589656951, -0.1732050426733538, -0.1708859526233497, -0.17527726413171174, -0.11460883712662828, -0.12654687299570622, -0.1304580319794144, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18821714773558873, -0.18947329132951984, -0.18863892813694827, -0.19090518267058765, -0.18758074892807786, -0.19128855528143762, -0.05246516736090867, -0.043207726894507026, -0.06095426520621383, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "7c96020e-5955-4b6d-bd65-73b58c4a1541", "fitness": -Infinity, "name": "EnhancedDynamicPSO", "description": "Enhanced Dynamic PSO with Adaptive Learning Rates and Diverse Exploratory Moves to improve exploration and exploitation balance.  ", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n        no_improvement_count = 0\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n                    no_improvement_count = 0\n                else:\n                    no_improvement_count += 1\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < 0.01 or no_improvement_count > self.population_size:  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n                no_improvement_count = 0\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 92, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (5,) (10,) ').", "error": "ValueError('operands could not be broadcast together with shapes (5,) (10,) ')", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {}}
{"id": "a87eb839-de41-446b-bbcb-2a9c271f548d", "fitness": -Infinity, "name": "EnhancedDynamicPSO", "description": "Adaptive Exploration Exploitation PSO that dynamically adjusts velocity and position strategies to maintain balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.5  # Increased cognitive coefficient\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < 0.03:  # Increased probability for stochastic restarts\n                perturbation = np.random.normal(0, 0.1, self.population.shape)\n                self.population = np.clip(self.population + perturbation,\n                                          self.lower_bound, self.upper_bound)\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 93, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,) (5,) ')", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {}}
{"id": "24a702cb-107d-46b5-85a5-b5ca7ff6c261", "fitness": -0.02403315546235727, "name": "RefinedDynamicPSO", "description": "Introduce Adaptive Swarm Size Adjustment and Dynamic Escape Mechanism to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n        self.adaptive_threshold = 0.01  # Threshold for adaptive swarm size reduction\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < self.adaptive_threshold:\n                    self.population_size = max(5, self.population_size // 2)\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores = np.full(self.population_size, np.inf)\n\n            if np.random.rand() < 0.01:  # Stochastic restarts with reduced probability\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 94, "feedback": "The algorithm RefinedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02403 with standard deviation 0.11818.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11587334303260677, 0.1411367627788438, 0.14601256451707845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026927718916525123, 0.029161034909685357, 0.03283845034265964, 0.03656363285834208, 0.030799166238995923, 0.02559048076603776, 0.07839525502396671, 0.09428481905990393, 0.06945900921492976, 0.02725864037466097, 0.07699405322255481, 0.020000000000000018, 0.05769439077696403, 0.0912689377378223, 0.09611982082805215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03638255207981289, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04777952778419192, 0.029859745277293848, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16045833450271152, 0.1306852736393309, 0.14629755862693938, 0.029480867557237223, 0.020000000000000018, 0.03487719484854179, 0.08237218408025404, 0.0863116411064907, 0.0882076532979349, 0.16122593295272414, 0.16036547030863402, 0.13555635429606416, 0.08487978641170602, 0.09553987163855193, 0.0775150528715085, 0.18697269439193231, 0.10718200650811383, 0.12917272599232443, 0.14044546440932426, 0.09871861378100977, 0.036971456285601834, 0.1638062123033709, 0.06844089199785264, 0.09828322528584688, 0.09144009340085402, 0.1085356093722365, 0.0470785146907895, 0.14831885243012843, 0.14380640872097838, 0.15475448018179316, 0.05267301268595814, 0.03769181517553166, 0.02664262378448956, 0.06273625700368757, 0.04919536661281887, 0.06899799709893084, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059770616210894856, 0.02608542980974138, 0.020736634987649327, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013411610238187821, 0.027266992394312406, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08659697178131998, 0.0654534520456882, 0.10133556635120389, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057460394783998114, 0.06185839854218278, 0.0570725899462069, 0.12009373860173933, 0.10804708630151783, 0.10604216120793675, 0.06925052089880235, 0.04603293932126007, 0.055037363747681534, 0.09828718945006354, 0.09328090860440907, 0.10816526545139438, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04961145630574293, 0.044462767236901346, 0.04343014159615921, 0.027470077299184048, 0.03043557572968003, 0.03175794127196907, 0.15862824119760732, 0.1488696658700399, 0.14914708320300119, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19143168741482408, -0.1930131805690969, -0.19575041527133252, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19641700692123742, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.144743329647137, -0.14618601196036485, -0.1454861616418821, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1422774912735929, -0.15383647429818859, -0.147156061870225, -0.09707132158404286, -0.09541837370690098, -0.10398850421566341, -0.16540424530247755, -0.17052575427055694, -0.1631758576724085, -0.10915885695665484, -0.10604316651849888, -0.09576168896976633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18172032668837512, -0.1875739252099231, -0.18694239452555683, -0.18833215205554432, -0.18758074892807786, -0.18827423017046874, -0.05860939518555042, -0.043207726894507026, -0.05721127452592545, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "d1decab7-46fa-4f02-8036-32a38b6da6e0", "fitness": -0.024520978954667177, "name": "EnhancedDynamicPSO", "description": "Introduce Dynamic Velocity Adjustment by slightly adjusting inertia weight calculation to enhance convergence speed.", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.6 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < 0.01:  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02452 with standard deviation 0.11796.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.1168037653616204, 0.14446929162256228, 0.1477522036188864, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03317300764787745, 0.020000000000000018, 0.030279107387358284, 0.03829552395258251, 0.022137429698449562, 0.022763860814619674, 0.07835384209849561, 0.10360367648182522, 0.07043354346371555, 0.02866307458523143, 0.07814242792452686, 0.020000000000000018, 0.05769439077696403, 0.08674254365263268, 0.09580643860239269, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04145419463707156, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16044234582836014, 0.1314484415740561, 0.1447633665438226, 0.031871885664800925, 0.020000000000000018, 0.03388638510865205, 0.08423471082571521, 0.09481523221862342, 0.07392752636764233, 0.14683276826238723, 0.16860598800877125, 0.13577734138967767, 0.09205365317400893, 0.08266715982860884, 0.08337549447755055, 0.14890327866091635, 0.11069699348348605, 0.14829103974162106, 0.14166317164829023, 0.020000000000000018, 0.020000000000000018, 0.15833302470880828, 0.07216320461850134, 0.08947085621116946, 0.09096729637992274, 0.10650541256302093, 0.048833909396087116, 0.1618280763749027, 0.18316618043959465, 0.15475448018179316, 0.04889379959618845, 0.035652164236383066, 0.03029723604759882, 0.06173937116357464, 0.049144230422771495, 0.06896602838140098, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.060816313693922264, 0.02410750627146596, 0.0274134284619727, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027347990641207187, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08682209370962257, 0.06452609013334454, 0.10202861856118917, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05674044472265083, 0.06187777601775235, 0.06053200353768606, 0.1233185282866367, 0.11077869566580101, 0.10894902691531372, 0.07361796324859471, 0.050717910318149095, 0.05428536180961996, 0.10781434695819858, 0.09799862413523841, 0.10914955822759542, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04606464969328283, 0.044785456055591144, 0.04241941216290246, 0.02719014178853496, 0.030322755930445866, 0.03154389055440898, 0.13542887372832113, 0.16061565525501043, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19168654197137536, -0.19385291419151796, -0.19569641584171982, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19577400953839152, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.14376197870298602, -0.1464004251753861, -0.14512956349511308, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.13638195363074668, -0.15430337027981067, -0.15109057929965553, -0.09703292596467272, -0.09546432075081768, -0.10664658568159835, -0.16730465399108008, -0.1680938048052174, -0.16320189770002247, -0.11365509226728743, -0.10481845011302915, -0.10313367100709847, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1815304566867162, -0.1875584068252043, -0.18695295705058634, -0.18849288704834866, -0.18762815799074373, -0.1882787367199934, -0.048630244531705724, -0.043207726894507026, -0.053359470801378706, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "731da58c-4e79-4fd6-bb8c-2579f0f0b199", "fitness": -0.02590824109861107, "name": "HybridAdaptivePSO", "description": "Hybrid Adaptive PSO introduces random swarm size adjustments and adaptive velocity scaling to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evals = 0\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n            adaptive_velocity_factor = 1.0 + 0.5 * np.sin(2 * np.pi * evals / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] *= adaptive_velocity_factor\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < 0.02:  # Stochastic restarts with new swarm size\n                if np.random.rand() < 0.5:\n                    self.population_size = np.random.randint(self.initial_population_size // 2, self.initial_population_size * 2)\n                else:\n                    self.population_size = self.initial_population_size\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores = np.full(self.population_size, np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 96, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02591 with standard deviation 0.11678.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11113557079530834, 0.13417159836317472, 0.13328831615505576, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020319929113459367, 0.020000000000000018, 0.029538713440254716, 0.02905450444308655, 0.023115155039034496, 0.03126462619683712, 0.0785188970402051, 0.1118022360196409, 0.06126144580581672, 0.03373885192147119, 0.05840006618109328, 0.020000000000000018, 0.05161141511401435, 0.08594148016760361, 0.08264841440823711, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14897137571095354, 0.1262033464203669, 0.15334849239654147, 0.03583117823812487, 0.020000000000000018, 0.03921160626839337, 0.08337948703428455, 0.0863116411064907, 0.09071747400904939, 0.1479002144306919, 0.14341081571601266, 0.12704271566316538, 0.08133481928430086, 0.08903011018438245, 0.06707868218248192, 0.14135016512736687, 0.11809877173095062, 0.1313087726201264, 0.12745893390557428, 0.020000000000000018, 0.020000000000000018, 0.13637402423746525, 0.09699841123480502, 0.08966862805227782, 0.11248140019910091, 0.09745055689474325, 0.04530917380922006, 0.16134527798538723, 0.18147656042765936, 0.16041940548519928, 0.04204978587416319, 0.03355685232494876, 0.04262510887767301, 0.060164666360915886, 0.04487077692696673, 0.06266251923273458, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06633239016270709, 0.017834370526033427, 0.02709639969076605, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013208258045104171, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07758237387483835, 0.07105468009978566, 0.10381458834413437, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0613417037229973, 0.0615609065189221, 0.05395939349942802, 0.12063131180495101, 0.11227193079618814, 0.10323417159401116, 0.06455374374036982, 0.04600884527102478, 0.054504440766156126, 0.09990054993677933, 0.09177846788547028, 0.11151354044810735, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03572251123192194, 0.03246560090127404, 0.042046510754478184, 0.025795673277168585, 0.03214040973843657, 0.02825921927984365, 0.13402757223617812, 0.13498317315459607, 0.1364968190924022, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19989949120892003, -0.1958204946793416, -0.19660996747212978, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19770051915513842, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.14779767194395332, -0.145434072956919, -0.14519334761072367, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1602959498537886, -0.15106789550026822, -0.15415863532582819, -0.0968843124440899, -0.09007376304762849, -0.09859252929820461, -0.1691134325510999, -0.15880295928844812, -0.16318610070647654, -0.10412756476965246, -0.11194361223152804, -0.10674197286861986, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18379749340291784, -0.18908098488586056, -0.18486052713553414, -0.18723302927754037, -0.18688541673081027, -0.18682523376447557, -0.06346300149728301, -0.03770291373482082, -0.0542597105088769, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "23854213-f893-4713-b7bb-05202daf7801", "fitness": -0.02403315546235727, "name": "EnhancedSubpopulationPSO", "description": "Introduce Dynamic Subpopulation Splitting in PSO to preserve diversity by dividing particles into subpopulations when convergence stalls.", "code": "import numpy as np\n\nclass EnhancedSubpopulationPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n        self.subpopulation_size = self.population_size // 2\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n        subpopulations = [self.population]\n\n        while evals < self.budget:\n            for subpop in subpopulations:\n                for i in range(len(subpop)):\n                    score = func(subpop[i])\n                    evals += 1\n\n                    if score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = score\n                        self.pbest_positions[i] = subpop[i]\n\n                    if score < self.gbest_score:\n                        self.gbest_score = score\n                        self.gbest_position = subpop[i]\n\n                if evals >= self.budget:\n                    break\n\n                if evals >= self.phase_change_point * phase:\n                    phase += 1\n                    self.c1 -= 0.5\n                    self.c2 += 0.5\n\n                self.w = 0.4 + 0.5 * (1 - evals / self.budget)\n\n                for i in range(len(subpop)):\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    cognitive = self.c1 * r1 * (self.pbest_positions[i] - subpop[i])\n                    social = self.c2 * r2 * (self.gbest_position - subpop[i])\n                    self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                    self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                    subpop[i] = np.clip(subpop[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    new_subpop = np.random.uniform(self.lower_bound, self.upper_bound, (self.subpopulation_size, self.dim))\n                    subpopulations.append(new_subpop)\n                    self.velocities = np.random.uniform(-1, 1, (self.subpopulation_size, self.dim))\n                    self.pbest_positions = np.vstack([self.pbest_positions, new_subpop])\n                    self.pbest_scores = np.concatenate([self.pbest_scores, np.full(self.subpopulation_size, np.inf)])\n\n            if np.random.rand() < 0.01:\n                for subpop in subpopulations:\n                    subpop[:] = np.random.uniform(self.lower_bound, self.upper_bound, subpop.shape)\n                    self.velocities = np.random.uniform(-1, 1, subpop.shape)\n                    self.pbest_positions = np.copy(subpop)\n                    self.pbest_scores.fill(np.inf)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedSubpopulationPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02403 with standard deviation 0.11818.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11587334303260677, 0.1411367627788438, 0.14601256451707845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026927718916525123, 0.029161034909685357, 0.03283845034265964, 0.03656363285834208, 0.030799166238995923, 0.02559048076603776, 0.07839525502396671, 0.09428481905990393, 0.06945900921492976, 0.02725864037466097, 0.07699405322255481, 0.020000000000000018, 0.05769439077696403, 0.0912689377378223, 0.09611982082805215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03638255207981289, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04777952778419192, 0.029859745277293848, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16045833450271152, 0.1306852736393309, 0.14629755862693938, 0.029480867557237223, 0.020000000000000018, 0.03487719484854179, 0.08237218408025404, 0.0863116411064907, 0.0882076532979349, 0.16122593295272414, 0.16036547030863402, 0.13555635429606416, 0.08487978641170602, 0.09553987163855193, 0.0775150528715085, 0.18697269439193231, 0.10718200650811383, 0.12917272599232443, 0.14044546440932426, 0.09871861378100977, 0.036971456285601834, 0.1638062123033709, 0.06844089199785264, 0.09828322528584688, 0.09144009340085402, 0.1085356093722365, 0.0470785146907895, 0.14831885243012843, 0.14380640872097838, 0.15475448018179316, 0.05267301268595814, 0.03769181517553166, 0.02664262378448956, 0.06273625700368757, 0.04919536661281887, 0.06899799709893084, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059770616210894856, 0.02608542980974138, 0.020736634987649327, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013411610238187821, 0.027266992394312406, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08659697178131998, 0.0654534520456882, 0.10133556635120389, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057460394783998114, 0.06185839854218278, 0.0570725899462069, 0.12009373860173933, 0.10804708630151783, 0.10604216120793675, 0.06925052089880235, 0.04603293932126007, 0.055037363747681534, 0.09828718945006354, 0.09328090860440907, 0.10816526545139438, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04961145630574293, 0.044462767236901346, 0.04343014159615921, 0.027470077299184048, 0.03043557572968003, 0.03175794127196907, 0.15862824119760732, 0.1488696658700399, 0.14914708320300119, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19143168741482408, -0.1930131805690969, -0.19575041527133252, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19641700692123742, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.144743329647137, -0.14618601196036485, -0.1454861616418821, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1422774912735929, -0.15383647429818859, -0.147156061870225, -0.09707132158404286, -0.09541837370690098, -0.10398850421566341, -0.16540424530247755, -0.17052575427055694, -0.1631758576724085, -0.10915885695665484, -0.10604316651849888, -0.09576168896976633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18172032668837512, -0.1875739252099231, -0.18694239452555683, -0.18833215205554432, -0.18758074892807786, -0.18827423017046874, -0.05860939518555042, -0.043207726894507026, -0.05721127452592545, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "58523ba1-8546-48b7-a028-fff113e44402", "fitness": -0.02403315546235727, "name": "EnhancedDynamicPSOAdaptive", "description": "Introduce Adaptive Mutation and Trajectory Memory to diversify exploration and exploit successful paths in EnhancedDynamicPSO.", "code": "import numpy as np\n\nclass EnhancedDynamicPSOAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n        self.memory = []\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n                    self.memory.append(self.gbest_position)\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < 0.01:\n                mutation_strength = np.random.exponential(0.1)\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.1:\n                        mutation_vector = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n                        self.population[i] = np.clip(self.population[i] + mutation_vector, self.lower_bound, self.upper_bound)\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedDynamicPSOAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02403 with standard deviation 0.11818.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11587334303260677, 0.1411367627788438, 0.14601256451707845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026927718916525123, 0.029161034909685357, 0.03283845034265964, 0.03656363285834208, 0.030799166238995923, 0.02559048076603776, 0.07839525502396671, 0.09428481905990393, 0.06945900921492976, 0.02725864037466097, 0.07699405322255481, 0.020000000000000018, 0.05769439077696403, 0.0912689377378223, 0.09611982082805215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03638255207981289, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04777952778419192, 0.029859745277293848, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16045833450271152, 0.1306852736393309, 0.14629755862693938, 0.029480867557237223, 0.020000000000000018, 0.03487719484854179, 0.08237218408025404, 0.0863116411064907, 0.0882076532979349, 0.16122593295272414, 0.16036547030863402, 0.13555635429606416, 0.08487978641170602, 0.09553987163855193, 0.0775150528715085, 0.18697269439193231, 0.10718200650811383, 0.12917272599232443, 0.14044546440932426, 0.09871861378100977, 0.036971456285601834, 0.1638062123033709, 0.06844089199785264, 0.09828322528584688, 0.09144009340085402, 0.1085356093722365, 0.0470785146907895, 0.14831885243012843, 0.14380640872097838, 0.15475448018179316, 0.05267301268595814, 0.03769181517553166, 0.02664262378448956, 0.06273625700368757, 0.04919536661281887, 0.06899799709893084, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059770616210894856, 0.02608542980974138, 0.020736634987649327, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013411610238187821, 0.027266992394312406, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08659697178131998, 0.0654534520456882, 0.10133556635120389, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057460394783998114, 0.06185839854218278, 0.0570725899462069, 0.12009373860173933, 0.10804708630151783, 0.10604216120793675, 0.06925052089880235, 0.04603293932126007, 0.055037363747681534, 0.09828718945006354, 0.09328090860440907, 0.10816526545139438, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04961145630574293, 0.044462767236901346, 0.04343014159615921, 0.027470077299184048, 0.03043557572968003, 0.03175794127196907, 0.15862824119760732, 0.1488696658700399, 0.14914708320300119, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19143168741482408, -0.1930131805690969, -0.19575041527133252, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19641700692123742, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.144743329647137, -0.14618601196036485, -0.1454861616418821, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1422774912735929, -0.15383647429818859, -0.147156061870225, -0.09707132158404286, -0.09541837370690098, -0.10398850421566341, -0.16540424530247755, -0.17052575427055694, -0.1631758576724085, -0.10915885695665484, -0.10604316651849888, -0.09576168896976633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18172032668837512, -0.1875739252099231, -0.18694239452555683, -0.18833215205554432, -0.18758074892807786, -0.18827423017046874, -0.05860939518555042, -0.043207726894507026, -0.05721127452592545, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "2aa42f95-a892-408f-a1a6-7672cbc0da22", "fitness": -0.02403315546235727, "name": "EnhancedDynamicPSO", "description": "Introduce a dynamic population size adjustment based on performance to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 + dim\n        self.population_size = self.initial_population_size\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound)\n        self.phase_change_point = self.budget // 3\n\n    def __call__(self, func):\n        evals = 0\n        phase = 1\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                evals += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.population[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.population[i]\n\n            if evals >= self.budget:\n                break\n\n            if evals >= self.phase_change_point * phase:\n                phase += 1\n                self.c1 -= 0.5\n                self.c2 += 0.5\n\n            self.w = 0.4 + 0.5 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.population[i])\n                social = self.c2 * r2 * (self.gbest_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            if evals % (self.budget // 5) == 0:\n                if np.ptp(self.pbest_scores) < 1e-6:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                    self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                    self.pbest_positions = np.copy(self.population)\n                    self.pbest_scores.fill(np.inf)\n\n            if np.random.rand() < 0.01:  # Stochastic restarts\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n                self.pbest_positions = np.copy(self.population)\n                self.pbest_scores.fill(np.inf)\n                \n            if evals % (self.budget // 10) == 0:  # Dynamic population size adjustment\n                self.population_size = int(0.9 * self.population_size) if np.ptp(self.pbest_scores) < 1e-5 else self.population_size\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02403 with standard deviation 0.11818.", "error": "", "parent_ids": ["708f9a0b-6f00-4135-889c-837e2f71aee8"], "operator": null, "metadata": {"aucs": [0.11587334303260677, 0.1411367627788438, 0.14601256451707845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026927718916525123, 0.029161034909685357, 0.03283845034265964, 0.03656363285834208, 0.030799166238995923, 0.02559048076603776, 0.07839525502396671, 0.09428481905990393, 0.06945900921492976, 0.02725864037466097, 0.07699405322255481, 0.020000000000000018, 0.05769439077696403, 0.0912689377378223, 0.09611982082805215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03638255207981289, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04777952778419192, 0.029859745277293848, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16045833450271152, 0.1306852736393309, 0.14629755862693938, 0.029480867557237223, 0.020000000000000018, 0.03487719484854179, 0.08237218408025404, 0.0863116411064907, 0.0882076532979349, 0.16122593295272414, 0.16036547030863402, 0.13555635429606416, 0.08487978641170602, 0.09553987163855193, 0.0775150528715085, 0.18697269439193231, 0.10718200650811383, 0.12917272599232443, 0.14044546440932426, 0.09871861378100977, 0.036971456285601834, 0.1638062123033709, 0.06844089199785264, 0.09828322528584688, 0.09144009340085402, 0.1085356093722365, 0.0470785146907895, 0.14831885243012843, 0.14380640872097838, 0.15475448018179316, 0.05267301268595814, 0.03769181517553166, 0.02664262378448956, 0.06273625700368757, 0.04919536661281887, 0.06899799709893084, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059770616210894856, 0.02608542980974138, 0.020736634987649327, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013411610238187821, 0.027266992394312406, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08659697178131998, 0.0654534520456882, 0.10133556635120389, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057460394783998114, 0.06185839854218278, 0.0570725899462069, 0.12009373860173933, 0.10804708630151783, 0.10604216120793675, 0.06925052089880235, 0.04603293932126007, 0.055037363747681534, 0.09828718945006354, 0.09328090860440907, 0.10816526545139438, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04961145630574293, 0.044462767236901346, 0.04343014159615921, 0.027470077299184048, 0.03043557572968003, 0.03175794127196907, 0.15862824119760732, 0.1488696658700399, 0.14914708320300119, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19143168741482408, -0.1930131805690969, -0.19575041527133252, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19641700692123742, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.144743329647137, -0.14618601196036485, -0.1454861616418821, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1422774912735929, -0.15383647429818859, -0.147156061870225, -0.09707132158404286, -0.09541837370690098, -0.10398850421566341, -0.16540424530247755, -0.17052575427055694, -0.1631758576724085, -0.10915885695665484, -0.10604316651849888, -0.09576168896976633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18172032668837512, -0.1875739252099231, -0.18694239452555683, -0.18833215205554432, -0.18758074892807786, -0.18827423017046874, -0.05860939518555042, -0.043207726894507026, -0.05721127452592545, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
