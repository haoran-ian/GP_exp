{"id": "ae46f693-9630-4000-a0e8-3da729ce7f02", "fitness": 0.031119058021491126, "name": "HybridPSODE", "description": "Hybrid Particle Swarm and Differential Evolution algorithm that explores the search space dynamically by combining swarm intelligence and differential mutation strategies for effective optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = personal_best[a] + self.F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.04294977087579577, 0.04294977087579577, 0.04294977087579577, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05436453789936935, 0.05436453789936935, 0.05436453789936935, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.101874169008214, 0.101874169008214, 0.101874169008214, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052017609329708336, 0.052017609329708336, 0.052017609329708336, 0.11453705693922722, 0.11453705693922722, 0.11453705693922722, 0.06008775752797069, 0.06008775752797069, 0.06008775752797069, 0.09699710590340616, 0.09699710590340616, 0.09699710590340616, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05848861645723036, 0.05848861645723036, 0.05848861645723036, 0.02526796080055227, 0.02526796080055227, 0.02526796080055227, 0.13418585125257354, 0.13418585125257354, 0.13418585125257354, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "33f5756b-cb5d-4da6-83dd-fcc2c2123a21", "fitness": 0.031119058021491126, "name": "HybridPSODE", "description": "Introduced adaptive parameters for PSO and DE to enhance search space exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = personal_best[a] + self.F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["ae46f693-9630-4000-a0e8-3da729ce7f02"], "operator": null, "metadata": {"aucs": [0.04294977087579577, 0.04294977087579577, 0.04294977087579577, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05436453789936935, 0.05436453789936935, 0.05436453789936935, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.101874169008214, 0.101874169008214, 0.101874169008214, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052017609329708336, 0.052017609329708336, 0.052017609329708336, 0.11453705693922722, 0.11453705693922722, 0.11453705693922722, 0.06008775752797069, 0.06008775752797069, 0.06008775752797069, 0.09699710590340616, 0.09699710590340616, 0.09699710590340616, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05848861645723036, 0.05848861645723036, 0.05848861645723036, 0.02526796080055227, 0.02526796080055227, 0.02526796080055227, 0.13418585125257354, 0.13418585125257354, 0.13418585125257354, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "59ddc567-ff84-4e53-a3b3-dac5040b56f3", "fitness": 0.028566818014711188, "name": "HybridPSODE", "description": "HybridPSODE with adaptive inertia weight for better convergence by dynamically adjusting the exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            self.w = 0.9 - 0.8 * (eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = personal_best[a] + self.F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["ae46f693-9630-4000-a0e8-3da729ce7f02"], "operator": null, "metadata": {"aucs": [0.047875578321527446, 0.047875578321527446, 0.047875578321527446, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0369059130563425, 0.0369059130563425, 0.0369059130563425, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08163625999276003, 0.08163625999276003, 0.08163625999276003, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04855298899853888, 0.04855298899853888, 0.04855298899853888, 0.11232464706416168, 0.11232464706416168, 0.11232464706416168, 0.05068956591766205, 0.05068956591766205, 0.05068956591766205, 0.09307538182010733, 0.09307538182010733, 0.09307538182010733, 0.00916811783643745, 0.00916811783643745, 0.00916811783643745, 0.04160707902452687, 0.04160707902452687, 0.04160707902452687, 0.016406044600660863, 0.016406044600660863, 0.016406044600660863, 0.1417098818072997, 0.1417098818072997, 0.1417098818072997, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "3b89cc43-b319-43ac-9584-7572b95bc4f8", "fitness": 0.029541896486493507, "name": "HybridPSODE", "description": "Improved Hybrid PSO-DE with adaptive parameters and enhanced mutation strategy for robust optimization.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 2.0  # Increased cognitive parameter for PSO\n        self.c2 = 2.0  # Increased social parameter for PSO\n        self.w = 0.7   # Increased inertia weight for PSO\n        self.F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = (1 - self.F) * personal_best[i] + self.F * (personal_best[a] - personal_best[b] + personal_best[c]) \n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["ae46f693-9630-4000-a0e8-3da729ce7f02"], "operator": null, "metadata": {"aucs": [0.0488497454361827, 0.046452862813404994, 0.03942015918606345, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04025282940848085, 0.039324495310400276, 0.01795741739019696, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0012337740482244453, 0.0025234985977223845, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08445255005099661, 0.08474947132757382, 0.09556046002898333, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048266320387806205, 0.052821560402941725, 0.05390428908040357, 0.10357324006739732, 0.11276562436952597, 0.11031641797904423, 0.055671511871496326, 0.05232959190139119, 0.060985932698840783, 0.09545624403324382, 0.09670280911094209, 0.09824963367193285, 0.00043478260869567187, 0.0017476044892812403, 0.014368220567236634, 0.0503355374042993, 0.05011236484091752, 0.04896730625320744, 0.024413797152808003, 0.019783615914471975, 0.01900477830553604, 0.14154399693303776, 0.1489005532935832, 0.14949659356952183, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0e58a8e4-176a-4108-bba1-38c2a3d6d89b", "fitness": 0.03531398617545086, "name": "HybridPSODE", "description": "A modified Hybrid Particle Swarm and Differential Evolution algorithm where the inertia weight is dynamically adjusted using a decaying factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget)  # Dynamic inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = personal_best[a] + self.F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.04.", "error": "", "parent_ids": ["ae46f693-9630-4000-a0e8-3da729ce7f02"], "operator": null, "metadata": {"aucs": [0.0658382452338967, 0.0658382452338967, 0.0658382452338967, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04224227105723355, 0.04224227105723355, 0.04224227105723355, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004163182410576782, 0.004163182410576782, 0.004163182410576782, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10917190813199495, 0.10917190813199495, 0.10917190813199495, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048220078296240976, 0.048220078296240976, 0.048220078296240976, 0.10884356978110132, 0.10884356978110132, 0.10884356978110132, 0.05660386472071699, 0.05660386472071699, 0.05660386472071699, 0.10266081000034122, 0.10266081000034122, 0.10266081000034122, 0.06820881792833422, 0.06820881792833422, 0.06820881792833422, 0.06735005864923238, 0.06735005864923238, 0.06735005864923238, 0.02518410047239006, 0.02518410047239006, 0.02518410047239006, 0.1438313702244135, 0.1438313702244135, 0.1438313702244135, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2d913048-7cd2-460c-9a50-a615bbca6535", "fitness": 0.037959650017031214, "name": "HybridPSODE", "description": "Enhanced Hybrid Particle Swarm and Differential Evolution with adaptive mutation factor to improve local search.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget)  # Dynamic inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0e58a8e4-176a-4108-bba1-38c2a3d6d89b"], "operator": null, "metadata": {"aucs": [0.09233811399637704, 0.09233811399637704, 0.09233811399637704, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05846665878500967, 0.05846665878500967, 0.05846665878500967, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.02216812842629523, 0.02216812842629523, 0.02216812842629523, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1269624248585779, 0.1269624248585779, 0.1269624248585779, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05131473635739714, 0.05131473635739714, 0.05131473635739714, 0.12218781284167379, 0.12218781284167379, 0.12218781284167379, 0.06053834867169683, 0.06053834867169683, 0.06053834867169683, 0.10351487015096861, 0.10351487015096861, 0.10351487015096861, 0.052235121754443004, 0.052235121754443004, 0.052235121754443004, 0.06330907136880781, 0.06330907136880781, 0.06330907136880781, 0.01839534147487032, 0.01839534147487032, 0.01839534147487032, 0.1343835804182838, 0.1343835804182838, 0.1343835804182838, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "141df425-29cc-4632-97e1-563c44a23375", "fitness": 0.06104646010450819, "name": "HybridPSODE", "description": "Enhanced Hybrid Particle Swarm and Differential Evolution with adaptive inertia weight and crossover rate to improve exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = self.CR - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.13.", "error": "", "parent_ids": ["2d913048-7cd2-460c-9a50-a615bbca6535"], "operator": null, "metadata": {"aucs": [0.06824246345767537, 0.06824246345767537, 0.06824246345767537, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6591801220489166, 0.6591801220489166, 0.6591801220489166, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.000796698831783349, 0.000796698831783349, 0.000796698831783349, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09359564898496109, 0.09359564898496109, 0.09359564898496109, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05360947628310242, 0.05360947628310242, 0.05360947628310242, 0.12199308764423555, 0.12199308764423555, 0.12199308764423555, 0.06573504545609743, 0.06573504545609743, 0.06573504545609743, 0.10059565159180928, 0.10059565159180928, 0.10059565159180928, 0.0349785369335982, 0.0349785369335982, 0.0349785369335982, 0.10661419341589073, 0.10661419341589073, 0.10661419341589073, 0.021020923021979443, 0.021020923021979443, 0.021020923021979443, 0.13353580353379912, 0.13353580353379912, 0.13353580353379912, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "57ffa1b2-c510-4b22-8104-af3288b6f63b", "fitness": 0.036077436931164594, "name": "HybridPSODE", "description": "Enhanced Hybrid PSO-DE with self-adaptive selection of parameters and dynamic population resizing to improve convergence efficiency.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.3 + 0.4 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.2 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = self.CR - 0.3 * (eval_count / self.budget)  # Adaptive crossover rate\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["141df425-29cc-4632-97e1-563c44a23375"], "operator": null, "metadata": {"aucs": [0.07761744377659796, 0.07761744377659796, 0.07761744377659796, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051171118202798405, 0.051171118202798405, 0.051171118202798405, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.009069437344225606, 0.009069437344225606, 0.009069437344225606, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09758199565456815, 0.09758199565456815, 0.09758199565456815, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04842257828104857, 0.04842257828104857, 0.04842257828104857, 0.12870794785364648, 0.12870794785364648, 0.12870794785364648, 0.06403078050906374, 0.06403078050906374, 0.06403078050906374, 0.10109725611477305, 0.10109725611477305, 0.10109725611477305, 0.011052191552314627, 0.011052191552314627, 0.011052191552314627, 0.10699423803706931, 0.10699423803706931, 0.10699423803706931, 0.0242772888806686, 0.0242772888806686, 0.0242772888806686, 0.1406188188368277, 0.1406188188368277, 0.1406188188368277, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b4088a78-8433-4b7c-a755-02a030910d6d", "fitness": 0.06170819870053955, "name": "HybridPSODE", "description": "HybridPSODE with adaptive self-adjusting crossover rate for enhanced convergence.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = self.CR - 0.35 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.13.", "error": "", "parent_ids": ["141df425-29cc-4632-97e1-563c44a23375"], "operator": null, "metadata": {"aucs": [0.07136041873855548, 0.07136041873855548, 0.07136041873855548, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6717165523258646, 0.6717165523258646, 0.6717165523258646, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0036235831122093387, 0.0036235831122093387, 0.0036235831122093387, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10245061956362222, 0.10245061956362222, 0.10245061956362222, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050522710009886396, 0.050522710009886396, 0.050522710009886396, 0.1223460571955175, 0.1223460571955175, 0.1223460571955175, 0.058340574578247706, 0.058340574578247706, 0.058340574578247706, 0.09937606056584314, 0.09937606056584314, 0.09937606056584314, 0.04579456946281368, 0.04579456946281368, 0.04579456946281368, 0.09241793416596922, 0.09241793416596922, 0.09241793416596922, 0.0221105112824167, 0.0221105112824167, 0.0221105112824167, 0.13571978650765515, 0.13571978650765515, 0.13571978650765515, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4de72ea6-94f5-4842-b59e-89fe6d65c74e", "fitness": 0.06293270826823462, "name": "HybridPSODE", "description": "HybridPSODE with improved adaptive mutation and crossover strategies for better exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.15.", "error": "", "parent_ids": ["b4088a78-8433-4b7c-a755-02a030910d6d"], "operator": null, "metadata": {"aucs": [0.06418892356451367, 0.06418892356451367, 0.06418892356451367, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7504852744471278, 0.7504852744471278, 0.7504852744471278, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003613788926093542, 0.003613788926093542, 0.003613788926093542, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09338579546619197, 0.09338579546619197, 0.09338579546619197, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05114420816974652, 0.05114420816974652, 0.05114420816974652, 0.12713651074936283, 0.12713651074936283, 0.12713651074936283, 0.05741906241517147, 0.05741906241517147, 0.05741906241517147, 0.10086119397702709, 0.10086119397702709, 0.10086119397702709, 0.0016084365664312816, 0.0016084365664312816, 0.0016084365664312816, 0.08979387336609446, 0.08979387336609446, 0.08979387336609446, 0.017845997038102746, 0.017845997038102746, 0.017845997038102746, 0.14768454244741946, 0.14768454244741946, 0.14768454244741946, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "106c2f72-5d86-4b87-a984-573fdeeb7106", "fitness": 0.030787623084661986, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic particle velocity adjustment for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = ((self.w + 0.2 * np.random.rand()) * velocities[i] +  # Dynamic velocity adjustment\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["4de72ea6-94f5-4842-b59e-89fe6d65c74e"], "operator": null, "metadata": {"aucs": [0.06013812310974198, 0.06013812310974198, 0.06013812310974198, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03973733743419361, 0.03973733743419361, 0.03973733743419361, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003641815300666984, 0.003641815300666984, 0.003641815300666984, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07781886433494456, 0.07781886433494456, 0.07781886433494456, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05584640083977066, 0.05584640083977066, 0.05584640083977066, 0.1136369335398435, 0.1136369335398435, 0.1136369335398435, 0.05909623636537931, 0.05909623636537931, 0.05909623636537931, 0.09633736626226097, 0.09633736626226097, 0.09633736626226097, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06417830013519266, 0.06417830013519266, 0.06417830013519266, 0.02228027461686921, 0.02228027461686921, 0.02228027461686921, 0.1405391281799806, 0.1405391281799806, 0.1405391281799806, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "abfb7dd0-c601-4ffe-9000-2872ab7e9554", "fitness": 0.06460725953736321, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by adjusting PSO's inertia weight for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 11, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.15.", "error": "", "parent_ids": ["4de72ea6-94f5-4842-b59e-89fe6d65c74e"], "operator": null, "metadata": {"aucs": [0.06619995573166348, 0.06619995573166348, 0.06619995573166348, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7368391052898932, 0.7368391052898932, 0.7368391052898932, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002085814097093519, 0.002085814097093519, 0.002085814097093519, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10272293669648724, 0.10272293669648724, 0.10272293669648724, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05063323919365437, 0.05063323919365437, 0.05063323919365437, 0.12943537433422725, 0.12943537433422725, 0.12943537433422725, 0.06089761816275585, 0.06089761816275585, 0.06089761816275585, 0.10430496082458851, 0.10430496082458851, 0.10430496082458851, 0.030438612138466548, 0.030438612138466548, 0.030438612138466548, 0.09776094504486099, 0.09776094504486099, 0.09776094504486099, 0.02693860906728074, 0.02693860906728074, 0.02693860906728074, 0.13709966701139742, 0.13709966701139742, 0.13709966701139742, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "cd49c86e-f0fa-4459-a862-a859077e68cf", "fitness": 0.030040375334622633, "name": "HybridPSODE", "description": "Enhanced exploration-exploitation balance in HybridPSODE by fine-tuning adaptive parameters.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.7  # Cognitive parameter for PSO\n        self.c2 = 1.7  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.7 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 12, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["abfb7dd0-c601-4ffe-9000-2872ab7e9554"], "operator": null, "metadata": {"aucs": [0.04379520471218157, 0.04379520471218157, 0.04379520471218157, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05535605805048971, 0.05535605805048971, 0.05535605805048971, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09963639635769439, 0.09963639635769439, 0.09963639635769439, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.047503845461096095, 0.047503845461096095, 0.047503845461096095, 0.11198610431158573, 0.11198610431158573, 0.11198610431158573, 0.06208351343705232, 0.06208351343705232, 0.06208351343705232, 0.08835116769249196, 0.08835116769249196, 0.08835116769249196, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.054726038067840266, 0.054726038067840266, 0.054726038067840266, 0.01665792702538449, 0.01665792702538449, 0.01665792702538449, 0.13478579639338728, 0.13478579639338728, 0.13478579639338728, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0631fa24-1659-4098-89fb-8122384ef73f", "fitness": 0.06157580920080425, "name": "HybridPSODE", "description": "Improved HybridPSODE by introducing a linearly decreasing inertia weight strategy for better convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 - 0.3 * (eval_count / self.budget)  # Linearly decreasing inertia weight strategy\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 13, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.13.", "error": "", "parent_ids": ["abfb7dd0-c601-4ffe-9000-2872ab7e9554"], "operator": null, "metadata": {"aucs": [0.08158887813463955, 0.08158887813463955, 0.08158887813463955, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6406556837598234, 0.6406556837598234, 0.6406556837598234, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.008162625001590929, 0.008162625001590929, 0.008162625001590929, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1104448846750562, 0.1104448846750562, 0.1104448846750562, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0706268391984266, 0.0706268391984266, 0.0706268391984266, 0.11498024655007577, 0.11498024655007577, 0.11498024655007577, 0.07422658567325469, 0.07422658567325469, 0.07422658567325469, 0.10042345310310341, 0.10042345310310341, 0.10042345310310341, 0.027609024104609414, 0.027609024104609414, 0.027609024104609414, 0.07387886930033738, 0.07387886930033738, 0.07387886930033738, 0.02356271575116764, 0.02356271575116764, 0.02356271575116764, 0.14644222426286868, 0.14644222426286868, 0.14644222426286868, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a6c36d42-8ae2-4611-8163-05188e4c5b9f", "fitness": 0.03343475194612702, "name": "HybridPSODE", "description": "Optimized Adaptive Inertia and Crossover in HybridPSODE for enhanced global exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Slightly increased adaptive inertial weight\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.90 - 0.4 * (eval_count / self.budget)  # Slightly reduced adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 14, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["abfb7dd0-c601-4ffe-9000-2872ab7e9554"], "operator": null, "metadata": {"aucs": [0.05089372528720704, 0.05089372528720704, 0.05089372528720704, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05749127598838799, 0.05749127598838799, 0.05749127598838799, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005478575381355766, 0.0005478575381355766, 0.0005478575381355766, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10285906330554728, 0.10285906330554728, 0.10285906330554728, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05490451469224, 0.05490451469224, 0.05490451469224, 0.12157467617466167, 0.12157467617466167, 0.12157467617466167, 0.059316160225937775, 0.059316160225937775, 0.059316160225937775, 0.09666984845065818, 0.09666984845065818, 0.09666984845065818, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0930365294697082, 0.0930365294697082, 0.0930365294697082, 0.024920676552199095, 0.024920676552199095, 0.024920676552199095, 0.1345675451093219, 0.1345675451093219, 0.1345675451093219, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "19703f52-9b2e-4b5b-a929-a78acf62a1be", "fitness": 0.03666836019575539, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive parameters based on population diversity for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            \n            diversity = np.mean(np.std(particles, axis=0))  # Calculate diversity.\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand() * diversity  # Adaptive inertia weight.\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand() * (1 - diversity)  # Adaptive mutation factor based on diversity.\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 15, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["abfb7dd0-c601-4ffe-9000-2872ab7e9554"], "operator": null, "metadata": {"aucs": [0.0737508325918863, 0.0737508325918863, 0.0737508325918863, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049615628666796585, 0.049615628666796585, 0.049615628666796585, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0038566662036051413, 0.0038566662036051413, 0.0038566662036051413, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07823500218953383, 0.07823500218953383, 0.07823500218953383, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05204099852208344, 0.05204099852208344, 0.05204099852208344, 0.13056195419287775, 0.13056195419287775, 0.13056195419287775, 0.06593007675640383, 0.06593007675640383, 0.06593007675640383, 0.10637405402657119, 0.10637405402657119, 0.10637405402657119, 0.05290743482266669, 0.05290743482266669, 0.05290743482266669, 0.09051969036012752, 0.09051969036012752, 0.09051969036012752, 0.024936890683720403, 0.024936890683720403, 0.024936890683720403, 0.1460940243775085, 0.1460940243775085, 0.1460940243775085, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6baa8c4b-0297-4a74-9e24-fb946115ff56", "fitness": 0.038369461771093516, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by refining DE's adaptive crossover rate for more effective exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 1.0 - 0.4 * (eval_count / self.budget)  # Refined adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 16, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["abfb7dd0-c601-4ffe-9000-2872ab7e9554"], "operator": null, "metadata": {"aucs": [0.07424387765770524, 0.07424387765770524, 0.07424387765770524, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07283019071888441, 0.07283019071888441, 0.07283019071888441, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1216577057267696, 0.1216577057267696, 0.1216577057267696, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04662883407221352, 0.04662883407221352, 0.04662883407221352, 0.1284074485395127, 0.1284074485395127, 0.1284074485395127, 0.059764826298046136, 0.059764826298046136, 0.059764826298046136, 0.10281198987354556, 0.10281198987354556, 0.10281198987354556, 0.04153872609102627, 0.04153872609102627, 0.04153872609102627, 0.11076726443447316, 0.11076726443447316, 0.11076726443447316, 0.018422308504725926, 0.018422308504725926, 0.018422308504725926, 0.13814173667629814, 0.13814173667629814, 0.13814173667629814, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5ab5342f-2db6-4e11-9597-b67e0af2f52f", "fitness": 0.0761631000548097, "name": "HybridPSODE", "description": "Improved Global-best selection by updating global_best only if fitness is better than current global_best_fitness.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 17, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["abfb7dd0-c601-4ffe-9000-2872ab7e9554"], "operator": null, "metadata": {"aucs": [0.11698027255261367, 0.11698027255261367, 0.11698027255261367, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0011534227774888661, 0.0011534227774888661, 0.0011534227774888661, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8443547343567681, 0.8443547343567681, 0.8443547343567681, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001285688255405537, 0.001285688255405537, 0.001285688255405537, 0.008721061567394273, 0.008721061567394273, 0.008721061567394273, 0.005311831864215022, 0.005311831864215022, 0.005311831864215022, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11467306418903478, 0.11467306418903478, 0.11467306418903478, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052758299745873316, 0.052758299745873316, 0.052758299745873316, 0.13971110451151025, 0.13971110451151025, 0.13971110451151025, 0.0671785738725248, 0.0671785738725248, 0.0671785738725248, 0.10308823181272642, 0.10308823181272642, 0.10308823181272642, 0.0724512737094769, 0.0724512737094769, 0.0724512737094769, 0.13159975724186523, 0.13159975724186523, 0.13159975724186523, 0.03109153779016982, 0.03109153779016982, 0.03109153779016982, 0.13364250359010488, 0.13364250359010488, 0.13364250359010488, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f78821c3-5788-459d-b5e5-f508bf6c1d58", "fitness": 0.07120443693699277, "name": "HybridPSODE", "description": "Enhanced convergence by introducing adaptive parameters for inertia weight and differential evolution mutation factor.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.5 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.5 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 18, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["5ab5342f-2db6-4e11-9597-b67e0af2f52f"], "operator": null, "metadata": {"aucs": [0.08602116684729477, 0.08602116684729477, 0.08602116684729477, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8308730623635785, 0.8308730623635785, 0.8308730623635785, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005160540482075815, 0.005160540482075815, 0.005160540482075815, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1196121819640964, 0.1196121819640964, 0.1196121819640964, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05769270940848059, 0.05769270940848059, 0.05769270940848059, 0.13073324118564666, 0.13073324118564666, 0.13073324118564666, 0.06442163247730393, 0.06442163247730393, 0.06442163247730393, 0.09933714214414979, 0.09933714214414979, 0.09933714214414979, 0.04817106457182507, 0.04817106457182507, 0.04817106457182507, 0.10358335637494687, 0.10358335637494687, 0.10358335637494687, 0.026216660203851605, 0.026216660203851605, 0.026216660203851605, 0.13186633716022844, 0.13186633716022844, 0.13186633716022844, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ac02350f-a8c2-43a8-84b3-a69bbc2284d5", "fitness": 0.07692616765534285, "name": "HybridPSODE", "description": "HybridPSODE with enhanced velocity update by introducing dynamic personal-best influence in PSO.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 19, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["5ab5342f-2db6-4e11-9597-b67e0af2f52f"], "operator": null, "metadata": {"aucs": [0.1397868845075262, 0.1397868845075262, 0.1397868845075262, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8528010583366588, 0.8528010583366588, 0.8528010583366588, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002313375628944847, 0.002313375628944847, 0.002313375628944847, 0.009489524806681748, 0.009489524806681748, 0.009489524806681748, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11915580552912541, 0.11915580552912541, 0.11915580552912541, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0548919470457907, 0.0548919470457907, 0.0548919470457907, 0.13111796557739586, 0.13111796557739586, 0.13111796557739586, 0.05682162524618517, 0.05682162524618517, 0.05682162524618517, 0.10701136832656966, 0.10701136832656966, 0.10701136832656966, 0.0720646660260742, 0.0720646660260742, 0.0720646660260742, 0.12429709312443493, 0.12429709312443493, 0.12429709312443493, 0.031445182850460385, 0.031445182850460385, 0.031445182850460385, 0.14024891802672812, 0.14024891802672812, 0.14024891802672812, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a7a1ffb5-0b69-4685-bba6-260fdc1eeefa", "fitness": 0.07055536839742557, "name": "HybridPSODE", "description": "HybridPSODE with dynamic inertia weight and crossover rate adjustment based on fitness improvement rate.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                # Adjust crossover rate based on fitness improvement\n                adaptive_CR = 0.95 - 0.4 * (personal_best_fitness[i] - global_best_fitness) / abs(global_best_fitness)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 20, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.08078200572260807, 0.08078200572260807, 0.08078200572260807, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.83219462724592, 0.83219462724592, 0.83219462724592, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00707184673181116, 0.00707184673181116, 0.00707184673181116, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004203281285383276, 0.004203281285383276, 0.004203281285383276, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0014235823886247223, 0.0014235823886247223, 0.0014235823886247223, 0.0924109882827725, 0.0924109882827725, 0.0924109882827725, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.058461810679726, 0.058461810679726, 0.058461810679726, 0.1374994841873386, 0.1374994841873386, 0.1374994841873386, 0.05589681162646665, 0.05589681162646665, 0.05589681162646665, 0.10454476928873069, 0.10454476928873069, 0.10454476928873069, 0.044940555244935565, 0.044940555244935565, 0.044940555244935565, 0.11117923883341774, 0.11117923883341774, 0.11117923883341774, 0.01934258009449641, 0.01934258009449641, 0.01934258009449641, 0.13902943383902588, 0.13902943383902588, 0.13902943383902588, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9a77d079-ca97-4ee5-9da7-ef6142a343f0", "fitness": 0.07509056541237864, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing a dynamic social parameter update in PSO.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                self.c2 = 1.5 + 0.5 * (eval_count / self.budget)  # Added dynamic update to social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 21, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.08580255252436586, 0.08580255252436586, 0.08580255252436586, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.85399410887234, 0.85399410887234, 0.85399410887234, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0120093513737064, 0.0120093513737064, 0.0120093513737064, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0025174920511195076, 0.0025174920511195076, 0.0025174920511195076, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.15721654341599556, 0.15721654341599556, 0.15721654341599556, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05329125582472538, 0.05329125582472538, 0.05329125582472538, 0.13838913236214145, 0.13838913236214145, 0.13838913236214145, 0.07503730133435704, 0.07503730133435704, 0.07503730133435704, 0.11182309606409102, 0.11182309606409102, 0.11182309606409102, 0.044682142357631016, 0.044682142357631016, 0.044682142357631016, 0.095612021819374, 0.095612021819374, 0.095612021819374, 0.0246193724424687, 0.0246193724424687, 0.0246193724424687, 0.14239659075911948, 0.14239659075911948, 0.14239659075911948, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c1129c7c-5b0a-4687-b071-65a9a88a4c34", "fitness": 0.07509056541237864, "name": "HybridPSODE", "description": "HybridPSODE with adaptive social parameter to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                self.c2 = 1.5 + 0.5 * (eval_count / self.budget)  # Adaptive social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 22, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.08580255252436586, 0.08580255252436586, 0.08580255252436586, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.85399410887234, 0.85399410887234, 0.85399410887234, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0120093513737064, 0.0120093513737064, 0.0120093513737064, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0025174920511195076, 0.0025174920511195076, 0.0025174920511195076, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.15721654341599556, 0.15721654341599556, 0.15721654341599556, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05329125582472538, 0.05329125582472538, 0.05329125582472538, 0.13838913236214145, 0.13838913236214145, 0.13838913236214145, 0.07503730133435704, 0.07503730133435704, 0.07503730133435704, 0.11182309606409102, 0.11182309606409102, 0.11182309606409102, 0.044682142357631016, 0.044682142357631016, 0.044682142357631016, 0.095612021819374, 0.095612021819374, 0.095612021819374, 0.0246193724424687, 0.0246193724424687, 0.0246193724424687, 0.14239659075911948, 0.14239659075911948, 0.14239659075911948, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0a19bcff-c980-4744-a069-c9c387ed0c4f", "fitness": 0.03615870019373234, "name": "HybridPSODE", "description": "HybridPSODE with adaptive social influence in PSO and enhanced boundary handling.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c2 = 1.5 * (1 + 0.3 * np.random.rand())  # Adaptive social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 23, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.08924756520980082, 0.08924756520980082, 0.08924756520980082, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07066603441020813, 0.07066603441020813, 0.07066603441020813, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002304159404645123, 0.002304159404645123, 0.002304159404645123, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09972328816314369, 0.09972328816314369, 0.09972328816314369, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0455789273423397, 0.0455789273423397, 0.0455789273423397, 0.12361667176849378, 0.12361667176849378, 0.12361667176849378, 0.0668720343386977, 0.0668720343386977, 0.0668720343386977, 0.10369008446155792, 0.10369008446155792, 0.10369008446155792, 0.05368747828094145, 0.05368747828094145, 0.05368747828094145, 0.04292960648501365, 0.04292960648501365, 0.04292960648501365, 0.022521856256857542, 0.022521856256857542, 0.022521856256857542, 0.14175370722352865, 0.14175370722352865, 0.14175370722352865, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d1a383c5-bf56-4db9-9a43-8d2abd7cdf79", "fitness": 0.03922767308061669, "name": "HybridPSODE", "description": "Enhanced PSO-DE with adaptive exploration-exploitation balance through modified velocity update.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                if np.random.rand() < 0.1: velocities[i] *= 1.2  # Enhance exploration\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 24, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.09171586196476156, 0.09171586196476156, 0.09171586196476156, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.02848801546130897, 0.02848801546130897, 0.02848801546130897, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015381610404407664, 0.015381610404407664, 0.015381610404407664, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09313176857939653, 0.09313176857939653, 0.09313176857939653, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056986307372550504, 0.056986307372550504, 0.056986307372550504, 0.11550356411145857, 0.11550356411145857, 0.11550356411145857, 0.07917586502225649, 0.07917586502225649, 0.07917586502225649, 0.1102118816304205, 0.1102118816304205, 0.1102118816304205, 0.07667946359847833, 0.07667946359847833, 0.07667946359847833, 0.10640120702002587, 0.10640120702002587, 0.10640120702002587, 0.022111669088688557, 0.022111669088688557, 0.022111669088688557, 0.14045954837669905, 0.14045954837669905, 0.14045954837669905, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5b19c9be-26f4-49e2-9ed7-ca5640ec6e51", "fitness": 0.07195856509626747, "name": "HybridPSODE", "description": "Improved HybridPSODE with adaptive cognition and differential evolution factor updates.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 25, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.16.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.12527837620076143, 0.12527837620076143, 0.12527837620076143, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0016202376702113552, 0.0016202376702113552, 0.0016202376702113552, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.801945616332298, 0.801945616332298, 0.801945616332298, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.006156255128092036, 0.006156255128092036, 0.006156255128092036, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09482583122571941, 0.09482583122571941, 0.09482583122571941, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.058486130015435456, 0.058486130015435456, 0.058486130015435456, 0.12914208504515357, 0.12914208504515357, 0.12914208504515357, 0.06035644856931177, 0.06035644856931177, 0.06035644856931177, 0.10588873907314511, 0.10588873907314511, 0.10588873907314511, 0.05812518676734946, 0.05812518676734946, 0.05812518676734946, 0.09994382228558829, 0.09994382228558829, 0.09994382228558829, 0.02796639132088652, 0.02796639132088652, 0.02796639132088652, 0.15248783398081478, 0.15248783398081478, 0.15248783398081478, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d2bab9f3-c416-4557-89e6-af6b09c7e142", "fitness": 0.07628024175578013, "name": "HybridPSODE", "description": "Introduce adaptive population size based on evaluation count to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            self.population_size = max(10, int(self.population_size * (1 - eval_count / self.budget)))  # Adaptive population size\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 26, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.07377858357871192, 0.07377858357871192, 0.07377858357871192, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8564396548239454, 0.8564396548239454, 0.8564396548239454, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11745063593527727, 0.11745063593527727, 0.11745063593527727, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05589157707043957, 0.05589157707043957, 0.05589157707043957, 0.134468218392513, 0.134468218392513, 0.134468218392513, 0.07334940347788332, 0.07334940347788332, 0.07334940347788332, 0.10909193604117973, 0.10909193604117973, 0.10909193604117973, 0.10332285512470818, 0.10332285512470818, 0.10332285512470818, 0.1307804817824677, 0.1307804817824677, 0.1307804817824677, 0.02886195389774393, 0.02886195389774393, 0.02886195389774393, 0.14163832810080978, 0.14163832810080978, 0.14163832810080978, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8eb0d156-03bd-470e-98b0-16a376d16a72", "fitness": 0.05194381083736559, "name": "HybridPSODE", "description": "Refine HybridPSODE by enhancing the dynamic adaptation of social parameter and differential crossover for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                self.c2 = 1.5 * (eval_count / self.budget) + 0.5  # Enhanced dynamic social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 27, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.18095728515323972, 0.18095728515323972, 0.18095728515323972, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0010407700023897792, 0.0010407700023897792, 0.0010407700023897792, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04082547453468188, 0.04082547453468188, 0.04082547453468188, 0.032304755111230876, 0.032304755111230876, 0.032304755111230876, 0.039230749088087546, 0.039230749088087546, 0.039230749088087546, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0007492268403791469, 0.0007492268403791469, 0.0007492268403791469, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0021609409425071835, 0.0021609409425071835, 0.0021609409425071835, 0.15215162635807644, 0.15215162635807644, 0.15215162635807644, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05787760507120587, 0.05787760507120587, 0.05787760507120587, 0.12724103848792612, 0.12724103848792612, 0.12724103848792612, 0.08816267619088158, 0.08816267619088158, 0.08816267619088158, 0.11238461499883856, 0.11238461499883856, 0.11238461499883856, 0.1129175401437299, 0.1129175401437299, 0.1129175401437299, 0.0984993003647, 0.0984993003647, 0.0984993003647, 0.05506159187960713, 0.05506159187960713, 0.05506159187960713, 0.14160800405972707, 0.14160800405972707, 0.14160800405972707, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "60a2cced-cad5-42b9-95de-147627d05cbe", "fitness": 0.07397054414823939, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive randomness added to velocities for exploration diversity.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added randomness\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 28, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.16.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.11613567555176085, 0.11613567555176085, 0.11613567555176085, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8249526066996002, 0.8249526066996002, 0.8249526066996002, 0.0018539990752520774, 0.0018539990752520774, 0.0018539990752520774, 0.014556214740487738, 0.014556214740487738, 0.014556214740487738, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0007776630745676139, 0.0007776630745676139, 0.0007776630745676139, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12624901308146563, 0.12624901308146563, 0.12624901308146563, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04926221962940869, 0.04926221962940869, 0.04926221962940869, 0.11253466686079605, 0.11253466686079605, 0.11253466686079605, 0.0750566563473759, 0.0750566563473759, 0.0750566563473759, 0.10573883388651628, 0.10573883388651628, 0.10573883388651628, 0.06038880809020175, 0.06038880809020175, 0.06038880809020175, 0.10120837824977569, 0.10120837824977569, 0.10120837824977569, 0.031164954564720904, 0.031164954564720904, 0.031164954564720904, 0.15106554361885904, 0.15106554361885904, 0.15106554361885904, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e3aedf1c-b198-4460-8c02-aa578f9a0580", "fitness": 0.04354403412195724, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing a time-varying social parameter and adaptive velocity scaling for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5\n                self.c2 = 1.0 + 1.5 * (eval_count / self.budget)  # Time-varying social parameter\n                adaptive_velocity_scaling = 0.8 + 0.4 * np.random.rand()  # Adaptive velocity scaling\n                velocities[i] = adaptive_velocity_scaling * (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 29, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.1278540851307275, 0.1278540851307275, 0.1278540851307275, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.043577624160190065, 0.043577624160190065, 0.043577624160190065, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.011443262121018871, 0.011443262121018871, 0.011443262121018871, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043573712584887847, 0.00043573712584887847, 0.00043573712584887847, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1413214574199274, 0.1413214574199274, 0.1413214574199274, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0531480010469042, 0.0531480010469042, 0.0531480010469042, 0.1101701673024591, 0.1101701673024591, 0.1101701673024591, 0.07707294265771891, 0.07707294265771891, 0.07707294265771891, 0.1080152369504116, 0.1080152369504116, 0.1080152369504116, 0.08256513456348413, 0.08256513456348413, 0.08256513456348413, 0.11819132049858971, 0.11819132049858971, 0.11819132049858971, 0.026779089445296833, 0.026779089445296833, 0.026779089445296833, 0.13970015180874407, 0.13970015180874407, 0.13970015180874407, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "19966dbc-9367-4e8d-8e17-b8c61bdc54a8", "fitness": 0.07412792956948633, "name": "HybridPSODE", "description": "Fine-tune the cognitive parameter's lower bound from 0.5 to 0.1 for enhanced exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.1  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 30, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.09275091836274896, 0.09275091836274896, 0.09275091836274896, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8433546296629172, 0.8433546296629172, 0.8433546296629172, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005835148083896735, 0.005835148083896735, 0.005835148083896735, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006401051948365932, 0.0006401051948365932, 0.0006401051948365932, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12233610029694209, 0.12233610029694209, 0.12233610029694209, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04887752953787616, 0.04887752953787616, 0.04887752953787616, 0.12946302741521276, 0.12946302741521276, 0.12946302741521276, 0.06274145172194101, 0.06274145172194101, 0.06274145172194101, 0.10820694937808484, 0.10820694937808484, 0.10820694937808484, 0.07348386610366187, 0.07348386610366187, 0.07348386610366187, 0.12310985153560428, 0.12310985153560428, 0.12310985153560428, 0.028919778314191902, 0.028919778314191902, 0.028919778314191902, 0.1345683453641049, 0.1345683453641049, 0.1345683453641049, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "07beb4b8-508d-4e4d-bd97-f49b50efecc0", "fitness": 0.07656805404115322, "name": "HybridPSODE", "description": "Improved HybridPSODE by introducing adaptive velocity damping to enhance convergence speed and accuracy.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Dynamic cognitive parameter\n                velocities[i] = (0.9 * self.w * velocities[i] +  # Adaptive velocity damping\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 31, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.1320069595886636, 0.1320069595886636, 0.1320069595886636, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005054455517976564, 0.0005054455517976564, 0.0005054455517976564, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8387908810465627, 0.8387908810465627, 0.8387908810465627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0057816675083001146, 0.0057816675083001146, 0.0057816675083001146, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005781371142381975, 0.005781371142381975, 0.005781371142381975, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001844654979760496, 0.001844654979760496, 0.001844654979760496, 0.13523129624068198, 0.13523129624068198, 0.13523129624068198, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05611044533569565, 0.05611044533569565, 0.05611044533569565, 0.13598564165167681, 0.13598564165167681, 0.13598564165167681, 0.055829398853386336, 0.055829398853386336, 0.055829398853386336, 0.10479951969845946, 0.10479951969845946, 0.10479951969845946, 0.05713053785921307, 0.05713053785921307, 0.05713053785921307, 0.1342158991964575, 0.1342158991964575, 0.1342158991964575, 0.030569928311794392, 0.030569928311794392, 0.030569928311794392, 0.13913660654458448, 0.13913660654458448, 0.13913660654458448, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b3f9b192-1232-4ab0-8029-395767cdd518", "fitness": 0.07729345187248865, "name": "HybridPSODE", "description": "Improved HybridPSODE by fine-tuning adaptive parameters for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.7 * (1 - eval_count / self.budget) + 0.3  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 32, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["ac02350f-a8c2-43a8-84b3-a69bbc2284d5"], "operator": null, "metadata": {"aucs": [0.10257284731931304, 0.10257284731931304, 0.10257284731931304, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0026738943097366352, 0.0026738943097366352, 0.0026738943097366352, 0.000441826599770323, 0.000441826599770323, 0.000441826599770323, 0.8499350681826375, 0.8499350681826375, 0.8499350681826375, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007580920186505469, 0.007580920186505469, 0.007580920186505469, 0.0005575482173488799, 0.0005575482173488799, 0.0005575482173488799, 0.00491995972898962, 0.00491995972898962, 0.00491995972898962, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12870869365038895, 0.12870869365038895, 0.12870869365038895, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0579754906617963, 0.0579754906617963, 0.0579754906617963, 0.13390116689127685, 0.13390116689127685, 0.13390116689127685, 0.06160326315494602, 0.06160326315494602, 0.06160326315494602, 0.10471715206262433, 0.10471715206262433, 0.10471715206262433, 0.0817774278396447, 0.0817774278396447, 0.0817774278396447, 0.13317028254320795, 0.13317028254320795, 0.13317028254320795, 0.029798433982414885, 0.029798433982414885, 0.029798433982414885, 0.1512306087395605, 0.1512306087395605, 0.1512306087395605, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "62cbb259-4d6b-4698-9a7a-d4650f4b84f8", "fitness": 0.07492034836735689, "name": "HybridPSODE", "description": "Refined HybridPSODE by adjusting cognitive and social parameters to enhance convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.8  # Cognitive parameter for PSO, updated from 1.5\n        self.c2 = 1.3  # Social parameter for PSO, updated from 1.5\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.7 * (1 - eval_count / self.budget) + 0.3  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 33, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.16.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.11585744867460435, 0.11585744867460435, 0.11585744867460435, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002448280910296141, 0.002448280910296141, 0.002448280910296141, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8126977910613061, 0.8126977910613061, 0.8126977910613061, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007850571042766097, 0.007850571042766097, 0.007850571042766097, 0.007067812333920176, 0.007067812333920176, 0.007067812333920176, 0.007353899667381425, 0.007353899667381425, 0.007353899667381425, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.13253019228238216, 0.13253019228238216, 0.13253019228238216, 0.0019089228194459906, 0.0019089228194459906, 0.0019089228194459906, 0.04837341084950941, 0.04837341084950941, 0.04837341084950941, 0.11637248420249358, 0.11637248420249358, 0.11637248420249358, 0.09207587066449541, 0.09207587066449541, 0.09207587066449541, 0.11143053488112131, 0.11143053488112131, 0.11143053488112131, 0.09422949561923144, 0.09422949561923144, 0.09422949561923144, 0.07918499420626313, 0.07918499420626313, 0.07918499420626313, 0.027883673530823994, 0.027883673530823994, 0.027883673530823994, 0.13734471720095942, 0.13734471720095942, 0.13734471720095942, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f1543c75-b28c-4873-bfe8-46ac5916e6c4", "fitness": 0.07161895559551198, "name": "HybridPSODE", "description": "Introduced stochastic velocity reset strategy in PSO to escape local optima more effectively.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.7 * (1 - eval_count / self.budget) + 0.3  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                if np.random.rand() < 0.05:  # Stochastic velocity reset with 5% chance\n                    velocities[i] = np.random.uniform(-1, 1, self.dim)\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 34, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.14.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.1195404380484506, 0.1195404380484506, 0.1195404380484506, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6757127950109296, 0.6757127950109296, 0.6757127950109296, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013735120898486053, 0.013735120898486053, 0.013735120898486053, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005309474118167845, 0.005309474118167845, 0.005309474118167845, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1524095788564488, 0.1524095788564488, 0.1524095788564488, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.047301913190119005, 0.047301913190119005, 0.047301913190119005, 0.1294311433567451, 0.1294311433567451, 0.1294311433567451, 0.07931898689164385, 0.07931898689164385, 0.07931898689164385, 0.10003513539179631, 0.10003513539179631, 0.10003513539179631, 0.08009058291994042, 0.08009058291994042, 0.08009058291994042, 0.11071983310097666, 0.11071983310097666, 0.11071983310097666, 0.0572274622946749, 0.0572274622946749, 0.0572274622946749, 0.14323986151825618, 0.14323986151825618, 0.14323986151825618, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8247f9ef-9fcb-47e5-a40e-78b0a5b45040", "fitness": 0.07207682385406416, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with a novel adaptive local and global learning balance for improved convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()\n                self.c1 = 1.8 * (1 - eval_count / self.budget) + 0.2\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.5 * np.random.rand()\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.9 - 0.3 * (eval_count / self.budget)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 35, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.16.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.07694381409733231, 0.07694381409733231, 0.07694381409733231, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0004811196117203709, 0.0004811196117203709, 0.0004811196117203709, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8055229951125739, 0.8055229951125739, 0.8055229951125739, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0021739121223112168, 0.0021739121223112168, 0.0021739121223112168, 0.0030535237792529424, 0.0030535237792529424, 0.0030535237792529424, 0.0007647946082652846, 0.0007647946082652846, 0.0007647946082652846, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12693979021596968, 0.12693979021596968, 0.12693979021596968, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056885926703615475, 0.056885926703615475, 0.056885926703615475, 0.12995278474412797, 0.12995278474412797, 0.12995278474412797, 0.07612636601156719, 0.07612636601156719, 0.07612636601156719, 0.1073184708599575, 0.1073184708599575, 0.1073184708599575, 0.07126383469952835, 0.07126383469952835, 0.07126383469952835, 0.09947438618733839, 0.09947438618733839, 0.09947438618733839, 0.027949943462583504, 0.027949943462583504, 0.027949943462583504, 0.14107906680313476, 0.14107906680313476, 0.14107906680313476, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4b9656d0-b52f-4de9-9c59-fb4a30943ad4", "fitness": 0.07427897696080614, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing a nonlinear adaptive mutation factor for improved diversity and convergence speed.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.7 * (1 - eval_count / self.budget) + 0.3  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget)  # Nonlinear adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 36, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.16.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.1386904613600909, 0.1386904613600909, 0.1386904613600909, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006187484267606846, 0.0006187484267606846, 0.0006187484267606846, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7772368793388214, 0.7772368793388214, 0.7772368793388214, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0012555826218502153, 0.0012555826218502153, 0.0012555826218502153, 0.0005639908328525234, 0.0005639908328525234, 0.0005639908328525234, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0007442494634822827, 0.0007442494634822827, 0.0007442494634822827, 0.1193066339658424, 0.1193066339658424, 0.1193066339658424, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05455596023335696, 0.05455596023335696, 0.05455596023335696, 0.13972119296325725, 0.13972119296325725, 0.13972119296325725, 0.06922903580827433, 0.06922903580827433, 0.06922903580827433, 0.10267662375103392, 0.10267662375103392, 0.10267662375103392, 0.08121511657687164, 0.08121511657687164, 0.08121511657687164, 0.12438021466700744, 0.12438021466700744, 0.12438021466700744, 0.027873533386850946, 0.027873533386850946, 0.027873533386850946, 0.14071418018473347, 0.14071418018473347, 0.14071418018473347, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d1ea0055-5783-4c68-8cbf-1c119f9989d4", "fitness": 0.07729345187248865, "name": "HybridPSODE", "description": "Refine Improved HybridPSODE by incorporating dynamic DE selection pressure for enhanced optimization performance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.7 * (1 - eval_count / self.budget) + 0.3  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                modified_selection_pressure = max(0.1, 0.3 * (eval_count / self.budget))  # Dynamic selection pressure\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 37, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.10257284731931304, 0.10257284731931304, 0.10257284731931304, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0026738943097366352, 0.0026738943097366352, 0.0026738943097366352, 0.000441826599770323, 0.000441826599770323, 0.000441826599770323, 0.8499350681826375, 0.8499350681826375, 0.8499350681826375, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007580920186505469, 0.007580920186505469, 0.007580920186505469, 0.0005575482173488799, 0.0005575482173488799, 0.0005575482173488799, 0.00491995972898962, 0.00491995972898962, 0.00491995972898962, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12870869365038895, 0.12870869365038895, 0.12870869365038895, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0579754906617963, 0.0579754906617963, 0.0579754906617963, 0.13390116689127685, 0.13390116689127685, 0.13390116689127685, 0.06160326315494602, 0.06160326315494602, 0.06160326315494602, 0.10471715206262433, 0.10471715206262433, 0.10471715206262433, 0.0817774278396447, 0.0817774278396447, 0.0817774278396447, 0.13317028254320795, 0.13317028254320795, 0.13317028254320795, 0.029798433982414885, 0.029798433982414885, 0.029798433982414885, 0.1512306087395605, 0.1512306087395605, 0.1512306087395605, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "eed13f08-db27-4ae1-8a14-e568e52b52e7", "fitness": 0.07729345187248865, "name": "HybridPSODE", "description": "Improved HybridPSODE by reducing cognitive parameter and introducing dynamic population size for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(30 * (dim / 100) if dim >= 100 else 30)  # Dynamic population size\n        self.c1 = 1.4  # Reduced cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.7 * (1 - eval_count / self.budget) + 0.3  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 38, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.10257284731931304, 0.10257284731931304, 0.10257284731931304, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0026738943097366352, 0.0026738943097366352, 0.0026738943097366352, 0.000441826599770323, 0.000441826599770323, 0.000441826599770323, 0.8499350681826375, 0.8499350681826375, 0.8499350681826375, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007580920186505469, 0.007580920186505469, 0.007580920186505469, 0.0005575482173488799, 0.0005575482173488799, 0.0005575482173488799, 0.00491995972898962, 0.00491995972898962, 0.00491995972898962, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12870869365038895, 0.12870869365038895, 0.12870869365038895, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0579754906617963, 0.0579754906617963, 0.0579754906617963, 0.13390116689127685, 0.13390116689127685, 0.13390116689127685, 0.06160326315494602, 0.06160326315494602, 0.06160326315494602, 0.10471715206262433, 0.10471715206262433, 0.10471715206262433, 0.0817774278396447, 0.0817774278396447, 0.0817774278396447, 0.13317028254320795, 0.13317028254320795, 0.13317028254320795, 0.029798433982414885, 0.029798433982414885, 0.029798433982414885, 0.1512306087395605, 0.1512306087395605, 0.1512306087395605, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "587e2560-77a3-4abb-837e-463fe0dcf337", "fitness": 0.07704997212380607, "name": "HybridPSODE", "description": "Further enhance the exploration by fine-tuning the velocity and differential mutation factor adaptively.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.1 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.7 * (1 - eval_count / self.budget) + 0.3  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.7 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 39, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.17610304474394212, 0.17610304474394212, 0.17610304474394212, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0017588710502853822, 0.0017588710502853822, 0.0017588710502853822, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7790281107612076, 0.7790281107612076, 0.7790281107612076, 0.0005441971771978915, 0.0005441971771978915, 0.0005441971771978915, 0.008501046465545836, 0.008501046465545836, 0.008501046465545836, 0.0005333104367584163, 0.0005333104367584163, 0.0005333104367584163, 0.008700524309005586, 0.008700524309005586, 0.008700524309005586, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.139444318382005, 0.139444318382005, 0.139444318382005, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04876347617693211, 0.04876347617693211, 0.04876347617693211, 0.14680795323134643, 0.14680795323134643, 0.14680795323134643, 0.061995419506268856, 0.061995419506268856, 0.061995419506268856, 0.10674033480229372, 0.10674033480229372, 0.10674033480229372, 0.0830666195322749, 0.0830666195322749, 0.0830666195322749, 0.11282604213984915, 0.11282604213984915, 0.11282604213984915, 0.029922254373699553, 0.029922254373699553, 0.029922254373699553, 0.14098554701316757, 0.14098554701316757, 0.14098554701316757, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "cc6cd40e-abf7-4bac-9134-feb2fb52492e", "fitness": 0.06263827901234205, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing diversity preservation through random elite replacement, improving exploration in later stages of optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.7 * (1 - eval_count / self.budget) + 0.3  # Dynamic cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n                        \n            # Randomly replace some particles for more exploration\n            if eval_count < self.budget:\n                random_indices = np.random.choice(self.population_size, size=3, replace=False)\n                particles[random_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n\n        return global_best", "configspace": "", "generation": 40, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.12.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.11057126079369806, 0.11057126079369806, 0.11057126079369806, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.602275682241241, 0.602275682241241, 0.602275682241241, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0033044050443193917, 0.0033044050443193917, 0.0033044050443193917, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1109112462485159, 0.1109112462485159, 0.1109112462485159, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05211411052279402, 0.05211411052279402, 0.05211411052279402, 0.1322670458520624, 0.1322670458520624, 0.1322670458520624, 0.05651043661926136, 0.05651043661926136, 0.05651043661926136, 0.09640386345391838, 0.09640386345391838, 0.09640386345391838, 0.04865723301698999, 0.04865723301698999, 0.04865723301698999, 0.11921264348428162, 0.11921264348428162, 0.11921264348428162, 0.025946680614569173, 0.025946680614569173, 0.025946680614569173, 0.13992669710020988, 0.13992669710020988, 0.13992669710020988, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "81df6ee0-42c1-478e-b96a-5745f762da52", "fitness": 0.03780903604528445, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by incorporating adaptive social and mutation dynamics for improved diversity and convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()\n                self.c1 = 1.7 * (1 - eval_count / self.budget) + 0.3\n                self.c2 = 1.5 + 0.5 * np.sin(np.pi * eval_count / self.budget)  # Adaptive social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.cos(np.pi * eval_count / self.budget)  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 41, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.09903288618684614, 0.09903288618684614, 0.09903288618684614, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006271901533763113, 0.0006271901533763113, 0.0006271901533763113, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03197580842705661, 0.03197580842705661, 0.03197580842705661, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005359439853967252, 0.005359439853967252, 0.005359439853967252, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1037371522741598, 0.1037371522741598, 0.1037371522741598, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052347176667244644, 0.052347176667244644, 0.052347176667244644, 0.1107721743627742, 0.1107721743627742, 0.1107721743627742, 0.06663900510510834, 0.06663900510510834, 0.06663900510510834, 0.10285100301638639, 0.10285100301638639, 0.10285100301638639, 0.044487396894331344, 0.044487396894331344, 0.044487396894331344, 0.12040515884454916, 0.12040515884454916, 0.12040515884454916, 0.025870267685575543, 0.025870267685575543, 0.025870267685575543, 0.13852959691979871, 0.13852959691979871, 0.13852959691979871, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0e450465-8fe1-443d-9d81-e60a477e10fc", "fitness": 0.07838203693988152, "name": "HybridPSODE", "description": "Improved adaptive parameters by incorporating an exponential decay factor into the cognitive parameter for dynamic balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 42, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["b3f9b192-1232-4ab0-8029-395767cdd518"], "operator": null, "metadata": {"aucs": [0.13027812984293918, 0.13027812984293918, 0.13027812984293918, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003054515991548379, 0.003054515991548379, 0.003054515991548379, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8500736849405052, 0.8500736849405052, 0.8500736849405052, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.008348910685440747, 0.008348910685440747, 0.008348910685440747, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001675343181517519, 0.001675343181517519, 0.001675343181517519, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11722400884611883, 0.11722400884611883, 0.11722400884611883, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056441784393368444, 0.056441784393368444, 0.056441784393368444, 0.14458843857646275, 0.14458843857646275, 0.14458843857646275, 0.07173874809506386, 0.07173874809506386, 0.07173874809506386, 0.10441859283357624, 0.10441859283357624, 0.10441859283357624, 0.08556726464515718, 0.08556726464515718, 0.08556726464515718, 0.1272759391436753, 0.1272759391436753, 0.1272759391436753, 0.032572762405745914, 0.032572762405745914, 0.032572762405745914, 0.14356293688908028, 0.14356293688908028, 0.14356293688908028, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "68373f0f-1303-4d08-841d-3aeaf2abbe42", "fitness": 0.04182783845866119, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by adding acceleration to the velocity update for faster convergence and adaptive inertia weight adjustment.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]) +\n                                 0.1 * (global_best - particles[i]))  # Added acceleration term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 43, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.11456567218755709, 0.11456567218755709, 0.11456567218755709, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08698608227378257, 0.08698608227378257, 0.08698608227378257, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0168772876846377, 0.0168772876846377, 0.0168772876846377, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12954650359694608, 0.12954650359694608, 0.12954650359694608, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.053780198654463374, 0.053780198654463374, 0.053780198654463374, 0.13350473598392743, 0.13350473598392743, 0.13350473598392743, 0.06414437491074498, 0.06414437491074498, 0.06414437491074498, 0.10643614038840143, 0.10643614038840143, 0.10643614038840143, 0.07740624893022174, 0.07740624893022174, 0.07740624893022174, 0.05681035046510463, 0.05681035046510463, 0.05681035046510463, 0.024724283122266266, 0.024724283122266266, 0.024724283122266266, 0.1338688535054673, 0.1338688535054673, 0.1338688535054673, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d3cb6d8b-e1e3-4874-b678-eb086e113028", "fitness": 0.07806241990291538, "name": "HybridPSODE", "description": "Enhance convergence by tweaking the cognitive parameter decay and adaptive crossover rate.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.5 * np.exp(-1.5 * eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.5 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 44, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.12491390481115416, 0.12491390481115416, 0.12491390481115416, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0015960698126185058, 0.0015960698126185058, 0.0015960698126185058, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8558638434209249, 0.8558638434209249, 0.8558638434209249, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.020513270388072047, 0.020513270388072047, 0.020513270388072047, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00888420709658655, 0.00888420709658655, 0.00888420709658655, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12852659197495597, 0.12852659197495597, 0.12852659197495597, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05258865695563675, 0.05258865695563675, 0.05258865695563675, 0.13683815095649898, 0.13683815095649898, 0.13683815095649898, 0.061150547421047086, 0.061150547421047086, 0.061150547421047086, 0.10726821103006245, 0.10726821103006245, 0.10726821103006245, 0.08484911262253203, 0.08484911262253203, 0.08484911262253203, 0.1199267246516521, 0.1199267246516521, 0.1199267246516521, 0.0301869303359783, 0.0301869303359783, 0.0301869303359783, 0.13604403010529242, 0.13604403010529242, 0.13604403010529242, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d4e80836-2b7e-4cf6-9045-698ad4974e3d", "fitness": 0.06915879231471155, "name": "HybridPSODE", "description": "Introduced dynamic adaptation of the social parameter using a sinusoidal function for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 + 0.5 * np.sin(np.pi * eval_count / self.budget)  # Sinusoidal adaptation of social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 45, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.08449025213018702, 0.08449025213018702, 0.08449025213018702, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.834493159445145, 0.834493159445145, 0.834493159445145, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0036455820627976365, 0.0036455820627976365, 0.0036455820627976365, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08904626930375936, 0.08904626930375936, 0.08904626930375936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05349320182487172, 0.05349320182487172, 0.05349320182487172, 0.11231240516877172, 0.11231240516877172, 0.11231240516877172, 0.06284595879149557, 0.06284595879149557, 0.06284595879149557, 0.10525532092004197, 0.10525532092004197, 0.10525532092004197, 0.036797356610436704, 0.036797356610436704, 0.036797356610436704, 0.10359797015603478, 0.10359797015603478, 0.10359797015603478, 0.023314006566625967, 0.023314006566625967, 0.023314006566625967, 0.14530214126856178, 0.14530214126856178, 0.14530214126856178, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f3cf9070-17fd-46a7-8791-4bd5f2846836", "fitness": 0.07085128581473449, "name": "HybridPSODE", "description": "Introduced dynamic social parameter and diversified initial velocities for enhanced convergence in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Changed line\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 + 0.5 * np.random.rand()  # Dynamic social parameter adjustment  # Changed line\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 46, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.09118384885589226, 0.09118384885589226, 0.09118384885589226, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8747248562106082, 0.8747248562106082, 0.8747248562106082, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006263679258304844, 0.0006263679258304844, 0.0006263679258304844, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.13299292710218868, 0.13299292710218868, 0.13299292710218868, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04916910673867203, 0.04916910673867203, 0.04916910673867203, 0.11656009322196303, 0.11656009322196303, 0.11656009322196303, 0.05256859152246307, 0.05256859152246307, 0.05256859152246307, 0.09870954922411113, 0.09870954922411113, 0.09870954922411113, 0.023502430237566596, 0.023502430237566596, 0.023502430237566596, 0.09696704160378156, 0.09696704160378156, 0.09696704160378156, 0.02366381307070653, 0.02366381307070653, 0.02366381307070653, 0.13454484253549615, 0.13454484253549615, 0.13454484253549615, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0d4b3eac-5d39-4484-850b-70083ad59c8c", "fitness": 0.07348720999965708, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing adaptive social parameter adjustment to improve convergence speed and precision.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 + 0.5 * (eval_count / self.budget)  # Adaptive social parameter adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 47, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.09162918790318564, 0.09162918790318564, 0.09162918790318564, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0017004206213822037, 0.0017004206213822037, 0.0017004206213822037, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8317518523094436, 0.8317518523094436, 0.8317518523094436, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.021978253177776574, 0.021978253177776574, 0.021978253177776574, 0.0006672679670078896, 0.0006672679670078896, 0.0006672679670078896, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12049452994907217, 0.12049452994907217, 0.12049452994907217, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.058800021041061745, 0.058800021041061745, 0.058800021041061745, 0.12862540031669256, 0.12862540031669256, 0.12862540031669256, 0.07273079208049316, 0.07273079208049316, 0.07273079208049316, 0.10644451907561747, 0.10644451907561747, 0.10644451907561747, 0.04864953411423378, 0.04864953411423378, 0.04864953411423378, 0.10717492141413376, 0.10717492141413376, 0.10717492141413376, 0.030410254565496397, 0.030410254565496397, 0.030410254565496397, 0.1382882593692163, 0.1382882593692163, 0.1382882593692163, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f3961bb2-23df-486a-bf48-cf5e2dab9a1b", "fitness": 0.048429466613736115, "name": "HybridPSODE", "description": "Incorporate a dynamic particle update mechanism to enhance exploration in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i] + 0.1 * np.random.randn(self.dim)  # Enhanced exploration mechanism\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 48, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.1324904943472679, 0.1324904943472679, 0.1324904943472679, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1962296531321125, 0.1962296531321125, 0.1962296531321125, 0.0005873365251187757, 0.0005873365251187757, 0.0005873365251187757, 0.018933885256291916, 0.018933885256291916, 0.018933885256291916, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.13617225040029302, 0.13617225040029302, 0.13617225040029302, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0561573413971177, 0.0561573413971177, 0.0561573413971177, 0.1065908664010391, 0.1065908664010391, 0.1065908664010391, 0.07195320137208616, 0.07195320137208616, 0.07195320137208616, 0.10069642214012142, 0.10069642214012142, 0.10069642214012142, 0.05819991172327721, 0.05819991172327721, 0.05819991172327721, 0.10575932992419002, 0.10575932992419002, 0.10575932992419002, 0.027061705009848835, 0.027061705009848835, 0.027061705009848835, 0.14669219240524967, 0.14669219240524967, 0.14669219240524967, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8705aa57-abb7-46eb-89f9-9041fa72e3d9", "fitness": 0.06915879231471125, "name": "HybridPSODE", "description": "HybridPSODE with adaptive social parameter adjustment using a sine wave for enhanced global search balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 + 0.5 * np.sin(eval_count / self.budget * np.pi)  # Adaptive social parameter adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 49, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.08449025213018702, 0.08449025213018702, 0.08449025213018702, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.834493159445145, 0.834493159445145, 0.834493159445145, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0036455820627976365, 0.0036455820627976365, 0.0036455820627976365, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08904626930375936, 0.08904626930375936, 0.08904626930375936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05349320182487172, 0.05349320182487172, 0.05349320182487172, 0.11231240516877172, 0.11231240516877172, 0.11231240516877172, 0.06284595879149557, 0.06284595879149557, 0.06284595879149557, 0.10525532092003642, 0.10525532092003642, 0.10525532092003642, 0.03679735661043493, 0.03679735661043493, 0.03679735661043493, 0.10359797015603478, 0.10359797015603478, 0.10359797015603478, 0.023314006566625967, 0.023314006566625967, 0.023314006566625967, 0.14530214126856178, 0.14530214126856178, 0.14530214126856178, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "40b36b4d-1860-46e7-a659-08377d6d7f89", "fitness": 0.03530163959115899, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by dynamically adjusting the social parameter for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 * (1 - eval_count / self.budget) + 0.5  # Added adaptive adjustment to the social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 50, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.0996227593217831, 0.0996227593217831, 0.0996227593217831, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.061892321301523445, 0.061892321301523445, 0.061892321301523445, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003323806180307809, 0.003323806180307809, 0.003323806180307809, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.13359510884018888, 0.13359510884018888, 0.13359510884018888, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04717458189543322, 0.04717458189543322, 0.04717458189543322, 0.11941904986707574, 0.11941904986707574, 0.11941904986707574, 0.056219165245901315, 0.056219165245901315, 0.056219165245901315, 0.10313881962668292, 0.10313881962668292, 0.10313881962668292, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06148704713901498, 0.06148704713901498, 0.06148704713901498, 0.017724175335760206, 0.017724175335760206, 0.017724175335760206, 0.13799034152110057, 0.13799034152110057, 0.13799034152110057, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c9766aed-db67-4fa1-a6d4-dbc1a784e7e3", "fitness": 0.035140768879760836, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing adaptive social parameter scaling for improved exploration capabilities.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.8 * np.exp(-0.5 * eval_count / self.budget) + 0.2  # Adaptive scaling for social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 51, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.04.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.06559883093539554, 0.06559883093539554, 0.06559883093539554, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0009208029923211125, 0.0009208029923211125, 0.0009208029923211125, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06209703012330803, 0.06209703012330803, 0.06209703012330803, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00441800287168248, 0.00441800287168248, 0.00441800287168248, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08663286680770099, 0.08663286680770099, 0.08663286680770099, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06066549246035147, 0.06066549246035147, 0.06066549246035147, 0.12250931719144942, 0.12250931719144942, 0.12250931719144942, 0.06689739551706841, 0.06689739551706841, 0.06689739551706841, 0.09974352249695007, 0.09974352249695007, 0.09974352249695007, 0.03889454331996467, 0.03889454331996467, 0.03889454331996467, 0.07277227672917475, 0.07277227672917475, 0.07277227672917475, 0.019222504948773422, 0.019222504948773422, 0.019222504948773422, 0.13822325802446733, 0.13822325802446733, 0.13822325802446733, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8e871672-bbee-4ef8-af7b-67af0f89f932", "fitness": 0.04411191336722184, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by integrating adaptive inertia and mutation factor strategies for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.5 * np.random.rand()  # Changed adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 52, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.1218220347342247, 0.1218220347342247, 0.1218220347342247, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.061131659391412296, 0.061131659391412296, 0.061131659391412296, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.009428052536579856, 0.009428052536579856, 0.009428052536579856, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001891000247711716, 0.001891000247711716, 0.001891000247711716, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.14417614424592828, 0.14417614424592828, 0.14417614424592828, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05270193765642672, 0.05270193765642672, 0.05270193765642672, 0.12471585246212602, 0.12471585246212602, 0.12471585246212602, 0.06580955813661726, 0.06580955813661726, 0.06580955813661726, 0.1041198249247588, 0.1041198249247588, 0.1041198249247588, 0.060480478448330155, 0.060480478448330155, 0.060480478448330155, 0.12889523743858822, 0.12889523743858822, 0.12889523743858822, 0.03125597219313614, 0.03125597219313614, 0.03125597219313614, 0.14747555970183168, 0.14747555970183168, 0.14747555970183168, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f658ae09-ac25-4d5e-af72-22254146619f", "fitness": 0.07587420442990117, "name": "HybridPSODE", "description": "Improved global exploration by adjusting the social parameter in PSO to adaptively decrease over iterations.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 * (1 - eval_count / self.budget) + 0.1  # Adaptive decay applied to social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 53, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.13484079477458888, 0.13484079477458888, 0.13484079477458888, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8571111603676138, 0.8571111603676138, 0.8571111603676138, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.029797342653081094, 0.029797342653081094, 0.029797342653081094, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.15291779263751792, 0.15291779263751792, 0.15291779263751792, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04888535478802547, 0.04888535478802547, 0.04888535478802547, 0.13162013811137696, 0.13162013811137696, 0.13162013811137696, 0.0911330865919403, 0.0911330865919403, 0.0911330865919403, 0.11143826697704595, 0.11143826697704595, 0.11143826697704595, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0804982390320228, 0.0804982390320228, 0.0804982390320228, 0.028939157486429168, 0.028939157486429168, 0.028939157486429168, 0.1481473989849421, 0.1481473989849421, 0.1481473989849421, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b0c2710e-09c3-484c-83a6-16dc979bff6d", "fitness": 0.07605024606007992, "name": "HybridPSODE", "description": "Enhance convergence by dynamically balancing exploration and exploitation through adaptive parameter adjustments in PSO and DE, refining inertia weight and mutation factor for improved performance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget)  # Adjusted inertia weight adjustment for better balance\n                self.c1 = (1.5 * np.exp(-eval_count / self.budget)) + 0.5  # Slightly adjusted exponential decay parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 54, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.15.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.1603957908413567, 0.1603957908413567, 0.1603957908413567, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0028751969233824504, 0.0028751969233824504, 0.0028751969233824504, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7561141405780475, 0.7561141405780475, 0.7561141405780475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.011459032931658841, 0.011459032931658841, 0.011459032931658841, 0.0020654289148196447, 0.0020654289148196447, 0.0020654289148196447, 0.01647501696828646, 0.01647501696828646, 0.01647501696828646, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.13177224734394333, 0.13177224734394333, 0.13177224734394333, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06465790384012426, 0.06465790384012426, 0.06465790384012426, 0.12617785748154664, 0.12617785748154664, 0.12617785748154664, 0.08276104088079528, 0.08276104088079528, 0.08276104088079528, 0.1023495264134967, 0.1023495264134967, 0.1023495264134967, 0.1100714592417531, 0.1100714592417531, 0.1100714592417531, 0.08668796288539793, 0.08668796288539793, 0.08668796288539793, 0.021158790850665077, 0.021158790850665077, 0.021158790850665077, 0.14627146586838302, 0.14627146586838302, 0.14627146586838302, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "454d6fab-d99b-4aa4-b00a-8373886b7dd3", "fitness": 0.06697432726439646, "name": "HybridPSODE", "description": "Introduced adaptive social parameter adjustment in HybridPSODE to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 * (1 + 0.5 * np.sin(eval_count / self.budget * np.pi))  # Adaptive social parameter adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 55, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.05547698755063901, 0.05547698755063901, 0.05547698755063901, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8550574984185296, 0.8550574984185296, 0.8550574984185296, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005173190861241683, 0.005173190861241683, 0.005173190861241683, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09194960917486716, 0.09194960917486716, 0.09194960917486716, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056526382304108, 0.056526382304108, 0.056526382304108, 0.11170152623827312, 0.11170152623827312, 0.11170152623827312, 0.07146277428477177, 0.07146277428477177, 0.07146277428477177, 0.10934448944862729, 0.10934448944862729, 0.10934448944862729, 0.00835758198593084, 0.00835758198593084, 0.00835758198593084, 0.07420858854127721, 0.07420858854127721, 0.07420858854127721, 0.018931387392385646, 0.018931387392385646, 0.018931387392385646, 0.14397644684051558, 0.14397644684051558, 0.14397644684051558, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b773ea99-6f6b-428d-9793-8b2f09b3dab3", "fitness": 0.040020506600569834, "name": "HybridPSODE", "description": "Enhanced adaptive mechanisms by modifying the inertia weight formula and the adaptive crossover rate calculation for improved performance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.4 * np.random.rand()  # Adjusted inertia weight\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.9 - 0.5 * (eval_count / self.budget)  # Adjusted adaptive crossover rate\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 56, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.07475429473951167, 0.07475429473951167, 0.07475429473951167, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00046039318769441895, 0.00046039318769441895, 0.00046039318769441895, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07874276342294728, 0.07874276342294728, 0.07874276342294728, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.016265854050386386, 0.016265854050386386, 0.016265854050386386, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10923731493251299, 0.10923731493251299, 0.10923731493251299, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05961055370656676, 0.05961055370656676, 0.05961055370656676, 0.1304316783696685, 0.1304316783696685, 0.1304316783696685, 0.06561791375210857, 0.06561791375210857, 0.06561791375210857, 0.10500779427112739, 0.10500779427112739, 0.10500779427112739, 0.038673447996819266, 0.038673447996819266, 0.038673447996819266, 0.10386909079796847, 0.10386909079796847, 0.10386909079796847, 0.025350465865659588, 0.025350465865659588, 0.025350465865659588, 0.14768798462505228, 0.14768798462505228, 0.14768798462505228, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "eb7b6140-2efd-4af5-babb-2c3b366c56f6", "fitness": 0.04172183135250873, "name": "HybridPSODE", "description": "Introduce a stochastic perturbation to the adaptive inertia weight for enhanced exploration in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand() + 0.1 * np.random.randn()  # Added stochastic perturbation\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 57, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.09804924702503837, 0.09804924702503837, 0.09804924702503837, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0690942324179834, 0.0690942324179834, 0.0690942324179834, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015347941033050816, 0.015347941033050816, 0.015347941033050816, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.16196777656674255, 0.16196777656674255, 0.16196777656674255, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049006979368098724, 0.049006979368098724, 0.049006979368098724, 0.11306763750149407, 0.11306763750149407, 0.11306763750149407, 0.07752582250981699, 0.07752582250981699, 0.07752582250981699, 0.10431591718823652, 0.10431591718823652, 0.10431591718823652, 0.0534118517948855, 0.0534118517948855, 0.0534118517948855, 0.08630299882121606, 0.08630299882121606, 0.08630299882121606, 0.024060115913215774, 0.024060115913215774, 0.024060115913215774, 0.14395604101608273, 0.14395604101608273, 0.14395604101608273, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6f4fbeae-9a59-4a23-9996-549943aa8215", "fitness": 0.03832920047821084, "name": "HybridPSODE", "description": "Enhanced global search by adjusting the social parameter to decay exponentially for improved exploration in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = (1.5 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 58, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.09284580837556722, 0.09284580837556722, 0.09284580837556722, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.061189580472684746, 0.061189580472684746, 0.061189580472684746, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007770637529789237, 0.007770637529789237, 0.007770637529789237, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1171994490432845, 0.1171994490432845, 0.1171994490432845, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04976877373606403, 0.04976877373606403, 0.04976877373606403, 0.12121942344589243, 0.12121942344589243, 0.12121942344589243, 0.07137409019556562, 0.07137409019556562, 0.07137409019556562, 0.1046971151466527, 0.1046971151466527, 0.1046971151466527, 0.07063653484161181, 0.07063653484161181, 0.07063653484161181, 0.05850382666838139, 0.05850382666838139, 0.05850382666838139, 0.02120211885580281, 0.02120211885580281, 0.02120211885580281, 0.1382760618614156, 0.1382760618614156, 0.1382760618614156, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b59f8460-ca72-484e-9927-a0598cf21ddb", "fitness": 0.07472780103703971, "name": "HybridPSODE", "description": "Optimized the weight and differential mutation factor in HybridPSODE using linear interpolation for enhanced performance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Optimized inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.7 + 0.3 * np.random.rand()  # Optimized mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 59, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.15.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.15523451573520541, 0.15523451573520541, 0.15523451573520541, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0039999022979442245, 0.0039999022979442245, 0.0039999022979442245, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.717987978109649, 0.717987978109649, 0.717987978109649, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007583357287883397, 0.007583357287883397, 0.007583357287883397, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.006541516745386944, 0.006541516745386944, 0.006541516745386944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0009094121005664979, 0.0009094121005664979, 0.0009094121005664979, 0.16619000850052779, 0.16619000850052779, 0.16619000850052779, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04959818952306683, 0.04959818952306683, 0.04959818952306683, 0.1435809999786295, 0.1435809999786295, 0.1435809999786295, 0.06513846194919082, 0.06513846194919082, 0.06513846194919082, 0.10694945676540579, 0.10694945676540579, 0.10694945676540579, 0.059749709931389505, 0.059749709931389505, 0.059749709931389505, 0.1351282815587984, 0.1351282815587984, 0.1351282815587984, 0.031728197700997995, 0.031728197700997995, 0.031728197700997995, 0.1392341932260499, 0.1392341932260499, 0.1392341932260499, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9020124d-f93d-4cc8-b32e-a5c6f02964df", "fitness": 0.03670512405217895, "name": "HybridPSODE", "description": "Enhanced global exploration by adjusting the social parameter using adaptive noise injection in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 += 0.1 * np.random.randn()  # Adaptive noise injection added to the social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 60, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.04838698826161836, 0.04838698826161836, 0.04838698826161836, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1960450514599471, 0.1960450514599471, 0.1960450514599471, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09837175289818734, 0.09837175289818734, 0.09837175289818734, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049103291618397105, 0.049103291618397105, 0.049103291618397105, 0.1156416688335814, 0.1156416688335814, 0.1156416688335814, 0.057172013009381906, 0.057172013009381906, 0.057172013009381906, 0.10035893898341175, 0.10035893898341175, 0.10035893898341175, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03053462348323399, 0.03053462348323399, 0.03053462348323399, 0.036949981626856254, 0.036949981626856254, 0.036949981626856254, 0.14227171055594023, 0.14227171055594023, 0.14227171055594023, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "135f9dc0-3248-4033-9495-bf2410cddae6", "fitness": 0.051018774860613125, "name": "HybridPSODE", "description": "Enhanced velocity update rule by incorporating an adaptive social parameter in HybridPSODE.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.0 + 0.5 * (eval_count / self.budget)  # Adaptive social parameter adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 61, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.17717869804308595, 0.17717869804308595, 0.17717869804308595, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002364519960220468, 0.002364519960220468, 0.002364519960220468, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07297347731877257, 0.07297347731877257, 0.07297347731877257, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.02170493358431491, 0.02170493358431491, 0.02170493358431491, 0.0006908917863276409, 0.0006908917863276409, 0.0006908917863276409, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0004953081814034199, 0.0004953081814034199, 0.0004953081814034199, 0.15038191796086542, 0.15038191796086542, 0.15038191796086542, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05640602617305812, 0.05640602617305812, 0.05640602617305812, 0.14721108284501494, 0.14721108284501494, 0.14721108284501494, 0.05834807953603616, 0.05834807953603616, 0.05834807953603616, 0.11744747988935889, 0.11744747988935889, 0.11744747988935889, 0.11772878262913367, 0.11772878262913367, 0.11772878262913367, 0.13114309275520808, 0.13114309275520808, 0.13114309275520808, 0.03234439615639628, 0.03234439615639628, 0.03234439615639628, 0.13411886635725756, 0.13411886635725756, 0.13411886635725756, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "dd477d2a-0560-4544-81bf-81fd74af9148", "fitness": 0.05032521135822096, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing velocity clamping and adaptive social parameter.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 + 0.5 * (eval_count / self.budget)  # Adaptive social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] = np.clip(velocities[i], -0.5, 0.5)  # Velocity clamping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 62, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.16580292589791545, 0.16580292589791545, 0.16580292589791545, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01265400727347199, 0.01265400727347199, 0.01265400727347199, 0.021243236913381702, 0.021243236913381702, 0.021243236913381702, 0.02173565260309651, 0.02173565260309651, 0.02173565260309651, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01877485934929113, 0.01877485934929113, 0.01877485934929113, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.18205091258040718, 0.18205091258040718, 0.18205091258040718, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0494281902928414, 0.0494281902928414, 0.0494281902928414, 0.10956589927455318, 0.10956589927455318, 0.10956589927455318, 0.06137040437325936, 0.06137040437325936, 0.06137040437325936, 0.1118618406385018, 0.1118618406385018, 0.1118618406385018, 0.11802649927306419, 0.11802649927306419, 0.11802649927306419, 0.1078220995002992, 0.1078220995002992, 0.1078220995002992, 0.08755017996700887, 0.08755017996700887, 0.08755017996700887, 0.1355705385732544, 0.1355705385732544, 0.1355705385732544, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "fbbbaf3b-9689-4905-a2da-103019e7b135", "fitness": 0.07750649028662596, "name": "HybridPSODE", "description": "Refined the HybridPSODE by adjusting the social parameter dynamically based on the evaluation count to improve convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 - 0.5 * (eval_count / self.budget)  # Dynamic adjustment of the social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 63, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.1466383598701555, 0.1466383598701555, 0.1466383598701555, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.802717968075739, 0.802717968075739, 0.802717968075739, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004285683993138223, 0.004285683993138223, 0.004285683993138223, 0.000459937869167093, 0.000459937869167093, 0.000459937869167093, 0.010784459910010868, 0.010784459910010868, 0.010784459910010868, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1264018647040327, 0.1264018647040327, 0.1264018647040327, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052522144680033134, 0.052522144680033134, 0.052522144680033134, 0.1490959296880987, 0.1490959296880987, 0.1490959296880987, 0.07616381991349541, 0.07616381991349541, 0.07616381991349541, 0.10136559555823266, 0.10136559555823266, 0.10136559555823266, 0.07308749582453722, 0.07308749582453722, 0.07308749582453722, 0.13825275391002056, 0.13825275391002056, 0.13825275391002056, 0.02929978923430865, 0.02929978923430865, 0.02929978923430865, 0.14473213756109649, 0.14473213756109649, 0.14473213756109649, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7857f12d-7642-4a0f-9917-e4016fc61002", "fitness": 0.06719600364605914, "name": "HybridPSODE", "description": "Enhanced convergence by adjusting the social parameter with a sinusoidal component for improved exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 + 0.5 * np.sin(eval_count / self.budget * np.pi * 2)  # Sinusoidal adjustment to social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 64, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.06690352645576614, 0.06690352645576614, 0.06690352645576614, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.856274201490103, 0.856274201490103, 0.856274201490103, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007699778131113222, 0.007699778131113222, 0.007699778131113222, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0019042602568691835, 0.0019042602568691835, 0.0019042602568691835, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0973675424843291, 0.0973675424843291, 0.0973675424843291, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.053571271992278846, 0.053571271992278846, 0.053571271992278846, 0.1281891447194643, 0.1281891447194643, 0.1281891447194643, 0.06779566650737212, 0.06779566650737212, 0.06779566650737212, 0.10704179214500709, 0.10704179214500709, 0.10704179214500709, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05755946566177794, 0.05755946566177794, 0.05755946566177794, 0.02379713414947293, 0.02379713414947293, 0.02379713414947293, 0.13938291220751753, 0.13938291220751753, 0.13938291220751753, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "3d5a2b40-a48f-4af7-a4d9-452ec648076d", "fitness": 0.033634756058806226, "name": "HybridPSODE", "description": "Introduced adaptive adjustment to social parameter and increased randomness in cognitive parameter for improved exploration and convergence balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.5 * np.random.rand()  # Increased randomness in cognitive parameter\n                self.c2 = 1.5 * (1 + 0.5 * np.random.rand())  # Adaptive adjustment to social parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 65, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.06736535257995058, 0.06736535257995058, 0.06736535257995058, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05171368946589927, 0.05171368946589927, 0.05171368946589927, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004444490845890714, 0.004444490845890714, 0.004444490845890714, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07773848215513346, 0.07773848215513346, 0.07773848215513346, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051400621718970085, 0.051400621718970085, 0.051400621718970085, 0.11356762541318333, 0.11356762541318333, 0.11356762541318333, 0.05746078339753535, 0.05746078339753535, 0.05746078339753535, 0.096336380823975, 0.096336380823975, 0.096336380823975, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09533933779019388, 0.09533933779019388, 0.09533933779019388, 0.046909910822904854, 0.046909910822904854, 0.046909910822904854, 0.13930529648466916, 0.13930529648466916, 0.13930529648466916, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "aeb27d88-18ac-4a15-9702-ab157c16d395", "fitness": 0.07516349381450312, "name": "HybridPSODE", "description": "Introduce a dynamic social parameter (c2) that linearly decreases to enhance exploration in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                self.c2 = 1.5 - (1.0 * eval_count / self.budget)  # Dynamic social parameter adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 66, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.14107609918974384, 0.14107609918974384, 0.14107609918974384, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0018400667339997234, 0.0018400667339997234, 0.0018400667339997234, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7881308003137436, 0.7881308003137436, 0.7881308003137436, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.012677603085964995, 0.012677603085964995, 0.012677603085964995, 0.000977109737481996, 0.000977109737481996, 0.000977109737481996, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.13011575253272822, 0.13011575253272822, 0.13011575253272822, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04938369050515179, 0.04938369050515179, 0.04938369050515179, 0.1291314440025083, 0.1291314440025083, 0.1291314440025083, 0.07125249292404334, 0.07125249292404334, 0.07125249292404334, 0.10562341999860703, 0.10562341999860703, 0.10562341999860703, 0.06869151972359011, 0.06869151972359011, 0.06869151972359011, 0.12291184379990061, 0.12291184379990061, 0.12291184379990061, 0.024116288095384797, 0.024116288095384797, 0.024116288095384797, 0.1536478948182699, 0.1536478948182699, 0.1536478948182699, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "39987a8c-30b4-4f48-b969-ff9e01e76d02", "fitness": 0.06885238248856453, "name": "HybridPSODE", "description": "Introduce stochastic inertia weight adaptation and strategic personal-best influence to enhance exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 (0.5 + 0.5 * np.random.rand()) * self.c2 * r2 * (global_best - particles[i]))  # Adjust social parameter\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 67, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.14.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.14602441931786025, 0.14602441931786025, 0.14602441931786025, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6864910772293273, 0.6864910772293273, 0.6864910772293273, 0.0007898373979866591, 0.0007898373979866591, 0.0007898373979866591, 0.02916611984166273, 0.02916611984166273, 0.02916611984166273, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0015559467522673343, 0.0015559467522673343, 0.0015559467522673343, 0.14392609198114703, 0.14392609198114703, 0.14392609198114703, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05615050408461353, 0.05615050408461353, 0.05615050408461353, 0.13468194934846467, 0.13468194934846467, 0.13468194934846467, 0.0437082635915923, 0.0437082635915923, 0.0437082635915923, 0.1098079705100351, 0.1098079705100351, 0.1098079705100351, 0.09047364196876995, 0.09047364196876995, 0.09047364196876995, 0.032758535784658926, 0.032758535784658926, 0.032758535784658926, 0.030222145707938353, 0.030222145707938353, 0.030222145707938353, 0.14235285012226773, 0.14235285012226773, 0.14235285012226773, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "57c710a5-250d-48ed-9819-05435f1c7765", "fitness": 0.07573207780837393, "name": "HybridPSODE", "description": "Enhanced the adaptive mutation factor in DE for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.5 * np.random.rand()  # Enhanced adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 68, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.09674905574608428, 0.09674905574608428, 0.09674905574608428, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00044172961753963236, 0.00044172961753963236, 0.00044172961753963236, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8110480112906125, 0.8110480112906125, 0.8110480112906125, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005491024950789791, 0.005491024950789791, 0.005491024950789791, 0.0010409573613090473, 0.0010409573613090473, 0.0010409573613090473, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.16474606337163566, 0.16474606337163566, 0.16474606337163566, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051949769336577245, 0.051949769336577245, 0.051949769336577245, 0.12394724976774962, 0.12394724976774962, 0.12394724976774962, 0.08299772099026803, 0.08299772099026803, 0.08299772099026803, 0.10380082324476536, 0.10380082324476536, 0.10380082324476536, 0.08630640628242714, 0.08630640628242714, 0.08630640628242714, 0.11435709362200308, 0.11435709362200308, 0.11435709362200308, 0.028058225488553856, 0.028058225488553856, 0.028058225488553856, 0.14228791024370213, 0.14228791024370213, 0.14228791024370213, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8eefc6b1-b981-422a-bc58-75f418f9fde8", "fitness": 0.07882913423042329, "name": "HybridPSODE", "description": "Introduce adaptive velocity damping in HybridPSODE for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.95  # Adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 69, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["0e450465-8fe1-443d-9d81-e60a477e10fc"], "operator": null, "metadata": {"aucs": [0.14334592649376576, 0.14334592649376576, 0.14334592649376576, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8511098414224726, 0.8511098414224726, 0.8511098414224726, 0.005793760293512085, 0.005793760293512085, 0.005793760293512085, 0.018950608246404155, 0.018950608246404155, 0.018950608246404155, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002887516055144146, 0.002887516055144146, 0.002887516055144146, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12122191530871496, 0.12122191530871496, 0.12122191530871496, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05251120393600761, 0.05251120393600761, 0.05251120393600761, 0.14121503551664705, 0.14121503551664705, 0.14121503551664705, 0.056041683803690345, 0.056041683803690345, 0.056041683803690345, 0.11215990628277583, 0.11215990628277583, 0.11215990628277583, 0.09175626711009599, 0.09175626711009599, 0.09175626711009599, 0.12155197010974694, 0.12155197010974694, 0.12155197010974694, 0.03131349986174148, 0.03131349986174148, 0.03131349986174148, 0.13769226100248355, 0.13769226100248355, 0.13769226100248355, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8f8bb7f8-2fc0-4806-83d4-30700278f230", "fitness": 0.07882913423042329, "name": "HybridPSODE", "description": "Introduce adaptive boundary reflection in HybridPSODE to limit out-of-bound particles and enhance convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.95  # Adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n                # Reflect particles that exceed boundaries\n                particles[i] = np.where(particles[i] < self.lower_bound, self.upper_bound - (self.lower_bound - particles[i]), particles[i])\n                particles[i] = np.where(particles[i] > self.upper_bound, self.lower_bound + (particles[i] - self.upper_bound), particles[i])\n\n        return global_best", "configspace": "", "generation": 70, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["8eefc6b1-b981-422a-bc58-75f418f9fde8"], "operator": null, "metadata": {"aucs": [0.14334592649376576, 0.14334592649376576, 0.14334592649376576, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8511098414224726, 0.8511098414224726, 0.8511098414224726, 0.005793760293512085, 0.005793760293512085, 0.005793760293512085, 0.018950608246404155, 0.018950608246404155, 0.018950608246404155, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002887516055144146, 0.002887516055144146, 0.002887516055144146, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12122191530871496, 0.12122191530871496, 0.12122191530871496, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05251120393600761, 0.05251120393600761, 0.05251120393600761, 0.14121503551664705, 0.14121503551664705, 0.14121503551664705, 0.056041683803690345, 0.056041683803690345, 0.056041683803690345, 0.11215990628277583, 0.11215990628277583, 0.11215990628277583, 0.09175626711009599, 0.09175626711009599, 0.09175626711009599, 0.12155197010974694, 0.12155197010974694, 0.12155197010974694, 0.03131349986174148, 0.03131349986174148, 0.03131349986174148, 0.13769226100248355, 0.13769226100248355, 0.13769226100248355, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "bf136912-4b4f-4c86-ae0d-0d2b0c95a53e", "fitness": 0.07678641573364266, "name": "HybridPSODE", "description": "Enhance convergence by tuning PSO inertia weight adjustment strategy for improved exploration-exploitation transition.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adjusted inertia weight\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.95  # Adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 71, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["8eefc6b1-b981-422a-bc58-75f418f9fde8"], "operator": null, "metadata": {"aucs": [0.10282163685704315, 0.10282163685704315, 0.10282163685704315, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002144653050131451, 0.002144653050131451, 0.002144653050131451, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8361464011641613, 0.8361464011641613, 0.8361464011641613, 0.0037683055519441844, 0.0037683055519441844, 0.0037683055519441844, 0.0032772139786940713, 0.0032772139786940713, 0.0032772139786940713, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003674262449591681, 0.003674262449591681, 0.003674262449591681, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.134364663598197, 0.134364663598197, 0.134364663598197, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04889868661463226, 0.04889868661463226, 0.04889868661463226, 0.13765695685154056, 0.13765695685154056, 0.13765695685154056, 0.07285901044376475, 0.07285901044376475, 0.07285901044376475, 0.10873422678763489, 0.10873422678763489, 0.10873422678763489, 0.09140692997790212, 0.09140692997790212, 0.09140692997790212, 0.11353346615479776, 0.11353346615479776, 0.11353346615479776, 0.030524490008382532, 0.030524490008382532, 0.030524490008382532, 0.14915003064074495, 0.14915003064074495, 0.14915003064074495, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ed7999bd-be3c-43f1-8163-222fbe26227c", "fitness": 0.0762250441843139, "name": "HybridPSODE", "description": "Enhance exploration in HybridPSODE by introducing an adaptive differential mutation factor for improved optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.95  # Adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.2 * np.sin(eval_count / self.budget * np.pi)  # Sine adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 72, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.15.", "error": "", "parent_ids": ["8eefc6b1-b981-422a-bc58-75f418f9fde8"], "operator": null, "metadata": {"aucs": [0.1486042160214972, 0.1486042160214972, 0.1486042160214972, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006117295586184346, 0.0006117295586184346, 0.0006117295586184346, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7561443174433534, 0.7561443174433534, 0.7561443174433534, 0.023196656429155582, 0.023196656429155582, 0.023196656429155582, 0.008360813335289707, 0.008360813335289707, 0.008360813335289707, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.009199917655093093, 0.009199917655093093, 0.009199917655093093, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005876509996142754, 0.005876509996142754, 0.005876509996142754, 0.09955583923190836, 0.09955583923190836, 0.09955583923190836, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.053529122794436446, 0.053529122794436446, 0.053529122794436446, 0.14605520890383517, 0.14605520890383517, 0.14605520890383517, 0.08505276884801372, 0.08505276884801372, 0.08505276884801372, 0.11288343270148915, 0.11288343270148915, 0.11288343270148915, 0.07618330073208202, 0.07618330073208202, 0.07618330073208202, 0.1308580367813671, 0.1308580367813671, 0.1308580367813671, 0.025361456062578558, 0.025361456062578558, 0.025361456062578558, 0.14444947305910738, 0.14444947305910738, 0.14444947305910738, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f6138900-3f20-4bf0-be47-4762f003e2c5", "fitness": 0.0571281328402164, "name": "HybridPSODE", "description": "Enhance global best update timing by introducing a new trigger for velocity reset.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.95  # Adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n                        velocities *= 0  # Reset velocities when a new global best is found\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 73, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.07.", "error": "", "parent_ids": ["8eefc6b1-b981-422a-bc58-75f418f9fde8"], "operator": null, "metadata": {"aucs": [0.21369189152690082, 0.21369189152690082, 0.21369189152690082, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.15307601922497083, 0.15307601922497083, 0.15307601922497083, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01625962566966177, 0.01625962566966177, 0.01625962566966177, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.16654312136702754, 0.16654312136702754, 0.16654312136702754, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04845896203006128, 0.04845896203006128, 0.04845896203006128, 0.1445353567205877, 0.1445353567205877, 0.1445353567205877, 0.06754245896207323, 0.06754245896207323, 0.06754245896207323, 0.11781107755894926, 0.11781107755894926, 0.11781107755894926, 0.12050979264454953, 0.12050979264454953, 0.12050979264454953, 0.15174906475466154, 0.15174906475466154, 0.15174906475466154, 0.033330484543895644, 0.033330484543895644, 0.033330484543895644, 0.13234994185750648, 0.13234994185750648, 0.13234994185750648, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "334dfd29-1fef-4b23-969f-ebe826a71adf", "fitness": 0.07329724148844494, "name": "HybridPSODE", "description": "Increase the social learning factor and introduce periodic velocity reset for enhanced diversity.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.7  # Increased Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        reset_period = self.budget // 3  # Introduce periodic velocity reset\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.95  # Adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if eval_count % reset_period == 0:  # Reset velocities periodically\n                    velocities[i] = np.random.uniform(-1, 1, self.dim)\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 74, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["8eefc6b1-b981-422a-bc58-75f418f9fde8"], "operator": null, "metadata": {"aucs": [0.11915297969656913, 0.11915297969656913, 0.11915297969656913, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8593349347840074, 0.8593349347840074, 0.8593349347840074, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005818893840818684, 0.005818893840818684, 0.005818893840818684, 0.0010571889058572648, 0.0010571889058572648, 0.0010571889058572648, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00045346291290271346, 0.00045346291290271346, 0.00045346291290271346, 0.12376958093759705, 0.12376958093759705, 0.12376958093759705, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04679187988897138, 0.04679187988897138, 0.04679187988897138, 0.14080145428229984, 0.14080145428229984, 0.14080145428229984, 0.06542952806179314, 0.06542952806179314, 0.06542952806179314, 0.10495269152848063, 0.10495269152848063, 0.10495269152848063, 0.06197595048982374, 0.06197595048982374, 0.06197595048982374, 0.062419668252909455, 0.062419668252909455, 0.062419668252909455, 0.026717038155514072, 0.026717038155514072, 0.026717038155514072, 0.1361107178981774, 0.1361107178981774, 0.1361107178981774, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d8b745b7-152f-4fa8-bb4c-2d08e4d5c200", "fitness": 0.046975718873671454, "name": "HybridPSODE", "description": "Fine-tune inertia weight decay and crossover rate to enhance convergence speed in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.3 * (1 - eval_count / self.budget) + 0.35 * np.random.rand()  # Adjusted adaptive inertia weight\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.95  # Adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.92 - 0.4 * (eval_count / self.budget)  # Adjusted adaptive crossover rate\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 75, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_ids": ["8eefc6b1-b981-422a-bc58-75f418f9fde8"], "operator": null, "metadata": {"aucs": [0.13921946740164515, 0.13921946740164515, 0.13921946740164515, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0016619929368166808, 0.0016619929368166808, 0.0016619929368166808, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08044104895878446, 0.08044104895878446, 0.08044104895878446, 0.009687270610322818, 0.009687270610322818, 0.009687270610322818, 0.014638150197924693, 0.014638150197924693, 0.014638150197924693, 0.0005654051120381753, 0.0005654051120381753, 0.0005654051120381753, 0.0027520351715653035, 0.0027520351715653035, 0.0027520351715653035, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1299085154926397, 0.1299085154926397, 0.1299085154926397, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.060185973221006384, 0.060185973221006384, 0.060185973221006384, 0.13276321134188895, 0.13276321134188895, 0.13276321134188895, 0.07826340775251661, 0.07826340775251661, 0.07826340775251661, 0.11329174907626682, 0.11329174907626682, 0.11329174907626682, 0.08633375129874488, 0.08633375129874488, 0.08633375129874488, 0.11279782706573704, 0.11279782706573704, 0.11279782706573704, 0.02655317111876465, 0.02655317111876465, 0.02655317111876465, 0.1348760153418872, 0.1348760153418872, 0.1348760153418872, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6cd65d12-5420-4e12-b8bd-6b0b62a11a7b", "fitness": 0.07955262345811877, "name": "HybridPSODE", "description": "Enhance global convergence in HybridPSODE by refining velocity damping and crossover rate adaptation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 76, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["8eefc6b1-b981-422a-bc58-75f418f9fde8"], "operator": null, "metadata": {"aucs": [0.1486977916027229, 0.1486977916027229, 0.1486977916027229, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8113421756891084, 0.8113421756891084, 0.8113421756891084, 0.001312482251536462, 0.001312482251536462, 0.001312482251536462, 0.02235847813231684, 0.02235847813231684, 0.02235847813231684, 0.0016577570416700382, 0.0016577570416700382, 0.0016577570416700382, 0.0004355360209572501, 0.0004355360209572501, 0.0004355360209572501, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11806521943849968, 0.11806521943849968, 0.11806521943849968, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05830418669443749, 0.05830418669443749, 0.05830418669443749, 0.13629442389344693, 0.13629442389344693, 0.13629442389344693, 0.07480672548842493, 0.07480672548842493, 0.07480672548842493, 0.10682786891666973, 0.10682786891666973, 0.10682786891666973, 0.10712246330780051, 0.10712246330780051, 0.10712246330780051, 0.13568530478989393, 0.13568530478989393, 0.13568530478989393, 0.03365396663006481, 0.03365396663006481, 0.03365396663006481, 0.1487855396190394, 0.1487855396190394, 0.1487855396190394, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "79132897-75da-4616-8d7f-61fb27198517", "fitness": 0.07621525939523499, "name": "HybridPSODE", "description": "Introduce adaptive cognitive and social factors in HybridPSODE for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = 1.5 - (1.0 * eval_count / self.budget)  # Adaptive cognitive factor\n                self.c2 = 1.5 + (1.0 * eval_count / self.budget)  # Adaptive social factor\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 77, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.10016657918310456, 0.10016657918310456, 0.10016657918310456, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8124587184078137, 0.8124587184078137, 0.8124587184078137, 0.0036265238042848535, 0.0036265238042848535, 0.0036265238042848535, 0.02260944418730304, 0.02260944418730304, 0.02260944418730304, 0.005841875290361287, 0.005841875290361287, 0.005841875290361287, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.13810498278336036, 0.13810498278336036, 0.13810498278336036, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048915868326505185, 0.048915868326505185, 0.048915868326505185, 0.1284635839845334, 0.1284635839845334, 0.1284635839845334, 0.09568288003263126, 0.09568288003263126, 0.09568288003263126, 0.10706644803960974, 0.10706644803960974, 0.10706644803960974, 0.07816563918457142, 0.07816563918457142, 0.07816563918457142, 0.1198723113552933, 0.1198723113552933, 0.1198723113552933, 0.026389026400259197, 0.026389026400259197, 0.026389026400259197, 0.13745451841905165, 0.13745451841905165, 0.13745451841905165, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "dc6e107e-3f07-4ea0-ab19-94a00d06473a", "fitness": 0.07841058904331108, "name": "HybridPSODE", "description": "Introduce an adaptive population size and refined inertia weight decay to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(20, int(30 - (10 * (budget / 5000))))  # Adaptive population size\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) ** 0.5 + 0.3 * np.random.rand()  # Refined adaptive inertia weight decay\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 78, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.1647783403854738, 0.1647783403854738, 0.1647783403854738, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001101469461731508, 0.001101469461731508, 0.001101469461731508, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.812271738528683, 0.812271738528683, 0.812271738528683, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.027853759213777307, 0.027853759213777307, 0.027853759213777307, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00047405255919530376, 0.00047405255919530376, 0.00047405255919530376, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0004681366280296917, 0.0004681366280296917, 0.0004681366280296917, 0.1290138575465305, 0.1290138575465305, 0.1290138575465305, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05443592529478303, 0.05443592529478303, 0.05443592529478303, 0.13644087469204935, 0.13644087469204935, 0.13644087469204935, 0.08893868957636941, 0.08893868957636941, 0.08893868957636941, 0.11500381097723, 0.11500381097723, 0.11500381097723, 0.08812846966805354, 0.08812846966805354, 0.08812846966805354, 0.07807685875007098, 0.07807685875007098, 0.07807685875007098, 0.0442721167651321, 0.0442721167651321, 0.0442721167651321, 0.13668299351409552, 0.13668299351409552, 0.13668299351409552, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "905fb9fa-10ba-4b89-bdc2-04d794562741", "fitness": 0.06862750756489819, "name": "HybridPSODE", "description": "Improve local exploration in HybridPSODE by introducing stochastic scaling of velocities in PSO and adaptive randomization in DE mutation strategy.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92 * (1.0 + 0.1 * np.random.randn())  # Refine adaptive velocity damping with stochastic scaling\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector + 0.1 * np.random.randn(self.dim), self.lower_bound, self.upper_bound)  # Introduce adaptive randomization\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 79, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.12.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.14602640648528198, 0.14602640648528198, 0.14602640648528198, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.5848512246388835, 0.5848512246388835, 0.5848512246388835, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01873091264167337, 0.01873091264167337, 0.01873091264167337, 0.008785134156163554, 0.008785134156163554, 0.008785134156163554, 0.0031424258998883348, 0.0031424258998883348, 0.0031424258998883348, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1471646316089501, 0.1471646316089501, 0.1471646316089501, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06745484146339864, 0.06745484146339864, 0.06745484146339864, 0.1464525684496687, 0.1464525684496687, 0.1464525684496687, 0.07039952459283261, 0.07039952459283261, 0.07039952459283261, 0.10835462653268702, 0.10835462653268702, 0.10835462653268702, 0.09705084643162531, 0.09705084643162531, 0.09705084643162531, 0.06767048593628655, 0.06767048593628655, 0.06767048593628655, 0.03299535484898708, 0.03299535484898708, 0.03299535484898708, 0.14363337178427327, 0.14363337178427327, 0.14363337178427327, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "71b55e15-72c9-46a0-b717-6b9625b71dd2", "fitness": 0.05020329553567815, "name": "HybridPSODE", "description": "Improve global convergence in HybridPSODE by fine-tuning adaptive parameter dynamics.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.94  # Refined adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.99 - 0.5 * (eval_count / self.budget)  # Refined adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 80, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.13932767863312256, 0.13932767863312256, 0.13932767863312256, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003151274994813269, 0.003151274994813269, 0.003151274994813269, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07859644187929182, 0.07859644187929182, 0.07859644187929182, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.027309987916142253, 0.027309987916142253, 0.027309987916142253, 0.0022383194533067696, 0.0022383194533067696, 0.0022383194533067696, 0.011893210053159908, 0.011893210053159908, 0.011893210053159908, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1721518489347149, 0.1721518489347149, 0.1721518489347149, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06593817892250509, 0.06593817892250509, 0.06593817892250509, 0.13090919565849368, 0.13090919565849368, 0.13090919565849368, 0.0848624892208324, 0.0848624892208324, 0.0848624892208324, 0.11426627303791603, 0.11426627303791603, 0.11426627303791603, 0.08935550868886422, 0.08935550868886422, 0.08935550868886422, 0.11565267324024942, 0.11565267324024942, 0.11565267324024942, 0.029064910419691392, 0.029064910419691392, 0.029064910419691392, 0.13624805832491083, 0.13624805832491083, 0.13624805832491083, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2235c321-673b-4491-b5c8-c1c49aed1231", "fitness": 0.07693639684463567, "name": "HybridPSODE", "description": "Enhance local exploration by adjusting the adaptive mutation factor and inertia weight strategy.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.3 * (1 - eval_count / self.budget) + 0.4 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.7 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 81, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.15.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.11526937346023625, 0.11526937346023625, 0.11526937346023625, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.756097145281247, 0.756097145281247, 0.756097145281247, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01911292778869622, 0.01911292778869622, 0.01911292778869622, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002059072265702011, 0.002059072265702011, 0.002059072265702011, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.15143975684703315, 0.15143975684703315, 0.15143975684703315, 0.0011039203852256652, 0.0011039203852256652, 0.0011039203852256652, 0.06203488210649166, 0.06203488210649166, 0.06203488210649166, 0.12761779076404633, 0.12761779076404633, 0.12761779076404633, 0.09675784552176936, 0.09675784552176936, 0.09675784552176936, 0.10773511725685259, 0.10773511725685259, 0.10773511725685259, 0.09090732721040873, 0.09090732721040873, 0.09090732721040873, 0.14056381171622612, 0.14056381171622612, 0.14056381171622612, 0.028970564679775213, 0.028970564679775213, 0.028970564679775213, 0.14245616290058905, 0.14245616290058905, 0.14245616290058905, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "dbb1b3c0-62d7-4a0b-8d08-efd5bfea0cc2", "fitness": 0.026586311161874526, "name": "HybridPSODE", "description": "Enhance convergence by dynamically updating PSO parameters based on fitness improvement ratio.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n                self.c2 = 1.5 * (1 - (global_best_fitness / np.min(personal_best_fitness)))  # Dynamically update\n\n        return global_best", "configspace": "", "generation": 82, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.036264613688160474, 0.036264613688160474, 0.036264613688160474, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.024167749574776853, 0.024167749574776853, 0.024167749574776853, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07467013983355508, 0.07467013983355508, 0.07467013983355508, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.058280845345628274, 0.058280845345628274, 0.058280845345628274, 0.10375636211363992, 0.10375636211363992, 0.10375636211363992, 0.04549060926392945, 0.04549060926392945, 0.04549060926392945, 0.0921869757067626, 0.0921869757067626, 0.0921869757067626, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.042253567419491045, 0.042253567419491045, 0.042253567419491045, 0.016341927992661986, 0.016341927992661986, 0.016341927992661986, 0.1385717204246435, 0.1385717204246435, 0.1385717204246435, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "71e5a684-428c-4119-9345-eff644add9ad", "fitness": 0.07649648470678483, "name": "HybridPSODE", "description": "Enhance HybridPSODE by improving global best velocity influence and adaptive mutation factor refinement.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.7 + 0.3 * np.random.rand()  # Revised adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 83, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.10583603038564926, 0.10583603038564926, 0.10583603038564926, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8005104627809784, 0.8005104627809784, 0.8005104627809784, 0.0012186336942840992, 0.0012186336942840992, 0.0012186336942840992, 0.029530893879184617, 0.029530893879184617, 0.029530893879184617, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1124441649964415, 0.1124441649964415, 0.1124441649964415, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05431020705759415, 0.05431020705759415, 0.05431020705759415, 0.12964674651829022, 0.12964674651829022, 0.12964674651829022, 0.08435176735889793, 0.08435176735889793, 0.08435176735889793, 0.10596502656510165, 0.10596502656510165, 0.10596502656510165, 0.10576965080263168, 0.10576965080263168, 0.10576965080263168, 0.12472925354033881, 0.12472925354033881, 0.12472925354033881, 0.03205994629324427, 0.03205994629324427, 0.03205994629324427, 0.14476024039454694, 0.14476024039454694, 0.14476024039454694, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4ddf62f4-148c-486c-99e5-7e476fb515c5", "fitness": 0.07345961369835181, "name": "HybridPSODE", "description": "Improve balance between exploration and exploitation in HybridPSODE by fine-tuning inertia weight and mutation factor decay.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.6 * (1 - eval_count / self.budget) + 0.2 * np.random.rand()  # Adjusted adaptive inertia weight\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.65 + 0.35 * np.random.rand()  # Refined adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 84, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.16.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.09296109637897343, 0.09296109637897343, 0.09296109637897343, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006385977612693994, 0.0006385977612693994, 0.0006385977612693994, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7808511309527831, 0.7808511309527831, 0.7808511309527831, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015572291959256135, 0.015572291959256135, 0.015572291959256135, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007047771939380998, 0.007047771939380998, 0.007047771939380998, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1107356077849202, 0.1107356077849202, 0.1107356077849202, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056039941425037765, 0.056039941425037765, 0.056039941425037765, 0.13121880451922696, 0.13121880451922696, 0.13121880451922696, 0.09376116598399775, 0.09376116598399775, 0.09376116598399775, 0.10717555967251113, 0.10717555967251113, 0.10717555967251113, 0.08462207126894006, 0.08462207126894006, 0.08462207126894006, 0.10691413642655112, 0.10691413642655112, 0.10691413642655112, 0.030958787458605364, 0.030958787458605364, 0.030958787458605364, 0.1401859391420336, 0.1401859391420336, 0.1401859391420336, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d8b0b929-8798-4300-9b49-88e224460741", "fitness": 0.07736234692661431, "name": "HybridPSODE", "description": "Enhance convergence by dynamically adjusting the adaptive mutation factor and crossover rate more effectively in the HybridPSODE algorithm.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.5 * np.random.rand()  # Adjusted mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.5 * (eval_count / self.budget)  # Adjusted crossover rate\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 85, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.1330633048437404, 0.1330633048437404, 0.1330633048437404, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0004827827287837705, 0.0004827827287837705, 0.0004827827287837705, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7908503254642648, 0.7908503254642648, 0.7908503254642648, 0.0005007889028982859, 0.0005007889028982859, 0.0005007889028982859, 0.020306780434792504, 0.020306780434792504, 0.020306780434792504, 0.011784272192595258, 0.011784272192595258, 0.011784272192595258, 0.0007066491838235711, 0.0007066491838235711, 0.0007066491838235711, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1080553123656447, 0.1080553123656447, 0.1080553123656447, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05819556749004595, 0.05819556749004595, 0.05819556749004595, 0.12474190375555205, 0.12474190375555205, 0.12474190375555205, 0.0969101816823138, 0.0969101816823138, 0.0969101816823138, 0.10618770507605169, 0.10618770507605169, 0.10618770507605169, 0.10757659886191817, 0.10757659886191817, 0.10757659886191817, 0.1260567375997218, 0.1260567375997218, 0.1260567375997218, 0.03361391173763695, 0.03361391173763695, 0.03361391173763695, 0.1341852430493945, 0.1341852430493945, 0.1341852430493945, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "320b00d6-2dc6-499a-8ff5-2fd130f947cb", "fitness": 0.0474611517529662, "name": "HybridPSODE", "description": "Enhance global convergence in HybridPSODE by refining velocity damping and crossover rate adaptation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.95  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.3 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 86, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.1278237700733601, 0.1278237700733601, 0.1278237700733601, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006672705419509262, 0.0006672705419509262, 0.0006672705419509262, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07719361956732251, 0.07719361956732251, 0.07719361956732251, 0.0008215372530501197, 0.0008215372530501197, 0.0008215372530501197, 0.014024492557296875, 0.014024492557296875, 0.014024492557296875, 0.009849779169352701, 0.009849779169352701, 0.009849779169352701, 0.005208457934126165, 0.005208457934126165, 0.005208457934126165, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1321227960120127, 0.1321227960120127, 0.1321227960120127, 0.0006195697009356849, 0.0006195697009356849, 0.0006195697009356849, 0.052504539071294154, 0.052504539071294154, 0.052504539071294154, 0.13924887567567312, 0.13924887567567312, 0.13924887567567312, 0.05963619179193358, 0.05963619179193358, 0.05963619179193358, 0.10831907182338885, 0.10831907182338885, 0.10831907182338885, 0.09395593862844986, 0.09395593862844986, 0.09395593862844986, 0.13834371049815686, 0.13834371049815686, 0.13834371049815686, 0.026154034861345155, 0.026154034861345155, 0.026154034861345155, 0.14953050865066986, 0.14953050865066986, 0.14953050865066986, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d91ed549-c4ee-4255-ad79-f5298e23844f", "fitness": 0.0793883777005487, "name": "HybridPSODE", "description": "Slightly improve global convergence by refining adaptive parameters for HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.25 * np.random.rand()  # Refined adaptive inertia weight adjustment\n                self.c1 = (1.8 * np.exp(-eval_count / self.budget)) + 0.2  # Further reduced exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 87, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.17918061447312283, 0.17918061447312283, 0.17918061447312283, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0010183509827473847, 0.0010183509827473847, 0.0010183509827473847, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7807435713989335, 0.7807435713989335, 0.7807435713989335, 0.007485560774076916, 0.007485560774076916, 0.007485560774076916, 0.00445752039430336, 0.00445752039430336, 0.00445752039430336, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003159173610744026, 0.003159173610744026, 0.003159173610744026, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1297933814925003, 0.1297933814925003, 0.1297933814925003, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04773444898420487, 0.04773444898420487, 0.04773444898420487, 0.136444089113133, 0.136444089113133, 0.136444089113133, 0.09665370377784677, 0.09665370377784677, 0.09665370377784677, 0.1088451520384649, 0.1088451520384649, 0.1088451520384649, 0.09155889043057175, 0.09155889043057175, 0.09155889043057175, 0.12881778864777493, 0.12881778864777493, 0.12881778864777493, 0.031015931917441897, 0.031015931917441897, 0.031015931917441897, 0.15449984329904143, 0.15449984329904143, 0.15449984329904143, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "233aadce-be5b-4937-b25f-b8b0989c991c", "fitness": 0.07877424556464702, "name": "HybridPSODE", "description": "Enhance convergence in HybridPSODE by refining adaptive parameters for velocity and crossover rates.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.95  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.97 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 88, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.17.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.15818893299314563, 0.15818893299314563, 0.15818893299314563, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8262311321693999, 0.8262311321693999, 0.8262311321693999, 0.0032184804717170223, 0.0032184804717170223, 0.0032184804717170223, 0.0252776883079725, 0.0252776883079725, 0.0252776883079725, 0.0007827646936857668, 0.0007827646936857668, 0.0007827646936857668, 0.002091977217916541, 0.002091977217916541, 0.002091977217916541, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11238155907428804, 0.11238155907428804, 0.11238155907428804, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05867593250777148, 0.05867593250777148, 0.05867593250777148, 0.13962181987720723, 0.13962181987720723, 0.13962181987720723, 0.0608110333596128, 0.0608110333596128, 0.0608110333596128, 0.11063342444574598, 0.11063342444574598, 0.11063342444574598, 0.11008496837667314, 0.11008496837667314, 0.11008496837667314, 0.11458474578547306, 0.11458474578547306, 0.11458474578547306, 0.029707419643473454, 0.029707419643473454, 0.029707419643473454, 0.1343769711491848, 0.1343769711491848, 0.1343769711491848, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c41f41e9-dcb8-4da7-ae20-461eb9216890", "fitness": 0.07952673948736017, "name": "HybridPSODE", "description": "Adaptive modification of cognitive parameter and crossover rate to enhance convergence efficiency.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.5 * np.exp(-1.5 * eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.97 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 89, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.15.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.1945237439990235, 0.1945237439990235, 0.1945237439990235, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7580828348706133, 0.7580828348706133, 0.7580828348706133, 0.009194985997571958, 0.009194985997571958, 0.009194985997571958, 0.022120953124798226, 0.022120953124798226, 0.022120953124798226, 0.00044359733066989815, 0.00044359733066989815, 0.00044359733066989815, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.15664037984869394, 0.15664037984869394, 0.15664037984869394, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05664494324948244, 0.05664494324948244, 0.05664494324948244, 0.1166549540565246, 0.1166549540565246, 0.1166549540565246, 0.0980660280076201, 0.0980660280076201, 0.0980660280076201, 0.10554374974957459, 0.10554374974957459, 0.10554374974957459, 0.10764641898579708, 0.10764641898579708, 0.10764641898579708, 0.10408398109706096, 0.10408398109706096, 0.10408398109706096, 0.030140065782350067, 0.030140065782350067, 0.030140065782350067, 0.14450728550990677, 0.14450728550990677, 0.14450728550990677, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "34b2a4c3-282e-48be-9ebf-98d7d6594ca6", "fitness": 0.04849474087921297, "name": "HybridPSODE", "description": "Improve HybridPSODE by introducing nonlinear scaling factors for mutation and crossover rates in DE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.5 * np.sin(np.pi * eval_count / self.budget)  # Nonlinear scaling for mutation\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * np.cos(np.pi * eval_count / self.budget)  # Nonlinear scaling for crossover\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 90, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.13728671040966245, 0.13728671040966245, 0.13728671040966245, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005467192077830418, 0.005467192077830418, 0.005467192077830418, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07441172348990444, 0.07441172348990444, 0.07441172348990444, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013167551880733264, 0.013167551880733264, 0.013167551880733264, 0.015219773997938835, 0.015219773997938835, 0.015219773997938835, 0.0007009347486089945, 0.0007009347486089945, 0.0007009347486089945, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.13781801434528507, 0.13781801434528507, 0.13781801434528507, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05379485351565272, 0.05379485351565272, 0.05379485351565272, 0.14981446740211068, 0.14981446740211068, 0.14981446740211068, 0.08776411925135341, 0.08776411925135341, 0.08776411925135341, 0.11031203290017633, 0.11031203290017633, 0.11031203290017633, 0.09267499212809172, 0.09267499212809172, 0.09267499212809172, 0.11463090388162422, 0.11463090388162422, 0.11463090388162422, 0.03088542242754777, 0.03088542242754777, 0.03088542242754777, 0.1360120451663297, 0.1360120451663297, 0.1360120451663297, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "cc6792c8-8595-43c2-add0-21044a6f5f3a", "fitness": 0.04011842431932802, "name": "HybridPSODE", "description": "Enhance HybridPSODE by implementing a dynamic update of the population size based on the evaluation budget to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(10, min(50, budget // (dim * 100)))  # Dynamic population size based on budget\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 91, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.0893396997607191, 0.0893396997607191, 0.0893396997607191, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007122066772069946, 0.007122066772069946, 0.007122066772069946, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0017607309184018982, 0.0017607309184018982, 0.0017607309184018982, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11477985191489426, 0.11477985191489426, 0.11477985191489426, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05787421770565837, 0.05787421770565837, 0.05787421770565837, 0.11942653861931629, 0.11942653861931629, 0.11942653861931629, 0.055965934960535924, 0.055965934960535924, 0.055965934960535924, 0.11040721396781439, 0.11040721396781439, 0.11040721396781439, 0.09643349368858567, 0.09643349368858567, 0.09643349368858567, 0.11450573091795457, 0.11450573091795457, 0.11450573091795457, 0.04832931083596259, 0.04832931083596259, 0.04832931083596259, 0.14168000229761146, 0.14168000229761146, 0.14168000229761146, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6f0fc62a-bcf4-4d1a-b7f7-b4a1a06aac04", "fitness": 0.0736090159488072, "name": "HybridPSODE", "description": "Enhance PSO's global convergence by refining adaptive inertia weight initialization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.7 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 92, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.17.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.07382032566843744, 0.07382032566843744, 0.07382032566843744, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8491571589471401, 0.8491571589471401, 0.8491571589471401, 0.0004916330900684995, 0.0004916330900684995, 0.0004916330900684995, 0.010827550662063978, 0.010827550662063978, 0.010827550662063978, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11252410382822142, 0.11252410382822142, 0.11252410382822142, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05193244089541382, 0.05193244089541382, 0.05193244089541382, 0.1289333112624872, 0.1289333112624872, 0.1289333112624872, 0.08124125082472766, 0.08124125082472766, 0.08124125082472766, 0.10495335071469225, 0.10495335071469225, 0.10495335071469225, 0.07316218817094444, 0.07316218817094444, 0.07316218817094444, 0.11015383163179904, 0.11015383163179904, 0.11015383163179904, 0.025964345889669227, 0.025964345889669227, 0.025964345889669227, 0.13867228249005537, 0.13867228249005537, 0.13867228249005537, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ef71d642-b178-4a6f-b15a-bb67b081f160", "fitness": 0.06017900339911461, "name": "HybridPSODE", "description": "Enhance HybridPSODE by refining inertia weight variability and introducing a feedback mechanism to improve convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.5 * (global_best_fitness / np.mean(personal_best_fitness))  # Adaptive inertia weight adjustment with feedback\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 93, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.16.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.023994341917389916, 0.023994341917389916, 0.023994341917389916, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8091042785967659, 0.8091042785967659, 0.8091042785967659, 0.0009518376775222714, 0.0009518376775222714, 0.0009518376775222714, 0.0010147560419180301, 0.0010147560419180301, 0.0010147560419180301, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00044698200008996825, 0.00044698200008996825, 0.00044698200008996825, 0.05706535189605666, 0.05706535189605666, 0.05706535189605666, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04871168585982644, 0.04871168585982644, 0.04871168585982644, 0.11572947736293371, 0.11572947736293371, 0.11572947736293371, 0.04931010483577625, 0.04931010483577625, 0.04931010483577625, 0.09738991453135737, 0.09738991453135737, 0.09738991453135737, 0.012459248581531246, 0.012459248581531246, 0.012459248581531246, 0.06581246913925176, 0.06581246913925176, 0.06581246913925176, 0.019205234674940286, 0.019205234674940286, 0.019205234674940286, 0.13875257237643424, 0.13875257237643424, 0.13875257237643424, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2670e36d-7f7d-4bf3-86ad-2301e63cd018", "fitness": 0.04901975045744029, "name": "HybridPSODE", "description": "Enhance convergence in HybridPSODE by dynamically adjusting mutation factors and crossover rates based on fitness variance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                fitness_variance = np.std(personal_best_fitness) / (np.mean(personal_best_fitness) + 1e-10)  # Adjust mutation factor based on fitness variance\n                adaptive_F = 0.6 + fitness_variance * 0.4  # Adjust mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - fitness_variance * 0.5  # Adjust crossover rate based on fitness variance\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 94, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.14349308225708568, 0.14349308225708568, 0.14349308225708568, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07550093096517585, 0.07550093096517585, 0.07550093096517585, 0.009309896689469133, 0.009309896689469133, 0.009309896689469133, 0.016146135097947267, 0.016146135097947267, 0.016146135097947267, 0.0021604832697764698, 0.0021604832697764698, 0.0021604832697764698, 0.00246131382582937, 0.00246131382582937, 0.00246131382582937, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1772033167807694, 0.1772033167807694, 0.1772033167807694, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.047913861766827104, 0.047913861766827104, 0.047913861766827104, 0.14016776751410076, 0.14016776751410076, 0.14016776751410076, 0.09151102802123323, 0.09151102802123323, 0.09151102802123323, 0.10825583747557099, 0.10825583747557099, 0.10825583747557099, 0.07382351371457285, 0.07382351371457285, 0.07382351371457285, 0.11815694150188472, 0.11815694150188472, 0.11815694150188472, 0.03020905071726543, 0.03020905071726543, 0.03020905071726543, 0.13624780790279767, 0.13624780790279767, 0.13624780790279767, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a746c2fd-cb8c-4f37-be5f-4f14b0335a74", "fitness": 0.07373485396892414, "name": "HybridPSODE", "description": "Enhance global convergence in HybridPSODE by refining inertia weight adjustment for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * np.cos(eval_count / self.budget) + 0.3 * np.random.rand()  # Refined adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 95, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.15.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.12789752506157204, 0.12789752506157204, 0.12789752506157204, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.736268132930538, 0.736268132930538, 0.736268132930538, 0.004881580044064804, 0.004881580044064804, 0.004881580044064804, 0.024813337557620163, 0.024813337557620163, 0.024813337557620163, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0004675205630954027, 0.0004675205630954027, 0.0004675205630954027, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0009308983706071139, 0.0009308983706071139, 0.0009308983706071139, 0.1459466987821194, 0.1459466987821194, 0.1459466987821194, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056457413920985244, 0.056457413920985244, 0.056457413920985244, 0.13475403482897963, 0.13475403482897963, 0.13475403482897963, 0.08049164370380724, 0.08049164370380724, 0.08049164370380724, 0.10395506946670707, 0.10395506946670707, 0.10395506946670707, 0.0832757663909407, 0.0832757663909407, 0.0832757663909407, 0.10472364490126085, 0.10472364490126085, 0.10472364490126085, 0.028698869622367007, 0.028698869622367007, 0.028698869622367007, 0.13216131563125366, 0.13216131563125366, 0.13216131563125366, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "da37adbd-2a70-42de-a2dc-f716969f63e8", "fitness": 0.0782286568189735, "name": "HybridPSODE", "description": "Introduce dynamic scaling for velocity and incorporate random perturbations to enhance exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92 * (0.9 + 0.2 * np.random.rand())  # Dynamic scaling with perturbations\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 96, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.18037982407081177, 0.18037982407081177, 0.18037982407081177, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7800913726642758, 0.7800913726642758, 0.7800913726642758, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.16438978671521498, 0.16438978671521498, 0.16438978671521498, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05729437863999165, 0.05729437863999165, 0.05729437863999165, 0.11725467362737296, 0.11725467362737296, 0.11725467362737296, 0.08083456272000678, 0.08083456272000678, 0.08083456272000678, 0.10799230286718586, 0.10799230286718586, 0.10799230286718586, 0.09593297269571766, 0.09593297269571766, 0.09593297269571766, 0.12442901793848304, 0.12442901793848304, 0.12442901793848304, 0.022958472070625735, 0.022958472070625735, 0.022958472070625735, 0.14027822573263427, 0.14027822573263427, 0.14027822573263427, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5048397b-476a-40c7-8854-edacff01bcda", "fitness": 0.04206508822880414, "name": "HybridPSODE", "description": "Enhance exploration in HybridPSODE by refining the adaptive velocity damping factor.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= (0.92 + 0.08 * np.random.rand())  # Refine adaptive velocity damping factor\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 97, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.13853787890611358, 0.13853787890611358, 0.13853787890611358, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.02807619484989532, 0.02807619484989532, 0.02807619484989532, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007432178198389927, 0.007432178198389927, 0.007432178198389927, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08454722934538617, 0.08454722934538617, 0.08454722934538617, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05641174515188796, 0.05641174515188796, 0.05641174515188796, 0.1460418017874453, 0.1460418017874453, 0.1460418017874453, 0.06875885226040834, 0.06875885226040834, 0.06875885226040834, 0.11044531915394395, 0.11044531915394395, 0.11044531915394395, 0.08220136971819614, 0.08220136971819614, 0.08220136971819614, 0.10733963152107073, 0.10733963152107073, 0.10733963152107073, 0.03322317102918182, 0.03322317102918182, 0.03322317102918182, 0.14132935426503213, 0.14132935426503213, 0.14132935426503213, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b1458701-6ef2-4471-ac58-090786e07dd5", "fitness": 0.07649648470678483, "name": "HybridPSODE", "description": "Improve mixed strategy in HybridPSODE by enhancing adaptive mutation scaling in DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.7 + 0.3 * np.random.rand()  # Enhanced adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n        return global_best", "configspace": "", "generation": 98, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {"aucs": [0.10583603038564926, 0.10583603038564926, 0.10583603038564926, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8005104627809784, 0.8005104627809784, 0.8005104627809784, 0.0012186336942840992, 0.0012186336942840992, 0.0012186336942840992, 0.029530893879184617, 0.029530893879184617, 0.029530893879184617, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1124441649964415, 0.1124441649964415, 0.1124441649964415, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05431020705759415, 0.05431020705759415, 0.05431020705759415, 0.12964674651829022, 0.12964674651829022, 0.12964674651829022, 0.08435176735889793, 0.08435176735889793, 0.08435176735889793, 0.10596502656510165, 0.10596502656510165, 0.10596502656510165, 0.10576965080263168, 0.10576965080263168, 0.10576965080263168, 0.12472925354033881, 0.12472925354033881, 0.12472925354033881, 0.03205994629324427, 0.03205994629324427, 0.03205994629324427, 0.14476024039454694, 0.14476024039454694, 0.14476024039454694, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "480f688f-a867-4ea5-83a9-73800d363a9c", "fitness": -Infinity, "name": "HybridPSODE", "description": "Improve HybridPSODE by using an adaptive population size to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = func(global_best)\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.4 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                self.c1 = (1.7 * np.exp(-eval_count / self.budget)) + 0.3  # Exponential decay applied to cognitive parameter\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                velocities[i] *= 0.92  # Refine adaptive velocity damping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < global_best_fitness:\n                        global_best = particles[i]\n                        global_best_fitness = fitness\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.98 - 0.5 * (eval_count / self.budget)  # Refine adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = trial_fitness\n\n            # Update population size adaptively\n            self.population_size = min(self.population_size + 1, int(self.budget / self.dim))  # Adjust population size\n\n        return global_best", "configspace": "", "generation": 99, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_ids": ["6cd65d12-5420-4e12-b8bd-6b0b62a11a7b"], "operator": null, "metadata": {}}
